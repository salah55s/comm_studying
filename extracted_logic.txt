
Digital Logic
and Computer Design
M. MORRIS MANO
Professor of Engineering
California State University, Los Angeles
Copyright © 2016 Pearson India Education Services Pvt. Ltd
Published by Pearson India Education Services Pvt. Ltd, CIN: U72200TN2005PTC057128,
formerly  known as TutorVista Global Pvt. Ltd, licensee of Pearson Education in South Asia.
No part of this eBook may be used or reproduced in any manner whatsoever without the
publisher’s prior written consent.
This eBook may or may not include all assets that were part of the print version. The publisher 
reserves the right to remove any material in this eBook at any time.
Head Office: A-8 (A), 7th Floor , Kno wledge Boulevar d, Sector 62, Noida 201 309,  
Uttar Pradesh, India.
Register ed Office: 4th Floor , Software Block , Elnet Softwar e City, TS-140, Block 2 & 9, 
Rajiv Gandhi Salai,  Taramani, Chennai 600 113, Tamil Nadu, India.
www.pearson.co .in, Email: companysecretary.india@pearson.comeISBN 978-93-325-8604-8 
Fax:  080-30461003, Phone: 080-304610604 ISBN 978-93-325- 252-5
Contents
Preface ix
1 Binary Systems 1
1.1 Digital Computers and Digital Systems 1
1.2 Binary Numbers 3
1.3 Number Base Conversions 6
1.4 Octal and Hexadecimal Numbers 8
1.5 Complements 9
1.6 Binary Codes 14
1.7 Binary Storage and Registers 20
1.8 Binary Logic 23
1.9 Integrated Circuits 26
2 Boolean Algebra and Logic Gates 31
2.1 Basic Definitions 31
2.2 Axiomatic Definition of Boolean Algebra 32
2.3 Basic Theorems and Properties of Boolean Algebra 35
2.4 Boolean Functions 39
2.5 Canonical and Standard Forms 43
2.6 Other Logic Operations 49
2.7 Digital Logic Gates 51
2.8 IC Digital Logic Families 54
3 Simplification of Boolean Functions 65
3.1 The Map Method 65
3.2 Two- and Three-variable Maps 65
iv Contents
3.3  Four-variable Map 69
3.4 Five- and Six-Variable Maps 72
3.5 Product of Sums Simplification 75
3.6 NAND and NOR Implementation 77
3.7 Other Two-level Implementations 83
3.8 Don’t-care Conditions 87
3.9 The Tabulation Method 89
3.10 Determination of Prime-implicants 90
3.11 Selection of Prime-implicants 94
3.12 Concluding Remarks 96
4 Combinational Logic 103
4.1 Introduction 103
4.2 Design Procedure 104
4.3 Adders 105
4.4 Subtractors 109
4.5 Code Conversion 111
4.6 Analysis Procedure 113
4.7 Multilevel Nand Circuits 117
4.8 Multilevel NOR Circuits 124
4.9 Exclusive-OR and Equivalence Functions 127
5 Combinational Logic with MSI and LSI  137
5.1 Introduction 137
5.2 Binary Parallel Adder 138
5.3 Decimal Adder 143
5.4 Magnitude Comparator 145
5.5 Decoders 147
5.6 Multiplexers 156
5.7 Read-Only Memory (ROM) 161
5.8 Programmable Logic Array (PLA) 167
5.9 Concluding Remarks 173
6 Sequential Logic 179
6.1 Introduction 179
6.2 Flip-Flops 180
Contents v 
6.3 Triggering of Flip-flops 185
6.4 Analysis of Clocked Sequential Circuits 193
6.5 State Reduction and Assignment 198
6.6 Flip-flop Excitation Tables 204
6.7 Design Procedure 206
6.8 Design of Counters 215
6.9 Design with State Equations 218
7 Registers, Counters, and the Memory Unit 229
7.1 Introduction 229
7.2 Registers 230
7.3 Shift Registers 235
7.4 Ripple Counters 242
7.5 Synchronous-counters 247
7.6 Timing Sequences 253
7.7 The Memory Unit 258
7.8 Examples of Random-access Memories 262
8 Register-Transfer Logic 271
8.1 Introduction 271
8.3 Arithmetic, Logic, and Shift Microoperations 281
8.4 Conditional Control Statements 284
8.5 Fixed-point Binary Data 285
8.6 Overflow 289
8.7 Arithmetic Shifts 291
8.8 Decimal Data 293
8.9 Floating-point Data 294
8.10 Nonnumeric Data 297
8.11 Instruction Codes 300
8.12 Design of a Simple Computer 304
9 Processor Logic Design 317
9.1 Introduction 317
9.2 Processor Organization 318
9.3 Arithmetic Logic Unit 325
9.4 Design of Arithmetic Circuit 326
9.5 Design of Logic Circuit 331
vi Contents
9.6 Design of Arithmetic Logic Unit 335
9.7 Status Register 338
9.8 Design of Shifter 341
9.9 Processor Unit 342
9.10 Design of Accumulator 346
10 Control Logic Design 362
10.1 Introduction 362
10.2 Control Organization 364
10.3 Hard-wired Control — Example 1 369
10.4 Microprogram Control 376
10.5 Control of Processor Unit 382
10.6 Hard-wired Control—Example 2 386
10.7 PLA Control 393
10.8 Microprogram Sequencer 396
11 Computer Design 407
11.1 Introduction 407
11.2 System Configuration 408
11.3 Computer Instructions 411
11.4 Timing and Control 417
11.5 Execution of Instructions 419
11.6 Design of Computer Registers 424
11.7 Design of Control 429
11.8 Computer Console 438
12 Microcomputer System Design 443
12.1 Introduction 443
12.2 Microcomputer Organization 445
12.3 Microprocessor Organization 449
12.4 Instructions and Addressing Modes 456
12.5 Stack, Subroutines, and Interrupt 463
12.6 Memory Organization 471
12.7 Input-output Interface 474
12.8 Direct Memory Access 484
Contents vii 
13 Digital Integrated Circuits 492
13.1 Introduction 492
13.2 Bipolar Transistor Characteristics 494
13.3 RTL and DTL Circuits 497
13.4 Integrated-injection Logic (I2L) 500
13.5 Transistor-Transistor Logic (TTL) 502
13.6 Emitter-coupled Logic (ECL) 511
13.7 Metal-Oxide Semiconductor (MOS) 513
13.8 Complementary MOS (CMOS) 515
Appendix 521
Index 537
This page is intentionally left blank
Preface
Digital logic is concerned with the interconnection among digital components and modules and 
is a term used to denote the design and analysis of digital systems. The best known example of a digital system is the general purpose digital computer. This book presents the basic concepts used in the design and analysis of digital systems and introduces the principles of digital com-puter organization and design. It provides various methods and techniques suitable for a variety of digital system design applications. It covers all aspects of digital systems from the electronic gate circuits to the complex structure of microcomputer systems.
Chapters 1 through 6 present digital logic design techniques from the classical point of 
view. Boolean algebra and truth tables are used for the analysis and design of combinational circuits and state transition techniques for the analysis and design of sequential circuits. Chap-ters 7 through 12 present digital system design methods from the register-transfer point of view. 
The digital system is decomposed into register subunits and the system is specified with a list of register-transfer statements that describe the operational transfers among the information stored in registers. The register-transfer method is used for the analysis and design of processor units, control units, a computer central processor, and for describing the internal operations of micro-processors and microcomputers. Chapter 13 deals with the electronics of digital circuits and presents the most common integrated circuit digital logic families.
The components used to construct digital systems are manufactured in integrated circuit 
form. Integrated circuits contain a large amount of interconnected digital circuits within a single small package. Medium scale integration (MSI) devices provide digital functions and large scale integration (LSI) devices provide complete computer modules. It is very important for the logic designer to be familiar with the various digital components encountered in integrated circuit form. For this reason, many MSI and LSI circuits are introduced throughout the book and their logical function fully explained. The use of integrated circuits in the design of digital systems is illustrated by means of examples in the text and in problems at the end of the chapters.
This book was originally planned as a second edition to the author’ s Computer Logic De-
sign (Prentice-Hall, 1972). Because of the amount of new material added and the extensive revi-
sions that have taken place, it seems more appropriate to adopt a new title for the present text. About one third of the text is material that appears in the previous book. The other two thirds constitutes new or revised information. The underlying factors for the revisions and additions arise from developments in the digital electronics technology. Great emphasis is given to MSI and LSI circuits and to design methods using integrated circuits. The book covers various LSI 
x Preface
components of the bit-slice and microcomputer variety. It presents applications of the read only 
memory (ROM) and programmable logic array (PLA). Moreover, further developments in the register transfer method of design mandated a complete rewriting of the second half of the book.
Chapter 1 presents various binary systems suitable for representing information in digital 
components. The binary number system is explained and binary codes are illustrated to show the representation of decimal and alphanumeric information. Binary logic is introduced from an intuitive point of view before proceeding with a formal definition of Boolean algebra.
The basic postulates and theorems of Boolean algebra are found in Chapter 2. The correla-
tion between a Boolean expression and its equivalent interwwwwconnection of gates is empha-sized. All possible logic operations for two variables are investigated and from that, the most useful logic gates are derived. The characteristics of digital gates available in integrated circuit form are presented early in this chapter but a more detailed analysis describing the internal con-struction of the gates is left for the last chapter.
Chapter 3 supplies the map and tabulation methods for simplifying Boolean functions. The 
map method is used to simplify digital circuits constructed with AND, OR, NAND, NOR, and wired-logic gates. The various simplification procedures are summarized in tabular form for easy reference.
Design and analysis procedures for combinational circuits are provided in Chapter 4. Some 
basic components used in the design of digital systems, such as adders and code converters, are introduced as design or analysis examples. The chapter investigates possible implementations using multilevel NAND and NOR combinational circuits.
Chapter 5 deals with combinational logic MSI and LSI components. Often used functions 
such as parallel adders, decoders, and multiplexers are explained, and their use in the design of combinational circuits is illustrated with examples. The read only memory (ROM) and program-mable logic array (PLA) are introduced and their usefulness in the design of complex combina-tional circuits is demonstrated.
Chapter 6 outlines various methods for the design and analysis of clocked sequential cir -
cuits. The chapter starts by presenting various types of flip-flops and the way they are triggered. The state diagram, state table, and state equations are shown to be convenient tools for analyz-ing sequential circuits. The design methods presented transform the sequential circuit to a set of Boolean functions that specify the input logic to the circuit flip-flops. The input Boolean func-tions are derived from the excitation table and are simplified by means of maps.
In Chapter 7, a variety of registers, shift-registers, and counters similar to those available in 
integrated circuit packages is presented. The operation of the random access memory (RAM) is also explained. The digital functions introduced in this chapter are the basic building blocks from which more complex digital systems are constructed.
Chapter 8 introduces the register-transfer method for describing digital systems. It shows 
how to express in symbolic form the operation sequence among the registers of a digital system. Symbols are defined for interregister transfer, arithmetic, logic, and shift microoperations. The different data types that are stored in computer registers are covered in detail. Some typical ex-amples are used to show how computer instructions are represented in binary coded form and how the operations specified by instructions can be expressed with register-transfer statements. The chapter concludes with the design of a very simple computer to demonstrate the register-transfer method of digital system design.
Chapter 9 is concerned with the processor unit of digital computers. It discusses alterna-
tives for organizing a processor unit with buses or scratchpad memory. A typical arithmetic logic 
Preface xi 
unit (ALU) is presented and a procedure is developed for the design of any other ALU configura-
tion. Other components commonly found in processors, such as shifters and status registers, are also presented. The design of a general purpose accumulator register is undertaken, starting from a specified set of register-transfer operations and culminating in a logic diagram.
Four methods of control logic design are introduced in Chapter 10. Two of the methods con-
stitute a hard-wired control. The other two introduce the concept of microprogramming and how to design a controller with the programmable logic array (PLA). The four methods are demon-strated by means of examples that show the development of design algorithms and the procedure for obtaining the control circuits for the system. The last section introduces an LSI microprogram sequencer and shows how it can be used to design a microprogram control unit.
Chapter 11 is devoted to the design of a small digital computer. The registers in the com-
puter are defined and a set of computer instructions is specified. The computer description is formalized with register-transfer statements that specify the microoperations among the registers as well as the control functions that initiate these microoperations. It is then shown that the set of microoperations can be used to design the data processor part of the computer. The control functions in the list of register-transfer statements supply the information for the design of the control unit. The control unit for the computer is designed by three different methods: hard-wired control, PLA control, and microprogram control.
Chapter 12 focuses on various LSI components that form a microcomputer system. The 
organization of a typical microprocessor is described and its internal operation explained. A typical set of instructions for the microprocessor is presented and various addressing modes are explained. The operation of a stack and the handling of subroutines and interrupts is covered from the hardware point of view. The chapter also illustrates the connection of memory chips to a microprocessor bus system and the operation of various interface units that communicate with input-output devices. It concludes with a description of the direct memory access mode of transfer.
Chapter 13 details the electronic circuits of the basic gate in seven integrated circuit logic 
families. This final chapter should be considered as an appendix and can be omitted if desired. Chapter 13 assumes prior knowledge of basic electronics, but there is no specific prerequisite for the rest of the book.
Every chapter includes a set of problems and a list of references. Answers to selected prob-
lems appear m the Appendix to provide an aid for the student and to help the independent reader. 
The book is suitable for a course in digital logic and computer design in an electrical or 
computer engineering department. It can also be used in a computer science department for a course in computer organization. Parts of the book can be used in a variety of ways. (1) As a first course in digital logic or switching circuits by covering Chapters 1 through 7 and possibly Chap-ter 13; (2) As a second course in digital computer logic with a prerequisite of a course in basic switching circuits by covering Chapter 5 and Chapters 7 through 12; (3) As an introduction to the hardware of microprocessors and microcomputers by covering Chapters 8 through 12.
In conclusion, I would like to explain the philosophy underlying the material presented in 
this book. The classical method has been predominant in the past for describing the operations of digital circuits. With the advent of integrated circuits, and especially the introduction of mi-crocomputer LSI components, the classical method seems to be far removed from practical ap-plications. Although the classical method for describing complex digital systems is not directly applicable, the basic concepts of Boolean algebra, combinational logic, and sequential logic pro-cedures, are still important for understanding the internal construction of many digital functions. 
xii Preface
On the other hand, the register-transfer method provides a better representation for describing the 
operations among the various modules in digital systems. It is concerned with the transfer of bit strings in parallel and may be considered to be one level higher in the hierarchy of digital system 
representation. The transition from the classical to the register-transfer method is made in the 
book by way of integrated circuit MSI functions. Chapters 5 and 7 cover many digital functions which are available in integrated circuits. Their operation is explained in terms of gates and flip-flops that make up the particular digital circuit. Each MSI circuit is considered as a functional unit that performs a particular operation. This operation is then described in the register-transfer 
method of notation. Thus, the analysis and design of registers and other digital functions is done by means of the classical method but the use of these functions in describing the operations of a digital system is specified by means of register-transfer statements. The register-transfer method is then used to define computer instructions, to express digital operations in concise form, to demonstrate the organization of digital computers, and to specify the hardware components for the design of digital systems.
I wish to express my thanks to Dr. John L. Fike for reviewing the original manuscript and to 
Professor Victor Payse for pointing out corrections while teaching a course using the manuscript. Most of the typing was done by Mrs. Lucy Albert and her skilled help is gratefully appreciated. My greatest thanks go to my wife for all the suggestions she made for improving the readability of the text and for her encouragement and support during the preparation of this book.
M. Morris Mano
Publisher’s Acknowledgement
The publishers would like to thank Shivani Goel, Thapar University, Kolkata for his valuable suggestions and inputs 
for enchancing the content of this book to suit the requirement of Indian Universities.
1Chapter
Binary Systems1.1  Digital Computers and Digital Systems
Digital computers have made possible many scientific, industrial, and commercial advances that 
would have been unattainable otherwise. Our space program would have been impossible without real-time, continuous computer monitoring, and many business enterprises function efficiently only with the aid of automatic data processing. Computers are used in scientific calculations, com-mercial and business data processing, air traffic control, space guidance, the educational field, and many other areas. The most striking property of a digital computer is its generality. It can follow a sequence of instructions, called a program, that operates on given data. The user can specify and change programs and/or data according to the specific need. As a result of this flexibility, general-purpose digital computers can perform a wide variety of information-processing tasks.
The general-purpose digital computer is the best-known example of a digital system. Other 
examples include telephone switching exchanges, digital voltmeters, frequency counters, calcu-lating machines, and teletype machines. Characteristic of a digital system is its manipulation of discrete elements of information. Such discrete elements may be electric impulses, the decimal digits, the letters of an alphabet, arithmetic operations, punctuation marks, or any other set of meaningful symbols. The juxtaposition of discrete elements of information represents a quantity of information. For example, the letters d, o, and g form the word dog . The digits 237 form a 
number. Thus, a sequence of discrete elements forms a language, that is, a discipline that con-veys information. Early digital computers were used mostly for numerical computations. In this case the discrete elements used are the digits. From this application, the term digital computer has emerged. A more appropriate name for a digital computer would be a “discrete information processing system.”
Discrete elements of information are represented in a digital system by physical quantities 
called signals. Electrical signals such as voltages and currents are the most common. The signals 
in all present-day electronic digital systems have only two discrete values and are said to be  
binary. The digital-system designer is restricted to the use of binary signals because of the lower 
reliability of many-valued electronic circuits. In other words, a circuit with ten states, using one discrete voltage value for each state, can be designed, but it would possess a very low reliability of operation. In contrast, a transistor circuit that is either on or off has two possible signal values and can be constructed to be extremely reliable. Because of this physical restriction of compo-nents, and because human logic tends to be binary, digital systems that are constrained to take discrete values are further constrained to take binary values.
Discrete quantities of information emerge either from the nature of the process or may be 
purposely quantized from a continuous process. For example, a payroll schedule is an inherently 
2 Chapter 1
discrete process that contains employee names, social security numbers, weekly salaries, income 
taxes, etc. An employee’ s paycheck is processed using discrete data values such as letters of the alphabet (names), digits (salary), and special symbols such as $. On the other hand, a research scientist may observe a continuous process but record only specific quantities in tabular form. The scientist is thus quantizing his continuous data. Each number in his table is a discrete ele-ment of information.
Many physical systems can be described mathematically by differential equations whose 
solutions as a function of time give the complete mathematical behavior of the process. An ana-log computer performs a direct simulation of a physical system. Each section of the computer 
is the analog of some particular portion of the process under study. The variables in the analog computer are represented by continous signals, usually electric voltages that vary with time. The signal variables are considered analogous to those of the process and behave in the same manner. Thus measurements of the analog voltage can be substituted for variables of the process. The term analog signal is sometimes substituted for continuous signal because “analog computer” 
has come to mean a computer that manipulates continuous variables.
To simulate a physical process in a digital computer, the quantities must be quantized. 
When the variables of the process are presented by real-time continuous signals, the latter are quantized by an analog-to-digital conversion device. A physical system whose behavior is de-scribed by mathematical equations is simulated in a digital computer by means of numerical methods. When the problem to be processed is inherently discrete, as in commercial applica-tions, the digital computer manipulates the variables in their natural form.
A block diagram of the digital computer is shown in Fig. 1.1. The memory unit stores 
programs as well as input, output, and intermediate data. The processor unit performs arithmetic and other data-processing tasks as specified by a program. The control unit supervises the flow of information between the various units. The control unit retrieves the instructions, one by one, from the program which is stored in memory. For each instruction, the control unit informs the processor to execute the operation specified by the instruction. Both program and data are stored in memory. The control unit supervises the program instructions, and the processor manipulates the data as specified by the program.
Control 
UnitProcessor
or
Arithmetic Unit
 
Storage
or
Memor y Unit
 
Input
Devices
and C ontrolOutputDevices
and C ontrol
Figure 1.1 Block diagram of a digital computer
Binary System 3 
The program and data prepared by the user are transferred into the memory unit by means 
of an input device such as punch-card reader or a teletypewriter. An output device, such as a 
printer, receives the result of the computations and the printed results are presented to the user. The input and output devices are special digital systems driven by electromechanical parts and controlled by electronic digital circuits.
An electronic calculator is a digital system similar to a digital computer, with the input 
device being a keyboard and the output device a numerical display. Instructions are entered in the calculator by means of the function keys, such as plus and minus. Data are entered through the numeric keys. Results are displayed directly in numeric form. Some calculators come close to resembling a digital computer by having printing capabilities and programmable facilities. A digital computer, however, is a more powerful device than a calculator. A digital computer can accommodate many other input and output devices; it can perform not only arithmetic computa-tions but logical operations as well and can be programmed to make decisions based on internal and external conditions.
A digital computer is an interconnection of digital modules. To understand the operation of 
each digital module, it is necessary to have a basic knowledge of digital systems and their general behavior. The first half of this book deals with digital systems in general to provide the back-ground necessary for their design. The second half of the book discusses the various modules of the digital computer, their operation and design. The operational characteristics of the memory unit are explained in Chapter 7. The organization and design of the processor unit is undertaken in Chapter 9. Various methods for designing the control unit are introduced in Chapter 10. The organization and design of a small, complete digital computer is presented in Chapter 11.
A processor, when combined with the control unit, forms a component referred to as a 
central processor unit or CPU. A CPU enclosed in small integrated-circuit package is called a microprocessor. The memory unit, as well as the part that controls the interface between the 
microprocessor and the input and output devices, may be enclosed within the microprocessor package or may be available in other small integrated-circuit packages. A CPU combined with memory and interface control to form a small-size computer is called a microcomputer. The 
availability of microcomputer components has revolutionized the digital system design technol-ogy, giving the designer the freedom to create structures that were previously uneconomical. The various components of a microcomputer system are presented in Chapter 12.
It has already been mentioned that a digital computer manipulates discrete elements of 
information and that these elements are represented in the binary form. Operands used for cal-culations may be expressed in the binary number system. Other discrete elements, including the decimal digits, are represented in binary codes. Data processing is carried out by means of binary logic elements using binary signals. Quantities are stored in binary storage elements. The purpose of this chapter is to introduce the various binary concepts as a frame of reference for further detailed study in the suceeding chapters.
1.2 Binary Numbers
A decimal number such as 7392 represents a quantity equal to 7 thousands plus 3 hundreds, plus 9 tens, plus 2 units. The thousands, hundreds, etc., are powers of 10 implied by the position of the coefficients. To be more exact, 7392 should be written as:
7 × 10
3 + 3 × 102 + 9 × 101 + 2 × 100
4 Chapter 1
However, the convention is to write only the coefficients and from their position deduce the 
necessary powers of 10. In general, a number with a decimal point is represented by a series of coefficients as follows:
a
5 a4 a3 a2 a1 a0. a–1 a–2 a-3
The aj coefficients are one of the ten digits (0, 1,2,...., 9), and the subscript value j gives the place 
value and, hence, the power of 10 by which the coefficient must be multiplied.
105a5 + 104a4 + 103a3 + 102a2 + 101a1 + 100a0 + 10-1 a-1 + 10-2 a-2 + 10-3 a-3
The decimal number system is said to be of base, or radix, 10 because it uses ten digits and the 
coefficients are multiplied by powers of 10. The binary system is a different number system. The 
coefficients of the binary numbers system have two possible values: 0 and 1. Each coefficient aj 
is multiplied by 2j. For example, the decimal equivalent of the binary number 11010.11 is 26.75, 
as shown from the multiplication of the coefficients by powers of 2:
1 × 24 + 1 × 23 + 0 × 22 + 1 × 21 + 0 × 20 + 1 × 2–1
                                                                              + 1 × 2–2 = 26.75
In general, a number expressed in base-r system has coefficients multiplied by powers of r.
an. rn + an-1 .rn-1 + … + a2 . r2 + a1 . r + a0
 + a-1 . r-1 + a-2 . r-2 + … + a-m .r-m
The coefficients aj range in value from 0 to r – 1. To distinguish between numbers of different 
bases, we enclose the coefficients in parentheses and write a subscript equal to the base used (except sometimes for decimal numbers, where the content makes it obvious that it is decimal). An example of a base-5 number is:
(4021.2)
5 = 4 × 53 + 0 × 52 + 2 × 51 + 1 × 50 + 2 × 5–l = (511.4)10
Note that coefficient values for base 5 can be only 0, 1,2, 3, and 4.
It is customary to borrow the needed r digits for the coefficients from the decimal system 
when the base of the number is less than 10. The letters of the alphabet are used to supplement the ten decimal digits when the base of the number is greater than 10. For example, in the hexa-decimal (base 16) number system, the first ten digits are borrowed from the decimal system. The 
letters A, B, C, D, E, and F are used for digits 10, 11, 12, 13, 14, and 15, respectively. An example 
of a hexadecimal number is:
(B65F)
I6 = 11 × 163 + 6 × 162 + 5 × 16 + 15 = (46687)l0
The first 16 numbers in the decimal, binary, octal, and hexadecimal systems are listed in  
Table 1-1.
Arithmetic operations with numbers in base r follow the same rules as for decimal numbers. 
When other than the familiar base 10 is used, one must be careful to use only the r allowable digits. Examples of addition, subtraction, and multiplication of two binary numbers are shown below:
Binary System 5 
Divisor Quotient
Dividend
Reminder1001
1100
1111
1100
111100  11 0111
augend:   101101 minuend:   101101 multiplicand:    1011
addend: +100111 subtrahend: –100111 multiplier:  × 101
sum: 1010100 difference:   000110    1011
 0000
1011   
product: 110111
The sum of two binary numbers is calculated by the same rules as in decimal, except 
that the digits of the sum in any significant position can be only 0 or 1. Any “carry” obtained 
in a given significant position is used by the pair of digits one significant position higher. The subtraction is slightly more complicated. The rules are still the same as in decimal, except that the “borrow” in a given significant position adds 2 to a minuend digit. (A borrow in the decimal  Table 1-1 Numbers with different bases
Decimal Binary Octal Hexadecimal
(base 10) (base 2) (base 8) (base 16)
00 0000 00 0
01 0001 01 1
02 0010 02 2
03 0011 03 3
04 0100 04 4
05 0101 05 5
06 0110 06 6
07 0111 07 7
08 1000 10 8
09 1001 11 9
10 1010 12 A
11 1011 13 B
12 1100 14 C
13 1101 15 D
14 1110 16 E
15 1111 17 F
6 Chapter 1
system adds 10 to a minuend digit.) Multiplication is very simple. The multiplier digits are 
always 1 or 0. Therefore, the partial products are equal either to the multiplicand or to 0.
1.3 Number Base Conversions
A binary number can be converted to decimal by forming the sum of the powers of 2 of those coefficients whose value is 1. For example:
(10l0.0ll)
2 = 23 + 21 + 2–2 + 2–3 = (10.375)10
The binary number has four l’ s and the decimal equivalent is found from the sum of four pow-ers of 2. Similarly, a number expressed in base r can be converted to its decimal equivalent by 
multiplying each coefficient with the corresponding power of r and adding. The following is an 
example of octal-to-decimal conversion:
(630.4)
8 = 6 × 82 + 3 × 8 + 4 × 8–1 = (408.5)10
The conversion from decimal to binary or to any other base-r system is more convenient if the number is separated into an integer part and a fraction part and the conversion of each part done separately. The conversion of an integer from decimal to binary is best explained by example.
EXAMPLE 1-1: Convert decimal 41 to binary. First, 41 is divided by 2 to give an integer 
quotient of 20 and a remainder of 
1
2. The quotient is again divided by 2 to give a new quo-
tient and remainder. This process is continued until the integer quotient becomes 0. The coef-ficients of the desired binary number are obtained from the remainders as follows:
integer quotient remainder coefficient
=41202 + 1
2a0 = 1
=20102 + 0 a1 = 0
=1052 + 0 a2 = 0
=522 + 1
2a3 = 1
=212 + 0 a4 = 0
=102 + 1
2a5 = 1
answer: (41)l0 = (a5a4a3a2a1a0)2 = (101001)2
Binary System 7 
The arithmetic process can be manipulated more conveniently as follows:
integer remainder
41
20 1
10 0
5 0
2 1
1 0
0 1 101001 = answer
The conversion from decimal integers to any base-r system is similar to the above example, 
except that division is done by r instead of 2.
EXAMPLE 1-2: Convert decimal 153 to octal. The required base r is 8. First, 153 is divided 
by 8 to give an integer quotient of 19 and a remainder of 1. Then 19 is divided by 8 to give an 
integer quotient of 2 and a remainder of 3. Finally, 2 is divided by 8 to give a quotient of 0 and a remainder of 2. This process can be conveniently manipulated as follows:
153
191
23
02   = (231)8
The conversion of a decimal fraction to binary is accomplished by a method similar to that 
used for integers. However, multiplication is used instead of division, and integers are accumu-lated instead of remainders. Again, the method is best explained by example.
EXAMPLE 1-3: Convert (0.6875)
l0 to binary. First, 0.6875 is multiplied by 2 to give an 
integer and a fraction. The new fraction is multiplied by 2 to give a new integer and a new fraction. This process is continued until the fraction becomes 0 or until the number of digits have sufficient accuracy. The coefficients of the binary number are obtained from the integers as follows:
integer fraction coefficient
0.6875 × 2 = 1 + 0.3750 a–1 = 1
0.3750 × 2 = 0 + 0.7500 a–2 = 0
0.7500 × 2 = 1 + 0.5000 a–3 = 1
0.5000 × 2 = 1 + 0.0000 a–4 = 1
answer: (0.6875)l0 = (0.a–1 a–2 a–3 a–4)2 = (0.1011)2
8 Chapter 1
To convert a decimal fraction to a number expressed in base r, a similar procedure is used. 
Multiplication is by r instead of 2, and the coefficients found from the integers may range in value 
from 0 to r – 1 instead of 0 and 1.
EXAMPLE 1-4: Convert (0.513)10 to octal.
0.513 × 8 = 4.104
0.104 × 8 = 0.8320.832 × 8 = 6.6560.656 × 8 = 5,2480.248 × 8 = 1.9840.984 × 8 = 7.872
The answer, to seven significant figures, is obtained from the integer part of the products:
(0.513)
10 = (0.406517 …)8
The conversion of decimal numbers with both integer and fraction parts is done by convert-
ing the integer and fraction separately and then combining the two answers together. Using the results of Examples 1-1 and 1-3, we obtain:
(41.6875)
10- (101001.1011)2
From Examples 1-2 and 1-4, we have:
(153.513)l0 = (231.406517)8
1.4 Octal and Hexadecimal Numbers
The conversion from and to binary, octal, and hexadecimal plays an important part in digital computers. Since 2
3 = 8 and 24 = 16, each octal digit corresponds to three binary digits and each 
hexadecimal digit corresponds to four binary digits. The conversion from binary to octal is easily accomplished by partitioning the binary number into groups of three digits each, starting from the binary point and proceeding to the left and to the right. The corresponding octal digit is then assigned to each group. The following example illustrates the procedure:
8
7 26 1 5 3 4 0 6 210 110 001 101 011 111 100 000 110 (26153.7406)=                
Conversion from binary to hexadecimal is similar, except that the binary number is divided into groups of four digits:
16
F 2C 6 B 2 210 1100 0110 1011 1111 0010 (2C6B.F2)=         
The corresponding hexadecimal (or octal) digit for each group of binary digits is easily remem-bered after studying the values listed in Table 1-1.
Binary System 9 
Conversion from octal or hexadecimal to binary is done by a procedure reverse to the above. 
Each octal digit is converted to its three-digit binary equivalent. Similarly, each hexadecimal 
digit is converted to its four-digit binary equivalent. This is illustrated in the following examples:
(673.124)8 = 
7 6 3 124 2110 111 011 001 010 100
          
                              (306. D)l6 = 
306 D 20011 0000 0110 1101
      
Binary numbers are difficult to work with because they require three or four times as many 
digits as their decimal equivalent. For example, the binary number 111111111111 is equivalent to decimal 4095. However, digital computers use binary numbers and it is sometimes necessary for the human operator or user to communicate directly with the machine by means of binary numbers. One scheme that retains the binary system in the computer but reduces the number of digits the human must consider utilizes the relationship between the binary number system and the octal or hexadecimal system. By this method, the human thinks in terms of octal or hexadeci-mal numbers and performs the required conversion by inspection when direct communication with the machine is necessary. Thus the binary number 111111111111 has 12 digits and is ex-pressed in octal as 7777 (four digits) or in hexadecimal as FFF (three digits). During communica-tion between people (about binary numbers in the computer), the octal or hexadecimal represen-tation is more desirable because it can be expressed more compactly with a third or a quarter of the number of digits required for the equivalent binary number. When the human communicates with the machine (through console switches or indicator lights or by means of programs written in machine language), the conversion from octal or hexadecimal to binary and vice versa is done 
by inspection by the human user.
1.5 Complements
Complements are used in digital computers for simplifying the subtraction operation and for logical manipulations. There are two types of complements for each base-r system: (1) the r’s  
complement and (2) the (r – 1)’ s complement. When the value of the base is substituted, the two 
types receive the names 2’ s and l’ s complement for binary numbers, or 10’ s and 9’ s complement for decimal numbers.
1.5.1 The r’s Complement
Given a positive number N in base r with an integer part of n digits, the r’s complement of N is 
defined as rn – N for N ≠ 0 and 0 for N = 0. The following numerical example will help clarify 
the definition.
The 10’ s complement of (52520)10 is 105 – 52520 = 47480.
The number of digits in the number is n = 5.
The 10’ s complement or (0.3267)10 is 1 - 0.3267 = 0.6733.
10 Chapter 1
No integer part, so 10n = 100 = 1.
The 10’ s complement of (25.639)10 is 102 – 25.639 = 74.361.
The 2’ s complement of (101100)2 is (26)10 – (101100)2 = (1000000 - 101100)2 = 010100.
The 2’ s complement of (0.0110)2 is (1 – 0.0110)2 = 0.1010.
The 16’ s complement of (4B7)16 is (163 - 4B7)10  = (1000 - 4B7)16 = (B49)16
From the definition and the examples, it is clear that the 10’ s complement of a decimal 
number can be formed by leaving all least significant zeros unchanged, subtracting the first non-
zero least significant digit from 10, and then subtracting all other higher significant digits from 9. The 2’ s complement can be formed by leaving all least significant zeros and the first nonzero digit unchanged, and then replacing l’ s by 0’ s and 0’ s by l’ s in all other higher significant digits. A third, simpler method for obtaining the r’s complement is given after the definition of the (r – l)’ s 
complement.
The r’ s complement of a number exists for any base r (r greater than but not equal to 1) 
and may be obtained from the definition given above. The examples listed here use numbers with r = 10 (decimal) and r = 2 (binary) because these are the two bases of most interest to 
us. The name of the complement is related to the base of the number used. For example, the  
(r - l)’ s complement of a number in base 11 is named the 10’ s complement, since r - 1 = 10 for 
r = 11.
1.5.2 The (r  – 1)’s Complement
Given a positive number N in base r with an integer part of n digits and a fraction part of m digits, 
the (r – l)’ s complement of N is defined as rn - r–m – N. Some numerical examples follow:
The 9’ s complement of (52520)10 is (105 – 1 – 52520) = 99999 - 52520 = 47479.
No fraction part, so 10–m = 100 = 1.
The 9’ s complement of (0.3267)10 is (1 - 10–4 0.3267) = 0.9999 – 0.3267 = 0.6732.
No integer part, so 10n = 100 - 1.
The 9’ s complement of (25.639)l0 is (102 – 10–3 – 25.639) = 99.999 - 25.639 = 74.360.
The l’ s complement of (101100)2 is (26 – 1) – (101100) = (111111 –101100)2 = 010011.
The l’ s complement of (0.0110)2 is (1 – 2–4)l0 – (0.0110)2 = (0.1111 – 0.0110)2 = 0.1001.
The 7’ s complement of (76)8 is (82 - 80)10 - 768 = (63)10 - 768 = (77 - 76)8 = 18
From the examples, we see that the 9’ s complement of a decimal number is formed simply 
by subtracting every digit from 9. The l’ s complement of a binary number is even simpler to form: the l’ s are changed to 0’ s and the 0’ s to l’ s. Since the (r – t)’ s complement is very easily obtained, it is sometimes convenient to use it when the r’s complement is desired. From the 
definitions and from a comparison of the results obtained in the examples, it follows that the r’s  
complement can be obtained from the (r – l)’ s complement after the addition of r
–m to the least 
significant digit. For example, the 2’ s complement of 10110100 is obtained from the l’ s comple-ment 01001011 by adding 1 to give 01001100.
Binary System 11 
It is worth mentioning that the complement of the complement restores the number to its 
original value. The r’s complement of N is rn – N and the complement of (rn – N) is rn – (rn – N) 
= N; and similarly for the l’ s complement.
1.5.3 Subtraction with r ’s Complements
The direct method of subtraction taught in elementary schools uses the borrow concept. In this 
method, we borrow a 1 from a higher significant position when the minuend digit is smaller than the corresponding subtrahend digit. This seems to be easiest when people perform subtraction with paper and pencil. When subtraction is implemented by means of digital components, this method is found to be less efficient than the method that uses complements and addition as stated below.
The subtraction of two positive numbers (M — N), both of base r, may be done as follows:
1. Add the minuend M to the r’ s complement of the subtrahend N.
2. Inspect the result obtained in step 1 for an end carry:
(a) If an end carry occurs, discard it.
(b) If an end carry does not occur, take the r ’s complement of the number obtained in 
step 1 and place a negative sign in front.
The following examples illustrate the procedure:
EXAMPLE 1-5: Using 10’ s complement, subtract 72532 – 3250.
               M = 72532                     72532
               N  = 03250
                + 
10’ s complement of N  = 96750   96750
      end carry → 1 69282
answer: 69282
EXAMPLE 1-6: Subtract: (3250 – 72532)l0.
               M = 03250                     03250
               N  = 72532
                + 
10’ s complement of N = 27468   27468
            no carry 30718
answer: – 69282 = – (10’s complement of 30718)
12 Chapter 1
EXAMPLE 1-7: Use 2’ s complement to perform M - N with the given binary numbers.
  (a)           M = 1010100   1010100
             N = 1000100
                  + 
2’ s complement of N = 0111100   0111100
      end carry → 1 0010000
answer: 10000  (b)           M = 1000100                1000100
             N  = 1010100
                  +
2’ s complement of N = 0101100   0101100
      no carry           1110000
answer: – 10000 = – (2’ s complement of 1110000)
The proof of the procedure is: The addition of M to the r’s complement of N gives  
(M + rn – N). For numbers having an integer part of n digits, rn is equal to a 1 in the (n + l)th posi-
tion (what has been called the “end carry”). Since both M and N are assumed to be positive, then:
(a)    (M + rn – N)  rn if M ≥ N,  or
(b)    (M + rn – N) < rn if M < N,  
In case (a) the answer is positive and equal to M – N, which is directly obtained by discarding the 
end carry rn. In case (b) the answer is negative and equal to -(N – M). This case is detected from 
the absence of an end carry. The answer is obtained by taking a second complement and adding a negative sign:
–[r
n – (M + rn – N)] = – (N – M).
1.5.4 Subtraction with (r  – 1)’s Complement
The procedure for subtraction with the (r - l)” s complement is exactly the same as the one used 
with the r’ s complement except for one variation, called “end-around carry,” as shown below. The subtraction of M – N, both positive numbers in base r, may be calculated in the following manner:
1. Add the minuend M to the (r – l)’ s complement of the subtrahend N.
2. Inspect the result obtained in step 1 for an end carry.
(a)  If an end carry occurs, add 1 to the least significant digit (end-around carry).
(b) If an end carry does not occur, take the (r – l)’ s complement of the number ob-
tained in step 1 and place a negative sign in front.
The proof of this procedure is very similar to the one given for the r’ s complement case and 
is left as an exercise. The following examples illustrate the procedure.
Binary System 13 
EXAMPLE 1-8: Repeat Examples 1-5 and 1-6 using 9’ s complements.
  (a)           M = 72532    72532
            N = 03250
9’ s complement of N = 96749           + 96749
               1 69281
     end-around carry     +
                1
        69282
answer: 69282  (b)           M = 03250    03250
              N = 72532
9’ s complement of N = 27467          +  27467
      no carry  30717
answer: – 69282 = – (9’ s complement of 30717)
EXAMPLE 1-9: Repeat Example 1 = 7 using l’ s complement.
  (a)           M = 1010100   1010100
              N = 1000100
 l’ s complement of N = 0111011          + 0111011
          end-around carry            1 0001111
             +  
                    1
        0010000
answer: 10000  (b)            M = 1000100   1000100
             N = 1010100         +
 
 l’ s complement of N = 0101011   0101011
      no carry  1101111
answer: – 10000 = – (l’ s complement of 1101111)
1.5.5 Comparison between 1’s and 2’s Complements
A comparison between l’ s and 2’ s complements reveals the advantages and disadvantages of 
each. The l’ s complement has the advantage of being easier to implement by digital components since the only thing that must be done is to change 0’ s into l’ s and l’ s into 0’ s. The implementation of the 2’ s complement may be obtained in two ways: (1) by adding 1 to the least significant digit of the l’ s complement, and (2) by leaving all leading 0’ s in the least significant positions and the first 1 unchanged, and only then changing all l’ s into 0’ s and all 0’ s into l’ s. During subtraction of 
14 Chapter 1
two numbers by complements, the 2’ s complement is advantageous in that only one arithmetic 
addition operation is required. The l’ s complement requires two arithmetic additions when an end-around carry occurs. The l’ s complement has the additional disadvantage of possessing two arithmetic zeros: one with all 0’ s and one with all l’ s. To illustrate this fact, consider the subtrac-tion of the two equal binary numbers 1100 - 1100 = 0.
Using l’ s complement:
     1100 
+      0011
+  
1111
Complement again to obtain -0000. 
Using 2’ s complement:
    1100 
+     0100
+  
0000
While the 2’ s complement has only one arithmetic zero, the l’ s complement zero can be positive or negative, which may complicate matters.
Complements, very useful for arithmetic manipulations in digital computers, are discussed 
more in Chapters 8 and 9. However, the l’ s complement is also useful in logical manipulations (as will be shown later), since the change of l’ s to 0’ s and vice versa is equivalent to a logical in-version operation. The 2’ s complement is used only in conjunction with arithmetic applications. Consequently, it is convenient to adopt the following convention: When the word complement, without mention of the type, is used in conjunction with a nonarithmetie application, the type is assumed to be the l’ s complement.
1.6 Binary Codes
Electronic digital systems use signals that have two distinct values and circuit elements that have two stable states. There is a direct analogy among binary signals, binary circuit elements, and binary digits. A binary number of n digits, for example, may be represented by n binary circuit 
elements, each having an output signal equivalent to a 0 or a 1. Digital systems represent and manipulate not only binary numbers, but also many other discrete elements of information. Any discrete element of information distinct among a group of quantities can be represented by a binary code. For example, red is one distinct color of the spectrum. The letter A is one distinct 
letter of the alphabet.
A bit, by definition, is a binary digit. When used in conjunction with a binary code, it is bet-
ter to think of it as denoting a binary quantity equal to 0 or 1. To represent a group of 2
n distinct 
elements in a binary code requires a minimum of n bits. This is because it is possible to arrange 
n bits in 2n distinct ways. For example, a group of four distinct quantities can be represented by 
a two-bit code, with each quantity assigned one of the following bit combinations: 00, 01, 10, 11. A group of eight elements requires a three-bit code, with each element assigned to one and only one of the following: 000, 001, 010, 011, 100, 101, 110, 111. The examples show that the distinct bit combinations of an n-bit code can be found by counting in binary from 0 to (2
n - 1). 
Some bit combinations are unassigned when the number of elements of the group to be coded 
Binary System 15 
is not a multiple of the power of 2. The ten decimal digits 0, 1, 2, ... , 9 are an example of such a 
group. A binary code that distinguishes among ten elements must contain at least four bits; three bits can distinguish a maximum of eight elements. Four bits can form 16 distinct combinations, but since only ten digits are coded, the remaining six combinations are unassigned and not used.
Although the minimum number of bits required to code 2
n distinct quantities is n, there is no 
maximum number of bits that may be used for a binary code. For example, the ten decimal digits 
can be coded with ten bits, and each decimal digit assigned a bit combination of nine 0’ s and a 1. In this particular binary code, the digit 6 is assigned the bit combination 0001000000.
1.6.1 Decimal Codes
Binary codes for decimal digits require a minimum of four bits. Numerous different codes can be obtained by arranging four or more bits in ten distinct possible combinations. A few possibilities are shown in Table 1-2.
The BCD (binary-coded decimal) is a straight assignment of the binary equivalent. It is 
possible to assign weights to the binary bits according to their positions. The weights in the BCD code are 8, 4, 2, 1. The bit assignment 0110, for example, can be interpreted by the weights to represent the decimal digit 6 because 0 × 8 + 1 × 4 + 1 × 2 + 0 × 1 = 6. It is also possible to assign negative weights to a decimal code, as shown by the 8, 4, - 2, - 1 code. In this case the bit com-
bination 0110 is interpreted as the decimal digit 2, as obtained from 0 × 8 + 1 × 4 + 1 × (-2) + 0 
× (-l) = 2. Two other weighted codes shown in the table are the 2421 and the 5043210. A decimal code that has been used in some old computers is the excess-3 code. This is an unweighted code; its code assignment is obtained from the corresponding value of BCD after the addition of 3.
Numbers are represented in digital computers either in binary or in decimal through a bi-
nary code. When specifying data, the user likes to give the data in decimal form. The input deci-mal numbers are stored internally in the computer by means of a decimal code. Each decimal digit requires at least four binary storage elements. The decimal numbers are converted to binary when arithmetic operations are done internally with numbers represented in binary. It is also possible to perform the arithmetic operations directly in decimal with all numbers left in a coded Table 1-2 Binary codes for the decimal digits
Decimal 
digit(BCD)
8421 Excess-3 84-2-1 2421(Biquinary) 
5043210
0 0000 0011 0000 0000 0100001
1 0001 0100 0111 0001 0100010
2 0010 0101 0110 0010 0100100
3 0011 0110 0101 0011 0101000
4 0100 0111 0100 0100 0110000
5 0101 1000 1011 1011 1000001
6 0110 1001 1010 1100 1000010
7 0111 1010 1001 1101 1000100
8 1000 1011 1000 1110 1001000
9 1001 1100 1111 1111 1010000
16 Chapter 1
form throughout. For example, the decimal number 395, when converted to binary, is equal to 
110001011 and consists of nine binary digits. The same number, when represented internally in the BCD code, occupies four bits for each decimal digit, for a total of 12 bits: 001110010101. The first four bits represent a 3, the next four a 9, and the last four a 5.
It is very important to understand the difference between conversion of a decimal number to 
binary and the binary coding of a decimal number. In each case the final result is a series of bits. 
The bits obtained from conveision are binary digits. Bits obtained from coding are combinations of l’ s and 0’ s arranged according to the rules of the code used. Therefore, it is extremely impor -
tant to realize that a series of l’ s and 0’ s in a digital system may sometimes represent a binary number and at other times represent some other discrete quantity of information as specified by a given binary code. The BCD code, for example, has been chosen to be both a code and a direct binary conversion, as long as the decimal numbers are integers from 0 to 9. For numbers greater than 9, the conversion and the coding are completely different. This concept is so important that it is worth repeating with another example. The binary conversion of decimal 13 is 1101; the coding of decimal 13 with BCD is 00010011.
From the five binary codes listed in Table 1-2, the BCD seems the most natural to use and 
is indeed the one most commonly encountered. The other four-bit codes listed have one charac-teristic in common that is not found in BCD. The excess-3, the 2, 4, 2, 1, and the 8, 4, – 2, – 1 are self-complementary codes, that is, the 9’ s complement of the decimal number is easily obtained by changing l’ s to 0’ s and 0’ s to l’ s. For example, the decimal 395 is represented in the 2, 4, 2, 1 code by 001111111011. Its 9’ s complement 604 is represented by 110000000100, which is easily 
obtained from the replacement of l’ s by 0’ s and 0’ s by l’ s. This property is useful when arithmetic operations are internally done with decimal numbers (in a binary code) and subtraction is calcu-lated by means of 9’ s complement.
The biquinary code shown in Table 1-2 is an example of a seven-bit code with error-detec-
tion properties. Each decimal digit consists of five 0’ s and two l’ s placed in the corresponding weighted columns. The error-detection property of this code may be understood if one realizes that digital systems represent binary 1 by one distinct signal and binary 0 by a second distinct signal. During transmission of signals from one location to another, an error may occur. One or more bits may change value. A circuit in the receiving side can detect the presence of more (or less) than two l’ s and, if the received combination of bits does not agree with the allowable com-bination, an error is detected.
1.6.2 Error-Detection Codes
Binary information, be it pulse-modulated signals or digital computer input or output, may be transmitted through some form of communication medium such as wires or radio waves. Any external noise introduced into a physical communication medium changes bit values from 0 to 1 or vice versa. An error-detection code can be used to detect errors during transmission. The detected error cannot be corrected, but its presence is indicated. The usual procedure is to observe the frequency of errors. If errors occur only once in a while, at random, and without a pronounced effect on the overall information transmitted, then either nothing is done or the par -
ticular erroneous message is transmitted again. If errors occur so often as to distort the meaning of the received information, the system is checked for malfunction.
A parity bit is an extra bit included with a message to make the total number of l’ s either odd 
or even. A message of four bits and a parity bit, P , are shown in Table 1-3. In (a), P is chosen so 
Binary System 17 
that the sum of all l’ s is odd (in all five bits). In (b), P is chosen so that the sum of all l’ s is even. 
During transfer of information from one location to another, the parity bit is handled as follows. In the sending end, the message (in this case the first four bits) is applied to a “parity-generation’ network where the required P bit is generated. The message, including the parity bit, is transfer -
red to its destination. In the receiving end, all the incoming bits (in this case five) are applied to a “parity-check” network to check the proper parity adopted. An error is detected if the checked parity does not correspond to the adopted one. The parity method detects the presence of one, three, or any odd combination of errors. An even combination of errors is undetectable. Further discussion of parity generation and checking can be found in Sec. 4-9.
1.6.3 The Reflected Code
Digital systems can be designed to process data in discrete form only. Many physical systems supply continous output data. These data must be converted into digital or discrete form before they are applied to a digital system. Continuous or analog information is convened into digital form by means of an analog-to-digital converter. It is sometimes convenient to use the reflected code shown in Table 1-4 to represent the digital data converted from the analog data. The advan-tage of the reflected code over pure binary numbers is that a number in the reflected code changes by only one bit as it proceeds from one number to the next. A typical application of the reflected code occurs when the analog data are represented by a continouous change of a shaft position. The shaft is partitioned into segments, and each segment is assigned a number. If adjacent seg-ments are made to correspond to adjacent reflected-code numbers, ambiguity is reduced when Table 1-3 Parity-bit generation
(a) Message P(odd) (b) Message P (even)
0000 1 0000 0
0001 0 0001 1
0010 0 0010 1
0011 1 0011 0
0100 0 0100 1
0101 1 0101 0
0110 1 0110 0
0111 0 0111 1
1000 0 1000 1
1001 1 1001 0
1010 1 1010 0
1011 0 1011 1
1100 1 1100 0
1101 0 1101 1
1110 0 1110 1
1111 1 1111 0
18 Chapter 1
detection is sensed in the line that separates any two segments. The reflected code shown in Table 
1-4 is only one of many possible such codes. To obtain a different reflected code, one can start with any bit combination and proceed to obtain the next bit combination by changing only one bit from 0 to 1 or 1 to 0 in any desired random fashion, as long as two numbers do not have identical 
code assignments. The reflected code is also known as the Gray code.
1.6.4 Alphanumeric Codes
Many applications of digital computers require the handling of data that consist not only of num-bers, but also of letters. For instance, an insurance company with millions of policy holders may use a digital computer to process its files. To represent the policy holder’ s name in binary form, it is necessary to have a binary code for the alphabet. In addition, the same binary code must represent decimal numbers and some other special characters. An alphanumeric (sometimes ab-breviated alphameric) code is a binary code of a group of elements consisting of the ten decimal 
digits, the 26 letters of the alphabet, and a certain number of special symbols such as $. The total number of elements in an alphanumeric group is greater than 36. Therefore, it must be coded with a minimum of six bits (2
6 = 64, but 25 = 32 is insufficient).
One possible arrangement of a six-bit alphanumeric code is shown in Table 1-5 under the 
name “internal code.” With a few variations, it is used in many computers to represent alphanu-meric characters internally. The need to represent more than 64 characters (the lowercase letters and special control characters for the transmission of digital information) gave rise to seven- and 
eight-bit alphanumeric codes. One such code is known as ASCII (American Standard Code for Table 1-4 Four-bit reflected code
Reflected code Decimal equivalent
0000 0
0001 1
0011 2
0010 3
0110 4
0111 5
0101 6
0100 7
1100 8
1101 9
1111 10
1110 11
1010 12
1011 13
1001 14
1000 15
Binary System 19 
Table 1-5 Alphanumeric character codes
6-Bit 7-Bit 8-Bit 12-Bit
Character internal code ASCII code EBCDIC code card code
A 010 001 100 0001 1100 0001 12,1
B 010 010 100 0010 1100  0010 12,2
C 010 011 100 0011 1100 0011 12,3
D 010 100 100 0100 1100  0100 12,4
E 010 101 100 0101 1100 0101 12,5
F 010 110 100 0110 1100 0110 12,6
G 010 111 100 0111 1100 0111 12,7
H 011 000 100 1000 1100  1000 12,8
I 011 001 100 1001 1100 1001 12,9
J 100 001 100 1010 1101 0001 11,1
K 100 010 100 1011 1101 0010 11,2
L 100 011 100 1100 1101 0011 11.3
M 100 100 100  1101 1101 0100 11,4
N 100 101 100  1110 1101 0101 11.5
O 100 110 100 1111 1101 0110 11,6
P 100 111 101 0000 1101 0111 11,7
Q 101 000 101 0001 1101 1000 11,8
R 101 001 101 0010 1101 1001 11,9
S 110 010 101 0011 1110 0010 0,2
T 110 011 101 0100 1110 0011 0,3
U 110 100 101 0101 1110 0100 0,4
V 110 101 101 0110 1110 0101 0,5
W 110 110 101 0111 1110 0110 0,6
X 110 111 101 1000 1110 0111 0,7
Y 111 000 101 1001 1110 1000 0,8
Z 111 001 101 1010 1110 1001 0,9
0 000 000 011 0000 1111 0000 0
1 000 001 011 0001 1111 0001 1
2 000 010 011 0010 1111 0010 2
3 000 011 011 0011 1111 0011 3
4 000 100 011 0100 1111 0100 4
5 000 101 011 0101 1111 0101 5
6 000 110 011 0110 1111 0110 6
20 Chapter 1
Information Interchange); another is known as EBCDIC (Extended BCD Interchange Code). 
The ASCII code listed in Table 1-5 consists of seven bits but is, for all practical purposes, an eight-bit code because an eighth bit is invariably added for parity. When discrete information is transferred through punch cards, the alphanumeric characters use a 12-bit binary code. A punch card consists of 80 columns and 12 rows. In each column, an alphanumeric character is repre-sented by holes punched in the appropriate rows. A hole is sensed as a 1 and the absence of a hole is sensed as a 0. The 12 rows are marked, starting from the top, as the 12, 11, 0, 1, 2,..., 9 punch. The first three are called the zone punch and the last nine are called the numeric punch. The 
12-bit card code shown in Table 1-5 lists the rows where a hole is punched (giving the l’ s). The 
remaining unlisted rows are assumed to be 0’ s. The 12-bit card code is inefficient with respect to 
the number of bits used. Most computers translate the input code into an internal six-bit code. As an example, the internal code representation of the name “John Doe” is:
         100001 100110 011000 100101 110000 010100 1001 10 010101
J O H N blank D O E
1.7 Binary Storage and Registers
The discrete elements of information in a digital computer must have a physical existence in some information storage medium. Furthermore, when discrete elements of information are rep-resented in binary form, the information storage medium must contain binary storage elements for storing individual bits. A binary cell is a device that possesses two stable states and is capable of storing one bit of information. The input to the cell receives excitation signals that set it to one of the two states. The output of the cell is a physical quantity that distinguishes between the two states. The information stored in a cell is a 1 when it is in one stable state and a 0 when in the other stable state. Examples of binary cells are electronic flip-flop circuits, ferrite cores used in memories, and positions punched with a hole or not punched in a card.7 000 111 011 0111 1111 0111 7
8 001 000 011 1000 1111 1000 8
9 001 001 011 1001 1111 1001 9
blank 110 000 010 0000 0100 0000 no punch
011 011 010 1110 0100 1011 12,8,3
( 111 100 010 1000 0100 1101 12,8,5
 + 010 000 010 1011 0100 1110 12,8,6
$ 101 011 010 0100 0101 1011 11,8,3
* 101 100 010 1010 0101 1100 11,8,4
) 011 100 010 1001 0101 1101 11,8,5
– 100 000 010 1101 0110 0000 11
/ 110 001 010 1111 0110 0001 0,1
, 111 011 010 1100 0110 1011 0,8,3
 = 001 011 011 1101 0111 1110 8,6
Binary System 21 
1.7.1 Registers
A register is a group of binary cells. Since a cell stores one bit of information, it follows that a 
register with n cells can store any discrete quantity of information that contains n bits. The state 
of a register is an n-tuple number of l’ s and 0’ s, with each bit designating the state of one cell in 
the register. The content of a register is a function of the interpretation given to the information 
stored in it. Consider, for example, the following 16-cell register:
1100001111001001
12345678910111213141516
Physically, one may think of the register as composed of 16 binary cells, with each cell 
storing either a 1 or a 0. Suppose that the bit configuration stored in the register is as shown. The state of the register is the 16-tuple number 1100001111001001. Clearly, a register with n cells 
can be in one of 2
n possible states. Now, if one assumes that the content of the register represents 
a binary integer, then obviously the register can store any binary number from 0 to 216- 1. For 
the particular example shown, the content of the register is the binary equivalent of the decimal number 50121. If it is assumed that the register stores alphanumeric characters of an eight-bit code, the content of the register is any two meaningful characters (unassigned bit combinations do not represent meaningful information). In the EBCDIC code, the above example represents the two characters C (left eight bits) and I (right eight bits). On the other hand, if one interprets the content of the register to be four decimal digits represented by a four-bit code, the content of the register is a four-digit decimal number. In the excess-3 code, the above example is the decimal number 9096. The content of the register is meaningless in BCD since the bit combina-tion 1100 is not assigned to any decimal digit. From this example, it is clear that a register can store one or more discrete elements of information and that the same bit configuration may be interpreted differently for different types of elements of information. It is important that the user store meaningful information in registers and that the computer be programmed to process this information according to the type of information stored.
1.7.2 Register Transfer
A digital computer is characterized by its registers. The memory unit (Fig. 1-1) is merely a col-lection of thousands of registers for storing digital information. The processor unit is composed of various registers that store operands upon which operations are performed. The control unit uses registers to keep track of various computer sequences, and every input or output device must have at least one register to store the information transferred to or from the device. An inter-register transfer operation, a basic operation in digital systems, consists of a transfer of the information stored in one register into another. Figure 1-2 illustrates the transfer of information among registers and demonstrates pictorially the transfer of binary information from a teletype keyboard into a register in the memory unit. The input teletype unit is assumed to have a key-board, a control circuit, and an input register. Each time a key is struck, the control enters into the input register an equivalent eight-bit alphanumeric character code. We shall assume that the code used is the ASCII code with an odd-parity eighth bit. The information from the input register
 is 
transferred into the eight least significant cells of a processor register. After every transfer, the input register is cleared to enable the control to insert a new eight-bit code when the keyboard is struck again. Each eight-bit character transferred to the processor register is preceded by a shift 
22 Chapter 1
of the previous character to the next eight cells on its left. When a transfer of four characters is 
completed, the processor register is full, and its contents are transferred into a memory register. The content stored in the memory register shown in Fig. 1-2 came from the transfer of the cha-racters JOHN after the four appropirate keys were struck.
To process discrete quantities of information in binary form, a computer must be provided 
with (1) devices that hold the data to be processed and (2) circuit elements that manipulate individual bits of information. The device most commonly used for holding data is a register. Manipulation of binary variables is done by means of digital logic circuits. Figure 1-3 illustrates the process of adding two 10-bit binary numbers. The memory unit, which normally consists of thousands of registers, is shown in the diagram with only three of its registers. The part of the processor unit shown consists of three registers, Rl, R2, and R3, together with digital logic circuits that manipulate the bits of Rl and R2 and transfer into R3 a binary number equal to their arithmetic sum. Memory registers store information and are incapable of processing the two operands. However, the information stored in memory can be transferred to processor registers. Results obtained in processor registers can be transferred back into a memory register for stor -
age until needed again. The diagram shows the contents of two operands transferred from two memory registers into Rl and R2. The digital logic circuits produce the sum, which is transferred to register R3. The contents of R3 can now be transferred back to one of the memory registers.
The last two examples demonstrated the information flow capabilities of a digital system in 
a very simple manner. The registers of the system are the basic elements for storing and holding the binary information. The digital logic circuits process the information. Digital logic circuits and their manipulative capabilities are introduced in the next section. The subject of registers and register transfer operations is taken up again in Chapter 8.MEMOR Y UNI T
Memor y 
Regist erJO HN
010010100100111111 00100011001110
PROCESSOR UNIT
8 cells 8 cells 8 cells 8 cellsProcessor 
Regist er
INPUT TELETYPE UNI T
J
O
H
NInput Regist er
CONTR OLKeyboar d8 cells
Figure 1.2 Transfer of information with registers
Binary System 23 
1.8 Binary Logic
Binary logic deals with variables that take on two discrete values and with operations that assume 
logical meaning. The two values the variables take may be called by different names (e.g., true and false, yes and no, etc.), but for our purpose it is convenient to think in terms of bits and assign 
the values of 1 and 0. Binary logic is used to describe, in a mathematical way, the manipulation 
and processing of binary information. It is particularly suited for the analysis and design of digi-tal systems. For example, the digital logic circuiis of Fig. 1-3 that perform the binary arithmetic are circuits whose behavior is most conveniently expressed by means of binary variables and logical operations. The binary logic to be introduced in this section is equivalent to an algebra 
called Boolean algebra. The formal presentation of a two-valued Boolean algebra is covered in more detail in Chapter 2. The purpose of this section is to introduce Boolean algebra in a heuris-tic manner and relate it to digital logic circuits and binary signals.
1.8.1 Definition of Binary Logic
Binary logic consists of binary variables and logical operations. The variables are designated by letters of the alphabet such as A, B, C, x. y. z, etc., with each variable having two and only two 
distinct possible values: 1 and 0. There are three basic logical operations: AND, OR, and NOT.
1. AND: This operation is represented by a dot or by the absence of an operator. For ex-ample, x • y = z or xy = z  is read “x AND y is equal to z.”  The logical operation AND is 
interpreted to mean that z = 1 if and only if x  = 1 and y = 1; otherwise z  = 0. (Remember 
that x,y, and z are binary variables and can be equal either to I or 0, and nothing else.)0 0 0 0 0 0 0 0 0 0MEMOR Y UNI T
Sum
0 0 1 1 1 0 0 0 0 1Operand 1
Operand 2
0 0 0 1 0 0 0 0 1 0
0 0 0 1 0 0 0 0 1 0
0 0 1 1 1 0 0 0 0 10 1 0 0 1 0 0 0 1 1
PROCESSOR UNITR1
R2R3Digital logi c
ciruits fo r
binar y addition
Figure 1.3 Example of binary information processing
24 Chapter 1
2. OR: This operation is represented by a plus sign. For example, x  + y = z is read “x OR 
y is equal to z .” meaning that z = 1 if x  = 1 or if y = 1 or if both x  = 1 and y = 1. If both  
x = 0 and y  = 0, then z  = 0.
3. NOT: This operation is represented by a prime (sometimes by a bar). For example, x ′ = z 
(or x = z) is read “x not is equal to z ,” meaining that z is what x is not. In other words, if 
x = 1, then z  = 0 but if x  = 0, then z  = 1.
Binary logic resembles binary arithmetic, and the operations AND and OR have some simi-
larities to multiplication and addition, respectively. In fact, the symbols used for AND and OR 
are the same as those used for multiplication and addition. However, binary logic should not be confused with binary arithmetic. One should realize that an arithmetic variable designaies a number that may consist of many digits. A logic variable is always either a 1 or a 0. For example, in binary arithmetic we have 1 + 1 = 10 (read: “one plus one is equal to 2”), while in binary logic 
we have 1 + 1 = 1 (read: “one OR one is equal to one”).
For each combination of the values of x and y, there is a value of z specificed by the defini-
tion of the logical operation. These definitions may be listed in a compact form using truth tables. A truth table is a table of all possible combinations of the variables showing the relation between the values that the variables may take and the result of the operation. For example, the truth tables for the operations AND and OR with variables x and y are obtained by listing all possible values 
that the variables may have when combined in pairs. The result of the operation for each combi-nation is then listed in a separate row. The truth tables for AND, OR, and NOT are listed in Table 1-6. These tables clearly demonstrate the definitions of the operations.
1.8.2 Switching Circuits and Binary Signals
The use of binary variables and the application of binary logic are demonstrated by the simple switching circuits of Fig, 1-4. Let the manual switches A and B represent two binary variables 
with values equal to 0 when the switch is open and 1 when the switch is closed. Similarly, let the lamp L represent a third binary variable equal to 1 when the light is on and 0 when off. For the 
switches in series, the light turns on if A and B are closed. For the switches in parallel, the light turns on if A or B is closed. It is obvious that the two circuits can be expressed by means of binary 
logic with the AND and OR operations, respectively:
L = A . B      for the circuit of Fig. l-4(a) 
L = A + B      for the circuit of Fig. l-4(b)Table 1-6 Truth tables of logical operations
AND OR NOT
x y x ⋅ y x y x + y x x’
0 0 0 0 0 0 0 1
0 1 0 0 1 1 1 0
1 0 0 1 0 1
1 1 1 1 1 1
Binary System 25 
Electronic digital circuits are sometimes called switching circuits because they behave like 
a switch, with the active element such as a transistor either conducting (switch closed) or not 
conducting (switch open). Instead of changing the switch manually, an electronic switching cir -
cuit uses binary signals to control the conduction or nonconduction state of the active element. Electrical signals such as voltages or currents exist throughout a digital system in either one of two recognizable values (except during transition). V oltage-operated circuits, for example, re-spond to two separate voltage levels which represent a binary variable equal to logic-1 or logic-0. For example, a particular digital system may define logic-1 as a signal with a nominal value of 3 volts, and logic-0 as a signal with a nominal value of 0 volt. As shown in Fig. 1-5, each voltage level has an acceptable deviation from the nominal. The intermediate region between the allowed regions is crossed only during stale transitions. The input terminals of digital circuits accept binary signals within the allowable tolerances and respond at the output terminal with binary signals that fall within the specified tolerances.
1.8.3 Logic Gates
Electronic digital circuits are also called logic circuits because, with the proper input, they es-tablish logical manipulation paths. Any desired information for computing or control can be  
4Volts
Nominal logic-1
Nominal logic-0Transition occur s
between these limit sTolerance
allowed
for logic-1
Tolerance
allowed
for logic-03
2
1
0.5
–0.50
Figure 1.5 Example of binary signalssL
Voltage
sour ceAB
   
sL
Voltage
sour ceA
B
     (a) Switches in series - logic AND             (b) Switches in parallel - Logic OR
Figure 1.4 Switching circuits that demonstrate binary logic
26 Chapter 1
operated upon by passing binary signals through various combinations of logic circuits, each 
signal representing a variable and carrying one bit of information. Logic circuits that perform the logical operations of AND, OR, and NOT are shown with their symbols in Fig. 1-6. These cir -
cuits, called gates, are blocks of hardware that produce a logic-1 or logic-0 output signal if input 
logic requirements are satisfied. Note that four different names have been used for the same type of circuits, digital circuits, switching circuits, logic circuits, and gates. All four names are widely used, but we shall refer to the circuits as AND, OR, and NOT gates. The NOT gate is sometimes called an inverter circuit since it inverts a binary signal.
The input signals x and y in the two-input gates of Fig. 1-6 may exist in one of four possible 
states: 00, 10, 11, or 01. These input signals are shown in Fig. 1-7, together with the output sig-nals for the AND and OR gates. The timing diagrams in Fig. 1-7 illustrate the response of each circuit to each of the four possible input binary combinations. The reason for the name “inverter” for the NOT gate is apparent from a comparison of the signal x (input of inverter) and that of x’ 
(output of inverter).
AND and OR gates may have more than two inputs. An AND gate with three inputs and 
an OR gate with four inputs are shown in Fig. 1-6. The three-input AND gate responds with a logic-1 output if all three input signals are logic-1. The output produces a logic-0 signal if any input is logic 0. The four input OR gate responds with a logic-1 when any input is a logic-1. Its output becomes logic-0 if all input signals are logic-0.
The mathematical system of binary logic is better known as Boolean, or switching, alge-
bra. This algebra is conveniently used to describe the operation of complex networks of digital circuits. Designers of digital systems use Boolean algebra to transform circuit diagrams to alge-braic expressions and vice versa. Chapters 2 and 3 are devoted to the study of Boolean algebra, its properties, and manipulative capabilities. Chapter 4 shows how Boolean algebra may be used to express mathematically the interconnections among networks of gates.
1.9 Integrated Circuits
Digital circuits are invariably constructed with integrated circuits. An integrated circuit (abbrevi-ated IC) is a small silicon semiconductor crystal, called a chip, containing electrical components 
such as transistors, diodes, resistors, and capacitors. The various components are interconnected inside the chip to form an electronic circuit. The chip is mounted on a metal or plastic package, and connections are welded to external pins to form the IC. Integrated circuits differ from other electronic circuits composed of detachable components in that individual components in the IC                x z = x · y
y             z = x + y x
y               x x´
(a) Two-input AND gate         (b) Two-input OR gate        (c) NOT gate or inverter
 F = ABC
CBA
 G =  A + B + C + D BA
DC
           (d) Three-input AND gate (e) Four-input OR gate
Figure 1.6 Symbols for digital logic circuits
Binary System 27 
cannot be separated or disconnected and the circuit inside the package is accessible only through 
the external pins.
Integrated circuits come in two types of packages, the flat package and the dual-in-line 
(DIP) package, as shown in Fig. 1-8. The dual-in-line package is the most widely used type be-cause of the low price and easy installation on circuit boards. The envelope of the IC package is made of plastic or ceramic. Most packages have standard sizes, and the number of pins ranges from 8 to 64. Each IC has a numeric designation printed on the surface of the package for iden-tification. Each vendor publishes a data book or catalog that provides the necessary information concerning the various products.
The size of IC packages is very small. For example, four AND gates are enclosed inside a 
14-pin dual-in-line package with dimensions of 20 × 8 × 3 millimeters. An entire microproces-
sor is enclosed within a 40-pin dual-in-line package with dimensions of 50 × 15 × 4 millimeters.
Besides a substantial reduction in size, ICs offer other advantages and benefits compared 
to electronic circuits with discrete components. The cost of ICs is very low, which makes them economical to use. Their reduced power consumption makes the digital system more economical to operate. They have a high reliability against failure, so the digital system needs less repairs. The operating speed is higher, which makes them suitable for high-speed operations. The use of ICs reduces the number of external wiring connections because many of the connections are internal to the package. Because of all these advantages, digital systems are always constructed with integrated circuits.
Integrated circuits are classified in two general categories, linear and digital. Linear ICs 
operate with continuous signals to provide electronic functions such as amplifiers and voltage x
y
AND:  x · y
OR: x + y
NOT: x´0 00 11
0 0 0 1 1
0 000 1
0 0
0 01
1 111 1
Figure 1.7 Input-output signals for gates (a), (b), and (c) of Fig. 1.6
Flat package Dual-in-line package
Figure 1.8 Integrated-circuit packages
28 Chapter 1
comparators. Digital integrated circuits operate with binary signals and are made up of intercon-
nected digital gates. Here we are concerned only with digital integrated circuits.
As the technology of ICs has improved, the number of gates that can be put on a single 
silicon chip has increased considerably. The differentiation between those ICs that have a few internal gates and those having tens or hundreds of gates is made by a customary reference to a package as being either a small-, medium-, or large-scale integration device. Several logic gates in a single package make it a small-scale integration (SSI) device. To qualify as a medium-scale integration (MSI) device, the IC must perform a complete logic function and have a complexity of 10 to 100 gates. A large-scale integration (LSI) device performs a logic function with more than 100 gates. There are also very-large-scale integration (VLSI) devices that contain thousands of gates in a single chip.
Many diagrams of digital circuits considered throughout this book arc shown in detail up to 
the individual gates and their interconnections. Such diagrams are useful for demonstrating the logical construction of a particular function. However, it must be realized that, in practice, the function may be obtained from an MSI or LSI device, and the user has access only to external inputs and outputs but not to inputs and outputs of intermediate gates. For example, a designer who wants to incorporate a register in his system is more likely to choose such a function from an available MSI circuit instead of designing it with individual digital circuits as may be shown in a diagram.
REFERENCES
1. Richard, R. K., Arithmetic Operations in Digital Computers. New Y ork: Van Nostrand Co., 1955.
2. Flores, I. The Logic of Computer Arithmetic. Englewood Cliffs, N. J.: Prentice-Hall, Inc., l963.
3. Chu, Y ., Digital Computer Design Fundamentals. New Y ork: McGraw-Hill Book Co., 1962, Chaps. 
1 and 2.
4. Kostopoulos, G. K., Digital Engineering. New Y ork: John Wiley & Sons, Inc., 1975, Chap. 1.
5. Rhyne, V . T, Fundamentals of Digital Systems Design. Englewood Cliffs, N. J.: Prentice-Hall. Inc., 
1973, Chap, 1.
PROBLEMS
1-1. Write the first 20 decimal digits in base 3.
1-2. Add and multiply the following numbers in the given base without convening to decimal.
(a) (1230)4 and (23)4
(b) (135.4)6 and (43.2)6
(c) (367)8 and (715)8
(d) (296)12 and (57)12
1-3. Convert the decimal number 250.5 to base 3, base 4, base 7, base 8, and base 16.
1-4. Convert the following decimal numbers to binary: 12.0625, 104, 673.23, and 1998.
1-5.  Convert the following binary numbers to decimal: 10.10001, 101110.0101, 1110101.110,  
1101101.111.
Binary System 29 
1-6. Convert the following numbers from the given base to the bases indicated:
(a) decimal 225.225 to binary, octal, and hexadecimal
(b) binary 11010111.110 to decimal, octal, and hexadecimal
(c) octal 623.77 to decimal, binary, and hexadecimal
(d) hexadecimal 2AC5.D to decimal, octal, and binary
1-7. Convert the following numbers to decimal:(a) (1001001.01l)
2  (e)    (0.342)6
(b) (12121)3  (f)    (50)7
(c) (1032.2)4  (g)    (8.3)9
(d) (4310)5   (h)    (198)12
1-8. Obtain the l’ s and 2’ s complement of the following binary numbers: 1010101, 0111000, 0000001, 
10000, 00000.
1-9. Obtain the 9’ s and 10’ s complement of the following decimal numbers: 13579, 09900, 90090, 10000, 00000.
1-10.  Find the 10’ s complement of (935)
11
1-11.  Perform the subtraction with the following decimal numbers using (1) 10’ s complement and (2) 9’ s complement. Check the answer by straight subtraction.
(e) 5250 - 321  (c)    753 - 864
(f) 3570 - 2100  (d)    20 - 1000
1-12. Perform the subtraction with the following binary numbers using (1) 2’ s complement 
and (2) l’ s complement. Check the answer by straight subtraction.
(a)  11010- 1101  (c)    10010- 10011
(b) 11010-10000  (d)    100 - 110000
1-13.  Prove the procedure stated in Sec. 1-5 for the subtraction of two numbers with (r - l)’ s complement.
1-14.  For the weighted codes (a) 3, 3, 2, 1 and (b) 4, 4, 3, - 2 for the decimal digits, determine all possible 
tables so that the 9’ s complement of each decimal digit is obtained by changing l’ s to 0’ s and 0’ s  
to l’ s.
1-15.  Represent the decimal number 8620 (a) in BCD, (b) in excess-3 code, (c) in 2, 4, 2, 1 code, and (d) 
as a binary number.
1-16.  A binary code uses ten bits to represent each of the ten decimal digits. Each digit is assigned a code 
of nine 0’ s and a 1. The code for digit 6, for example, is 0001000000, Determine the binary code for 
the remaining decimal digits.
1-17.  Obtain the weighted binary code for the base-12 digits using weights of 5421.
1-18.  Determine the odd-parity bit generated when the message consists of the ten decimal digits in the 8, 
4, - 2, - 1 code.
1-19.  Determine two other combinations for a reflected code other than the one shown in Table 1-4.
1-20.  Obtain a binary code to represent all base-6 digits so that the 5’ s complement is obtained by repla-cing l’ s by 0’ s and 0’ s by 1’ s in the bits of the code.
1-21.  Assign a binary code in some orderly manner to the 52 playing cards. Use the minimum number of bits.
1-22.  Write your first name, middle initial, and last name in an eight-bit code made up of the seven ASCII bits of Table 1-5 and an even parity bit in the most significant position. Include blanks between names and a period after the middle initial.
30 Chapter 1
1-23.  Show the bit configuration of a 24-cell register when its content represents (a) the number (295)10 in 
binary, (b) the decimal number 295 in BCD, and (c) the characters XY5 in EBCDIC.
1-24.  The state of a 12-cell register is 010110010111. What is its content if it represents (a) three decimal 
digits in BCD, (b) three decimal digits in excess-3 code, (c) three decimal digits in 2, 4, 2, I code, and (d) two characters in the internal code of Table 1-5?
1-25.  Show the contents of all registers in Fig. 1-3 if the two binary numbers added have the decimal equi-valent of 257 and 1050. (Assume registers with 11 cells.)
1-26.  Express the following switching circuit in binary logic notation.
sL
Voltage
sour ceA
C
B
1-27.  Show the signals (by means of a diagram similar to Fig. 1-7) of the outputs F and G in Fig. 1-6, Use arbitrary binary signals for the inputs A, B, C, and D.
1-28. Explain switch equivalent circuits of NOT, NAND, NOR, X-OR, AND X-NOR.
1-29. Convert following into Octal
 (BC5A)
16, (10101011.1101)2, (765.54)10
1-30. Write short notes on Digital Computer, Number System, Complements, Error Detection Code,  
Reflected code, register transfer, integrated circuits.
1-31. Perform ( -44)10 - (67)10 using 10’ s complement method.
2Chapter
Boolean algebra and Logic Gates2.1 Basic Definitions
Boolean algebra, like any other deductive mathematical system, may be defined with a set of ele-
ments, a set of operators, and a number of unproved axioms or postulates. A set of elements is any 
collection of objects having a common property. If S is a set, and x and y are certain objects, then 
x  ∈ S denotes that x is a member of the set S, and y ∉ S denotes that y is not an element of S. A set 
with a denumerable number of elements is specified by braces: A = {1, 2, 3, 4}, i.e., the elements 
of set A are the numbers 1, 2, 3, and 4. A binary operator defined on a set S of elements is a rule 
that assigns to each pair of elements from S a unique element from S. As an example, consider the 
relation a*b = c. We say that * is a binary operator if it specifies a rule for finding c from the pair  
(a, b) and also if a, b, c  ∈ S. However, * is not a binary operator if a, b  ∈ S, while the rule  
finds c ∉ S.
The postulates of a mathematical system form the basic assumptions from which it is pos-
sible to deduce the rules, theorems, and properties of the system. The most common postulates used to formulate various algebraic structures are:
1. Closure. A set S is closed with respect to a binary operator if, for every pair of elements 
of S, the binary operator specifies a rule for obtaining a unique element of S. For example, the set of natural numbers N = {1, 2, 3, 4,...} is closed with respect to the binary opera-tor plus (+) by the rules of arithmetic addition, since for any a, b ∈ N we obtain a unique  
c ∈ N by the operation a + b = c. The set of natural numbers is not closed with respect to 
the binary operator minus (-) by the rules of arithmetic subtraction because 2 − 3 = − 1 
and 2, 3 ∈ N, while (−1) ∉ N.
2. Associative law. A binary operator * on a set S is said to be associative whenever:
 (x* y)*z = x*(y*z)          for all x, y, z ∈ S
3. Commutative law. A binary operator * on a set S is said to be commutative whenever:
 x* y = y* x          for all x, y ∈ S
4. Identity element. A set S is said to have an identity element with respect to a binary opera-tion * on S if there exists an element e ∈ S with the property:
 e* x = x* e = x          for every x ∈ S
32 Chapter 2
 Example: The element 0 is an identity element with respect to operation + on the set of 
integers I = {... ,−3, −2, −1, 0, 1, 2, 3, ... } since:
 x + 0 = 0 + x = x          for any x ∈ I
 The set of natural numbers N has no identity element since 0 is excluded from the set.
5. Inverse. A set S having the identity element e with respect to a binary operator * is said to 
have an inverse whenever, for every x ∈ S, there exists an element y ∈ S such that:
x* y = e
 Example: In the set of integers I with e = 0, the inverse of an element a is (-a) since  
a + (-a) = 0.
6. Distributive law. If * and • are two binary operators on a set S, * is said to be distributive 
over • whenever:
x*(y • z) = (x*y) • (x*z)
An example of an algebraic structure is a field. A field is a set of elements, together with two 
binary operators, each having properties 1 to 5 and both operators combined to give property 6. The set of real numbers together with the binary operators + and • form the field of real numbers. The field of real numbers is the basis for arithmetic and ordinary algebra. The operators and postulates have the following meanings:
The binary operator + defines addition.
The additive identity is 0.The additive inverse defines subtraction.The binary operator • defines multiplication.The multiplicative identity is 1.The multiplicative inverse of a = 1/a defines division, i.e., a • 1/a = 1.The only distributive law applicable is that of • over +:
a • (b + c) = (a • b) + (a • c)
2.2 Axiomatic Definition of Boolean Algebra
In 1854 George Boole (1) introduced a systematic treatment of logic and developed for this 
purpose an algebraic system now called Boolean algebra. In 1938 C. E. Shannon (2) introduced a two-valued Boolean algebra called switching algebra, in which he demonstrated that the prop-
erties of bistable electrical switching circuits can be represented by this algebra. For the formal definition of Boolean algebra, we shall employ the postulates formulated by E. V . Huntington (3) in 1904. These postulates or axioms are not unique for defining Boolean algebra. Other sets of postulates have been used.
* Boolean algebra is an algebraic structure defined on a set of elements 
*See, for example, Birkoff and Bartee (4), Chapter 5.
Boolean Algebra and Logic Gates  33 
B together with two binary operators + and • provided the following (Huntington) postulates are 
satisfied:
1. (a) Closure with respect to the operator +.
 (b) Closure with respect to the operator.
2. (a) An identity element with respect to +, designated by 0: x + 0 = 0 + x = x.
 (b) An identity element with respect to •, designated by 1: x 1 = 1 • x = x.
3. (a) Commutative with respect to +: x + y = y + x.
 (b) Commutative with respect to : x y = y • x.
4. (a) • is distributive over + : x • (y + z) = (x • y) + (x • z).
 (b) + is distributive over: x + (y • z) = (x + y) • (x + z).
5. For every element x ∈ B, there exists an element x′ ∈ B (called the complement of x) such 
that: (a) x + x′= 1 and (b) x • x′ = 0.
6. There exists at least two elements x, y ∈ B such that x ¹ y.
Comparing Boolean algebra with arithmetic and ordinary algebra (the field of real num-
bers), we note the following differences:
1. Huntington postulates do not include the associative law. However, this law holds for Bool-ean algebra and can be derived (for both operators) from the other postulates.
2. The distributive law of + over •, i.e., x + (y • z) = (x + y) • (x + z), is valid for Boolean alge-
bra, but not for ordinary algebra.
3. Boolean algebra does not have additive or multiplicative inverses; therefore, there are no subtraction or division operations.
4. Postulate 5 defines an operator called complement which is not available in ordinary  
algebra.
5. Ordinary algebra deals with the real numbers, which constitute an infinite set of elements. Boolean algebra deals with the as yet undefined set of elements B, but in the two-valued 
Boolean algebra defined below (and of interest in our subsequent use of this algebra), B is 
defined as a set with only two elements, 0 and 1.
Boolean algebra resembles ordinary algebra in some respects. The choice of symbols + and 
• is intentional to facilitate Boolean algebraic manipulations by persons already familiar with ordinary algebra. Although one can use some knowledge from ordinary algebra to deal with Boolean algebra, the beginner must be careful not to substitute the rules of ordinary algebra where they are not applicable.
It is important to distinguish between the elements of the set of an algebraic structure and 
the variables of an algebraic system. For example, the elements of the field of real numbers are numbers, whereas variables such as a, b, c, etc., used in ordinary algebra, are symbols that stand for real numbers. Similarly in Boolean algebra, one defines the elements of the set B, and vari-
ables such as x, y. z are merely symbols that represent the elements. At this point, it is important to realize that in order to have a Boolean algebra, one must show:
34 Chapter 2
1. the elements of the set B,
2. the rules of operation for the two binary operators, and
3. that the set of elements B, together with the two operators, satisfies the six Huntington 
postulates.
One can formulate many Boolean algebras, depending on the choice of elements of B and 
the rules of operation.* In our subsequent work, we deal only with a two-valued Boolean algebra, 
i.e., one with only two elements. Two-valued Boolean algebra has applications in set theory (the 
algebra of classes) and in propositional logic. Our interest here is with the application of Boolean algebra to gate-type circuits.
2.2.2 Two-Valued Boolean Algebra
A two-valued Boolean algebra is defined on a set of two elements, B = {0, 1}, with rules for the 
two binary operators + and • as shown in the following operator tables (the rule for the comple-ment operator is for verification of postulate 5):
x   y x • y
0   0 0
0   1 0
1   0 0
1   1 1  x   y x + y
0   0 0
0   1 1
1   0 1
1   1 1  x x'
0 1
1 0
These rules are exactly the same as the AND, OR, and NOT operations, respectively, 
defined in Table 1-6. We must now show that the Huntington postulates are valid for the set  
B = {0, 1} and the two binary operators defined above.
1. Closure is obvious from the tables since the result of each operation is either 1 or 0 and 1, 
0 ∈ B.
2. From the tables we see that:
(a) 0 + 0 = 0    0 + 1 − 1 + 0 = 1
(b) 1 • 1 = 1    1 • 0 = 0 • 1 = 0
 which establishes the two identity elements 0 for + and 1 for • as defined by postulate 2.
3. The commutative laws are obvious from the symmetry of the binary operator tables.
4. (a)   The distribute law x • (y + z) = (x • y) + (x • z) can be shown to hold true from the 
operator tables by forming a truth table of all possible values of x, y, and z. For each 
combination, we derive x • (y + z) and show that the value is the same as (x • y)  
+ (x • z).
*See, for example, Hohn (6), Whitesitt (7), or Birkhoff and Bartee (4).
Boolean Algebra and Logic Gates  35 
x   y   z y + z x • (y + z) x • y x • z (x • y) + (x • z)
0   0   0 0 0 0 0 0
0   0   1 1 0 0 0 0
0   1   0 1 0 0 0 0
0   1   1 1 0 0 0 0
1   0   0 0 0 0 0 0
1   0   1 1 1 0 1 1
1   1   0 1 1 1 0 1
1   1   1 1 1 1 1 1
(b) The distributive law of + over • can be shown to hold true by means of a truth table 
similar to the one above.
5. From the complement table it is easily shown that:
(a) x + x′ = 1, since 0 + 0′ = 0 + 1 = 1 and 1 + 1′ = 1 + 0 = 1
(b) x • x′ = 0, since 0 • 0′ = 0 • 1 = 0 and 1 • 1′ = 1 • 0 = 0 which verifies postulate 5.
6. Postulate 6 is satisfied because the two-valued Boolean algebra has two distinct elements 
1 and 0 with 1 ¹ 0.
We have just established a two-valued Boolean algebra having a set of two elements, 1 and 
0, two binary operators with operation rules equivalent to the AND and OR operations, and a complement operator equivalent to the NOT operator. Thus, Boolean algebra has been defined in a formal mathematical manner and has been shown to be equivalent to the binary logic presented heuristically in Section 1-8. The heuristic presentation is helpful in understanding the application of Boolean algebra to gate-type circuits. The formal presentation is necessary for developing the theorems and properties of the algebraic system. The two-valued Boolean algebra defined in this section is also called “switching algebra” by engineers. To emphasize the similarities between two-valued Boolean algebra and other binary systems, this algebra was called “binary logic” in Section 1-8. From here on, we shall drop the adjective “two-valued” from Boolean algebra in subsequent discussions.
2.3 Basic Theorems and Properties of Boolean Algebra
2.3.1 Duality
The Huntington postulates have been listed in pairs and designated by part (a) and part (b). One part may be obtained from the other if the binary operators and the identity elements are inter -
changed. This important property of Boolean algebra is called the duality principle. It states that every algebraic expression deducible from the postulates of Boolean algebra remains valid if the operators and identity elements are interchanged. In a two-valued Boolean algebra, the identity elements and the elements of the set B are the same: 1 and 0. The duality principle has many ap-
plications. If the dual of an algebraic expression is desired, we simply interchange OR and AND 
operators and replace 1’ s by 0’ s and 0’ s by 1’ s.
36 Chapter 2
2.3.2 Basic Theorems
Table 2-1 lists six theorems of Boolean algebra and four of its postulates. The notation is sim-
plified by omitting the • whenever this does not lead to confusion. The theorems and postulates listed are the most basic relationships in Boolean algebra. The reader is advised to become fa-miliar with them as soon as possible. The theorems, like the postulates, are listed in pairs; each relation is the dual of the one paired with it. The postulates are basic axioms of the algebraic structure and need no proof. The theorems must be proven from the postulates. The proofs of the theorems with one variable are presented below. At the right is listed the number of the postulate which justifies each step of the proof.
THEOREM 1(a): x + x = x.
  x + x = (x + x) • 1 by postulate: 2(b)
            = (x + x)(x + x′) 5(a)
            = x + xx′ 4(b)
            = x + 0 5(b)
            = x 2(a)
THEOREM 1(b): x • x = x.
  x • x = xx + 0 by postulate: 2(a)
          = xx + xx′ 5(b)
          = x(x + x′) 4(a)
          = x • 1 5(a)
          = x 2(b)
Note that theorem 1(b) is the dual of theorem 1(a) and that each step of the proof in part 
(b) is the dual of part (a). Any dual theorem can be similarly derived from the proof of its cor -
responding pair.Table 2–1 Postulates and theorems of Boolean algebra
Postulate 2 (a) x + 0 = x (b) x • 1 = x
Postulate 5 (a) x + x′ = 1 (b) x • x′ = 0
Theorem 1 (a) x + x = x (b) x • x = x
Theorem 2 (a) x + 1 = 1 (b) x • 0 = 0
Theorem 3, involution      (x′)′ = x
Postulate 3, commutative (a) x + y = y + x (b) xy = yx
Theorem 4, associative (a) x + (y + z) = (x + y) + z (b) x(yz) = (xy) z
Postulate 4, distributive (a) x (y + z) = xy + xz (b) x + yz = (x + y) (x + z)
Theorem 5, DeMorgan (a) (x + y)′ = x′ y′ (b) (xy)′ = x′ + y′
Theorem 6, absorption (a) x + xy = x (b) x(x + y) = x
Boolean Algebra and Logic Gates  37 
THEOREM 2(a): x + 1 = 1.
x + 1  = 1 • (x + 1) 
= (x + x′) (x + 1) = x + x′ • 1 = x + x′ = 1by postulate: 2(b)
5(a)
4(b)2(b) 
5(a)
THEOREM 2 (b): x • 0 = 0 by duality.
THEOREM 3: (x′)′ = x. From postulate 5, we have x + x′ = 1 and x • x′ = 0, which defines the 
complement of x. The complement of x′ is x and is also (x′)′. Therefore, since the complement is 
unique, we have that (x′)′ = x.
The theorems involving two or three variables may be proven algebraically from the pos-
tulates and the theorems which have already been proven. Take, for example, the absorption 
theorem.
THEOREM 6(a): x + xy − x.
x + xy  = x • 1 + xy = x (1 + y) = x (y + 1) = x • 1  = xby postulate 2(b)by postulate 4(a)by postulate 3(a)by theorem 2(a) by postulate 2(b)
THEOREM 6(b): x(x + y) = x by duality.
The theorems of Boolean algebra can be shown to hold true by means of truth tables. In 
truth tables, both sides of the relation are checked to yield identical results for all possible com-binations of variables involved. The following truth table verifies the first absorption theorem.
x y xy x + xy
0 0 0 0
0 1 0 0
1 0 0 1
1 1 1 1=
The algebraic proofs of the associative law and De Morgan’ s theorem are long and will not be shown here. However, their validity is easily shown with truth tables. For example, the truth table for the first De Morgan’ s theorem (x + y)′ = x′ y′ is shown below.
x y x + y (x + y)′ x′ y′ x′ y′
0 0 0 1 1 1 [
0 1 1 0 1 0 0
1 0 1 0 0 1 0
1 1 1 0 0 0 0
38 Chapter 2
2.3.3 Operator Precedence
The operator precedence for evaluating Boolean expressions is (1) parentheses, (2) NOT, (3) 
AND, and (4) OR. In other words, the expression inside the parentheses must be evaluated before all other operations. The next operation that holds precedence is the complement, then follows the AND, and finally the OR. As an example, consider the truth table for De Morgan’ s theorem. The left side of the expression is (x + y)′. Therefore, the expression inside the parentheses is 
evaluated first and the result then complemented. The right side of the expression is x′ y′. There-
fore, the complement of x and the complement of y are both evaluated first and the result is then 
ANDed. Note that in ordinary arithmetic the same precedence holds (except for the complement) when multiplication and addition are replaced by AND and OR, respectively.
EXAMPLE 2-1: Using basic Boolean theorem prove:
(a) (x  + y)(x + z) = x  + yz
 Soln:  (x  + y) (x + z)
         = x ⋅ x + x ⋅ z + y ⋅ x + y ⋅ z    since  x .x = x
         = x  + xz + yx + yz
         = x  (1 + z ) + yx + yz    since (1 + z ) = 1
         = x  + yx + yz
         = x  (1 + y ) + yz     since (1 + y ) = 1
         = x  + yz (Proved)
(b) xy + xz + yz′  = xz + yz′
 Soln:  xy + xz + yz′
         = xy( z + z′) + xz( y + y′) + yz′ (x + x′)   since  x  + x′ = 1
         = xyz + xyz′  + xyz + xy′ z + xyz′  + x′yz′
         = xyz + xyz′  +xy′z + x′yz′    since xyz + xyz = xyz
         = xyz + xy′ z + xyz′  + x′yz′    rearranging
         = xz( y + y′) + yz′ (x + x′)    since y + y′ = 1 and x  + x′ = 1
         = xz + yz′  (Proved)
2.3.4 Venn Diagram
A helpful illustration that may be used to visualize the relationships among the variables of a Boolean expression is the V enn diagram. This diagram consists of a rectangle such as shown 
 x′y
 x′y′ xy′  xy x y
Figure 2.1 Venn diagram for two variables
Boolean Algebra and Logic Gates  39 
in Fig. 2-1, inside of which are drawn overlapping circles, one for each variable. Each circle is  
labeled by a variable. We designate all points inside a circle as belonging to the named variable 
and all points outside a circle as not belonging to the variable. Take, for example, the circle la-beled x. If we are inside the circle, we say that x = 1; when outside, we say x = 0. Now, with two 
overlapping circles, there are four distinct areas inside the rectangle: the area not belonging to either x or y (x′ y′), the area inside circle y but outside x (x′ y), the area inside circle x but outside 
y (xy′), and the area inside both circles (xy).
Venn diagrams may be used to illustrate the postulates of Boolean algebra or to show the 
validity of theorems. Figure 2-2, for example, illustrates that the area belonging to xy is inside 
the circle x and therefore x + xy = x. Figure 2-3 illustrates the distributive law x(y + z) = xy + xz. 
In this diagram we have three overlapping circles, one for each of the variables x, y, and z. It is 
possible to distinguish eight distinct areas in a three-variable Venn diagram. For this particular example, the distributive law is demonstrated by noting that the area intersecting the circle x with 
the area enclosing y or z is the same area belonging to xy or xz.
2.4 Boolean Functions
A binary variable can take the value of 0 or 1. A Boolean function is an expression formed with binary variables, the two binary operators OR and AND, the unary operator NOT, parentheses, and equal sign. For a given value of the variables, the function can be either 0 or 1. Consider, for example, the Boolean function:
F
1 = xyz′
The function F1 is equal to 1 if x = 1 and y = 1 and z′ = 1; otherwise F1 = 0, The above is an 
example of a Boolean function represented as an algebraic expression. A Boolean function may also be represented in a truth table. To represent a function in a truth table, we need a list of the 2
n combinations of l’ s and 0’ s of the n binary variables, and a column showing the combinations  x y
Figure 2.2 Venn diagram illustration x = xy + x
 x
 x(y + z) y
 z x
 xy + xz y
 z
Figure 2.3 Venn diagram illustration of the distributive law
40 Chapter 2
for which the function is equal to 1 or 0. As shown in Table 2-2, there are eight possible distinct 
combinations for assigning bits to three variables. The column labeled F1 contains either a 0 or 
a 1 for each of these combinations. The table shows that the function F1 is equal to 1 only when 
x = 1, y = 1, and z — 0. It is equal to 0 otherwise. (Note that the statement z′ = 1 is equivalent to 
saying that z = 0.) Consider now the function:
F2 - x + y′ z
F2 = 1 if x = 1 or if y = 0, while z = 1. In Table 2-2, x = 1 in the last four rows and yz = 01 in rows 
001 and 101. The latter combination applies also for x = 1. Therefore, there are five combinations 
that make F2 = 1. As a third example, consider the function:
F3 = x′ y′ z + x′ y z + xy′
This is shown in Table 2-2 with four l’ s and four 0’ s. F4 is the same as F3 and is considered  
below.
Any Boolean function can be represented in a truth table. The number of rows in the table 
is 2n, where n is the number of binary variables in the function. The 1’ s and 0’ s combinations for 
each row is easily obtained from the binary numbers by counting from 0 to 2n - 1. For each row 
of the table, there is a value for the function equal to either 1 or 0. The question now arises, Is an algebraic expression of a given Boolean function unique? In other words, Is it possible to find two algebraic expressions that specify the same function? The answer to this question is yes. As a matter of fact, the manipulation of Boolean algebra is applied mostly to the problem of finding simpler expressions for the same function. Consider, for example, the function:
F
4 = xy′ + x′ z
From Table 2-2, we find that F4 is the same as F3 since both have identical 1’ s and 0’ s for each 
combination of values of the three binary variables. In general, two functions of n binary vari-
ables are said to be equal if they have the same value for all possible 2n combinations of the n 
variables.
A Boolean function may be transformed from an algebraic expression into a logic diagram 
composed of AND, OR, and NOT gates. The implementation of the four functions introduced in Table 2-2 Truth tables for F1 = xyz ′, F2 = x + y ′ z,  
F3 = x′ y′ z + x ′ yz + xy ′, and F4 = xy ′ + x′ z
x y z F1F2F3F4
0 0 0 0 0 0 0
0 0 1 0 1 1 1
0 1 0 0 0 0 0
0 1 1 0 0 1 1
1 0 0 0 1 1 1
1 0 1 0 1 1 1
1 1 0 1 1 0 0
1 1 1 0 1 0 0
Boolean Algebra and Logic Gates  41 
the previous discussion is shown in Fig. 2-4. The logic diagram includes an inverter circuit for 
every variable present in its complement form. (The inverter is unnecessary if the complement of the variable is available.) There is an AND gate for each term in the expression, and an OR gate is used to combine two or more terms. From the diagrams, it is obvious that the implementation of F
4 requires fewer gates and fewer inputs than F3. Since F4 and F3 are equal Boolean functions, 
it is more economical to implement the F4 form than the F3 form. To find simpler circuits, one 
must know how to manipulate Boolean functions to obtain equal and simpler expressions. What constitutes the best form of a Boolean function depends on the particular application. In this section, consideration is given to the criterion of equipment minimization.
2.4.1 Algebraic Manipulation
A literal is a primed or unprimed variable. When a Boolean function is implemented with logic 
gates, each literal in the function designates an input to a gate, and each term is implemented with a gate. The minimization of the number of literals and the number of terms results in a circuit with less equipment. It is not always possible to minimize both simultaneously; usually,  further criteria must be available. At the moment, we shall narrow the minimization criterion to literal minimization. We shall discuss other criteria in Chapter 5. The number of literals in a Boo-lean function can be minimized by algebraic manipulations. Unfortunately, there are no specific rules to follow that will guarantee the final answer. The only method available is a cut-and-try Figure 2.4 Implementation of Boolean function with gatesx
yz
F2
(b) F2 = x + y ′zx
y
zF1
(a) F1 = xyz ′ 
(c) F3 = x′y′z + x′yz + xy ′x
y
zF3
x
y
zF4
(d) F4 = xy ′ + x′z
42 Chapter 2
procedure employing the postulates, the basic theorems, and any other manipulation method 
which becomes familiar with use. The following examples illustrate this procedure.
EXAMPLE 2-2: Simplify the following Boolean functions to a minimum number of literals.
1. x + x′ y – (x + x′)(x + y) = 1 • (x + y) = x + y
2. x (x′ + y) = xx′ + xy =  0 + xy = xy
3. x′ y′ z + x′ yz +  xy′ = x′ z(y′ + y) + xy′ = x′ z + xy′
4. xy + x′ z + yz = xy +  x′ z + yz(x + x′)
       = xy + x′ z + xyz + x′ yz
       = xy (1 + z) + x′ z (1 + y)
       = xy + x′ z
5. (x + y) (x′ + z) (y + z) = (x + y) (x′ + z) by duality from function 4.
Functions 1 and 2 are the duals of each other and use dual expressions in corresponding steps. Function 3 shows the equality of the functions F
3 and F4 discussed previously. The fourth il-
lustrates the fact that an increase in the number of literals sometimes leads to a final simpler expression. Function 5 is not minimized directly but can be derived from the dual of the steps used to derive function 4.
2.4.2 Complement of a Function
The complement of a function F is F′ and is obtained from an interchange of 0’ s for 1’ s and l’ s 
for 0’ s in the value of F.  The complement of a function may be derived algebraically through 
De Morgan’ s theorem. This pair of theorems is listed in Table 2-1 for two variables. De Mor -
gan’ s theorems can be extended to three or more variables. The three-variable form of the first De Morgan’ s theorem is derived below. The postulates and theorems are those listed in  
Table 2-1.
(A + B + C)′ = (A + X)′ let B + C = X
                      = A′ X′ by theorem 5(a) (De Morgan)
                      = A′ • (B + C)′ substitute B + C = X
                      = A′ • (B′ C′ ) by theorem 5(a) (De Morgan)
                      = A′ B′ C′ by theorem 4(b) (associative)
De Morgan’ s theorems for any number of variables resemble in form the two-variable case and can be derived by successive substitutions similar to the method used in the above derivation. These theorems can be generalized as follows:
(A + B + C + D + … + F)′ = A′B′C′D′ … F′
(ABCD … F)′ = A′ + B′ + C′ + D′ + … + F′
Boolean Algebra and Logic Gates  43 
The generalized form of De Morgan’ s theorem states that the complement of a function is 
obtained by interchanging AND and OR operators and complementing each literal.
EXAMPLE 2-3: Find the complement of the functions F1 = x′ yz′ + x′ y′ z and F2 = x  
(y’z’ + yz). Applying De Morgan’ s theorem as many times as necessary, the complements are 
obtained as follows:
F′1 = (x′ yz′ + x′ y′ z)′ = (x′ yz′)′(x′ y′ z)′ = (x + y′ + z)(x + y + z′)
F′2 = [x (y′ z′ + yz)]′ = x′ + (y′ z′ + yz)′ = x′ + (y′ z′)′ • (yz) ′
      = x′ + (y + z)(y′ + z′)
A simpler procedure for deriving the complement of a function is to take the dual of the 
function and complement each literal. This method follows from the generalized De Morgan’ s 
theorem. Remember that the dual of a function is obtained from the interchange of AND and OR operators and 1’ s and 0’ s.
EXAMPLE 2-4: Find the complement of the functions F
1 and F2 of Example 2-3 by taking 
their duals and complementing each literal.
1. F1 = x′ yz′ + x′ y′ z.
 The dual of F1 is (x′ + y + z′) (x′ + y′ + z).
 Complement each literal: (x + y′ + z)(x + y + z′) = F1′.
2. F2 – x (y′ z′ + yz).
 The dual of F2 is x +  (y′ + z′) (y + z).
 Complement each literal: x ′ + (y + z)(y′ + z′) = F2′.
2.5 Canonical and Standard Forms
2.5.1 Minterms and Maxterms
A binary variable may appear either in its normal form (x) or in its complement form (x′). Now 
consider two binary variables x and y combined with an AND operation. Since each variable 
may appear in either form, there are four possible combinations: x′y′, x′y, xy′, and xy. Each of 
these four AND terms represents one of the distinct areas in the Venn diagram of Fig. 2-1 and 
is called a minterm or a standard product. In a similar manner, n variables can he combined to 
form 2n minterms. The 2n different minterms may be determined by a method similar to the one 
shown in Table 2-3 for three variables. The binary numbers from 0 to 2n - 1 are listed under the 
n variables. Each minterm is obtained from an AND term of the n variables, with each variable 
being primed if the corresponding bit of the binary number is a 0 and imprinted if a 1. A symbol for each mineterns is also shown in the table and is of the form m
j, where j denotes the decimal 
equivalent of the binary number of the minterm designated.
44 Chapter 2
In a similar fashion, n variables forming an OR term, with each variable being primed or 
unprimed, provide 1, 2n possible combinations, called maxterms or standard sums. The eight 
maxterms for three variables, together with their symbolic designation, are listed in Table 2-3. 
Any 2 n maxterms for n variables may be determined similarly. Each maxterm is obtained from 
an OR term of the n variables, with each variable being unprimed if the corresponding bit is a 
0 and primed if a 1.* Note that each maxterm is the complement of its corresponding minterm, 
and vice versa.
A Boolean function may be expressed algebraically from a given truth table by forming a 
minterm for each combination of the variables which produces a 1 in the function, and then tak-ing the OR of all those terms. For example, the function f
1 in Table 2-4 is determined by express-
ing the combinations 001, 100, and 111 as x′y′z, xy′z′, and xyz, respectively. Since each one of 
these minterms results in f1 = 1, we should have:
f1 = x′y′z + xy′z′ + xyz = m1 + m4 + m7
Similarly, it may be easily verified that:
f2 = x′yz + xy′z + xyz′ + xyz = m3 + m5 + m6 + m7
These examples demonstrate an important property of Boolean algebra: Any Boolean function can be expressed as a sum of mjnterms (by “sum” is meant the ORing of terms).
Now consider the complement of a Boolean function. It may be read from the truth table by 
forming a minterm for each combination that produces a 0 in the function and then ORing those terms. The complement of f
1 is read as:
f1′ = x′y′z′ + x′yz′ + x′yz + xy′z + xyz′
*Some books define a maxterm as an OR term of the n variables, with each variable being unprimed if the bit 
is a 1 and primed if a 0. The definition adopted in this book is preferable as it leads to simpler conversions 
between maxterm- and minterm-type functions.Table 2-3 Minterms and maxterms for three binary variables
                 Minterms                                                                      Maxterms
x y z Term Designation Term Designation
0 0 0 x′y′z′ m0x + y + z M0
0 0 1 x′y′z m1 x + y + z′ M1
0 1 0 x′yz′ m2 x + y′ + z M2
0 1 1 x′yz m3 x + y′ + z′ M3
1 0 0 xy′z′ m4 x′ + y + z M4
1 0 1 xy′z m5 x′ + y + z′ M5
1 1 0 xyz′ m6 x′ + y′ + z M6
1 1 1 xyz m7 x′ + y′ + z′ M7
Boolean Algebra and Logic Gates  45 
If we take the complement of f1′, we obtain the function f1:
f1 = (x + y + z)(x + y′+ z)(x + y′ + z′)(x′ + y + z′)(x′ + y′ + z)
     = M0⋅M2⋅M3⋅M5⋅M6
Similarly, it is possible to read the expression for f2 from the table;
f2 = (x + y + z)(x + y +z′)(x + y′ + z)(x′ + y + z) = M0M1M2M4
These examples demonstrate a second important property of Boolean algebra: Any Boolean 
function can be expressed as a product of maxterms (by “product” is meant the ANDing of terms). The procedure for obtaining the product of maxterms directly from the truth table is as follows. Form a maxterm for each combination of the variables which produces a 0 in the func-tion, and then form the AND of all those maxterms. Boolean functions expressed as a sum of minterms or product of maxterms are said to be in canonical form.
2.5.2 Sum of Minterms
It was previously stated that for n binary variables, one can obtain 2n distinct minterms. and that 
any Boolean function can be expressed as a sum of minterms. The minterms whose sum defines the Boolean function are those that give the l’ s of the function in a truth table. Since the func-tion can be either 1 or 0 for each minterm. and since there are 2
n minterms, one can calculate 
the possible functions that can be formed with n variables to be 2n. It is sometimes convenient 
to express the Boolean function in its sum-of-minterms form. If not in this form, it can be made so by first expanding the expression into a sum of AND terms. Each term is then inspected to see if it contains all the variables. If it misses one or more variables, it is ANDed with an expres-sion such as x + x′, where x is one of the missing variables. The following example clarifies this  
procedure.Table 2-4 Functions of three variables
x y z Function f1Function f2
0 0 0 0 0
0 0 1 1 0
0 1 0 0 0
0 1 1 0 1
1 0 0 1 0
1 0 1 0 1
1 I 0 0 1
1 1 1 1 1
46 Chapter 2
EXAMPLE 2-5: Express the Boolean function F = A + B’C in a sum of minterms. The func-
tion has three variables A, B, and C. The first term A is missing two variables; therefore:
A = A(B + B′) = AB + AB’
This is still missing one variable:
A = AB(C + C′) + AB′(C + C′)
       = ABC + ABC′ + AB′C + AB′C ′
The second term B′C is missing one variable:
B′C = B′C (A + A′) = AB′C + A′B′C 
Combining all terms, we have:
                               F = A + B′C
= ABC + ABC ′ + AB′C + AB′C ′ + AB′C + A′B′C
But AB′C appears twice, and according to theorem 1 (x + x = x), it is possible to remove one 
of them. Rearranging the minterms in ascending order, we finally obtain:
F = A′B′C + AB′C ′ + AB′C + ABC ′ + ABC 
= m1 + m4 + m5 + m6 + m7
It is sometimes convenient to express the Boolean function, when in its sum of minterms, 
in the following short notation:
F(A,B,C) = ∑ (1,4, 5,6,7)
The summation symbol ∑ stands for the ORing of terms; the numbers following it are the 
minterms of the function. The letters in parentheses following F form a list of the variables in the 
order taken when the minterm is converted to an AND term.
2.5.3 Product of Maxterms
Each of the 22n functions of n binary variables can be also expressed as a product of maxterms. 
To express the Boolean function as a product of maxterms, it must first be brought into a form 
of OR terms. This may be done by using the distributive law x + yz = (x + y)(x + z). Then any 
missing variable x in each OR term is ORed with xx′. This procedure is clarified by the following 
example.
Boolean Algebra and Logic Gates  47 
EXAMPLE 2-6: Express the Boolean function F = xy + x′z in a product of maxterm form. 
First convert the function into OR terms using the distributive law:
F = xy + x′z = (xy + x′)(xy + z)
= ( x + x′)(y + x′)(x + z)(y + z)
= (x′ + y)(x + z)(y + z)
The function has three variables: x, y, and z. Each OR term is missing one variable; therefore:
  x′ + y = x′ + y + zz′ = (x′ + y + z)(x′ + y + z′)
x + z = x + z + yy′ = (x + y + z)(x + y′ + z)
  y + z=y + z + xx′ = (x + y + z)(x′ + y + z)
Combining all the terms and removing those that appear more than once, we finally obtain:
F = (x + y + z)(x + y′ + z)(x′ + y + z)(x′ + y + z′)
= M0M2M4M5
A convenient way to express this function is as follows:
F(x,y,z) = ∏(0,2, 4, 5)
The product symbol, ∏, denotes the ANDing of maxterms; the numbers, are the maxterms 
of the function.
2.5.4 Conversion between Canonical Forms
The complement of a function expressed as the sum of minterms equals the sum of minterms missing from the original function. This is because the original function is expressed by those minterms that make the function equal to I, while its complement is a 1 for those minterms that 
the function is a 0. As an example, consider the  function:
F(A,B, C) = ∑(1,4,5,6,7)
This has a complement that can be expressed as:
F′(A, B, C) = ∑ (0, 2, 3) = m
0 + m2 + m3
Now, if we take the complement of F′ by De Morgan’ s theorem, we obtain F in a different form:
F = (m0 + m2 + m3)′ = m′0 .m′2 .m′3= M0M2M3 = ∏ (0, 2, 3)
The last conversion follows from the definition of minterms and maxterms as shown in Table 2-3. 
From the table, it is clear that the following relation holds true:
M′j = Mj
That is, the maxterm with subscript j is a complement of the minterm with the same subscript j, and vice versa.
48 Chapter 2
The last example demonstrates the conversion between a function expressed in sum of min-
terms and its equivalent in product of maxterms. A similar argument will show that the conver -
sion between the product of maxterms and the sum of minterms is similar. We now state a general 
conversion procedure. To convert from one canonical form to another, interchange the symbols  
∑ and ∏ and list those numbers missing from the original form. As another example, the function:
F(x, y, z) = ∏ (0, 2, 4, 5)
is expressed in the product of maxterm form. Its conversion to sum of minterms is:
F(x, y, z) = ∑ (1,3,6,7)
Note that, in order to find the missing terms, one must realize that the total number of minterms or maxterms is 2
n, where n is the number of binary variables in the function.
2.5.5 Standard Forms
The two canonical forms of Boolean algebra are basic forms that one obtains from reading a function from the truth table. These forms are very seldom the ones with the least number of literals, because each minterm or maxterm must contain, by definition, all the variables either 
complemented or uncomplemented.
Another way to express Boolean functions is in standard form. In this configuration, the 
terms that form the function may contain one, two or any number of literals. There are two types 
of standard forms: the sum of products and product of sums.
The sum of products is a Boolean expression containing AND terms, called product terms, 
of one or more literals each. The sum denotes the ORing of these terms. An example of a function 
expressed in sum of products is:
F
1 = y′ + xy + x′yz′
The expression has three product terms of one, two, and three literals each, respectively. Their 
sum is in effect an OR operation.
A product of sums is a Boolean expression containing OR terms, called sum terms. Each 
term may have any number of literals. The product denotes the AN Ding of these terms. An ex-
ample of a function expressed in product of sums is:
F2 = x(y′ + z)(x′ + y + z′ + w)
This expression has three sum terms of one, two, and four literals each. The product is an AND operation. The use of the words product and sum stems from the similarity of the AND operation 
to the arithmetic product (multiplication) and the similarity of the OR operation to the arithmetic sum (addition).
A Boolean function may be expressed in a nonstandard form. For example, the function:
F
3 = (AB + CD)(A′B′ + C′D′)
is neither in sum of products nor in product of sums. It can be changed to a standard form by using the distributive law to remove the parentheses:
F
3 = A′B′CD + ABC′D′
Boolean Algebra and Logic Gates  49 
2.6 Other Logic Operations
When the binary operators AND and OR are placed between two variables x and y, they form two 
Boolean functions x ⋅ y and x + y, respectively. It was stated previously that there are 22n functions 
for n binary variables. For two variables, n = 2 and the number of possible Boolean functions is 
16. Therefore, the AND and OR functions are only two of a total of 16 possible functions formed 
with two binary variables. It would be instructive to find the other 14 functions and investigate their properties.
The truth tables for the 16 functions formed with two binary variables x and y are listed in 
Table 2-5. In this table, each of the 16 columns F
0 to F15 represents a truth table of one possible 
function for the two given variables x and y. Note that the functions are determined from the 16 
binary combinations that can be assigned to F. Some of the functions are shown with an operator 
symbol. For example, F1 represents the truth table for AND and F7 represents the truth table for 
OR. The operator symbols for these functions are (⋅) and ( + ), respectively.
The 16 functions listed in truth table form can be expressed algebraically by means of Bool-
ean expressions. This is shown in the first column of Table 2-6. The Boolean expressions listed are simplified to their minimum number of literals.
Although each function can be expressed in terms of the Boolean operators AND, OR, and 
NOT, there is no reason one cannot assign special operator symbols for expressing the other func-tions. Such operator symbols are listed in the second column of Table 2-6. However, all the new 
symbols shown, except for the exclusive-OR symbol 
⊕, are not in common use by digital designers.
Each of the functions in Table 2-6 is listed with an accompanying name and a comment that 
explains the function in some way. The 16 functions listed can be subdivided into three categories:
1. Two functions that produce a constant 0 or 1.
2. Four functions with unary operations complement and transfer.
3. Ten functions with binary operators that define eight different operations AND, OR, NAND, NOR, exclusive-OR, equivalence, inhibition, and implication.
Any function can be equal to a constant, but a binary function can be equal to only 1 or 0. 
The complement function produces the complement of each of the binary variables. A function which is equal to an input variable has been given the name transfer, because the variable x or y 
is transferred through the gate that forms the function without changing its value. Of the eight binary operators, two (inhibition and implication) are used by logicians but are seldom used in Table 2-5 Truth tables for the 16 functions of two binary variables
   x y F0F1F2F3F4F5F6F7F8F9F10F11F12F13F14F15
   0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
   0 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1
   1 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
   1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
Operator
Symbol / /  ⊕ +↓ ⊂ ⊃ ↑
50 Chapter 2
computer logic. The AND and OR operators have been mentioned in conjunction with Boolean 
algebra. The other four functions are extensively used in the design of digital systems.
The NOR function is the complement of the OR function and its name is an abbreviation 
of not-OR. Similarly, NAND is the complement of AND and is an abbreviation of not-AND. The 
exclusive-OR, abbreviated XOR or EOR, is similar to OR but excludes the combination of both x and y being equal to 1. The equivalence is a function that is 1 when the two binary variables are 
equal, i.e., when both are 0 or both are 1. The exclusive-OR and equivalence functions are the complements of each other. This can be easily verified by inspecting Table 2-5. The truth table for the exclusive-OR is F
6 and for the equivalence is F9, and these two functions are the comple-
ments of each other. For this reason, the equivalence function is often called exclusive-NOR, i.e., exclusive-OR-NOT.
Boolean algebra, as defined in Sections 2-2, has two binary operators, which we have called 
AND and OR, and a unary operator, NOT (complement). From the definitions, we have deduced a number of properties of these operators and now have defined other binary operators in terms of them. There is nothing unique about this procedure. We could have just as well started with the operator NOR (↓), for example, and later defined AND, OR, and NOT in terms of it. There are, 
nevertheless, good reasons for introducing Boolean algebra in the way it has been introduced. The concepts of “and,” “or,” and “not” are familiar and are used by people to express everyday logical ideas. Moreover, the Huntington postulates reflect the dual nature of the algebra, empha-sizing the symmetry of + and · with respect to each other.Table 2-6 Boolean expressions for the 16 functions of two variables
Boolean functions Operator symbol Name Comments
F0 = 0 Null Binary constant 0
F1 = xy x ⋅ y AND x and y
F2 = xy′ x/y Inhibition x but not y
F3 = x Transfer x
F4 = x′y y/x Inhibition y but not x
F5 = y Transfer y
F6 = xy′ + x′y x ⊕ y Exciusive-OR x or y but not both
F7 = x +y x + y OR x or y
F8 = (x + y)′ x ↓ y NOR Not-OR
F9 = xy + x′y′ x  y Equivalence* x equals y
F10 = y′ y′ Complement Not y
F11 = x + y′ x ⊂ y Implication If y then x
F12 = x′ x′ Complement Not x
F13 = x′ + y x ⊃ y Implication If x then y
F14 = (xy)′ x↑y NAND Not-AND
F15 = 1 Identity Binary constant 1
*Equivalence is also known as equality, coincidence, and exclusive-NOR.
Boolean Algebra and Logic Gates  51 
2.7 Digital Logic Gates
Since Boolean functions are expressed in terms of AND, OR, and NOT operations, it is easier 
to implement a Boolean function with these types of gates. The possibility of constructing gates for the other logic operations is of practical interest. Factors to be weighed when considering the construction of other types of logic gates are (1) the feasibility and economy of producing the gate with physical components, (2) the possibility of extending the gate to more than two inputs, (3) the basic properties of the binary operator such as commutativity and associativity, and (4) the ability of the gate to implement Boolean functions alone or in conjuction with other gates.
Of the 16 functions defined in Table 2-6, two are equal to a constant and four others are re-
peated twice. There are only ten functions left to be considered as candidates for logic gates. Two, inhibition and implication, are not commutative or associative and thus are impractical to use as standard logic gates. The other eight: complement, transfer, AND, OR, NAND, NOR, exclusive-OR, and equivalence, are used as standard gates in digital design.
The graphic symbols and truth tables of the eight gates are shown in Fig. 2-5. Each gate has 
one or two binary input variables designated by x and y and one binary output variable designated 
by F. The AND, OR, and inverter circuits were defined in Fig. 1-6. The inverter circuit inverts the 
logic sense of a binary variable. It produces the NOT, or complement, function. The small circle in the output of the graphic symbol of an inverter designates the logic complement. The triangle symbol by itself designates a buffer circuit. A buffer produces the transfer function but does not 
produce any particular logic operation, since the binary value of the output is equal to the binary value of the input. This circuit is used merely for power amplification of the signal and is equiva-lent to two inverters connected in cascade.
The NAND function is the complement of the AND function, as indicated by a graphic 
symbol which consists of an AND graphic symbol followed by a small circle. The NOR function is the complement of the OR function and uses an OR graphic symbol followed by a small circle. The NAND and NOR gates are extensively used as standard logic gates and are in fact far more popular than the AND and OR gates. This is because NAND and NOR gates are easily construct-ed with transistor circuits and because Boolean functions can be easily implemented with them.
The exclusive-OR gate has a graphic symbol similar to that of the OR gate, except for the ad-
ditional curved line on the input side. The equivalence, or exclusive-NOR, gate is the complement of the exclusive-OR, as indicated by the small circle on the output side of the graphic symbol.
2.7.1 Extension to Multiple Inputs
The gates shown in Fig. 2-5, except for the inverter and buffer, can be extended to have more than two inputs. A gate can be extended to have multiple inputs if the binary operation it represents is 
commutative and associative. The AND and OR operations, defined in Boolean algebra, possess these two properties. For the OR function we have:
x + y = y + x         commutative
and
(x + y) + z = x + (y + z) = x + y + z         associative
which indicates that the gate inputs can be interchanged and that the OR function can be ex-
tended to three or more variables.
52 Chapter 2
F = xy AND
OR
Inverter
Buffer
NAND
NOR
Exclusiv e-OR
    (XOR)
Exclusiv e-NOR
           or
   equiv alenceF = x + y
F = x′
F = x
F = (xy)′
F = (x + y)′
F = xy′ + x′y
   = x ⊕ y
F = xy + x′y′
   = x ⊙ yx
yF
xFy
0
0
1
10
1
0
11
0
0
1xF y001
10
10
10
11
0xF y0
0
1
10
1
0
11
0
0
0xF y00
1
10
1
0
11
1
1
0xF y0
101Fx0110Fx0
0
1
10
1
0
10
1
1
1xF y0
0
1
101
0
100
0
1xF y
x F
x F
x
yF
xFy
xFyxFyName Graphic Algebraic Truth
symbol function table
Figure 2.5 Digital logic gates
Boolean Algebra and Logic Gates  53 
The NAND and NOR functions are commutative and their gates can be extended to have 
more than two inputs, provided the definition of the operation is slightly modified. The difficulty 
is that the NAND and NOR operators are not associative, i.e., (x ↓ y) ↓z ≠ x ↓ (y ↓ z), as shown 
in Fig. 2-6 and below:
(x ↓ y) ↓z = [(x + y)′ + z]′ = (x + y)z′ = xz′ + yz′ 
x ↓ (y ↓ z) = [x + (y + z)′]′ − x′(y + z) − x′y + x′z
To overcome this difficulty, we define the multiple NOR (or NAND) gate as a complemented OR 
(or AND) gate. Thus, by definition, we have:
x ↓ y ↓ z = (x + y + z)′
   x ↑ y ↑ z = (xyz)′
The graphic symbols for the three-input gates are shown in Fig. 2-7. In writing cascaded NOR 
and NAND operations, one must use the correct parentheses to signify the proper sequence of 
the gates. To demonstrate this, consider the circuit of Fig. 2-7(c). The Boolean function for the circuit must be written as:
F = [(ABC)′(DE)′]′ = ABC + DE
The second expression is obtained from De Morgan’ s theorem. It also shows that an expression in sum of products can be implemented with NAND gates. Further discussion of NAND and NOR gates can be found in Sections 3-6, 4-7, and 4-8.x
y
zx ↓ (y ↓ z)      x′(y + z )x
y
z(x ↓ y) ↓ z = (x + y)z′
Figure 2.6 Demonstrating the nonassciativity of the NOR operator; (x ↓ y) ↓ z ≠ x(y ↓ z)
x
z(x + y + z)′ y
(a) Three-input NOR gate(xyz)′x
y
z
(b) Three-input NAND gate
A
D
EB
C
F = [(ABC)′:(DE)]′ = ABC + DE
(c) Cascaded NAND gate
Figure 2.7 Multiple-input and Cascaded NOR and NAND gate
54 Chapter 2
The exclusive-OR and equivalence gates are both commutative and associative and can be 
extended to more than two inputs. However, multiple-input exclusive-OR gates are uncommon 
from the hardware standpoint. In fact, even a two-input function is usually constructed with other types of gates. Moreover, the definition of these functions must be modified when extended to 
more than two variables. The exclusive-OR is an odd function, i.e., it is equal to 1 if the input 
variables have an odd number of 1’ s. The equivalence function is an even function, i.e., it is equal 
to 1 if the input variables have an even number of 0’ s. The construction of a three-input exclusive-OR function is shown in Fig. 2-8. It is normally implemented by cascading two-input gates as 
shown in (a). Graphically, it can be represented with a single three-input gate as shown in (b). The 
truth table in (c) clearly indicates that the output F is equal to 1 if only one input is equal to 1 or 
if all three inputs are equal to 1, i.e., when the total number of 1’ s in the input variables is odd. Further discussion of exclusive-OR and equivalence can be found in Section 4-9.
EXAMPLE 2-7: Construct AND Gate using NOR Gate
Soln: A.B = (A.B)ˮ =  (A′ + B′)′ using D Morgan’ s theorem 
AA'
y = (A' + B')' = A.B
B'
B
2.8 IC Digital Logic Families
The IC was introduced in Section 1-9, where it was stated that digital circuits are invariably 
constructed with ICs. Having discussed various digital logic gates in the previous section, we are 
now in a position to present IC gates and discuss their general properties.x
y
zF = x ⊕ y ⊕ z
(a) Using two-input gatesF = x ⊕ y ⊕ zx
y
z
(b) A three-input gate
xy zF
0
0
0
0
1
1
1
10
0
1
1
0
0
1
10
1
0
1
0
1
0
10
1
1
0
1
0
0
1
(c) Truth table
Figure 2.8 Three-input exclusive-OR gate
Boolean Algebra and Logic Gates  55 
Digital IC gates are classified not only by their logic operation, but also by the specific 
logic-circuit family to which they belong. Each logic family has its own basic electronic circuit 
upon which more complex digital circuits and functions are developed. The basic circuit in each family is either a NAND or a NOR gate. The electronic components employed in the construc-tion of the basic circuit are usually used to name the logic family. Many different logic families of digital ICs have been introduced commercially. The ones that have achieved widespread popular -
ity are listed below.
TTL Transistor-transistor logic
ECL Emitter-coupled logic
MOS Metal-oxide semiconductor
CMOS Complementary metal-oxide semiconductor
I
2L  Integrated-injection logic
TTL has an extensive list of digital functions and is currently the most popular logic family. 
ECL is used in systems requiring high-speed operations. MOS and I2L are used in circuits requir -
ing high component density, and CMOS is used in systems requiring low power consumption.
The analysis of the basic electronic circuit in each logic family is presented in Chapter 13. 
The reader familiar with basic electronics can refer to Chapter 13 at this time to become ac-quainted with these electronic circuits. Here we restrict the discussion to the general properties of the various IC gates available commercially.
Because of the high density with which transistors can be fabricated in MOS and I
2L, these 
two families are mostly used for LSI functions. The other three families. TTL, ECL, and CMOS, have LSI devices and also a large number of MSI and SSI devices. SSI devices are those that come with a small number of gates or flip-flops (presented in Section 6.2) in one IC package. The limit on the number of circuits in SSI devices is the number of pins in the package, A 14-pin package, for example, can accommodate only four two-input gates, because each gate requires three external pins—two each for inputs and one each for output, for a total of 12 pins. The re-maining two pins are needed for supplying power to the circuits.
Some typical SSI circuits are shown in Fig. 2-9. Each IC is enclosed within a 14- or 16-pin 
package. The pins are numbered along the two sides of the package and specify the connections that can be made. The gates drawn inside the ICs are for information only and cannot be seen because the actual IC package appears as shown in Fig. 1-8.
TTL ICs are usually distinguished by numerical designation as the 5400 and 7400 series. 
The former has a wide operating-temperature range, suitable for military use, and the latter has a narrower temperature range, suitable for industrial use. The numeric designation of the 7400 series means that IC packages are numbered as 7400, 7401, 7402, etc. Some vendors make avail-able TTL ICs with different numerical designations, such as the 9000 or the 8000 series.
Figure 2-9(a) shows two TTL SSI circuits. The 7404 provides six (hex) inverters in a pack-
age. The 7400 provides four (quadruple) 2-input NAND gates. The terminals marked V
cc and 
GND are the power supply pins which require a voltage of 5 volts for proper operation.
The most common ECL type is designated as the 10,000 series. Figure 2-9(b) shows two 
ECL circuits. The 10102 provides four 2-input NOR gates. Note that an ECL gate may have two outputs, one for the NOR function and another for the OR function (pin 9 of the 10102 IC). The 10107 IC provides three exclusive-OR gates. Here again there are two outputs from each gate; the 
56 Chapter 2
12 34 5698 10 11 12 13 14vcc
7
GND 7404–He x inverters9 8 10 11 12 13 14vcc
12 34 56 7
GND
7400–Quadr uple 2-input NAND ga tes
(a) TTL gates
12 34 5 67 8161514 13 12 11 109vcc2
vcc1VEE
10102–Quadr uple 2-input NOR ga tes2 3 45 6 7 816 15 14 13 12 11 10 9vcc2
1vcc1 VEE NC
10107–T riple ex clusiv e-OR/NOR ga tes
(b) ECL gates
1112 13 14 10 9
1 23 45 6 78
Vss NCNC VDD
4002–D ual 4-input NOR ga tes.1615 14 1312 11 10 9
23 45 67 1 VssVDDNC NC
4050–He x buffers.
(c) CMOS gates
Figure 2.9 Some typical integrated-circuit gates
Boolean Algebra and Logic Gates  57 
other output gives the exclusive-NOR function or equivalence. ECL gates have three terminals 
for power supply. VCC1 and VCC2 are usually connected to ground, and VEE to a - 5.2-volt supply.
CMOS circuits of the 4000 series are shown in Fig. 2-9(c). Only two 4-input NOR gates 
can be accommodated in the 4002 because of pin limitation. The 4050 type provides six buffer gates, Both ICs have two unused terminals marked NC (no connection). The terminal marked V
DD requires a power supply voltage from 3 to 15 volts, while Vss is usually connected to ground.
2.8.1 Positive and Negative Logic
The binary signal at the inputs or output of any gate can have one of two values, except during transition. One signal value represents logic-1 and the other, logic-0. Since two signal values are assigned to two logic values, there exist two different assignments of signals to logic. Because of the principle of duality of Boolean algebra, an interchange of signal-value assignment results in a dual-function implementation.
Consider the two values of a binary signal as shown in Fig. 2-10. One value must be higher 
than the other since the two values must be different in order to distinguish between them. We designate the higher level by H and the lower level by L. There are two choices for logic-value 
assignment. Choosing the high-level H to represent logic-1, as shown in Fig. 2-10(a), defines a 
positive-logic system. Choosing the low-level L to represent logic-1, as shown in Fig. 2-10(b), 
defines a negative-logic system. The terms positive and negative are somewhat misleading since 
both signal values may be positive or both may be negative. It is not signal polarity that deter -
mines the type of logic, but rather the assignment of logic values according to the relative am-plitudes of the signals.
Integrated-circuit data sheets define digital functions not in terms of logic-1 or logic-0, but 
rather in terms of H and L levels. It is up to the user to decide on a positive or negative logic as-
signment. The high-level and low-level voltages for the three IC digital logic families are listed in Table 2-7. In each family, there is a range of voltage values that the circuit will recognize as a high or low level. The typical value is the most commonly encountered. The table also lists the voltage-supply requirements for each family as a reference.
TTL has typical values of H = 3.5 volts and L = 0.2 volt. ECL has two negative values, with 
H = − 0.8 volt and L = − 1.8 volt. Note that even though both levels are negative, the higher one 
is -0.8. CMOS gates can use a supply voltage V
DD anywhere from 3 to 15 volts; typically, either 
5 or 10 volts is used. The signal values in CMOS are a function of the supply voltage with H = 
VDD and L = 0 volt. The polarity assignments for positive and negative logic are also indicated in 
the table.
In light of this discussion, it would be necessary to justify the logic symbols used for the ICs 
listed in Fig. 2-9. Take, for example, one of the gates of the 7400 IC. This gate is shown in block 01
LHLogic
valueSignal
value
10
LHLogic
valueSignal
value
(a) Positive logic (b) Negative logic
Figure 2.10 Signal-amplitude assignment and type of logic
58 Chapter 2
diagram form in Fig. 2-11(b). The manufacturer’ s truth table for this gate given in a data sheet 
is shown in Fig. 2-11(a). This specifies the physical behavior of the gate, with H being typically 
3.5 volts and L being 0.2 volt. This physical gate can function as either a NAND or NOR gate, 
depending on the polarity assignment.
The truth table of Fig. 2-11(c) assumes positive-logic assignment with H = 1 and L = 0. 
Checking this truth table with the truth tables in Fig. 2-5, we recognize it as a NAND gate. The graphic symbol for a positive-logic NAND gate is shown in Fig. 2-11(d) and is similar to the one adopted previously.
Now consider the negative-logic assignment for this physical gate with L = 1 and H = 0. 
The result is the truth table shown in Fig. 2-11(e). This table can be recognized to represent the 
L
L
H
HL
H
L
HH
H
H
Lxz y
(a)  Truth table in terms 
of H and LzTTL
7400
gatex
y
(b) Gate block diagram
0
0
1
10
1
0
11
1
1
0xz y
(c)  Truth table for positive logic; H 
= 1, L = 0x
yz
(d)  Graphic symbol for posi-
tive logic NAND gate.
1
1
0
01
0
1
00
0
0
1xz y
(e)  Truth table for nagative logic; 
L = 1, H = 0x
zy
(f)  Graphic symbol for naga-
tive logic NOR gate.
Figure 2.11 Demonstration of positive and negative logicTable 2-7 H and L levels in IC logic families
IC family 
typeV oltage 
supply (V)High-level voltage (V) Low-level voltage (V)
Range Typical Range Typical
TTL   VCC = 5
ECL   VEE = − 5.2 
CMOS  VDD = 3 - 10
Positive logic:
Negative logic:2.4 - 5- 0.95 -0.7V
DD3.5-0.8V
DD
logic-1 logic-00 − 0.4-1.9 
- -1.6
0 - 0.50.2-1.8
0
logic-0 
logic-1
Boolean Algebra and Logic Gates  59 
NOR function even though its entries are listed backwards. The graphic symbol for a negative-
logic NOR gate is shown in Fig. 2-11(f). The small triangle in the input and output wires desi-gnates a polarity indicator. The presence of this polarity indicator along a terminal indicates that negative logic is assigned to the terminal. Thus, the same physical gate can function either as a positive-logic NAND or as a negative-logic NOR. The one drawn in the diagram is completely dependent on the polarity assignment that the designer wishes to employ.
In a similar manner, it is possible to show that a positive-logic NOR is the same physical 
gate as a negative-logic NAND. The same relation holds between AND and OR gates or between 
exclusive-OR and equivalence gates, In any case, if negative logic is assumed in any input or out-put terminal, it is necessary to include the polarity indicator triangle symbol along the terminal. Some digital designers use this convention to facilitate the design of digital circuits when NAND or NOR gates are used exclusively. We will not use this symbology in this book but will resort to other methods for designing with NAND and NOR gates. Note that the ICs presented in Fig. 2-9 are shown with their positive-logic graphic symbols. They could have been shown with their negative-logic symbols if one wished to do so.
The conversion from positive logic to negative logic, and vice versa, is essentially an opera-
tion that changes l’ s to 0’ s and 0’ s to 1’ s in both inputs and output of a gate. Since this operation produces the dual of a function, the change of all terminals from one polarity to the other results in taking the dual of the function. The result of this conversion is that all AND operations are converted to OR operations (or graphic symbols) and vice versa. In addition, one must not forget to include the polarity indicator in graphic symbols when negative logic is assumed.
The small triangle that represents a polarity indicator and the small circle that represents 
a complementation have similar effects but different meanings. Therefore, one can be replaced by the other, but the interpretation is different. A circle followed by a triangle, as in Fig. 2-11(f), represents a complementation followed by a negative-logic polarity indicator. The two cancel each other and both can be removed. But if both are removed, then the inputs and output of the gate will represent different polarities.
2.8.2 Special Characteristics
The characteristics of IC digital logic families are usually compared by analyzing the circuit of the basic gate in each family. The most important parameters that are evaluated and compared are fan-out, power dissipation, propagation delay, and noise margin. We first explain the properties of these parameters and then use them to compare the IC logic families.
Fan-out specifies the number of standard loads that the output of a gate can drive without 
impairing its normal operation. A standard load is usually defined as the amount of current needed by an input of another gate in the same IC family. Sometimes the term loading is used 
instead of fan-out. This term is derived from the fact that the output of a gate can supply a limited amount of current, above which it ceases to operate property and is said to be overloaded. The output of a gate is usually connected to the inputs of other similar gates, Each input consumes a certain amount of power from the gate input, so that each additional connection adds to the load of the gate. “Loading rules” are usually listed for a family of standard digital circuits. These rules specify the maximum amount of loading allowed for each output of each circuit. Exceeding the specified maximum load may cause a malfunction because the circuit cannot supply the power demanded from it. The fan-out is the maximum number of inputs that can be connected to the output of a gate, and it is expressed by a number.
60 Chapter 2
The fan-out capabilities of a gate must be considered when simplifying Boolean functions. 
Care must be taken not to develop expressions that result in an overloaded gate. Noninverting 
amplifiers or buffers are sometimes employed to provide additional driving capabilities for heavy loads.
Power dissipation is the supplied power required to operate the gate. This parameter is ex-
pressed in milliwatts (mW) and represents the actual power dissipated in the gate. The number that represents this parameter does not include the power delivered from another gate; rather, it represents the power delivered to the gate from the power supply. An IC with four gates will require, from its power supply, four times the power dissipated in each gate. In a given system, there may be many ICs, and the power required by each IC must be considered. The total power dissipation in a system is the sum total of the power dissipated in all ICs.
Propagation delay is the average transition delay time for a signal to propagate from input 
to output when the binary signals change in value. The signals through a gate take a certain amount of time to propagate from the inputs to the output. This interval of time is defined as the propagation delay of the gate. Propagation delay is expressed in nanoseconds (ns), and 1 ns is equal to 10
−9 of a second.
The signals that travel from the inputs of a digital circuit to its outputs pass through a series 
of gates. The sum of the propagation delays through the gates is the total propagation delay of the circuit. When speed of operation is important, each gate must have a small propagation delay and the digital circuit must have a minimum number of series gates between inputs and outputs.
The input signals in most digital circuits are applied simultaneously to more than one gate. 
All those gates that receive their inputs exclusively from external inputs constitute the first logic level of the circuit. Gates that receive at least one input from an output of a first-logic-level gate are considered to be in the second logic level, and similarly for third and higher levels. The total propagation delay of the circuit is equal to the propagation delay of a gate times the number of logic levels in the circuit. Thus, a reduction in the number of logic levels results in a reduction of signal delay and faster circuits. The reduction of the propagation delay in circuits may be more important than the reduction in the total number of gates if speed of operation is a major factor.
Noise margin is the maximum noise voltage added to the input signal of a digital circuit 
that does not cause an undesirable change in the circuit output. There are two types of noise to be 
considered. DC noise is caused by a drift in the voltage levels of a signal. AC noise is a random 
pulse that may be created by other switching signals. Thus, noise is a term used to denote an undesirable signal that is superimposed upon the normal operating signal. The ability of circuits to operate reliably in a noise environment is important in many applications. Noise margin is expressed in volts (V) and represents the maximum noise signal that can be tolerated by the gate.
2.8.3 Characteristics of IC Logic Families
The basic circuit of the TTL logic family is the NAND gate. There are many versions of TTL, and 
three of them are listed in Table 2-8. This table gives the general characteristics of the IC logic families. Values listed are representative on a comparison basis. For any one family or version, the values may vary somewhat.
The standard TTL gate was the first version of the TTL family. Additional improvements 
were added as the technology progressed. The Schottky TTL is a later improvement that reduces the propagation delay but results in an increase in power dissipation. The low-power Schottky TTL version sacrifices some speed for reduced power dissipation. It has the same propagation 
Boolean Algebra and Logic Gates  61 
delay as the standard TTL, but the power dissipation is reduced considerably. The fan-out of the 
standard TTL is 10 but the low-power Schottky version has a fan-out of 20. Under certain condi-tions the other versions may also have a fan-out of 20. The noise margin is better than 0.4 V , with a typical value of 1 V .
The basic circuit of the ECL family is the NOR gate. The special advantage of ECL gates 
is their low propagation delay. Some ECL versions may have a propagation delay as low as 0.5 ns. The power dissipation in ECL gales is comparatively high and the noise margin low. These two parameters impose a disadvantage when choosing ECL over other logic families. However, because of its low propagation delay, ECL offers the highest speed of any family and is the ulti-mate choice for very fast systems.
The basic circuit of CMOS is the inverter from which both NAND and NOR gates can be 
constructed. The special advantage of CMOS is its extremely low power dissipation. Under static conditions, the CMOS gate power dissipation is negligible and averages about 10 nW . When the gate signal changes state, there is a dynamic power dissipation which is proportional to the frequency at which the circuit is exercised. The number listed in the table is a typical value of dynamic power dissipation in CMOS gates.
The one major disadvantage of CMOS is its high propagation delay. This means that it is 
not practical for use in systems requiring high-speed operations. The characteristic parameters for the CMOS gate depend on the power supply voltage V
DD that is used. The power dissipation 
increases with increase in voltage supply. The propagation delay decreases with increase in volt-age supply, and the noise margin is estimated to be about 40% of the voltage supply value.
REFERENCES
1. Boole, G., An Investigation of the Laws of Thought. New Y ork: Dover Rub., 1954.
2. Shannon. C, E., “A Symbolic Analysis of Relay and Switching Circuits.” Trans. of the AIEE, V ol. 57 
(1938), 713-23.
3. Huntington, E. V ., “Sets of Independent Postulates far the Algebra of Logic.” Trans. Am. Math. Soc., 
V ol. 5 (1904), 288-309.
4. Birkhoff, G., and T. C. Bartee, Modern Applied Algebra, New Y ork: McGraw-Hill Book Co., 1970.
5. Birkhoff, G., and S. Maclane, A Survey of Modern Algebra, 3rd ed. New Y ork: The Macmillan Co., 
1965.
6. Hohn, F . E., Applied Boolean Algebra, 2nd ed. New Y ork: The Macmillan Co., 1966.Table 2.8 Typical characteristics of IC logic families
IC logic  
familyFan-out Power dissipation 
(mW)Propagation 
delay (ns)Noise margin 
(V)
Standard TTL 10 10 10 0.4
Schottky TTL 10 22 3 0.4
Low-power
Schottky TTL 20 2 10 0.4
ECL 25 25 2 0.2
CMOS 50 0.1 25 3
62 Chapter 2
7. Whitesitt, J. E., Boolean Algebra and its Applications. Reading, Mass.: Addison-Wesley Pub. Co., 
1961.
8. The TTL Data Book for Design Engineers, Dallas, Texas: Texas Instruments Inc., 1976.
9. MECL integrated Circuits Data Book. Phoenix, Ariz.: Motorola Semiconductor Products, Inc., 1972.
10. RCA Solid State Data Book Series: COS/MOS Digital Integrated Circuits. Somerville, N. J.: RCA 
Solid State Div., 1974.
PROBLEMS
2-1. Which of the six basic laws (closure, associative, commutative, identity, inverse, and distributive) are 
satisfied for the pair of binary operators listed below?
+ 0 1 2 0 1 2
0 0 0 0 0 0 1 2
1 0 1 1 1 1 1 2
2 0 1 2 2 2 2 2
2-2. Show that the set of three elements {0, 1, 2} and the two binary operators + and · as defined by the 
above table is not a Boolean algebra. State which of the Huntington postulates is not satisfied?
2-3. Demonstrate by means of truth tables the validity of the following theorems of Boolean algebra.
(a) The associative laws.
(b) De Morgan’ s theorems for three variables.
(c) The distributive law of + over
2-4. Repeat problem 2-3 using Venn diagrams.
2-5. Simplify the following Boolean functions to a minimum number of literals.
(a) xy + xy′
(b) (x + y)(x + y′)
(c)  xyz + x′y + xyz′
(d) zx + zx′y
(e) (A + B)′(A′ + B′)′
(f) y(wz′ + wz) + xy
2-6. Reduce the following Boolean expressions to the required number of literals.(a) ABC + A′B′C + A′BC + ABC′ + A′B′C′  to five literals
(b) BC + AC ′ + AB + BCD   to four literals
(c) [(CD)′ + A]′ + A + CD + AB   to three literals
(d) (A + C + D)(A + C + D′)(A + C + D)(A + B′) to four literals
2-7. Find the complement of the following Boolean functions and reduce them to a minimum number of 
literals.
(a) (BC′ + A′D)(AB′ + CD′)
(b) B′D + A′BC′ + ACD + A′BC
(c) [(AB)′A][(AB)′B]
(d) AB′ + C′D′
Boolean Algebra and Logic Gates  63 
2-8. Given two Boolean functions F1 and F2:
(a) Show that the Boolean function E = F1 + F2 obtained by ORing the two functions, contains the 
sum of all the minterms in F1 and F2.
(b) Show that the Boolean function G = F1F2, obtained from ANDing the two functions, contains 
those minterms common to both F1 and F2.
2-9. Obtain the truth table of the function:
 F = xy + xy′ + y′ z
2-10. Implement the simplified Boolean functions from problem 2-6 with logic gates.
2-11. Given the Boolean function:
 F = xy + x′y′ + y′z
(a) Implement it with AND, OR, and NOT gates,
(b) Implement it with only OR and NOT gates.
(c) Implement it with only AND and NOT gates.
2-12. Simplify the functions T1 and T2 to a minimum number of literals.
A B C T1 T2
0 0 0 1 0
0 0 1 1 0
0 1 0 1 0
0 1 1 0 1
1 0 0 0 1
1 0 1 0 1
1 1 0 0 1
1 1 1 0 1
2-13. Express the following functions in a sum of minterms and a product of maxterms.
(a) F(A, B, C, D)= D(A′ + B) + B′D
(b) F(w, x, y, z) = y′z + wxy′ + wxz′ + w′x′z
(c) F(A, B, C, D) = (A + B′ + C)(A + B′)(A + C′ + D′)
 (A′ + B + C + D′)(B + C′ + D′)
(d) F(A, B, C) = (A′ + B)(B′ + C)
(e) F(x,y,z) = 1
(f) F(x, y, z) = (xy + z)(y + xz)
2-14. Convert the following to the other canonical form.(a) F(x,y,z) = ∑(1.3, 7)
(b) F(A, B, C, D) = ∑(0, 2, 6,11,13, 14)
(c) F(x,y,z) = ∏(0, 3, 6, 7)
(d) F(A, B, C, D) = ∏(0, 1, 2, 3, 4, 6, 12)
64 Chapter 2
2-15. What is the difference between canonical form and standard form? Which form is preferable when 
implementing a Boolean function with gates? Which form is obtained when reading a function from 
a truth table?
2-16. The sum of all minterms of a Boolean function of n variables is 1.
(a) Prove the above statement for n = 3.
(b) Suggest a procedure for a general proof.
2-17. The product of all maxterms of a Boolean function of n variables is 0
(a) Prove the above statement for n =3.
(b) Suggest a procedure for a general proof. Can we use the duality principle after proving (b) of 
problem 2-16?
2-18. Show that the dual of the exclusive-OR is equal to its complement.
2-19. By substituting the Boolean function equivalent of the binary operations as defined in Table 2 6, 
show that:
(a) The inhibition and implication operators are neither commutative nor associative.
(b) The exclusive-OR and equivalence operators are commutative and associative.
(c) The NAND operator is not associative.
(d) The NOR and NAND operators are not distributive.
2-20. A majority gate is a digital circuit whose output is equal to 1 if the majority of the inputs are l’ s. The 
output is 0 otherwise. By means of a truth table, find the Boolean function implemented by a 3-input 
majority gate. Simplify the function.
2-21. Verify the truth table for the 3-input exclusive-OR gate listed in Fig. 2-8(c). List all eight combina-
tions of x, y, and z; evaluate A = x ⊕ y; then evaluate F = A ⊕ z = x ⊕ y ⊕ z.
2-22. TTL SSI come mostly in 14-pin packages. Two pins are reserved for power supply and the other 
pins are used for input and output terminals. How many gates are enclosed in one such package if it 
contains the following types of gates:
(a) 2-input exclusive-OR gates.
(b) 3-input AND gates.
(c) 4-input NAND gates.
(d) 5-input NOR gates.
(e) 8-input NAND gates.
2-23. Show that a positive-logic AND gate is a negative-logic OR gate, and vice versa.
2-24. An IC logic family has NAND gates with fan-out of 5 and buffer gates with fan-out of 10. Show how 
the output signal of a single NAND gate can be applied to 50 other gate inputs.
2-25. Implement EX-NOR gate using minimum number of NAND gate and NAND gates using minimum 
number of NOR gates.
2-26. Show that (x ⊕ y)  z = x ⊕ (y  z)
2-27. With examples, make out difference between (a) min term & max term (b) positive and negative 
logic.
2-28. Differentiate between Standard TTL, Schottky TTL, ECL and CMOS IC logic families in terms of 
fan-out, noise margin, propagation delay and power dissipation.
3Chapter
Simplification of Boolean Functions3.1 The Map Method
The complexity of the digital logic gates that implement a Boolean function is directly related 
to the complexity of the algebraic expression from which the function is implemented. Although the truth table representation of a function is unique, expressed algebraically, it can appear in many different forms. Boolean functions may be simplified by algebraic means as discussed in Section 2-4. However, this procedure of minimization is awkward because it lacks specific rules to predict each succeeding step in the manipulative process. The map method provides a simple straightforward procedure for minimizing Boolean functions. This method may be regarded ei-ther as a pictorial form of a truth table or as an extension of the Venn diagram. The map method, first proposed by Veitch (1) and slightly modified by Karnaugh (2), is also known as the “Veitch diagram” or the “Karnaugh map.”
The map is a diagram made up of squares. Each square represents one minterm. Since any 
Boolean function can be expressed as a sum of minterms, it follows that a Boolean function is recognized graphically in the map from the area enclosed by those squares whose minterms are included in the function. In fact, the map presents a visual diagram of all possible ways a function may be expressed in a standard form. By recognizing various patterns, the user can derive alter -
native algebraic expressions for the same function, from which he can select the simplest one. We shall assume that the simplest algebraic expression is any one in a sum of products or product of sums that has a minimum number of literals. (This expression is not necessarily unique.)
3.2 Two- and Three-variable Maps
A two-variable map is shown in Fig. 3-1. There are four minterms for two variables; hence the map consists of four squares, one for each minterm. The map is redrawn in (b) to show the rela-tionship between the squares and the two variables. The 0’ s and 1’ s marked for each row and each column designate the values of variables x and y, respectively. Notice that x appears primed in 
row 0 and unprimed in row 1. Similarly, y appears primed in column 0 and unprimed in column 1.
If we mark the squares whose minterms belong to a given function, the two-variable map 
becomes another useful way to represent any one of the 16 Boolean functions of two variables. 
As an example, the function xy is shown in Fig. 3-2(a). Since xy is equal to m
3, a 1 is placed inside 
the square that belongs to m3 Similarly, the function x + y is represented in the map of Fig. 3-2(b) 
66 Chapter 3
by three squares marked with l’ s. These squares are found from the minterms of the function:
x + y = x′y + xy′ + xy = m1 + m2 + m3
The three squares could have also been determined from the intersection of variable x in the 
second row and variable y in the second column, which encloses the area belonging to x or y.
A three-variable map is shown in Fig. 3-3. There are eight minterms for three binary vari-
ables. Therefore, a map consists of eight squares. Note that the minterms are arranged, not in a 
binary sequence, but in a sequence similar to the reflected code listed in Table 1-4. The charac-teristic of this sequence is that only one bit changes from 1 to 0 or from 0 to 1 in the listing se-
quence. The map drawn in part (b) is marked with numbers in each row and each column to show the relationship between the squares and the three variables. For example, the square assigned to m
5 corresponds to row 1 and column 01. When these two numbers are concatenated, they give the 
binary number 101, whose decimal equivalent is 5.m1m0
m3 m2
(a)x
xyy
01
10x′y′
xy′ xyx′y
(b)
Figure 3.1 Two-variable map
Figure 3-2 Representation of functions in the mapx
xyy
01
10
1
(a) xyx
xyy
01
1011
1
(b) x + y
m0m1m3m2
m4m5m7m6
(a)yz
00 01 11 10y
x
z0
1x′y′z′ x′y′zx ′yz x′yz′
xy′z′ xy′z xyz xyz′x
(b)
Figure 3-3 Three-variable map
Simplification of Boolean Functions  67 
Another way of looking at square m5 = xy′z is to consider it to be in the row marked x and 
the column belonging to y′z (column 01). Note that there are four squares where each variable is 
equal to 1 and four where each is equal to 0. The variable appears unprimed in those four squares 
where it is equal to 1 and primed in those squares where it is equal to 0. For convenience, we write the variable with its letter symbol under the four squares where it is unprimed.
To understand the usefulness of the map for simplifying Boolean functions, we must rec-
ognize the basic property possessed by adjacent squares. Any two adjacent squares in the map differ by only one variable which is primed in one square and unprimed in the other. For example, m
5 and m7 lie in two adjacent squares. Variable y is primed in m5 and unprimed in m7, while the 
other two variables are the same in both squares. From the postulates of Boolean algebra, it fol-lows that the sum of two minterms in adjacent squares can be simplified to a single AND term consisting of only two literals. To clarify this, consider the sum of two adjacent squares such as m
5 and m7:
m5 + m7 = xy′z + xyz = xz(y′ + y) = xz
Here the two squares differ by the variable y, which can be removed when the sum of the 
two minterms is formed. Thus, any two minterms in adjacent squares that are ORed together will cause a removal of the different variable. The following example explains the procedure for minimizing a Boolean function with a map.
EXAMPLE 3-1: Simplify the Boolean function:
F = x′yz + x′yz′ + xy′z′ + xy′z
First, a 1 is marked in each square as needed to represent the function as shown in Fig. 3-4. This can be accomplished in two ways: either by converting each minterm to a binary number and then marking a 1 in the corresponding square, or by obtaining the coincidence of the variables in each term. For example, the term x′yz has the corresponding binary number 011 
and represents minterm m
3, in square 011. The second way to recognize the square is by the 
coincidence of variables x′, y, and z, which is found in the map by observing that x′ belongs 
to the four squares in the first row, y belongs to the four squares in the two right columns, and 
z belongs to the four squares in the two middle columns. The area that belongs to all three 
literals is the single square in the first row and third column. In a similar manner, the other three squares belonging to the function F are marked by l’ s in the map. The function is thus 
represented by an area containing four squares, each marked with a 1, as shown in Fig. 3-4.  
yz
00 01 11 10y
x
z0
11 111
x
Figure 3.4 Map for Example 3-1; x ′yz + x ′yz′ + xy ′z′ + xy ′z = x′y + xy ′
68 Chapter 3
The next step is to subdivide the given area into adjacent squares. These are indicated in the 
map by two rectangles, each enclosing two 1’ s. The upper right rectangle represents the area enclosed by x′y; the lower left, the area enclosed by xy′. The sum of these two terms gives the 
answer:
F = x′y + xy′
Next consider the two squares labeled m0 and m2 in Fig. 3-3(a) or x′y′z′ and x′yz′ in  
Fig. 3-3 (b). These two minterms also differ by one variable y, and their sum can be simplified to 
a two-literal expression:
x′y′z′ + x′yz′ = x′z′
Consequently, we must modify the definition of adjacent squares to include this and other 
similar cases. This is done by considering the map as being drawn on a surface where the right and left edges touch each other to form adjacent squares.
EXAMPLE 3-2: Simplify the Boolean function:
F = x′yz + xy′z′ + xyz + xyz′
The map for this function is shown in Fig. 3-5. There are four squares marked with l’ s, one for each minterm of the function. Two adjacent squares are combined in the third column to give a two-literal term yz. The remaining two squares with l’ s are also adjacent by the new definition and are shown in the diagram enclosed by half rectangles. These two squares, when combined, give the two-literal term xz′. The simplified function becomes:
F = yz + xz′
Consider now any combination of four adjacent squares in the three-variable map. Any 
such combination represents the ORing of four adjacent minterms and results in an expression of only one literal. As an example, the sum of the four adjacent minterms m
0, m2, m4, and m6 reduces 
to the single literal z′ as shown:
x′y′z′ + x′yz′ + xy′z′ + xyz′ = x′z′(y′ + y) + xz′(y′ + y)
  = x′z′ + xz′ = z′(x′ + x) = z′
yz
00 01 11 10y
x
z0
11
11
x1
Figure 3.5 Map for Example 3-2; x′yz + xy′z′ + xyz + xyz′ = xz + xz′
Simplification of Boolean Functions  69 
EXAMPLE 3-3: Simplify the Boolean function:
F = A′C + A′B + AB′C + BC
The map to simplify this function is shown in Fig. 3-6. Some of the terms in the function have 
less than three literals and are represented in the map by more than one square. For example, to find the squares corresponding to A′C, we form the coincidence of A′ (first row) and C (two 
middle coiumns) and obtain squares 001 and 011. Note that when marking 1’ s in the squares, it is possible to find a 1 already placed there by a preceding term. In this example, the second term A′B has l’ s in squares 011 and 010, but square 011 is common to the first term A′C and 
only one 1 is marked in it. The function in this example has five minterms, as indicated by the five squares marked with l’ s. It is simplified by combining four squares in the center to give the literal C. The remaining single square marked with a 1 in 010 is combined with an 
adjacent square that has already been used once. This is permissible and even desirable since the combination of the two squares gives the term A′B while the single minterm represented 
by the square gives the three-variable term A′BC′. The simplified function is:
F = C + A′B
EXAMPLE 3-4: Simplify the Boolean function:
F(x,y, z) = ∑(0, 2, 4, 5, 6)
Here we are given the minterms by their decimal numbers. The corresponding squares are marked by l’ s as shown in Fig. 3-7. From the map we obtain the simplified function:
F = z′ + xy′
3.3  Four-variable Map
The map for Boolean functions of four binary variables is shown in Fig. 3-8. In (a) are listed the 16 minterms and the squares assigned to each. In (b) the map is redrawn to show the relation-ship with the four variables. The rows and columns are numbered in a reflected-code sequence, 
with only one digit changing value between two adjacent rows or columns. The minterm  BC
00 01 11 10B
A
C0
11
11
11
1
A
Figure 3.6 Map for Example 3-3; A′C + A′B + AB′C + BC = C + A′B
70 Chapter 3
corresponding to each square can be obtained from the concatenation of the row number with 
the column number. For example, the numbers of the third row (11) and the second column (01), when concatenated, give the binary number 1101, the binary equivalent of decimal 13. Thus, the square in the third row and second column represents minterm m
13.
The map minimization of four-variable Boolean functions is similar to the method used to 
minimize three-variable functions. Adjacent squares are defined to be squares next to each other. In addition, the map is considered to lie on a surface with the top and bottom edges, as well as the right and left edges, touching each other to form adjacent squares. For example, m
0 and m2 form 
adjacent squares, as do m3 and m11. The combination of adjacent squares that is useful during the 
simplification process is easily determined from inspection of the four-variable map:
One square represents one minterm, giving a term of four literals. 
Two adjacent squares represent a term of three literals. Four adjacent squares represent a term of two literals. Eight adjacent squares represent a term of one literal. Sixteen adjacent squares represent the function equal to 1.
No other combination of squares can simplify the function. The following two examples show 
the procedure used to simplify four-variable Boolean functions.yz
00 01 11 10y
x
z0
11 11 1
x1
Figure 3.7 f(x,y,z) = ∑(0,2,4,5,6) = z′ + xy′
m0m1m3m2
m4m5m7m6
m12m13m15m14
m8m9m11m10w′x′y′z′
w′xy′z′ w′xy′zw ′xyz w′xyz′
wxy′z′ wxy′z wxyz wxyz′
wx′y′z′ wx′y′zw x′yz wx′yz′w′x′y′zw ′x′yz w′x′yz′yz
wx00
0001
0111
1110
10y
wx
(a) (b)
Figure 3.8 Four-variable map
Simplification of Boolean Functions  71 
EXAMPLE 3-5: Simplify the Boolean function;
F(w, x,y, z) = ∑(0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 14)
Since the Function has four variables, a four-variable map must be used. The minterms listed 
in the sum are marked by l’ s in the map of Fig. 3-9. Eight adjacent squares marked with l’ s can be combined to form the one literal term y′. The remaining three l’ s on the right cannot be combined together to give a simplified term. They must be combined as two or four adjacent squares. The larger the number of squares combined, the less the number of literals in the term. In this example, the top two l’ s on the right are combined with the top two l’ s on the left to give the term w′z′. Note that it is permissible to use the same square more than once. We are 
now left with a square marked by 1 in the third row and fourth column (square 1110). Instead of taking this square alone (which will give a term of four literals), we combine it with squares already used to form an area of four adjacent squares. These squares comprise the two middle rows and the two end columns, giving the term xz′. The simplified function is:
F = y′ + w′z′ + xz′
EXAMPLE 3-6: Simplify the Boolean function:
F = A′B′C′ + B′CD′ + A′BCD′ + AB′C′
The area in the map covered by this function consists of the squares marked with l’ s in  
Fig. 3-10. This function has four variables and, as expressed, consists of three terms, each with three literals, and one term of four literals. Each term of three literals is represented in the map by two squares, For example, A′B′C′ is represented in squares 0000 and 0001. The 
function can be simplified in the map by taking the l’ s in the four corners to give the term B′D′. This is possible because these four squares are adjacent when the map is drawn in a 
surface with top and bottom or left and right edges touching one another. The two left-hand 1’ s in the top row are combined with the two 1’ s in the bottom row to give the term B′C′. yz
wx 00
0001
1
1
1
11 1
1
11
1
10111
1110
10y
zwx
Figure 3.9 Map for Example 3-5; F(w,x,y,z) = ∑(0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 14) = y′ + w′z′ + xz′
72 Chapter 3
The remaining 1 may be combined in a two-square area to give the term A′CD′. The simpli-
fied function is:
F = B′D′ + B′C + A′CD′
3.4 Five- and Six-Variable Maps
Maps of more than four variables are not as simple to use. The number of squares becomes ex-
cessively large and the geometry for combining adjacent squares becomes more involved. The number of squares is always equal to the number of minterms. For five-variable maps, we need 32 squares; for six-variable maps, we need 64 squares. Maps with seven or more variables need too many squares. They are impractical to use. The five- and six-variable maps are shown in Figs. 3-11 and 3-12, respectively. The rows and columns are numbered in a reflected-code sequence; the minterm assigned to each square is read from these numbers. In this way, the square in the third row (11) and second column (001), in the five-variable map, is number 11001, the equiva-lent of decimal 25. Therefore, this square represents minterm m
25. The letter symbol of each 
variable is marked along those squares where the corresponding bit value of the reflected-code CD
AB 00
0001
1
11
1
1
1 10111
1110
10C
DAB
Figure 3.10 Map for Example 3-6: A′B′C′ + B′CD + A′BCD′ + AB′C′ = B′D′ + B′C′ + A′CD′
CDE
AB00
0001
01 32
89 11 10
24 25 27 26
16 17 19 180111
1110 110 111
67 54
14 15 13 12
30 31 29 28
22 23 21 20101 100
10C
DB
E EA
Figure 3.11 Five-variable map
Simplification of Boolean Functions  73 
number is a 1. For example, in the five-variable map, the variable A is a 1 in the last two rows; B is 
a 1 in the middle two rows. The reflected numbers in the columns show variable C with a 1 in the 
rightmost four columns, variable D with a 1 in the middle four columns, and the 1’ s for variable 
E not physically adjacent but split in two parts. The variable assignment in the six-variable map 
is determined similarly.
The definition of adjacent squares for the maps of Figs. 3-11 and 3-12 must be modified 
again to take into account the fact that some variables are split into two parts. The five-variable 
map must be thought to consist of two four-variable maps, and the six-variable map to consist of four four-variable maps. Each of these four-variable maps is recognized from the double lines in the center of the map; each retains the previously defined adjacency when taken individually. In addition, the center double line must be considered as the center of a book, with each half of the map being a page. When the book is closed, two adjacent squares will fall one on the other. In other words, the center double line is like a mirror with each square being adjacent, not only to its four neighboring squares, but also to its mirror image. For example, minterm 31 in the five-variable map is adjacent to minterms 30, 15, 29, 23, and 27. The same minterm in the six-
variable map is adjacent to all these minterms plus minterm 63.
From inspection, and taking into account the new definition of adjacent squares, it is possi-
ble to show that any 2
k adjacent squares, for k = 0, 1, 2, . . . , n, in an n-variable map, will represent 
an area that gives a term of n - k literals. For the above statement to have any meaning, n must 
be larger than k. When n = k, the entire area of the map is combined to give the identity function. 
Table 3-1 shows the relationship between the number of adjacent squares and the number of literals in the term. For example, eight adjacent squares combine an area in the five-variable map to give a term of two literals.DEF
ABC000 001
01 32
89 11 10
24 25 27 26
16 17 19 180110 10110 111
67 54
14 15 13 12
30 31 29 28
22 23 21 20101100
000
001
011
010
110
111
101
100D
A
F FEB
CC
48 49 51 50
56 57 59 58
40 41 43 42
32 33 35 3454 55 53 52
62 63 61 60
46 47 45 44
38 39 37 36
Figure 3.12 Six-variable map
74 Chapter 3
EXAMPLE 3-7: Simplify the Boolean function:
F(A, B, C, D, E) = ∑(0, 2, 4, 6, 9, 11, 13, 15, 17, 21, 25, 27, 29, 31)
The five-variable map of this function is shown in Fig. 3-13. Each minterm is converted to 
its equivalent binary number and the 1’ s are marked in their corresponding squares. It is now necessary to find combinations of adjacent squares that will result in the largest possible area. The four squares in the center of the right-half map are reflected across the double line and are combined with the four squares in the center of the left-half map to give eight allowable adja-cent squares equivalent to the term BE. The two l’ s in the bottom row are the reflection of each 
other about the center double line. By combining them with the other two adjacent squares, we obtain the term AD′E. The four l’ s in the top row are all adjacent and can be combined to 
give the term A′B′E′. All the l’ s are now included. The simplified function is:
F = BE + AD′E + A′B′E′Table 3-1 The relationship between the number of adjacent squares and the number of  
literals in the term
Number of adjacent  
squares Number of literals in a term in an n-variable map
k 2kn = 2 n = 3 n = 4 n = 5 n = 6 n = 7
0 1 2 3 4 5 6 7
1 2 1 2 3 4 5 6
2 4 0 1 2 3 4 5
3 8 0 1 2 3 4
4 16 0 1 2 3
5 32 0 1 2
6 64 0 1
00
11
1111111
1
101
11
10B
A1 1CDE
AB110111 101100 000 001011010C
D
E E
Figure 3.13 Map for Example 3.7; F(A, B, C, D, E) = (0, 2, 4, 6, 9, 11, 13, 15, 17, 21, 25, 27, 
29, 31) = BE + AD′E + A′B′E′
Simplification of Boolean Functions  75 
3.5 Product of Sums Simplification
The minimized Boolean functions derived from the map in all previous examples were expressed 
in the sum of products form. With a minor modification, the product of sums form can be obtained.
The procedure for obtaining a minimized function in product of sums follows from the 
basic properties of Boolean functions. The 1’ s placed in the squares of the map represent the minterms of the function. The minterms not included in the function denote the complement of the function. From this we see that the complement of a function is represented in the map by the squares not marked by 1’ s. If we mark the empty squares by 0’ s and combine them into valid adjacent squares, we obtain a simplified expression of the complement of the function, i.e., of F′. The complement of F′ gives us back the function F.  Because of the generalized DeMorgan’ s 
theorem, the function so obtained is automatically in the product of sums form. The best way to show this is by example.
EXAMPLE 3-8: Simplify the following Boolean function in (a) sum of products and (b) 
product of sums.
F (A, B, C, D) = ∑(0, 1, 2, 5, 8, 9, 10)
The 1’ s marked in the map of Fig. 3-14 represent all the minterms of the function. The squares marked with 0’ s represent the minterms not included in F and therefore denote the comple-
ment of F.  Combining the squares with 1’ s gives the simplified function in sum of products:
(a) F = B′D′ + B′C′ + A′C′D
If the squares marked with 0’ s are combined, as shown in the diagram, we obtain the simpli-
fied complemented function:
F′ = AB + CD + BD′
Applying DeMorgan’ s theorem (by taking the dual and complementing each literal as de-scribed in Section 2-4), we obtain the simplified function in product of sums:
(b) F = (A′ + B′) (C′ + D′) (B′ + D)
0011 01
01 00
00 00
11 0101
11
10ACDC
DBAB000 0010 11 010
Figure 3.14 Map for Example 3.8; F(A, B, C, D) = ∑ (0, 1, 2, 5, 8, 9, 10) = B′ D′ + B′ C′ + A′ C′ 
D′ = (A′ + B′)(C′ + D′)(B′ + D)
76 Chapter 3
The implementation of the simplified expressions obtained in Example 3-8 is shown in 
Fig. 3-15. The sum of products expression is implemented in (a) with a group of AND gates, 
one for each AND term. The outputs of the AND gates are connected to the inputs of a single OR gate. The same function is implemented in (b) in its product of sums form with a group of OR gates, one for each OR term. The outputs of the OR gates are connected to the inputs of a single AND gate, in each case, it is assumed that the input variables are directly available in their complement, so inverters are not needed. The configuration pattern established in Fig. 3-15 is the general form by which any Boolean function is implemented when expressed in one of the standard forms. AND gates are connected to a single UR gate when in sum of products; OR gates are connected to a single AND gate when in product of sums. Either configuration forms two levels of gates. Thus, the implementation of a function in a standard form is said to be a two-level implementation.
Example 3-8 showed the procedure for obtaining the product of sums simplification when 
the function is originally expressed in the sum of minterms canonical form. The procedure is also valid when the function is originally expressed in the product of maxterm canonical form. Con-sider, for example, the truth table that defines the function F in Table 3-2. In sum of minterms, this function is expressed as:
F (x, y, z) = ∑(1,3,4,6)B′
C′A′
F
D′
DB′
D′
C′
A′
DF
                   (a) F = B′D′ + B′C′ + A′C′D      (b) F = (A′ + B′)(C′ + D′)(B′ + D)
Figure 3.15 Gate implementation of the function of Example 3-8
Table 3-2 Truth table of function F
x y z F
0 0 0 0
0 0 1 1
0 1 0 0
0 1 1 1
1 0 0 1
1 0 1 0
1 1 0 1
1 1 1 0
Simplification of Boolean Functions  77 
In product of maxterms, it is expressed as:
F (x, y, z) = ∏ (0, 2, 5, 7)
In other words, the 1’ s of the function represent the minterms, and the 0’ s represent the maxterms. 
The map for this function is drawn in Fig. 3-16. One can start simplifying this function by first 
marking the 1’ s for each minterm that the function is a 1. The remaining squares are marked by 0’ s. If, on the other hand, the product of maxterms is initially given, one can start marking 0’ s in those squares listed in the function; the remaining squares are then marked by 1’ s. Once the 1’ s and 0’ s are marked, the function can be simplified in either one of the standard forms. For the sum of products, we combine the 1’ s to obtain:
F = x′ z + x z′
For the product of sums, we combine the 0’ s to obtain the simplified complemented function:
F′ = x z + x′z′
which shows that the exclusive-OR function is the complement of the equivalence function (Sec-
tion 2-6). Taking the complement of F′, we obtain the simplified function in product of sums:
F = (x′ + z′) (x + z)
To enter a function expressed in product of sums in the map, take the complement of the function and from it find the squares to be marked by 0’ s. For example, the function:
F = (A′ + B′ + C)(B + D)
can be entered in the map by first taking its complement:
F′ = ABC′ + B′D′
and then marking 0’ s in the squares representing the minterms of F′. The remaining squares are 
marked with 1’ s.
3.6 NaNd and Nor Implementation
Digital circuits are more frequently constructed with NAND or NOR gates than with AND and OR gates. NAND and NOR gates are easier to fabricate with electronic components and are the yz
00 01 11 10y
x
z0
111 10
10 01 x
Figure 3.16 Map for the function of Table 3.2
78 Chapter 3
basic gates used in all IC digital logic families. Because of the prominence of NAND and NOR 
gates in the design of digital circuits, rules and procedures have been developed for the conver -
sion from Boolean functions given in terms of AND, OR, and NOT into equivalent NAND or NOR logic diagrams. The procedure for two-level implementation is presented in this section. Multilevel implementation is discussed in Section 4-7.
To facilitate the conversion to NAND and NOR logic, it is convenient to define two oth-
er graphic symbols for these gates. Two equivalent symbols for the NAND gate are shown in  
Fig. 3-17(a). The AND-invert symbol has been defined previously and consists of an AND graph-ic symbol followed by a small circle. Instead, it is possible to represent a NAND gate by an OR graphic symbol preceded by small circles in all the inputs. The invert-OR symbol for the NAND gate follows from DeMorgan’ s theorem and from the convention that small circles denote complementation.
Similarly, there are two graphic symbols for the NOR gate as shown in Fig. 3-17(b). The 
OR-invert is the conventional symbol. The invert-AND is a convenient alternative that utilizes DeMorgan’ s theorem and the convention that small circles in the inputs denote complementation.
A one-input NAND or NOR gate behaves like an inverter. As a consequence, an inverter 
gate can be drawn in three different ways as shown in Fig. 3-17(c). The small circles in all inverter symbols can be transferred to the input terminal without changing the logic of the gate.
It should be pointed out that the alternate symbols for the NAND and NOR gates could 
be drawn with small triangles in all input terminals instead of the circles. A small triangle is a negative-logic polarity indicator (see Section 2-8 and Fig. 2-11). With small triangles in the input terminals, the graphic symbol denotes a negative-logic polarity for the inputs, but the output of the gate (not having a triangle) would have a positive-logic assignment. In this book, we prefer to stay with positive logic throughout and employ small circles when necessary to denote comple-mentation.
x
y
z
Invert-ORF = x′ + y′ + z′ = (xyz)′x
AND- in vertF = (xyz)′ y
z
(a) Two grapic symbol for NAND gate
x
y
zx
y
zF = (x + y + z)′
OR-In vertF = x′y′z′ = (x + y + z)′
invert-AND
(b) Two grapic symbols for NOR gate.
AND- in vert Buffer- invertx x x′ x′
OR-In vertx x′
(c) Three grapic symbols for inverter.
Figure 3.17 Graphic symbols for NAND and NOR gates
Simplification of Boolean Functions  79 
3.6.1 NAND Implementation
The implementation of a Boolean function with NAND gates requires that the function be sim-
plified in the sum of products form. To see the relationship between a sum of products expression 
and its equivalent NAND implementation, consider the logic diagrams drawn in Fig. 3-18. All three diagrams are equivalent and implement the function:
F = AB + CD + E
The function is implemented in Fig. 3-18 (a) in sum of products form with AND and OR gates. 
In (b) the AND gates are replaced by NAND gates and the OR gate is replaced by a NAND gate with an invert-OR symbol. The single variable E is complemented and applied to the second-lev-
el invert-OR gate. Remember that a small circle denotes complementation. Therefore, two circles on the same line represent double complementation and both can be removed. The complement of E goes through a small circle which complements the variable again to produce the normal 
value of E. Removing the small circles in the gates of Fig. 3-18 (b) produces the circuit in (a). 
Therefore, the two diagrams implement the same function and are equivalent.
In Fig. 3-18 (c), the output NAND gate is redrawn with the conventional symbol. The one-
input NAND gate complements variable E. It is possible to remove this inverter and apply E′ 
directly to the input of the second-level NAND gate. The diagram in (c) is equivalent to the one in (b), which in turn is equivalent to the diagram in (a). Note the similarity between the diagrams in (a) and (c). The AND and OR gates have been changed to NAND gates, but an additional NAND gate has been included with the single variable E. When drawing NAND logic diagrams, the 
circuit shown in either (b) or (c) is acceptable. The one in (b), however, represents a more direct relationship to the Boolean expression it implements.
The NAND implementation in Fig. 3-18(c) can be verified algebraically. The NAND function 
it implements can be easily converted to a sum of products form by using DeMorgan’ s theorem:
F = [(AB)′ • (CD)′ • E′]′ = AB + CD + E
From the transformation shown in Fig. 3-18, we conclude that a Boolean function can be 
implemented with two levels of NAND gates. The rule for obtaining the NAND logic diagram from a Boolean function is as follows:
1. Simplify the function and express it in sum of products.
2. Draw a NAND gate for each product term of the function that has at least two literals. The 
inputs to each NAND gate are the literals of the term, This constitutes a group of first-level gates.FA
C
D
EB
FA
C
D
EBA
FC
D
EB
(a) (c) (b)
Figure 3.18 Three ways to implement F = AB + CD + E
80 Chapter 3
3. Draw a single NAND gate (using the AND-invert or invert-OR graphic symbol) in the 
second level, with inputs coming from outputs of first-level gates.
4. A term with a single literal requires an inverter in the first level or may be complemented 
and applied as an input to the second-level NAND gate.
Before applying these rules to a specific example, it should be mentioned that there is a 
second way to implement a Boolean function with NAND gates. Remember that if we combine 
the 0’ s in a map, we obtain the simplified expression of the complement of the function in sum 
of products. The complement of the function can then be implemented with two levels of NAND gates using the rules stated above. If the normal output is desired, it would be necessary to insert a one-input NAND or inverter gate to generate the true value of the output variable. There are oc-casions where the designer may want to generate the complement of the function; so this second method may be preferable.
EXAMPLE 3-9: Implement the following function with NAND gates:
F(x, y, z) = ∑ (0, 6)
The first step is to simplify the function in sum of products form. This is attempted with the map shown in Fig. 3-19(a). There are only two l’ s in the map, and they cannot be combined. The simplified function in sum of products for this example is:
F = x′ y′ z′ + x y z′
The two-level NAND implementation is shown in Fig. 3-19(b). Next we try to simplify the complement of the function in sum of products. This is done by combining the 0’ s in the map:
F′ = x′ y + x y′ + z
The two-level NAND gate for generating F′ is shown in Fig. 3-19(c). If output F is required, 
it is necessary to add a one-input NAND gate to invert the function. This gives a three-level implementation. In each case, it is assumed that the input variables are available in both the normal and complement forms. If they were available in only one form, it would be neces-sary to insert inverters in the inputs, which would add another level to the circuits. The one-input NAND gate associated with the single variable z can be removed provided the input is 
changed to z′.
3.6.2 NOR Implementation
The NOR function is the dual of the NAND function. For this reason, all procedures and rules for NOR logic are the dual of the corresponding procedures and rules developed for NAND  
logic.
The implementation of a Boolean function with NOR gates requires that the function be 
simplified in product of sums form. A product of sums expression specifies a group of OR gates 
for the sum terms, followed by an AND gate to produce the product. The transformation from 
the OR-AND to the NOR-NOR diagram is depicted in Fig. 3-20. It is similar to the NAND  
Simplification of Boolean Functions  81 
transformation discussed previously, except that now we use the product of sums expression:
F = (A + B) (C + D) E
The rule for obtaining the NOR logic diagram from a Boolean function can be derived from 
this transformation. It is similar to the three-step NAND rule, except that the simplified expres-
sion must be in the product of sums and the terms for the first-level NOR gates are the sum terms. 
A term with a single literal requires a one-input NOR or inverter gate or may be complemented and applied directly to the second-level NOR gate.yz
00 01 11 10y
x
z0
10 10 0
0 10 1xF = x′y′z′ + xyz′
F = x′y + xy′ + z
(a) Map simplification in sum of products
Fy′
z′x′
y
z′x
(b) F = x′ y′ z′ + x y z
x′
FF
x
y′
zy
(c) F′ = x′ y + x y′ + z′
Figure 3.19 Implementation of the function of Example 3.9 with NAND gates
FA
B
C
D
EFA
B
C
D
EFA
B
C
D
E’
(c) (a) (b)
Figure 3.20 Three ways to implement F = (A + B) (C + D)E
82 Chapter 3
A second way to implement a function with NOR gates would be to use the expression for 
the complement of the function in product of sums. This will give a two-level implementation for 
F′ and a three-level implementation if the normal output F is required.
To obtain the simplified product of sums from a map, it is necessary to combine the 0’ s in 
the map and then complement the function. To obtain the simplified product of sums expres-sion for the complement of the function, it is necessary to combine the 1’ s in the map and then complement the function. The following example demonstrates the procedure for NOR imple-mentation.
EXAMPLE 3-10: Implement the function of Example 3-9 with NOR gates.
The map of this function is drawn in Fig. 3-19(a). First, combine the 0’ s in the map to 
obtain:
F′ = x′ y + x y′ + z
This is the complement of the function in sum of products. Complement F′ to obtain the sim-
plified function in product of sums as required for NOR implementation:
F = (x + y′) (x′ + y) z′
The two-level implementation with NOR gates is shown in Fig. 3-21(a). The term with a single literal z′ requires a one-input NOR or inverter gate. This gate can be removed and input 
z applied directly to the input of the second-level NOR gate.
A second implementation is possible from the complement of the function in product of 
sums. For this case, first combine the 1’ s in the map to obtain:
F = x′ y′ z′ + x y z′
This is the simplified expression in sum of products. Complement this function to obtain the complement of the function in product of sums as required for NOR implementation:
F′ = (x + y + z) (x′ +y′ + z)
The two-level implementation for F′ is shown in Fig. 3-21(b). If output F is desired, it can be 
generated with an inverter in the third level.
Fx
y´
x´
y
z’x’F’Fx
y’z
zy
(a) F = (x + y′) (x′ + y) z′ (b) F′ = (x + y + z) (x′ + y′ + z)
Figure 3.21 Implementation with NOR gate
Simplification of Boolean Functions  83 
Table 3-3 summarizes the procedures for NAND or NOR implementation. One should not 
forget to always simplify the function in order to reduce the number of gates in the implementa-
tion. The standard forms obtained from the map simplification procedures apply directly and are very useful when dealing with NAND or NOR logic.
3.7 other Two-level Implementations
The types of gates most often found in integrated circuits are NAND and NOR. For this reason, NAND and NOR logic implementations are the most important from a practical-point of view. Some NAND or NOR gates (but not all) allow the possibility of a wire connection between the outputs of two gates to provide a specific logic function. This type of logic is called wired logic. For example, open-collector TTL NAND gates, when tied together, perform the wired-AND logic, (The open-collector TTL gate is shown in Chapter 13, Fig, 13-11). The wired-AND logic performed with two NAND gates is depicted in Fig. 3-22(a). The AND gate is drawn with the 
lines going through the center of the gate to distinguish it from a conventional gate. The wired-AND gate is not a physical gate but only a symbol to designate the function obtained from the indicated wired connection. The logic function implemented by the circuit of Fig. 3-22(a) is:
F = (AB)′ • (CD)′ = (AB + CD)′
and is called an AND-OR-INVERT function.
Similarly, the NOR output of ECL gates can be tied together to perform a wired-OR func-
tion. The logic function implemented by the circuit of Fig. 3-22(b) is:
F = (A + B)′ + (C + D)′ = [(A + B) (C + D)]′
and is called an OR-AND-INVERT function.Table 3-3 Rules for NAND and NOR implementation
CaseFunction to 
simplifyStandard form to 
use How to deriveImplement 
withNumber of levels 
to F
(a) F Sum of products Combine 1’ s in map NAND 2
(b) F′ Sum of products Combine 0’ s in map NAND 3
(c) F Product of sums Complement F ′ in (b) NOR 2
(d) F′ Product of sums Complement F in (a) NOR 3
F=(AB+CD)’C
DA
B
F={(A+B) (C+D)}’x
y’
x
y
(a) Wired - And in open – collector 
TTL NAND gates
(AND - OR - INVERT)(b) Wired-OR in ECL gates
(OR – AND - INVERT)
Figure 3.22 Wired logic
84 Chapter 3
A wired-logic gate does not produce a physical second-level gate since it is just a wire 
connection. Nevertheless, for discussion purposes, we will consider the circuits of Fig. 3-22 as 
two-level implementations. The first level consists of NAND (or NOR) gates and the second level has a single AND (or OR) gate. The wired connection in the graphic symbol will be omitted in subsequent discussions.
3.7.1 Nondegenerate Forms
It will be instructive from a theoretical point of view to find out how many two-level combina-tions of gates are possible. We consider four types of gates: AND, OR, NAND, and NOR. If we assign one type of gate for the first level and one type for the second level, we find that there are 16 possible combinations of two-level forms. (The same type of gate can be in the first and second levels, as in NAND-NAND implementation.) Eight of these combinations are said to be degenerate forms because they degenerate to a single operation. This can be seen from a circuit 
with AND gates in the first level and an AND gate in the second level. The output of the circuit is merely the AND function of all input variables.
The other eight nondegenerate forms produce an implementation in sum of products or 
product of sums. The eight nondegenerate forms are:
AND-OR  OR-AND
NAND-NAND  NOR-NOR
NOR-OR  NAND-AND
OR-NAND  AND-NOR
The first gate listed in each of the forms constitutes a first level in the implementation. The sec-ond gate listed is a single gate placed in the second level. Note that any two forms listed in the same line are the duals of each other.
The AND-OR and OR-AND forms are the basic two-level forms discussed in Section 3-5. 
The NAND-NAND and NOR-NOR were introduced in Section 3-6. The remaining four forms are investigated in this section.
3.7.2 AND-OR-INVERT Implementation
The two forms NAND-AND and AND-NOR are equivalent forms and can be treated together. Both perform the AND-OR-INVERT function, as shown in Fig. 3-23. The AND-NOR form re-sembles the AND-OR form with an inversion done by the small circle in the output of the NOR gate. It implements the function:
F = (AB + CD + E)′
A
FC
D
EBA
FC
D
EBA
FC
D
EB
(c) NAND – AND (b) AND – NOR (a) AND – NOR
Figure 3.23 AND – OR – INVERT circuits; F = (AB + CD + E)′
Simplification of Boolean Functions  85 
By using the alternate graphic symbol for the NOR gate, we obtain the diagram of Fig. 
3-23(b). Note that the single variable E is not complemented because the only change made is 
in the graphic symbol of the NOR gate. Now we move the circles from the input terminal of the 
second-level gate to the output terminals of the first-level gates. An inverter is needed for the single variable to maintain the circle. Alternatively, the inverter can be removed provided input E is complemented. The circuit of Fig. 3-23(c) is a NAND - AND form and was shown in Fig. 3-22 to implement the AND-OR-INVERT function.
An AND-OR implementation requires an expression in sum of products. The AND-OR-
INVERT implementation is similar except for the inversion. Therefore, if the complement of the 
function is simplified in sum of products (by combining the 0’ s in the map), it will be possible to implement F′ with the AND-OR part of the function. When F′ passes through the always present 
output inversion (the INVERT part), it will generate the output F of the function. An example for 
the AND-OR-INVERT implementation will be shown subsequently.
3.7.3 OR-AND-INVERT Implementation
The OR-NAND and NOR-OR forms perform the OR-AND-INVERT function. This is shown in 
Fig. 3-24, The OR-NAND form resembles the OR-AND form, except for the inversion done by the circle in the NAND gate. It implements the function:
F = [(A + B) (C + D) E]′
By using the alternate graphic symbol for the NAND gate, we obtain the diagram of Fig. 
3-24(b). The circuit in (c) is obtained by moving the small circles from the inputs of the second-
level gate to the outputs of the first-level gates. The circuit of Fig. 3-24(c) is a NOR-OR form and was shown in Fig. 3-22 to implement the OR-AND-INVERT function.
The OR-AND-INVERT implementation requires an expression in product of sums. If the 
complement of the function is simplified in product of sums, we can implement F′ with the OR-
AND part of the function. When F′ passes through the INVERT part, we obtain the complement 
of F′, or F,  in the output.
3.7.4 Tabular Summary and Example
Table 3-4 summarizes the procedures for implementing a Boolean function in any one of the four two-level forms. Because of the INVERT part in each case, it is convenient to use the simplifica-tion of F′ (the complement) of the function. When F′ is implemented in one of these forms, we 
A
FC
D
EBA
FC
D
EB A
FC
D
EB
(a) OR – NAND (b) OR – NAND (c) NOR – OR
Figure 3.24 OR – AND – INVERT circuits; F = [(A + B) (C + D) E]′
86 Chapter 3
obtain the complement of the function in the AND-OR or OR-AND form. The four two-level 
forms invert this function, giving an output which is the complement of F′. This is the normal 
output F.
EXAMPLE 3-11: Implement the function of Fig. 3-19(a) with the four two-level forms listed 
in Table 3-4. The complement of the function is simplified in sum of products by combining the 0’ s in the map:
F′ = x′ y + x y′ + z
The normal output for this function can be expressed as
F = (x′ y + x y′ + z)′
which is in the AND-OR-INVERT form. The AND-NOR and NAND-AND implementations are shown in Fig. 3-25(a). Note that a one-input NAND or inverter gate is needed in the NAND-AND implementation, but not in the AND-NOR case. The inverter can be removed if we apply the input variable z′ instead of z.
The OR-AND-INVERT forms require a simplified expression of the complement of the 
function in product of sums. To obtain this expression, we must first combine the 1’ s in the map:
F = x′ y′ z′ + x y z′
Then we take the complement of the function:
F′ = (x + y + z) (x′ + y′ + z)
The normal output F can now be expressed in the form:
F = [(x + y + z)(x′ + y′ + z)]′
which is in the OR-AND-INVERT form. From this expression we can implement the function in the OR-NAND and NOR-OR forms as shown in Fig. 3-25(b).Table 3-4 Implementation with other two-level forms
Equivalent 
nondegenerate 
formImplements 
the 
functionSimplify 
F′ 
inTo get an 
output of
       (a)                     (b)*
AND-NOR     NAND - AND AND-OR-INVERT Sum of products by combining 
0’ s in the mapF
OR-NAND      NOR-OR OR-AND-INVERT Product of sums by combining 1’ s in the map and then com-plementingF
*Form (b) requires a one-input NAND or NOR (inverter) gate for a single literal term.
Simplification of Boolean Functions  87 
3.8 don’t-care Conditions
The 1’ s and 0’ s in the map signify the combination of variables that makes the function equal to 
1 or 0, respectively. The combinations are usually obtained from a truth table that lists the condi-tions under which the function is a 1. The function is assumed equal to 0 under all other condi-tions. This assumption is not always true since there are applications where certain combinations of input variables never occur. A four-bit decimal code, for example, has six combinations which are not used. Any digital circuit using this code operates under the assumption that these unused combinations will never occur as long as the system is working properly. As a result, we don’t care what the function output is to be for these combinations of the variables because they are guaranteed never to occur. These don’t-care conditions can be used on a map to provide further simplification of the function.
It should be realized that a don’t-care combination cannot be marked with a 1 on the map 
because it would require that the function always be a 1 for such input combination. Likewise, putting a 0 in the square requires the function to be 0. To distinguish the don’t-care conditions from 1’ s and 0’ s, an X will be used.
When choosing adjacent squares to simplify the function in the map, the X’ s may be as-
sumed to be either 0 or 1, whichever gives the simplest expression. In addition, an X need not be 
used at all if it does not contribute to covering a larger area. In each case, the choice depends only on the simplification that can be achieved.AND-NOR NAND-AND
(a) F = (x′ y + x y′ + z)′Fx’
x
y’
zyx’
Fx
y’
zy
Fy
zx
y’
zx’Fyzx
y’
zx’
OR-NAND NOR-OR
(b) F = [(x + y + z) (x′ + y′ + z)]′
Figure 3.25 Other two-level implementations
88 Chapter 3
EXAMPLE 3-12: Simplify the Boolean function:
F(w, x, y, z) = ∑(1,3, 7, 11, 15)
and the don’t-care conditions:
d(w, x, y, z) = ∑(0, 2, 5)
The minterms of F are the variable combinations that make the function equal to 1. The 
minterms of d are the don’t-care combinations known never to occur. The minimization is 
shown in Fig. 3-26. The minterms of F are marked by 1’ s, those of d are marked by X’s ,  and 
the remaining squares are filled with 0’ s. In (a), the 1’ s and X’ s are combined in any conve-
nient manner so as to enclose the maximum number of adjacent squares. It is not necessary 
to include all or any of the X’ s, but only those useful for simplifying a term. One combination that gives a minimum function encloses one X and leaves two out. This results in a simplified sum-of-products function:
F = w′ z + y z
In (b), the 0’ s are combined with any X’ s convenient to simplify the complement of the func-
tion. The best results are obtained if we enclose the two X’ s as shown. The complement func-tion is simplified to:
F′ =  z′ + w y′
Complementing again, we obtain a simplified product of sums function:
F =  z (w′ + y)
The two expressions obtained in Example 3-12 give two functions which can be shown to 
be algebraically equal. This is not always the case when don’t-care conditions are involved. As 
Figure 3.26 Example with don’t-care conditionsxx
0
0
01
x
0
01
1
1
1x
0
0
0yz
wx00
0001
0111
1110
10y
zw
(a) Combining 1′s and X′s F = w′ z + y zx
0
0
01
x
0
01
1
1
1x
0
0
0yz
wx00
0001
0111
1110
10y
zwx
(b) Combining 0′s and X′s F = z (w′ + y)
Simplification of Boolean Functions  89 
a matter of fact, if an X is used as a 1 when combining the 1’ s and again as a 0 when combining 
the 0’ s, the two resulting functions will not yield algebraically equal answers. The selection of the don’t-care condition as a 1 in the first case and as a 0 in the second results in different minterm expressions and thus different functions. This can be seen from Example 3-12. In the solution of this example, the X chosen to be a 1 was not chosen to be a 0. Now, if in Fig. 3-26(a) we choose 
the term w′ x′ instead of w′ z, we still obtain a minimized function:
F = w′ x′ + y z
But it is not algebraically equal to the one obtained in product of sums because the same X’s  
are used as 1’ s in the first minimization and as 0’ s in the second.
This example also demonstrates that an expression with the minimum number of literals is 
not necessarily unique. Sometimes the designer is confronted with a choice between two terms with an equal number of literals, with either choice resulting in a minimized expression.
More Sol Ved ProbleMS
Simplify by K-Map
1. Simplify the following equation by K-Map
 F(A, B, C) = ∑m(0, 2, 4) + ∑d(1, 3, 5, 6, 7)
  BC
00 01 11 10 A
XX1 XX 12
63
71
50
4
XX0
1
 F(A, B, C) = C′
2. Simplify π(0, 2, 3.6) by K-Map
  BC
00 01 11 10 A
2
63
71
50
4
000
00
1
 f = (A + C) (A + B′) (B′ + C)3. Simplify the following equation by K-Map
 F(A, B, C, D) = ∑m(2, 4, 5, 13, 14) + ∑d(0, 1, 
8, 10)
  CD
XX
XAB00
0001
0111
11111
1110
102
63
71
50
4
14
1015
1113
912
8
 Ans. F = A′C′ + BC′D + B′CD′ + ACD ′
3.9 The Tabulation Method
The map method of simplification is convenient as long as the number of variables does not ex-
ceed five or six. As the number of variables increases, the excessive number of squares prevents a reasonable selection of adjacent squares. The obvious disadvantage of the map is that it is es-sentially a trial-and-error procedure which relies on the ability of the human user to recognize certain patterns. For functions of six or more variables, it is difficult to be sure that the best selec-tion has been made.
90 Chapter 3
The tabulation method overcomes this difficulty. It is a specific step-by-step procedure that 
is guaranteed to produce a simplified standard-form expression for a function. It can be applied 
to problems with many variables and has the advantage of being suitable for machine computa-tion. However, it is quite tedious for human use and is prone to mistakes because of its routine, monotonous process. The tabulation method was first formulated by Quine (3) and later im-proved by McCluskey (4). It is also known as the Quine-McCluskey method.
The tabular method of simplification consists of two parts. The first is to find by an exhaus-
tive search all the terms that are candidates for inclusion in the simplified function. These terms are called prime-implicants. The second operation is to choose among the prime-implicants 
those that give an expression with the least number of literals.
3.10 determination of Prime-implicants
The starting point of the tabulation method is the list of minterms that specify the function. The first tabular operation is to find the prime-implicants by using a matching process. This process compares each minterm with every other minterm. If two minterms differ in only one variable, that variable is removed and a term with one less literal is found. This process is repeated for every minterm until the exhaustive search is completed. The matching-process cycle is repeated for those new terms just found. Third and further cycles are continued until a single pass through a cycle yields no further elimination of literals. The remaining terms and all the terms that did not match during the process comprise the prime-implicants. This tabulation method is illustrated by the following example.
EXAMPLE 3-13: Simplify the following Boolean function by using the tabulation method:
F = ∑(0, 1, 2, 8, 10, 11, 14, 15)
Step 1: Group binary representation of the minterms according to the number of 1’ s 
contained, as shown in Table 3-5, column (a). This is done by grouping the minterms into five sections separated by horizontal lines. The first section contains the number with no 1’ s in it. The second section contains those numbers that have only one 1, The third, fourth, and fifth sections contain those binary numbers with two, three, and four 1’ s, respectively. The decimal equivalents of the minterms are also carried along for identification.
Step 2: Any two minterms which differ from each other by only one variable can be 
combined, and the unmatched variable removed. Two minterm numbers fit into this category if they both have the same bit value in all positions except one. The minterms in one section are compared with those of the next section down only, because two terms differing by more than one bit cannot match. The minterm in the first section is compared with each of the three minterms in the second section. If any two numbers are the same in every position but one, a check is placed to the right of both minterms to show that they have been used. The resulting term, together with the decimal equivalents, is listed in column (b) of the table. The vari-
able eliminated during the matching is denoted by a dash in its original position. In this case 
m
0 (0000) combines with m1, (0001) to form (000 -). This combination is equivalent to the  
Simplification of Boolean Functions  91 
algebraic operation:
m0 + m1 = w′ x′ y′ z′ + w′ x′ y′ z = w′ x′ y′
Minterm m0 also combines with m2 to form (00-0) and with m8 to form (-000). The result of 
this comparison is entered into the first section of column (b). The minterms of sections two 
and three of column (a) are next compared to produce the terms listed in the second section of column (b). All other sections of (a) are similarly compared and subsequent sections formed in (b). This exhaustive comparing process results in the four sections of (b).
Step 3: The terms of column (b) have only three variables. A 1 under the variable means 
it is unprimed, a 0 means it is primed, and a dash means the variable is not included in the term. The searching and comparing process is repeated for the terms in column (b) to form the two-variable terms of column (c). Again, terms in each section need to be compared only if they have dashes in the same position. Note that the term (000-) does not match with any other term. Therefore, it has no check mark at its right. The decimal equivalents are written on the left-hand side of each entry for identification purposes. The comparing process should be carried out again in column (c) and in subsequent columns as long as proper matching is encountered. In the present example, the operation stops at the third column.
Step 4: The unchecked terms in the table form the prime-implicants. In this example 
we have the term w′ x′ y′ (000-) in column (b), and the terms x′ z′(-0-0) and wy (1-1-) in 
column (c). Note that each term in column (c) appears twice in the table, and as long as the term forms a prime-implicants, it is unnecessary to use the same term twice. The sum of the prime-implicants gives a simplified expression for the function. This is because each checked term in the table has been taken into account by an entry of a simpler term in a subsequent column. Therefore, the unchecked entries (prime-implicants) are the terms left to formulate the function. For the present example, the sum of prime-implicants gives the minimized func-tion in sum of products:
F = w′ x′ y′ + x′ z′ + w yTable 3-5 Determination of prime-implicants for Example 3-13
(a) (b) (c)
        w x y z              w x  y  z                         w  x  y  z
0        0 0 0 0 √ 0,   1     0  0   0  -
0,   2     0  0   - 0 √0,   2,   8,   10   - 0  –  0
0,   8,   2,   10   - 0  - 0
1        0 0 0 1 √
2        0 0 1 0 √0,   8     - 0  0  0 √ 10,  11, 14,  15     1   - 1   -
10,  14,  11, 15    1   - 1   -
8       1 0 0 0 √ 2,    10   - 0  1   0 √
8,    10   1  0  -  0 √
10   1 0 1 0 √
10, 11   1   0  1  - √
11   1 0 1 1 √
14    1 1 1 0 √10, 14   1  - 1  0 √
1 5      1 1 1 1 √11, 15   1  - 1  1 √
14, 15   1 1   1  - √
92 Chapter 3
It is worth comparing this answer with that obtained by the map method. Figure 3-27 shows 
the map simplification of this function. The combinations of adjacent squares give the three 
prime-implicants of the function. The sum of these three terms is the simplified expression in sum of products.
It is important to point out that Example 3-13 was purposely chosen to give the simplified 
function from the sum of prime-implicants. In most other cases, the sum of prime-implicants does not necessarily form the expression with the minimum number of terms. This is demon-strated in Example 3-14.
The tedious manipulation that one must undergo when using the tabulation method is re-
duced if the comparing is done with decimal numbers instead of binary. A method will now be shown that uses subtraction of decimal numbers instead of the comparing and matching of binary numbers. We note that each 1 in a binary number represents the coefficient multiplied by a power of 2. When two minterms are the same in every position except one, the minterm with the extra 1 must be larger than the number of the other minterm by a power of 2. Therefore, two mint-erms can be combined if the number of the first minterm differs by a power of 2 from a second larger number in the next section down the table. We shall illustrate this procedure by repeating  
Example 3-13.
As shown in Table 3-6, column (a), the minterms are arranged in sections as before, except 
that now only the decimal equivalents of the minterms are listed. The process of comparing min-terms is as follows: Inspect every two decimal numbers in adjacent sections of the table. If the number in the section below is greater than the number in the section above by a power of 2 (i.e., 
1, 2, 4, 8, 16, etc.), check both numbers to show that they have been used, and write them down in column (b). The pair of numbers transferred to column (b) includes a third number in paren-theses that designates the power of 2 by which the numbers differ. The number in parentheses tells us the position of the dash in the binary notation. The result of all comparisons of column (a) is shown in column (b).
The comparison between adjacent sections in column (b) is carried out in a similar fashion, 
except that only those terms with the same number in parentheses are compared. The pair of numbers in one section must differ by a power of 2 from the pair of numbers in the next section. And the numbers in the next section below must be greater for the combination to take place. In 1 1
11
1
11
1yz
wx 00
0001
0111
1110
10y
zwx
Figure 3.27 Map for the function of Example 3.13: F = w′ x′ y′ + x′ z′ + w y
Simplification of Boolean Functions  93 
column (c), write all four decimal numbers with the two numbers in parentheses designating the 
positions of the dashes. A comparison of Tables 3-5 and 3-6 may be helpful in understanding the derivations in Table 3-6.
The prime-implicants are those terms not checked in the table. These are the same as be-
fore, except that they are given in decimal notation. To convert from decimal notation to binary, convert all decimal numbers in the term to binary and then insert a dash in those positions desi-gnated by the numbers in parentheses. Thus 0, 1 (1) is converted to binary as 0000, 0001; a dash in the first position of either number results in (000-). Similarly, 0, 2, 8, 10 (2, 8) is converted to the binary notation from 0000, 0010, 1000, and 1010, and a dash inserted in positions 2 and 8, to result in (-0-0)
EXAMPLE 3-14: Determine the prime-implicants of the function:
F (w, x, y, z) = Σ(1, 4, 6, 7, 8, 9, 10, 11, 15)
The minterm numbers are grouped in sections as shown in Table 3-7, column (a). The binary equivalent of the minterm is included for the purpose of counting the number of 1’ s. The binary numbers in the first section have only one 1; in the second section, two 1’ s; etc. The minterm numbers are compared by the decimal method and a match is found if the number in the section below is greater than that in the section above. If the number in the section below is smaller than the one above, a match is not recorded even if the two numbers differ by a power of 2. The exhaustive search in column (a) results in the terms of column (b), with all minterms in column (a) being checked. There are only two matches of terms in column (b). Each gives the same two-literal term recorded in column (c). The prime-implicants consist of all the unchecked terms in the table. The conversion from the decimal to the binary notation is shown at the bottom of the table. The prime-implicants are found to be x′ y′ z, w′ x z′, w′ x y, x y z, w y z, and w x′.Table 3-6 Determination of prime-implicants of  
Example 3-13 with decimal notation
(a) (b) (c)
0√ 0,   1   (1) 0,   2,    8,  10 (2, 8)
0,   2   (2) √ 0,   2,    8,  10 (2, 8)
1√ 0,   8   (8) √
2√ 2,   10 (8) √ 10, 11, 14, 15 (1, 4)
8√ 8,   10 (2) √ 10, 11, 14, 15 (1, 4)
10√10, 11 (1) √
11√ 10, 14 (4) √
14√
15√ 11, 15 (4) √
14, 15 (1) √
94 Chapter 3
The sum of the prime-implicants gives a valid algebraic expression for the function. 
However, this expression is not necessaily the one with the minimum number of terms. This 
can be demonstrated from inspection of the map for the function of Example 3-14. As shown in  
Fig. 3-28, the minimized function is recognized to be:
F = x′ y′z + w′ x z′ + x y z + w x′
which consists of the sum of four of the six prime-implicants derived in Example 3-14. The tabu-
lar procedure for selecting the prime-implicants that give the minimized function is the subject of the next section.
3.11 Selection of Prime-implicants
The selection of prime-implicants that form the minimized function is made from a prime-im-plicant table. In this table, each prime-implicant is represented in a row and each minterm in a column. Crosses are placed in each row to show the composition of minterms that make the Table 3-7 Determination of prime-implicants for Example 3-14
(a) (b) (c)
0001 1 √ 1,   9  (8) 8, 9, 10, 11 (1, 2) 
0100 4 √ 4,   6  (2) 8, 9, 10, 11 (1, 2)
1000 8 √ 8,   9  (1) √
8,   10 (2)√
0110 6 √
1001 9 √ 6,   7  (1)
1010 10 √ 9,   11 (2)√
10, 11 (1)√
0111 7 √
1011 11 √ 7,   15 (8)
11,15 (4)
1111 15 √
Prime-implicants
DecimalBinary 
w  x y  z Term
1, 9 (8) -  0  0  1 x′ y′ z
4, 6 (2) 0  1  -  0 w′xz′
6, 7(1) 0  1  1    - w′xy
7, 15 (8) -  1 1   1 xyz
11, 15(4) 1  - 1   1 wyz
8, 9, 10, 11 (1, 2) 1  0  - - wx′
Simplification of Boolean Functions  95 
1
11 1
1
1 1 11yz
wx 00
0001
0111
1110
10y
zwx
Figure 3.28 Map for the function of Example 3.14; F = x′ y′ z + w′ x z′ + x y z + w x′
Table 3-8 Prime-implicant table for Example 3-15
1 4 6 7 8 9 10 11 15
√ x′ y′ z 1, 9 X X
√ w′ x z′ 4, 6 X X
   w′ x y 6, 7 X X
   x y z 7, 15 X X
   w y z 11, 15 X X
√ w x′ 8, 9, 10, 11 X X X X
√ √ √ √ √ √ √prime-implicants. A minimum set of prime-implicants is then chosen that covers all the minterms 
in the function. This procedure is illustrated in Example 3-15.
EXAMPLE 3-15: Minimize the function of Example 3-14. The prime-implicant table for 
this example is shown in Table 3-8. There are six rows, one for each prime-implicant (derived in Example 3-14), and nine columns, each representing one minterm of the function. Crosses are placed in each row to indicate the minterms contained in the prime-implicant of that row. For example, the two crosses in the first row indicate that minterms 1 and 9 are contained in the prime-implicant x′ y′ z. It is advisable to include the decimal equivalent of the prime-im-plicant in each row, as it conveniently gives the minterms contained in it. After all the crosses have been marked, we proceed to select a minimum number of prime-implicants.
The completed prime-implicant table is inspected for columns  containing only a single 
cross. In this example, there are four minterms whose columns have a single cross: 1, 4, 8, and 10. Minterm 1 is covered by prime-implicant x′ y′ z, i.e., the selection of prime-implicant x′ y′ z guarantees that minterm 1 is included in the function. Similarly, minterm 4 is covered 
by prime-implicant w′ x z′, and minterms 8 and 10, by prime-implicant w x′. Prime-implicants  
96 Chapter 3
The simplified expressions derived in the preceding examples were all in the sum of prod-
ucts form. The tabulation method can be adapted to give a simplified expression in product of 
sums. As in the map method, we have to start with the complement of the function by taking the 0’ s as the initial list of minterms. This list contains those minterms not included in the original function which are numerically equal to the maxterms of the function. The tabulation process is carried out with the 0’ s of the function and terminates with a simplified expression in sum of products of the complement of the function. By taking the complement again, we obtain the simplified product of sums expression.
A function with don’t-care conditions can be simplified by the tabulation method after a 
slight modification. The don’t-care terms are included in the list of minterms when the prime-implicants are determined. This allows the derivation of prime-implicants with the least number of literals. The don’t-care terms are not included in the list of minterms when the prime-impli-cant table is set up, because don’t-care terms do not have to be covered by the selected prime-  
implicants.
3.12 Concluding remarks
Two methods of Boolean function simplification were introduced in this chapter. The criterion for simplification was taken to be the minimization of the number of literals in sum of products or product of sums expressions. Both the map and the tabulation methods are restricted in their capabilities since they are useful for simplifying only Boolean functions expressed in the stan-dard forms. Although this is a disadvantage of the methods, it is not very critical. Most applica-tions prefer the standard forms over any other form. We have seen from Fig. 3-15 that the gate implementation of expressions in standard form consists of no more than two levels of gates. Expressions not in the standard form are implemented with more than two levels. Humphrey (5) shows an extension of the map method that produces simplified multilevel expressions.
One should recognize that the reflected-code sequence chosen for the maps is not unique. It 
is possible to draw a map and assign a binary reflected-code sequence to the rows and columns that cover minterms with a single cross in their column are called essential prime-implicants. To enable the final simplified expression to contain all the minterms, we have no alternative 
but to include essential prime-implicants. A check mark is placed in the table next to the es-sential prime-implicants to indicate that they have been selected.
Next we check each column whose minterm is covered by the selected essential prime-
implicants. For example, the selected prime-implicant x′ y′ z covers minterms 1 and 9. A check is inserted in the bottom of the columns. Similarly, prime-implicant w′ x z′ covers min-terms 4 and 6, and w x′ covers minterms 8, 9, 10, and 11. Inspection of the prime-implicant table shows that the selection of the essential prime-implicants covers all the minterms of 
the function except 7 and 15. These two minterms must be included by the selection of one or more prime-implicants. In this example, it is clear that prime-implicant x y z covers both minterms and is therefore the one to be selected. We have thus found the minimum set of prime-implicants whose sum gives the required minimized function:
F = x′ y′ z + w′ x z′ + w x′ + x y z
Simplification of Boolean Functions  97 
different from the sequence employed here. As long as the binary sequence chosen produces a 
change in only one bit between adjacent squares, it will produce a valid and useful map.
Two alternate versions of the three-variable maps which are often found in the digital logic 
literature are shown in Fig. 3-29. The minterm numbers are written in each square for reference. In (a), the assignment of the variables to the rows and columns is different from the one used in 
this book. In (b), the map has been rotated in a vertical position. The minterm number assign-ment in all maps remains in the order x y z. For example, the square for minterm 6 is found by assigning to the ordered variables the binary number x y z = 110. The square for this minterm is found in (a) from the column marked x y = 11 and the row with z = 0. The corresponding square 
in (b) belongs in the column marked with x = 1 and the row with y z = 10. The simplification procedure with these maps is exactly the same as described in this chapter except, of course, for the variations in minterm and variable assignment.
Two other versions of the four-variable map are shown in Fig. 3-30. The map in (a) is very 
popular and is used quite often in the literature. Here again, the difference is slight and is mani-
fested by a mere interchange of variable assignment from rows to columns and vice versa. The map in (b) is the original Veitch diagram (1) which Karnaugh (2) modified to the one shown in xy
00 01 11 10x
z
y0
102 64
13 75z04
15
37
2 6yz0
001
01
11
10yzx
Figure 3.29 Variations of the three-variable map         (a)          (b)
CDAB
00
0001
04 12 8
15 13 9
37 15 11
26 14 100111
1110
10
BA
CD12 14 64
13 15 75
91 1 31
81 0 20BA
CD
Figure 3.30 Variation of the four-variable map    (a)          (b)
98 Chapter 3
(a). Again, the simplification procedures do not change when these maps are used instead of the 
one employed in this book. There are also variations of the five- and six-variable maps. In any case, any map that looks different from the one used in this book, or is called by a different name, should be recognized merely as a variation of minterm assignment to the squares in the map.
As is evident from Examples 3-13 and 3-14, the tabulation method has the drawback that 
errors inevitably occur in trying to compare numbers over long lists. The map method would seem to be preferable, but for more than five variables, we cannot be certain that the best simpli-fied expression has been found. The real advantage of the tabulation method lies in the fact that it consists of specific step-by-step procedures that guarantee an answer. Moreover, this formal procedure is suitable for computer mechanization.
It was stated in Section 3-9 that the tabulation method always starts with the minterm list 
of the function. If the function is not in this form, it must be converted. In most applications, the function to be simplified comes from a truth table, from which the minterm list is readily 
available. Otherwise, the conversion to minterms adds considerable manipulative work to the problem. However, an extension of the tabulation method exists for finding prime-implicants from arbitrary sum of products expressions. See, for example, McCluskey (7).
In this chapter, we have considered the simplification of functions with many input vari-
ables and a single output variable. However, some digital circuits have more than one output. 
Such circuits are described by a set of Boolean functions, one for each output variable. A circuit with multiple outputs may sometimes have common terms among the various functions which can be utilized to form common gates during the implementation. This results in further simpli-fication not taken into consideration when each function is simplified separately. There exists an extension of the tabulation method for multiple-output circuits (6, 7). However, this method is too specialized and very tedious for human manipulation. It is of practical importance only if a computer program based on this method is available to the user.
reFereNCeS
1. Veitch, E. W ., “A Chart Method for Simplifying Truth Functions.” Proc. of the ACM (May 1952), 
127-33.
2. Karnaugh, M., “A Map Method for Synthesis of Combinational Logic Circuits.” Trans. A1EE, Comm. 
and Electronics, V ol. 72, Part I (November 1953), 593-99.
3. Quine, W . V ., “The Problem of Simplifying Truth Functions.” Am. Math. Monthly, V ol. 59, No. 8 
(October 1952), 521-31.
4. McCluskey, E. J., Jr., “Minimization of Boolean Functions.” Belt System Tech. J., V ol. 35, No. 6 
(November 1956), 1417–44.
5. Humphrey, W , S., Jr., Switching Circuits with Computer Applications. New Y ork; McGraw-Hill Book Co, 1958, Chap. 4.
6. Hill, F . J, and G. R. Peterson, Introduction to Switching Theory and Logical Design, 2nd ed. New 
Y ork: John Wiley & Sons, Inc., 1974, Chapters. 6 and 7.
7. McCluskey, E. J., Jr., Introduction to the Theory of Switching Circuits. New Y ork: McGraw-Hill Book Co., 1965, Chap. 4.
Simplification of Boolean Functions  99 
8. Kohavi, Z., Switching and Finite Automata Theory. New Y ork: McGraw-Hill Book Co, 1970.
9. Nagle, H. T. Jr., B. D. Carrol, and J. D. Irwin, An Introduction to Computer Logic. Englewood Cliffs. 
N.J.: Prentice-Hall, Inc., 1975.
ProbleMS
3-1.  Obtain the simplified expressions in sum of products for the following Boolean functions:
(a) F(x, y, z) = Σ(2, 3, 6, 7)
(b) F(A, B, C. D) = Σ(7, 13, 14, 15)
(c) F(A, B, C, D) = Σ(4, 6, 7, 15)
(d) F(w, x, y, z) = Σ(2, 3, 12, 13, 14, 15)
3-2.  Obtain the simplified expressions in sum of products for the following Boolean functions;
(a) x y + x′ y′ z′ + x′ y z′
(b) A′B + BC′ + B′C′
(c) a′ b′ + bc + a′ b c′
(d) x y′ z + x y z′ + x′ y z + x y z
3-3.  Obtain the simplified expressions in sum of products for the following Boolean functions:
(a) D (A′ + B)+ B′(C + AD)
(b) ABD + A′C′D′ + A′B + A′CD′ + AB′D′
(c) k′ l m′ + k′ m′ n + klm′n′ + lmn′
(d) A′B′C′D′ + AC ′D′ + B′CD′ + A′BCD + BC′D
(e) x′ z + w′ x y′ + w(x′ y + x y′)
3-4.  Obtain the simplified expressions in sum of products for the following Boolean functions:
(a) F(A, B, C, D, E) = Σ(0, 1, 4, 5, 16, 17, 21, 25, 29)
(b) BDE + B′C′D + CDE + A′B′CE + A′B′C + B′C′D′E′
(c) A′B′CE′ + A′B′C′D′ + B′D′E′ + B′CD′ + CDE′ + BDE′
3-5.  Given the following truth table:
x y z F1F2
0 0 0 0 0
0 0 1 1 0
0 1 0 1 0
0 1 1 0 1
1 0 0 1 0
1 0 1 0 1
1 1 0 0 1
1 1 1 1 1
(a) Express F1 and F2 in product of maxterms.
(b) Obtain the simplified functions in sum of products.
(c) Obtain the simplified functions in product of sums.
100 Chapter 3
3-6.  Obtain the simplified expressions in product of sums:
(a) F(x, y, z) = ∏ (0, 1, 4, 5)
(b) F(A, B, C, D) = ∏ (0, 1, 2, 3, 4, 10, 11)
(c) F(w, x, y, z) = ∏ (1, 3, 5, 7, 13, 15)
3-7.  Obtain the simplified expressions in (1) sum of products and (2) product of sums:
(a) x′ z′ + y′ z′ + yz′ + x y z
(b) (A + B′ + D) (A′ + B + D)(C + D)(C′ + D′)
(c) (A′ + B′ + D′)(A + B′ + C′)(A′ + B + D′)(B + C′ + D′)
(d) (A′ + B′ + D) (A′ + D′) (A + B + D′)(A + B′ + C + D)
(e) w′ y z′ + υ w′ z′ + υ w′ x + υ′ wz + υ′ w′ y′ z′
3-8.  Draw the gate implementation of the simplified Boolean functions obtained in problem 3-7 using 
AND and OR gates.
3-9. Simplify each of the following functions and implement them with NAND gates.
(a) F1 = AB′ + AB′C + A′BD + ABE′+ A′BE′+ A′D
(b) F2 = (A + C) (A′ + B′ + C)(A′ + B′ + C + D)(B′ + C + D′)
3-10. Simplify each of the following functions and implement them with NOR gates(a) F1 = (A + B) (A′ + B′ + C + D′)(A′ + B′ + D′)(A+ B′ + C + D′)(C + D′)
(b) F2 = AB′C + A′BD + A′BE′ + A′BC′ + A′BC′ + CD
3-11.  Implement the following functions with NAND gates. Assume that both the normal and complement 
inputs are available.
(a) BD + BCD + AB′C′D′ + A′B′CD′ with no more than six gates, each having three inputs.
(b) (AB + A′B′)(CD′ + C′D) with two-input gates.
3-12.  Implement the following functions with NOR gates. Assume that both the normal and complement inputs are available.
(a) AB′ + C′D′ + A′CD′ + DC(AB + A′B′) + DB(AC ′ + A′C)
(b) AB′CD′ + A′BCD′ + AB′C′D + A′BC′D
3-13.  List the eight degenerate two-level forms and show that they reduce to a single operation. Explain how the degenerate two-level forms can be used to extend the fan-in of gates.
3-14.  Implement the functions of problem 3-9 with the following two-level forms:
 NOR-OR, NAND-AND, OR-NAND, and AND-NOR.
3-15.  Simplify the Boolean function F in sum of products using the don’t-care conditions d:
(a) F = y′ + x′ z′
    d = y z + x y
(b) F = B′C′D′ + BCD′ + ABCD′
    d = B′CD′ + A′BC′D
Simplification of Boolean Functions  101 
3-16.  Simplify the Boolean function F using the don’t-care conditions d, in (1) sum of products and (2) 
product of sums:
(a) F = A′B′D′ + A′CD + A′BC
    d = A′BC′D + ACD + AB′ D′
(b) F = w′ (x′ y + x′ y′ + x y z) + x ‘z′(y + w)
    d = w′ x(y′ z + y z′) + wyz
(c) F = ACE + A′CD′E′ + A′C′DE
    d = DE′ + A′D′E + AD′E′
(d) F = B′DE′ + A′BE + B′C′E′ + A′BC′D′
    d = BDE′ + CD′E′
3-17.  Implement the following functions using the don’t-care conditions. Assume that both the normal and 
complement inputs are available.
(a) F = A′B′C′ + AB′D + A′B′CD′  with no more than two NOR gates.
    d = ABC + AB′D′
(b) F = (A + D)(A′ + B)(A′ + C′) with no more than three NAND gates.
(c) F = B′D + B′C + ABCD  with NAND gates.
    d = A′BD + AB′C′D′
3-18.  Implement the following function with either NAND or NOR gates. Use only four gates. Only the normal inputs are available.
F = w′ x z + w′ y z + x′ y z′ + w x y′ z 
d = w y z
3-19.  The following Boolean expression:
 BE + B′DE′
 is a simplified version of the expression:
 A′BE + BCDE + BC′D′E + A′B′DE′ + B′C′DE′
 Are there any don’t-care conditions? If so, what are they?
3-20.  Give three possible ways to express the function:
 F = A′B′D′ + AB′CD′ + A′BD + ABC′D
 with eight or less literals.
3-21.  With the use of maps, find the simplest form in sum of products of the function F = fg, where f and 
g are given by:
 f = w x y′ + y′ z + w′ y z′ + x′ y z′
 g = (w + x + y′ + z′) (x′ + y′ + z)(w′ + y + z′)
 Hint: See problem 2-8(b).
3-22.  Simplify the Boolean function of problem 3-2(a) using the map defined in Fig. 3-29(a). Repeat with 
the map of Fig. 3-29(b).
3-23.  Simplify the Boolean function of problem 3-3(a) using the map defined in Fig. 3-30(a). Repeat with the map of Fig. 3-30(b).
102 Chapter 3
3-24.  Simplify the following Boolean functions by means of the tabulation method.
(a) F(A, B, C, D, E, F , G)= ∑ (20. 28, 52, 60)
(b) F(A, B, C, D, E, F , G) = ∑ (20, 28, 38, 39, 52, 60, 102, 103, 127)
(c) F(A, B, C, D, E, F) = ∑ (6, 9, 13, 18, 19, 25, 27, 29, 41, 45, 57, 61)
3-25.  Repeat problem 3-6 using the tabulation method.
3-26.  Repeat problem 3-16 (c) and (d) using the tabulation method.
3-27. Simplify f(w, x, y, z) =  ∑(0, 1, 2, 8, 12, 13, 14) + d(3, 5, 10, 15) with K-Map and implement using 
two-variable NAND gates.
3-28. What are Prime-implicants? Minimize following equation using Quine-McCluskey method. 
 f(v, w, x, y, z) =  ∑(1, 4, 12, 14, 16, 18, 21, 25, 26, 29, 31) + d(0, 2, 5, 30)
4Chapter
Combinational Logic4.1 Introduction
Logic circuits for digital systems may be combinational or sequential. A combinational circuit 
consists of logic gates whose outputs at any time are determined directly from the present com-bination of inputs without regard to previous inputs. A combinational circuit performs a specific information-processing operation fully specified logically by a set of Boolean functions. Sequen-tial circuits employ memory elements (binary cells) in addition to logic gates. Their outputs are a function of the inputs and the state of the memory elements. The state of memory elements, in turn, is a function of previous inputs. As a consequence, the outputs of a sequential circuit depend not only on present inputs, but also on past inputs, and the circuit behavior must be specified by a time sequence of inputs and internal states. Sequential circuits are discussed in  
Chapter 6.
In Chapter 1 we learned to recognize binary numbers and binary codes that represent dis-
crete quantities of information. These binary variables are represented by electric voltages or by some other signal. The signals can be manipulated in digital logic gates to perform required functions. In Chapter 2 we introduced Boolean algebra as a way to express logic functions alge-braically. In Chapter 3 we learned how to simplify Boolean functions to achieve economical gate implementations. The purpose of this chapter is to use the knowledge acquired in previous chap-ters and formulate various systematic design and analysis procedures of combinational circuits. The solution of some typical examples will provide a useful catalog of elementary functions important for the understanding of digital computers and systems.
A combinational circuit consists of input variables, logic gates, and output variables. The 
logic gates accept signals from the inputs and generate signals to the outputs. This process trans-forms binary information from the given input data to the required output data. Obviously, both input and output data are represented by binary signals, i.e., they exist in two possible values, one representing logic-1 and the other logic-0. A block diagram of a combinational circuit is shown in Fig. 4-1. The n input binary variables come from an external source; the m output variables go 
to an external destination. In many applications, the source and/or destination are storage regis-ters (Section 1-7) located either in the vicinity of the combinational circuit or in a remote external device. By definition, an external register does not influence the behavior of the combinational circuit because, if it does, the total system becomes a sequential circuit.
104 Chapter 4 
For n input variables, there are 2n possible combinations of binary input values. For each 
possible input combination, there is one and only one possible output combination. A combina-
tional circuit can be described by m Boolean functions, one for each output variable. Each output 
function is expressed in terms of the n input variables.
Each input variable to a combinational circuit may have one or two wires. When only one 
wire is available, it may represent the variable either in the normal form (unprimed) or in the complement form (primed). Since a variable in a Boolean expression may appear primed and/or unprimed, it is necessary to provide an inverter for each literal not available in the input wire. On the other hand, an input variable may appear in two wires, supplying both the normal and complement forms to the input of the circuit. If so, it is unnecessary to include inverters for the inputs. The type of binary cells used in most digital systems are flip-flop circuits (Chapter 6) that have outputs for both the normal and comple ment values of the stored binary variable. In our 
subsequent work, we shall assume that each input variable appears in two wires, supplying both the normal and complement values simultaneously. We must also realize that an inverter circuit can always supply the complement of the variable if only one wire is available.
4.2 Design Procedure
The design of combinational circuits starts from the verbal outline of the problem and ends in a logic circuit diagram, or a set of Boolean functions from which the logic diagram can be easily obtained. The procedure involves the following steps:
1. The problem is stated.
2. The number of available input variables and required output variables is determined.
3. The input and output variables are assigned letter symbols.
4. The truth table that defines the required relationships between inputs and outputs is de-rived.
5. The simplified Boolean function for each output is obtained.
6. The logic diagram is drawn.
A truth table for a combinational circuit consists of input columns and output columns. 
The 1’ s and 0’ s in the input columns are obtained from the 2
n binary combinations available for n 
input variables. The binary values for the outputs are determined from examination of the stated problem. An output can be equal to either 0 or 1 for every valid input combination. However, the specifications may indicate that some input combinations will not occur. These combinations become don’t-care conditions.
The output functions specified in the truth table give the exact definition of the combina-
tional circuit. It is important that the verbal specifications be interpreted correctly into a truth   Combinational
        Logic
        Cir cuitn input
variablesm output
variables
Figure 4.1 Block diagram of a combinational circuit
Combinational Logic  105 
table. Sometimes the designer must use his intuition and experience to arrive at the correct in-
terpretation. Word specifications are very seldom complete and exact. Any wrong interpretation which results in an incorrect truth table produces a combinational circuit that will not fulfill the stated requirements.
The output Boolean functions from the truth table are simplified by any available method, 
such as algebraic manipulation, the map method, or the tabulation procedure. Usually there will be a variety of simplified expressions from which to choose. However, in any particular applica-tion, certain restrictions, limitations, and criteria will serve as a guide in the process of choosing a particular algebraic expression. A practical design method would have to consider such con-straints as (1) minimum number of gates, (2) minimum number of inputs to a gate, (3) minimum propagation time of the signal through the circuit, (4) minimum number of interconnections, and (5) limitations of the driving capabilities of each gate. Since all these criteria cannot be satisfied simultaneously, and since the importance of each constraint is dictated by the particular applica-tion, it is difficult to make a general statement as to what constitutes an acceptable simplification. In most cases the simplification begins by satisfying an elementary objective, such as produc-ing a simplified Boolean function in a standard form, and from that proceeds to meet any other performance criteria.
In practice, designers tend to go from the Boolean functions to a wiring list that shows the 
interconnections among various standard logic gates. In that case the design need not go any fur -
ther than the required simplified output Boolean functions. However, a logic diagram is helpful for visualizing the gate implementation of the expressions.
4.3 Adders
Digital computers perform a variety of information-processing tasks. Among the basic functions encountered are the various arithmetic operations. The most basic arithmetic operation, no doubt, is the addition of two binary digits. This simple addition consists of four possible elementary op-erations, namely, 0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, and 1 + 1 = 10. The first three operations produce a sum whose length is one digit, but when both augend and addend bits are equal to 1, the binary sum consists of two digits. The higher significant bit of this result is called a carry. When the 
augend and addend numbers contain more significant digits, the carry obtained from the addition of two bits is added to the next higher-order pair of significant bits. A combinational circuit that performs the addition of two bits is called a half-adder. One that performs the addition of three 
bits (two significant bits and a previous carry) is a full-adder. The name of the former stems from the fact that two half-adders can be employed to implement a full-adder. The two adder circuits are the first combinational circuits we shall design.
4.3.1 Half-Adder
From the verbal explanation of a half-adder, we find that this circuit needs two binary inputs 
and two binary outputs. The input variables designate the augend and addend bits; the output variables produce the sum and carry. It is necessary to specify two output variables because the result may consist of two binary digits. We arbitrarily assign symbols x and y to the two inputs 
and S (for sum) and C (for carry) to the outputs.
Now that we have established the number and names of the input and output variables, we 
are ready to formulate a truth table to identify exactly the function of the half-adder. This truth 
106 Chapter 4 
table is shown below:
x y C S
0 0 0 0
0 1 0 1
1 0 0 1
1 1 1 0
The carry output is 0 unless both inputs are 1. The S output represents the least significant bit of 
the sum.
The simplified Boolean functions for the two outputs can be obtained directly from the truth 
table. The simplified sum of products expressions are:
S = x′y + xy′
C = xy
The logic diagram for this implementation is shown in Fig. 4-2(a), as are four other implementa-
tions for a half-adder. They all achieve the same result as far as the input-output behavior is con-cerned. They illustrate the flexibility available to the designer when implementing even a simple combinational logic function such as this.
Figure 4-2(a), as mentioned above, is the implementation of the half-adder in sum of prod-
ucts. Figure 4-2(b) shows the implementation in product of sums:
S = (x + y) (x′ + y′)
C = x y
To obtain the implementation of Fig. 4-2(c), we note that S is the exclusive-OR of x and y. The 
complement of S is the equivalence of x and y (Section 2-6):
S′ = x y + x′y′
but C = x y, and therefore we have:
S′ = (C + x′y′)′
In Fig. 4-2(d) we use the product of sums implementation with C derived as follows:
C = x y = (x′ + y′)′
The half-adder can be implemented with an exclusive-OR and an AND gate as shown in  
Fig. 4-2(e). This form is used later to show that two half-adder circuits are needed to construct a full-adder circuit.
4.3.2 Full-Adder
A full-adder is a combinational circuit that forms the arithmetic sum of three input bits. It con-sists of three inputs and two outputs. Two of the input variables, denoted by x and y represent the 
two significant bits to be added. The third input, z represents the carry from the previous lower significant position. Two outputs are necessary because the arithmetic sum of three binary digits ranges in value from 0 to 3, and binary 2 or 3 needs two digits. The two outputs are designated by the symbols S for sum and C for carry. The binary variable S gives the value of the least  
Combinational Logic  107 
significant bit of the sum. The binary variable C gives the output carry. The truth table of the 
full-adder is as follows:
x y z C S
0 0 0 0 0
0 0 1 0 1
0 1 0 0 1
0 1 1 1 0
1 0 0 0 1
1 0 1 1 0
1 1 0 1 0
1 1 1 1 1
The eight rows under the input variables designate all possible combinations of 1’ s and 0’ s that 
these variables may have. The 1’ s and 0’ s for the output variables are determined from the arith-metic sum of the input bits. When all input bits are O’ s, the output is 0. The S output is equal to 1 x
C
yx
S
x′
yy′x
y
x′
y′S
x
Cy
(a) S = xy ′ + x′y
    C = xy(b) S = (x + y) (x′ + y′)
     C = x y
x′
y′
x
yCS
Cx
S
x′
y′y
(c) S = (C + x′y′)′
    C = xy(d) S = (x + y) (x′ + y′)
    C = (x′ +  y′)′
x
y
CS
(e) S = x ⊕ y
     C = xy
Figure 4.2 Various implementations of a half-adder
108 Chapter 4 
when only one input is equal to 1 or when all three inputs are equal to 1. The C output has a carry 
of 1 if two or three inputs are equal to 1.
The input and output bits of the combinational circuit have different interpretations at vari-
ous stages of the problem. Physically, the binary signals of the input wires are considered binary 
digits added arithmetically to form a two-digit sum at the output wires. On the other hand, the same binary values are considered variables of Boolean functions when expressed in the truth table or when the circuit is implemented with logic gates. It is important to realize that two dif-ferent interpretations are given to the values of the bits encountered in this circuit.
The input-output logical relationship of the full-adder circuit may be ex pressed in two Boo-
lean functions, one for each output variable. Each output Boolean function requires a unique map for its simplification. Each map must have eight squares, since each output is a function of three input variables. The maps of Fig. 4-3 are used for simplifying the two output functions. The 1’ s in the squares for the maps of S and C are determined directly from the truth table. The squares 
with 1’ s for the S output do not combine in adjacent squares to give a simplified expression in 
sum of products. The C output can be simplified to a six-literal expression. The logic diagram for the full-adder implemented in sum of products is shown in Fig. 4-4. This implementation uses the following Boolean expressions:
S = x′y′z + x′yz′ + xy′z′ + xyz
    C = xy + xz + yzyz
00 01 11 10y
x
z0
11 11 1
xyz
00 01 11 10y
x
z0
1 1 11
1 x
               S = x ′y′z + x′yz′ + xy ′z′ + xyz                           C = xy + xz + yz
Figure 4.3 Maps for full-adder
x′
y′
z
Sx′
y
z′
x
y′
z′ 
x
y
zx
y
Cx
y
y
z
Figure 4.4 Implementation of full-adder in sum of products
Combinational Logic  109 
Other configurations for a full-adder may be developed. The product-of-sums implementa-
tion requires the same number of gates as in Fig. 4-4, with the number of AND and OR gates 
interchanged. A full-adder can be implemented with two half-adders and one OR gate, as shown in Fig. 4-5. The S output from the second half-adder is the exclusive-OR of z and the output of 
the first half-adder, giving;
S = z ⊕ (x ⊕ y) 
= z′(x y′ + x′y) + z(x y′ + x′y)′ = z′(x y′ + x′y) + z(x y + x′y′) = x y′z′ + x′yz′ + x yz + x′y′z
and the carry output is:
C = z(x y′ + x′y) + x y = x y′z + x′yz + x y
4.4 Subtractors
The subtraction of two binary numbers may be accomplished by taking the complement of the subtrahend and adding it to the minuend (Section 1-5). By this method, the subtraction opera-tion becomes an addition operation requiring full-adders for its machine implementation. It is possible to implement subtraction with logic circuits in a direct manner, as done with paper and pencil. By this method, each subtrahend bit of the number is subtracted from its corresponding significant minuend bit to form a difference bit. If the minuend bit is smaller than the subtrahend bit, a 1 is borrowed from the next significant position. The fact that a 1 has been borrowed must be conveyed to the next higher pair of bits by means of a binary signal coming out (output) of a given stage and going into (input) the next higher stage. Just as there are half- and full-adders, there are half-and full-subtractors.
4.4.1 Half-Subtractor
A half-subtractor is a combinational circuit that subtracts two bits and produces their difference. It also has an output to specify if a 1 has been borrowed. Designate the minuend bit by x and the 
subtrahend bit by y. To perform x - y, we have to check the relative magnitudes of x and y. If x 
> y, we have three possibilities: 0 - 0 = 0, 1 - 0 = 1, and 1 - 1 = 0. The result is called the dif-
ference bit. If x < y, we have 0 - 1, and it is necessary to borrow a 1 from the next higher stage. 
The 1 borrowed from the next higher stage adds 2 to the minuend bit, just as in the decimal sys-x
zy s
c
Figure 4.5 Implementation of full-adder with two half-adders and an OR gate
110 Chapter 4 
tem a borrow adds 10 to a minuend digit. With the minuend equal to 2, the difference becomes 
2 - 1 = 1. The half-subtractor needs two outputs. One output generates the difference and will be 
designated by the symbol D. The second output, designated B for borrow, generates the binary 
signal that informs the next stage that a 1 has been borrowed. The truth table for the input-output 
relationships of a half-subtractor can now be derived as follows:
x y B D
0 0 0 0
0 1 1 1
1 0 0 1
1 1 0 0
The output borrow B is a 0 as long as x ≥ y. It is a 1 for x = 0 and y = 1. The D output is the result 
of the arithmetic operation 2B + x - y.
The Boolean functions for the two outputs of the half-subtractor are derived directly from 
the truth table:
 D = x′y + x y′
B = x′y
It is interesting to note that the logic for D is exactly the same as the logic for output S in the 
half-adder.
4.4.2 Full-Subtractor
A full-subtractor is a combinational circuit that performs a subtraction between two bits, taking into account that a 1 may have been borrowed by a lower significant stage. This circuit has three inputs and two outputs. The three inputs, x, y, and z, denote the minuend, subtrahend, and previ-ous borrow, respectively. The two outputs, D and B, represent the difference and output borrow, 
respectively. The truth table for the circuit is as follows:
x y z B D
0 0 0 0 0
0 0 1 1 1
0 1 0 1 1
0 1 1 1 0
1 0 0 0 1
1 0 1 0 0
1 1 0 0 0
1 1 1 1 1
The eight rows under the input variables designate all possible combinations of 1’ s and 0’ s that the binary variables may take. The 1’ s and 0’ s for the output variables are determined from the subtraction of x - y - z. The combinations having input borrow z = 0 reduce to the same four 
Combinational Logic  111 
conditions of the half-adder. For x = 0, y = 0, and z = 1, we have to borrow a 1 from the next stage, 
which makes B = 1 and adds 2 to x. Since 2 - 0 - 1 = 0, D = 0. For x = 0 and yz = 11, we need to 
borrow again, making B = 1 and x = 2. Since 2 - 1 - 1 = 0, D = 0. For x = 1 and yz = 01, we have 
x - y - z = 0, which makes B = 0 and D = 0. Finally, for x = 1, y = 1, z = 1, we have to borrow 1, 
making B = 1 and x = 3, and 3 - 1 - 1 = 1, making D = 1.
The simplified Boolean functions for the two outputs of the full-subtractor are derived in 
the maps of Fig. 4-6. The simplified sum of products output functions are:
D = x′y′z + x′yz′ + x y′z′ + x yz
B = x′y + x′z + yz
Again we note that the logic function for output D in the full-subtractor is exactly the same as 
output S in the full-adder. Moreover, the output B resembles the function for C in the full-adder, 
except that the input variable x is complemented. Because of these similarities, it is possible to 
convert a full-adder into a full-subtractor by merely complementing input x prior to its applica-
tion to the gates that form the carry output.
4.5 Code Conversion
The availability of a large variety of codes for the same discrete elements of information results 
in the use of different codes by different digital systems. It is sometimes necessary to use the out-put of one system as the input to another. A conversion circuit must be inserted between the two systems if each uses different codes for the same information. Thus, a code converter is a circuit that makes the two systems compatible even though each uses a different binary code.
To convert from binary code A to binary code B, the input lines must supply the bit combi-
nation of elements as specified by code A and the output lines must generate the corresponding bit combination of code B. A combinational circuit performs this transformation by means of logic gates. The design procedure of code converters will be illustrated by means of a specific example of conversion from the BCD to the excess-3 code.
The bit combinations for the BCD and excess-3 codes are listed in Table 1-2 (Section 1-6). 
Since each code uses four bits to represent a decimal digit, there must be four input variables and 
four output variables. Let us designate the four input binary variables by the symbols A, B, C, and D, and the four output variables by w. x, y, and z. The truth table relating the input and out-
put variables is shown in Table 4-1. The bit combinations for the inputs and their corresponding yz
00 01 11 10y
x
z0
11 11 1
xyz
00 01 11 10y
x
z0
11
11 1
x
            D = x ′y′z + x′yz + x y′z′ + x yz                                B = x ′y + x′z + yz
Figure 4-6 Maps for full-subtractor
112 Chapter 4 
outputs are obtained directly from Table 1-2. We note that four binary variables may have 16 bit 
combinations, only 10 of which are listed in the truth table. The six bit combinations not listed for the input variables are don’t-care combinations. Since they will never occur, we are at liberty 
to assign to the output variables either a 1 or a 0, whichever gives a simpler circuit.
The maps in Fig. 4-7 are drawn to obtain a simplified Boolean function for each output. 
Each of the four maps of Fig. 4-7 represents one of the four outputs of this circuit as a function of the four input variables. The 1’ s marked inside the squares are obtained from the minterms that make the output equal to 1. The 1’ s are obtained from the truth table by going over the output columns one at a time. For example, the column under output z has five 1’ s; therefore, the map for 
z must have five 1’ s, each being in a square corresponding to the minterm that makes z equal to 1. 
The six don’t-care combinations are marked by X’ s. One possible way to simplify the functions in sum of products is listed under the map of each variable.
A two-level logic diagram may be obtained directly from the Boolean expressions derived 
by the maps. There are various other possibilities for a logic diagram that implements this circuit. The expressions obtained in Fig. 4-7 may be manipulated algebraically for the purpose of using common gates for two or more outputs. This manipulation, shown below, illustrates the flexibility obtained with multiple-output systems when implemented with three or more levels of gates.
   z = D′ y = CD + C′D′ = CD + (C + D)′   x = B′C + B′D + BC′D′ = B′(C + D) + BC′D′          = B′(C + D) + B(C + D)′
w = A + BC + BD = A + B(C + D)
The logic diagram that implements the above expressions is shown in Fig. 4-8. In it we see that the OR gate whose output is C + D has been used to implement partially each of three outputs.
Not counting input inverters, the implementation in sum of products requires seven AND 
gates and three OR gates. The implementation of Fig. 4-8 requires four AND gates, four OR Table 4-1 Truth table for code-conversion example
Input
BCDOutput
Excess-3 code
A B C D w x y z
0 0 0 0 0 0 1 1
0 0 0 1 0 1 0 0
0 0 1 0 0 1 0 1
0 0 1 1 0 1 l 0
0 1 0 0 0 1 1 1
0 1 0 1 1 0 0 0
0 1 1 0 1 0 0 1
0 1 1 1 1 0 1 0
1 0 0 0 1 0 1 1
1 0 0 1 1 1 0 0
Combinational Logic  113 
gates, and one inverter. If only the normal inputs are available, the first implementation will re-
quire inverters for variables B, C , and D, whereas the second implementation requires inverters 
for variables B and D.
4.6 Analysis Procedure
The design of a combinational circuit starts from the verbal specifications of a required func-tion and culminates with a set of output Boolean functions or a logic diagram. The analysis of a 
combinational circuit is somewhat the reverse process. It starts with a given logic diagram and culminates with a set of Boolean functions, a truth table, or a verbal explanation of the circuit operation. If the logic diagram to be analyzed is accompanied by a function name or an explana-tion of what it is assumed to accomplish, then the analysis problem reduces to a verification of the stated function.
The first step in the analysis is to make sure that the given circuit is combinational and not 
sequential. The diagram of a combinational circuit has logic gates with no feedback paths or CD
AB 00
0001
1
11
1 1
XX X
XX
X0111
1110
10C
Dx = D′ABCD
AB 00
0001
1
11
1 1
XX X
XX
X0111
1110
10C
Dy = CD + C′D′AB
CD
AB 00
0001
1 1 1
1
1X XX X
XX0111
1110
10C
D
y = B′C + B′D + BC′D′ABCD
AB 00
0001
1 11
11XX X X
XX0111
1110
10C
D
w = A + BC + BDAB
Figure 4.7 Maps for BCD-to-excess-3 code coverter
114 Chapter 4 
memory elements. A feedback path is a connection from the output of one gate to the input of a 
second gate that forms part of the input to the first gate. Feedback paths or memory elements in a digital circuit define a sequential circuit and must be analyzed according to procedures outlined in Chapter 6.
Once the logic diagram is verified as a combinational circuit, one can proceed to obtain 
the output Boolean functions and/or the truth table. If the circuit is accompanied by a verbal explanation of its function, then the Boolean functions or the truth table is sufficient for verifi-cation. If the function of the circuit is under investigation, then it is necessary to interpret the operation of the circuit from the derived truth table. The success of such investigation is en-hanced if one has previous experience and familiarity with a wide variety of digital circuits. The 
ability to correlate a truth table with an information-processing task is an art one acquires with  
experience.
To obtain the output Boolean functions from a logic diagram, proceed as follows:
1. Label with arbitrary symbols all gate outputs that are a function of the input variables. Obtain the Boolean functions for each gate.
2. Label with other arbitrary symbols those gates which are a function of input variables and/or previously labeled gates. Find the Boolean func tions for these gates.
3. Repeat the process outlined in step 2 until the outputs of the circuit are obtained.
4. By repeated substitution of previously defined functions, obtain the output Boolean functions in terms of input variables only.
Analysis of the combinational circuit in Fig. 4-9 illustrates the proposed procedure. We 
note that the circuit has three binary inputs. A, B and C, and two binary outputs, F
1 and F2. The DD′
z
y
x
wCCD
B
A(C + D)′
C + D
Figure 4.8 Logic diagram for BCD-to-excess-3 code coverter
Combinational Logic  115 
outputs of various gates are labeled with intermediate symbols. The outputs of gates that are a  
function of input variables only are F2, T1 and T2. The Boolean functions for these three outputs 
are:
F2 = AB + AC + BC
T1 = A + B + C
T2 = ABC
Next we consider outputs of gates which are a function of already defined symbols:
T3 = F′2 T1
F1 = T3 + T2
The output Boolean function F2 expressed above is already given as a function of the inputs only. 
To obtain F1 as a function of A, B, and C, form a series of substitutions as follows:
F1 = T3 + T2 = F′2 T1 + ABC = (AB + AC  + BC)′(A + B + C) + ABC
= (A′ + B′)(A′ + C′)(B′ + C′)(A + B + C) + ABC
= (A′ + B′C′)(AB′ + AC ′ + BC′ + B′C) + ABC
= A′BC′ + A′B′C + AB′C′ + ABC
If we want to pursue the investigation and determine the information-transformation task 
achieved by this circuit, we can derive the truth table directly from the Boolean functions and 
try to recognize a familiar operation. For this example, we note that the circuit is a full-adder, with F
1 being the sum output and F2 the carry output. A, B, and C are the three inputs added  
arithmetically.A
B
C
A
AB
B
A
C
B
CCT1T2
T3F1
F′2
F2
Figure 4.9 Logic diagram for analysis example
116 Chapter 4 
The derivation of the truth table for the circuit is a straightforward process once the output 
Boolean functions are known. To obtain the truth table directly from the logic diagram without 
going through the derivations of the Boolean functions, proceed as follows:
1. Determine the number of input variables to the circuit. For n inputs, form the 2n possible 
input combinations of 1’ s and 0’ s by listing the binary numbers from 0 to 2n - 1.
2. Label the outputs of selected gates with arbitrary symbols.
3. Obtain the truth table for the outputs of those gates that are a function of the input vari-ables only.
4. Proceed to obtain the truth table for the outputs of those gates that are a function of pre-viously defined values until the columns for all outputs are determined.
This process can be illustrated using the circuit of Fig. 4-9. In Table 4-2, we form the eight 
possible combinations for the three input variables. The truth table for F
2 is determined directly 
from the values of A, B, and C, with F2 equal to 1 for any combination that has two or three inputs 
equal to 1. The truth table for F′2 is the complement of F′2. The truth tables for T1 and T2 are the 
OR and AND functions of the input variables, respectively. The values for T3 are derived from T1, 
and F′2: T3 is equal to 1 when both T1 and F′2 are equal to 1, and to 0 otherwise. Finally, F1 is equal 
to 1 for those combinations in which either T2 or T3 or both are equal to 1. Inspection of the truth 
table combinations for A, B, C, F1, and F2 of Table 4-2 shows that it is identical to the truth table 
of the full-adder given in Section 4-3 for x, y, z, S, and C, respectively.
Consider now a combinational circuit that has don’t-care input combinations. When such 
a circuit is designed, the don’t-care combinations are marked by X’s in the map and assigned an 
output of either 1 or 0, whichever is more convenient for the simplification of the output Boolean function. When a circuit with don’t-care combinations is being analyzed, the situation is entirely different. Even though we assume that the don’t-care input combinations will never occur, the fact of the matter is that if any one of these combinations is applied to the inputs (intentionally or in error), a binary output will be present. The value of the output will depend on the choice for the X’s taken during the design. Part of the analysis of such a circuit may involve the deter -
mination of the output values for the don’t-care input combinations. As an example, consider the BCD-to-excess-3 code converter designed in Section 4-5. The outputs obtained when the six Table 4-2 Truth table for logic diagram of Fig. 4-9
A B C F2 F2′ T1T2T3F1
0 0 0 0 1 0 0 0 0
0 0 1 0 1 1 0 1 1
0 1 0 0 1 1 0 I 1
0 1 1 1 0 1 0 0 0
1 0 0 0 1 1 0 1 1
1 0 1 1 0 1 0 0 0
1 1 0 1 0 1 0 0 0
1 1 1 1 0 1 1 0 1
Combinational Logic  117 
unused combinations of the BCD code are applied to the inputs are:
Unused BCD inputs Outputs
A B C D w x y z
1 0 1 0 1 1 0 1
1 0 1 1 1 1 1 0
1 I 0 0 1 1 1 1
1 1 0 1 1 0 0 0
1 1 1 0 1 0 0 1
1 1 1 1 1 0 1 0
These outputs may be derived by means of the truth table analysis method as outlined in this sec-
tion. In this particular case, the outputs may be obtained directly from the maps of Fig. 4-7. From inspection of the maps, we determine whether the X’ s in the corresponding minterm squares for each output have been included with the 1’ s or the O’ s. For example, the square for minterm m
l0 
(1010) has been included with the l’ s for outputs w, x, and z, but not for y. Therefore, the outputs 
for ml0 are wx yz = 1101, as listed in the above table. We also note that the first three outputs in 
the table have no meaning in the excess-3 code, and the last three outputs correspond to decimal 5, 6, and 7, respectively. This coincidence is entirely a function of the choice for the X’ s taken 
during the design.
4.7 Multilevel Nand Circuits
Combinational circuits are more frequently constructed with NAND or NOR gates rather than AND and OR gates. NAND and NOR gates are more common from the hardware point of view because they are readily available in integrated-circuit form. Because of the prominence of NAND and NOR gates in the design of combinational circuits, it is important to be able to recognize the relationships that exist between circuits constructed with AND-OR gates and their equivalent NAND or NOR diagrams.
The implementation of two-level NAND and NOR logic diagrams was presented in Section 
3-6. Here we consider the more general case of multilevel circuits. The procedure for obtaining NAND circuits is presented in this section, and for NOR circuits in the next section.
4.7.1 Universal Gate
The NAND gate is said to be a universal gale because any digital system can be implemented with it. Combinational circuits and sequential circuits as well can be constructed with this gate because the flip-flop circuit (the memory element most frequently used in sequential circuits) can be constructed from two NAND gates connected back to back, as shown in Section 6-2.
To show that any Boolean function can be implemented with NAND gates, we need only 
show that the logical operations AND, OR, and NOT can be implemented with NAND gates. The implementation of the AND, OR, and NOT operations with NAND gates is shown in Fig. 4-10. The NOT operation is obtained from a one-input NAND gate, actually another symbol for an inverter circuit. The AND operation requires two NAND gates. The first produces the inverted 
118 Chapter 4 
AND and the second acts as an inverter to produce the normal output. The OR operation is achie-
ved through a NAND gate with additional inverters in each input.
A convenient way to implement a combinational circuit with NAND gates is to obtain the 
simplified Boolean functions in terms of AND, OR, and NOT and convert the functions to NAND logic. The conversion of the algebraic expression from AND, OR, and NOT operations to NAND operations is usually quite complicated because it involves a large number of applications of De Morgan’ s theorem. This difficulty is avoided by the use of simple circuit manipulations and simple rules as outlined below.
4.7.2 Boolean Function Implementation — Block Diagram Method
The implementation of Boolean functions with NAND gates may be obtained by means of a simple block diagram manipulation technique. This method requires that two other logic dia-grams be drawn prior to obtaining the NAND logic diagram. Nevertheless, the procedure is very simple and straightforward:
1. From the given algebraic expression, draw the logic diagram with AND, OR, and NOT gates. Assume that both the normal and complement inputs are available.
2. Draw a second logic diagram with the equivalent NAND logic, as given in Fig. 4-10, substituted for each AND, OR, and NOT gate.
3. Remove any two cascaded inverters from the diagram, since double inversion does not perform a logic function. Remove inverters connected to single external inputs and complement the corresponding input variable. The new logic diagram obtained is the required NAND gate implementation,
 This procedure is illustrated in Fig. 4-11 for the function:
F = A(B + CD) + BC′A A′ NOT (inverter)
A
B(AB)′
AB AND
(A′B′)′ = A + B ORA
BA′
B′
Figure 4-10 Implementation of NOT. AND, or OR by NAND gates
Combinational Logic  119 
The AND-OR implementation of this function is shown in the logic diagram of Fig. 4-11(a). 
For each AND gate, we substitute a NAND gate followed by an inverter; for each OR gate, we substitute input inverters followed by a NAND gate. This substitution follows directly from the logic equivalences of Fig. 4-10 and is shown in the diagram of Fig. 4-11(b). This diagram has seven inverters and five two-input NAND gates listed with numbers inside the gate symbol. Pairs of inverters connected in cascade (from each AND box to each OR box) are removed since they form double inversion. The inverter connected to input B is removed and the input variable is 
designated by B′. The result is the NAND logic diagram shown in Fig. 4-11(c), with the number 
inside each symbol identifying the gate from Fig. 4-11(b).C
D
B
B F
C′A
(a) AND/OR implementation
CAND OR
1
3
4
5
2D
B
B
C′A
AANDAND OR
F
(b) Substituting equivalent NAND functions from Fig. 5.8
C
1
3
4
5
2D
B′
B F
C′A
(c) NAND implementation
Figure 4.11 Implementation of F = A(B + CD) + BC ′ with NAND gates
120 Chapter 4 
This example demonstrates that the number of NAND gates required to implement the 
Boolean function is equal to the number of AND-OR gates, provided both the normal and the 
complement inputs are available. If only the normal inputs are available, inverters must be used to generate any required complemented inputs.
A second example of NAND implementation is shown in Fig. 4-12. The Boolean function 
to be implemented is:
F = (A + B′) (CD+ E)
The AND-OR implementation is shown in Fig. 4-12(a), and its NAND logic substitution in Fig. 4-12(b). One pair of cascaded inverters may be removed. The three external inputs E, A, and B′, 
which go directly to inverters, are complemented and the corresponding inverters removed. The final NAND gate implementation is in Fig. 4-12(c).
The number of NAND gates for the second example is equal to the number of AND-OR 
gates plus an additional inverter in the output (NAND gate 5). In general, the number of NAND 
C
D
E
B′F A
(a) AND/OR implementation
CAND OR
1
3
4D
E
A
B′AND
25
ORF
(b) Substituting equivalent NAND functions
C
1
3
42D
E′
BA′ F 5
(c) NAND implementation
Figure 4.12 Implementation of (A + B′)(CD + E) with NAND gates
Combinational Logic  121 
gates required to implement a function equals the number of AND-OR gates, except for an oc-
casional inverter. This is true provided both normal and complement inputs are available, because the conversion forces certain input variables to be complemented.
The block diagram method is somewhat tiresome to use because it requires the drawing of 
two logic diagrams to obtain the answer in a third. With some experience, it is possible to reduce the amount of labor by anticipating the pairs of cascaded inverters and the inverters in the inputs. Starting from the procedure just outlined, it is not too difficult to derive general rules for imple-menting Boolean functions with NAND gates directly from an algebraic expression.
4.7.3 Analysis Procedure
The foregoing procedure considered the problem of deriving a NAND logic diagram from a given Boolean function. The reverse process is the analysis problem which starts with a given NAND logic diagram and culminates with a Boolean expression or a truth table. The analysis of NAND logic diagrams follows the same procedures presented in Section 4-6 for the analysis of combinational circuits. The only difference is that NAND logic requires a repeated application of De Morgan’ s theorem. We shall now demonstrate the derivation of the Boolean function from a logic diagram. Then we will show the derivation of the truth table directly from the NAND logic diagram. Finally, a method will be presented for converting a NAND logic diagram to AND-OR logic diagram by means of block diagram manipulation.
4.7.4 Derivation of the Boolean Function by Algebraic Manipulation
The procedure for deriving the Boolean function from a logic diagram is outlined in Section 4-6. This procedure is demonstrated for the NAND logic diagram shown in Fig. 4-13, which is the same as that in Fig. 4-11(c). First, all gate outputs are labeled with arbitrary symbols. Second, the Boolean functions for die outputs of gates that receive only external inputs are derived:
T
1 = (CD)′ = C′+ D′
T2 = (BC)′ = B′ + C
The second form follows directly from De Morgan’ s theorem and may, at times, be more con-venient to use. Third, Boolean functions of gates which have inputs from previously derived  
C T1
T3
T2T4D
B′
B F
C′A
Figure 4.13 Analysis example
122 Chapter 4 
functions are determined in consecutive order until the output is expressed in terms of input 
variables:
 T3 = (B′T1)′ = (B′C′ + B′D′)′
= (B + C)(B + D) = B + CD
T4 = (AT3)′ = [A(B+ CD)]′
F = (T2T4)′ = {(BC′)′[A(B + CD)]′}′
= BC′ + A(B+ CD)
4.7.5 Derivation of the Truth Table
The procedure for obtaining the truth table directly from a logic diagram is also outlined in Section 4-6. This procedure is demonstrated for the NAND logic diagram of Fig. 4-13. First, the four input variables, together with their 16 combinations of 1’ s and 0’ s, are listed as in Table 4-3. Second, the outputs of all gates are labeled with arbitrary symbols as in Fig. 4-13. Third, we obtain the truth table for the outputs of those gates that are a function of the input variables only. These are T
1, and T2. T1 = (CD)′; so we mark 0’ s in those rows where both C and D are equal 
to 1 and fill the rest of the rows of T1 with 1’s. Also, T2 = (BC′)′; so we mark 0’ s in those rows 
where B = 1 and C = 0, and fill the rest of the rows of T2 with 1’ s. We then proceed to obtain the 
truth table for the outputs of those gates that are a function of previously defined outputs until the column for the output F is determined. It is now possible to obtain an algebraic expression 
for the output from the derived truth table. The map shown in Fig. 4-14 is obtained directly from 
Table 4-3 and has 1’ s in the squares of those minterms for which F is equal to 1. The simplified 
Table 4-3 Truth table for the circuit of Figure 4-13
A B C D T1T2T3T4F
0 0 0 0 1 1 0 1 0
0 0 0 1 1 1 0 1 0
0 0 1 0 1 I 0 1 0
0 0 1 1 0 1 1 1 0
0 1 0 0 1 0 1 1 1
0 1 0 1 1 0 1 1 1
0 1 1 0 1 1 1 1 0
0 1 1 1 0 1 1 1 0
1 0 0 0 1 1 0 1 0
1 0 0 1 1 1 0 1 0
1 0 1 0 1 1 0 1 0
1 0 1 1 0 1 1 0 1
1 1 0 0 1 0 1 0 1
1 1 0 1 1 0 1 0 1
1 1 1 0 1 1 1 0 1
1 1 1 1 0 1 1 0 1
Combinational Logic  123 
expression obtained from the map is:
F = AB + ACD + BC′ = A(B + CD) + BC′
This is the same as the expression of Fig. 4-11, thus verifying the correct answer.
4.7.6 Block Diagram Transformation
It is sometimes convenient to convert a NAND logic diagram to its equivalent AND-OR log-
ic diagram to facilitate the analysis procedure. By doing so, the Boolean function can be de-rived more easily without employing De Morgan’ s theorem. The conversion of logic diagrams is accomplished through a process reverse from that used for implementation. In Section 3-6, we showed two alternate graphic symbols for the NAND gate. These symbols are repeated in  
Fig, 4-15 for convenience. By judicious use of both symbols, it is possible to convert a NAND diagram to an equivalent AND-OR form.
The conversion of a NAND logic diagram to an AND-OR diagram is achieved through a 
change in symbols from AND-invert to invert-OR in alternate levels of gates. The first level to be 
changed to an invert-OR symbol should be the last level. These changes produce pairs of circles along the same line, and these can be removed since they represent double complementation. 
Moreover, a one-input AND or OR gate can be removed since it does not perform a logical func-tion. A one-input AND or OR with a circle in the input or output is changed to an inverter circuit.
This procedure is demonstrated in Fig. 4-16. The NAND logic diagram of Fig. 4-16(a) is 
to be converted to an AND-OR diagram. The symbol of the gate in the last level is changed to CD
AB 00
0001
1 1
11 1
110111
1110
10C
D
F = AB + BC ′ + ACDAB
Figure 4.14 Derivation of F from Table 4.3
B
CA
(ABC)′ B
CA
A′ + B′ + C′
= (ABC)′
                               (a) AND-invert                                            (b) invert-OR
Figure 4.15 Two symbols for NAND gate
124 Chapter 4 
an invert-OR. Looking for alternate levels, we find one more gate requiring a change of symbol 
as shown in Fig, 4-16(b). Any two circles along the same line are removed. Circles that go to external inputs are also removed, provided the corresponding input variable is complemented. The re quired AND-OR logic diagram is drawn in Fig. 4-16(c).
4.8 Multilevel NOR Circuits
The NOR function is the dual of the NAND function. For this reason, all procedures and rules for NOR logic form a dual of the corresponding procedures and rules developed for NAND logic. This section enumerates various methods for NOR logic implementation and analysis by follow-ing the same list of topics used for NAND logic. However, less detailed explanation is included so as to avoid excessive repetition of the material in Section 4-7.
4.8.1 Universal Gate
The NOR gate is universal because any Boolean function can be implemented with it, including a flip-flop circuit as shown in Section 6-2. The conversion of AND, OR, and NOT to NOR is shown C
D
B′
B
C′A
(a) NAND logic diagram
C
D
B′
B
C′A
(b) Substitution of invert-OR symols in alternate levels
C
D
B
B
C′A
(c) AND-OR logic diagram
Figure 4.16 Conversion of NAND logic diagram to AND-OR
Combinational Logic  125 
in Fig. 4-17. The NOT operation is obtained from a one-input NOR gate, yet another symbol for 
an inverter circuit. The OR operation requires two NOR gates. The first produces the inverted-OR and the second acts as an inverter to obtain the normal output. The AND operation is achieved 
through a NOR gate with additional inverters at each input.
4.8.2 Boolean Function Implementation — Block Diagram Method
The block diagram procedure for implementing Boolean functions with NOR gates is similar to the procedure outlined in the previous section for NAND gates.
1. Draw the AND-OR logic diagram from the given algebraic expression. Assume that both the normal and the complement inputs are available.
2. Draw a second logic diagram with equivalent NOR logic, as given in Fig. 4-17, substi-tuted for each AND, OR, and NOT gate.
3. Remove pairs of cascaded inverters from the diagram. Remove inverters connected to single external inputs and complement the corresponding input variable.
The procedure is illustrated in Fig. 4-18 for the function:
F = A(B + CD) + BC′
The AND-OR implementation of the function is shown in the logic diagram of Fig. 4-18(a). For each OR gate, we substitute a NOR gate followed by an inverter. For each AND gate, we substi-tute input inverters followed by a NOR gate. The pair of cascaded inverters from the OR box to the AND box is removed. The four inverters connected to external inputs are removed and the input variables comple mented. The result is the NOR logic diagram shown in Fig. 4-l8(c). The 
number of NOR gates in this example equals the number of AND-OR gates plus an additional inverter in the output (NOR gate 6). In general, the number of NOR gates required to implement a Boolean function equals the number of AND-OR gates, except for an occasional inverter. This is true provided both normal and complement inputs are available, because the conversion forces certain input variables to be complemented.A
B(A + B)′
A + B OR
(A′ + B′)′ = ABANDA
BA′
B′A A′ NOT (inverter)
Figure 4.17 Implementation of NOT, OR, and AND by NOR gates
126 Chapter 4 
4.8.3 Analysis Procedure
The analysis of NOR logic diagrams follows the same procedures presented in Section 4-6 for 
the analysis of combinational circuits. To derive the Boolean function from a logic diagram, we mark the outputs of various gates with arbitrary symbols. By repetitive substitutions, we obtain the output variable as a function of the input variables. To obtain the truth table from a logic C
D
B
B F
C′A
(a) AND/OR implementation
CAND
1
4D
B
B
C′A3OR
AND
FAND
5OR2
6
(b) Substitution equivalent NOR functions from Fig 5-19
C′
1
23
4
5 6D′
FB
B′
CA′
(c) NOR implementation
Figure 4.18 Implementation of F = A(B + CD) + BC′ with NOR gates
Combinational Logic  127 
diagram without first deriving the Boolean function, we form a table listing the n input variables 
with 2n rows of 1’ s and 0’ s. The truth table of various NOR gate outputs is derived in succession 
until the output truth table is obtained. The output function of a typical NOR gate is of the form 
T = (A + B′ + C)′: so the truth table for T is marked with a 0 for those combinations where A = 1 
or B = 0 or C = l. The rest of the rows are filled with 1’ s.
4.8.4 Block Diagram Transformation
To convert a NOR logic diagram to its equivalent AND-OR logic diagram, we use the two sym-bols for NOR gates shown in Fig. 4-19. The OR-invert is the normal symbol for a NOR gate and the invert-AND is a convenient alternative that utilizes De Morgan’ s theorem and the convention that small circles at the inputs denote complementation.
The conversion of a NOR logic diagram to an AND-OR diagram is achieved through a 
change in symbols from OR-invert to invert-AND starting from the last level and in alternate levels. Pairs of small circles along the same line are removed. A one-input AND or OR gate is removed, but if it has a small circle at the input or output, it is converted to an inverter.
This procedure is demonstrated in Fig. 4-20, where the NOR logic diagram in (a) is con-
verted to an AND-OR diagram. The symbol of the gate in the last level (5) is changed to an invert-AND. Looking for alternate levels, we find one gate in level 3 and two in level 1. These three gates undergo a symbol change as shown in (b). Any two circles along the same line are removed. Circles that go to external inputs are also removed, provided the corresponding input variable is complemented. The gate in level 5 becomes a one-input AND gate and is removed. The required AND-OR logic diagram is drawn in Fig. 4-20(c).
4.9 Exclusive-OR and Equivalence Functions
Exclusive-OR and equivalence, denoted by ⊕ and , respectively, are binary operations that 
perform the following Boolean functions:
x ⊕ y = x y′ + x′y
x  y = x y + x′y′
The two operations are the complements of each other. Each is commutative and associative. Because of these two properties, a function of three or more variables can be expressed without parentheses as follows:
(A ⊕ B) ⊕ C = A ⊕ (B ⊕ C) = A ⊕ B ⊕ C
This would imply the possibility of using exclusive-OR (or equivalence) gates with three or more inputs. However, multiple-input exclusive-OR gates are very uneconomical from a hardware A (A + B + C)′B
CA′B′C′ = (A + B + C)′ A
B
C
                               (a)  OR-invert                                         (b) invert-AND
Figure 4-19 Two symbols for NOR gate
128 Chapter 4 
standpoint. In fact, even a two-input function is usually constructed with other types of gates. 
For example, Fig. 4-21(a) shows the im plementation of a two-input exclusive-OR function with 
AND, OR, and NOT gates. Figure 4-21(b) shows it with NAND gates.
Only a limited number of Boolean functions can be expressed exclusively in terms of exclu-
sive-OR or equivalence operations. Nevertheless, these functions emerge quite often during the design of digital systems. The two functions are particularly useful in arithmetic operations and in error detection and correction.
An n-variable exclusive-OR expression is equal to the Boolean function with 2
n/2 minterms 
whose equivalent binary numbers have an odd number of 1’ s. This is demonstrated in the map of Fig. 4-22 (a) for the four-variable case. There are 16 minterms for four variables. Half the min-terms have a numerical value with an odd number of 1’ s; the other half have a numerical value with an even number of 1’ s. The numerical value of a minterm is determined from the row and column numbers of the square that represents the minterm. The map of Fig. 4-22 (a) has 1’ s in the squares whose minterm numbers have an odd number of 1’ s. The function can be expressed C′
D′
B
B′
CA′
(a) NOR logic diagram
C′
D′
B
B′
CA′
(b) Substitution of invert-AND symbols in alternate levels
                  C
D
B
B
C′A
   (c) AND-OR logic diagram
Figure 4.20 Conversion of NOR logic diagram to AND-OR
Combinational Logic  129 
x
x ⊕ y
y
(a) with AND-OR-NOT gates
x
x ⊕ y
y
(b) with NAND gates
Figure 4.21 Exclusive-OR implementations
CD
AB 00
0001
111
111
110111
1110
10C
D
F = A ⊕ B ⊕ C ⊕ DABCD
AB 00
0001
1
1 1
1 11
1 10111
1110
10C
D
F = A ⊙ B ⊙ C ⊙ DAB
                                (a)        (b) 
Figure 4.22 Map for a four-variable (a) exclusive-OR function and (b) equivalence function 
130 Chapter 4 
in terms of the exclusive-OR operations on the four variables. This is justified by the following 
algebraic manipulation:
A ⊕ B ⊕ C ⊕ D    = (AB′ + A′B) ⊕ (CD′ + C′D)  = (AB′ + A′B)(CD + C′D′) + (AB + A′B′)(CD′ + C′D) 
   = ∑(1, 2, 4, 7, 8, 11, 13, 14)
An n-variable equivalence expression is equal to the Boolean function with 2
n/2 minterms, 
whose equivalent binary numbers have an even number of O’ s. This is demonstrated in the map of Fig. 4-22(b) for the four-variable case. The squares with l’ s represent the eight minterms with an even number of 0’ s, and the function can be expressed in terms of the equivalence operations on the four variables.
When the number of variables in a function is odd, the minterms with an even number of 
0’ s are the same as the minterms with an odd number of 1’ s. This is demonstrated in the three-variable map of Fig. 4-23(a). Therefore, an exclusive-OR expression is equal to an equivalence expression when both have the same odd number of variables. However, they form the comple-ments of each other when the number of variables is even, as demonstrated in the two maps of Fig. 4-22(a) and (b).
When the minterms of a function with an odd number of variables have an even number of 
1’ s (or equivalently, an odd number of 0’ s), the function can be expressed as the complement of either an exclusive-OR or an equivalence expression. For example, the three-variable function shown in the map of Fig. 4-23(b) can be expressed as follows:
(A ⊕ B ⊕ C)'=A ⊕ B  C 
or
(A  B  C)' = A  B ⊕ C
The S output of a full-adder and the D output of a full-subtractor (Section 4-3) can be 
implemented with exclusive-OR functions because each function consists of four minterms with numerical values having an odd number of 1’ s. The exclusive-OR function is extensively used in the implementation of digital arithmetic operations because the latter are usually implemented through proce dures that require a repetitive addition or subtraction operation.BC
00 01 11 10B
A
C0
11 11 1
ABC
00 01 11 10B
A
C011 11 1
A
               (a) F = A ⊕ B ⊕ C = A  B  C              (b) F = A ⊕ B  C = A  B ⊕ C
Figure 4.23 Map for three-variable functions
Combinational Logic  131 
Exclusive-OR and equivalence functions are very useful in systems requiring error-de-
tection and error-correction codes. As discussed in Section 1-6, a parity bit is a scheme for  
detecting errors during transmission of binary information. A parity bit is an extra bit included 
with a binary message to make the number of 1’ s either odd or even. The message, including the parity bit, is transmitted and then checked at the receiving end for errors. An error is detected 
if the checked parity does not correspond to the one transmitted. The circuit that generates the parity bit in the transmitter is called a parity generator; the circuit that checks the parity in the receiver is called a parity checker.
As an example, consider a three-bit message to be transmitted with an odd-parity bit.  
Table 4-4 shows the truth table for the parity generator. The three bits x, y, and z constitute the 
message and are the inputs to the circuit. The parity bit P is the output. For odd parity, the bit 
P is generated so as to make the total number of 1’ s odd (including P). From the truth table, 
we see that P = 1 when the number of 1’ s in x, y, and z is even. This corresponds to the map of  
Fig. 4-23(b); so the function for P can be expressed as follows:
P = x ⊕ y  z
The logic diagram for the parity generator is shown in Fig. 4-24(a). It consists of one two-input exclusive-OR gate and one two-input equivalence gate. The two gates can be interchanged and Table 4-4 Odd-parity generation
Parity bit
Three-bit message generated
x y z P
0 0 0 1
0 0 1 0
0 1 0 0
0 1 1 1
1 0 0 0
1 0 1 1
1 1 0 1
1 1 1 0
x
y
zP      x
y
z
pC
                    (a) 3-bit odd parity generator                      (b) 4-bit odd parity checker
Figure 4.24 Logic diagrams for parity generation and checking
132 Chapter 4 
still produce the same function, since P is also equal to:
P = x  y ⊕ z
The three-bit message and the parity bit are transmitted to their destination, where they are 
applied to a parity-checker circuit. An error occurs during transmission if the parity of the four 
bits received is even, since the binary information transmitted was originally odd. The output C of the parity checker should be a 1 when an error occurs, i.e., when the number of l’ s in the four inputs is even. Table 4-5 is the truth table for the odd-parity checker circuit. From it we see that the function for C consists of the eight minterms with numerical values having an even number 
of O’ s. This corresponds to the map of Fig. 4-22(b); so the function can be expressed with equi-valence operators as follows:
C = x  y  z  P
The logic diagram for the parity checker is shown in Fig. 4-24(b) and consists of three two-input equivalence gates.
It is worth noting that the parity generator can be implemented with the circuit of  
Fig. 4-24(b) if the input P is permanently held at logic-0 and the output is marked P,  the advan-
tage being that the same circuit can be used for both parity generation and checking.
It is obvious from the foregoing example that panty generation and checking circuits always 
have an output function that includes half of the minterms whose numerical values have either Table 4-5 Odd-parity check
Four-bits received Parity-error check
x y z P C
0 0 0 0 1
0 0 0 1 0
0 0 1 0 0
0 0 1 1 1
0 1 0 0 0
0 1 0 1 1
0 1 1 0 1
0 1 1 1 0
1 0 0 0 0
1 0 0 1 1
1 0 1 0 1
1 0 1 1 0
1 1 0 0 1
1 1 0 1 0
1 1 1 0 0
1 1 1 1 1
Combinational Logic  133 
an even or odd number of 1’ s. As a consequence, they can be implemented with equivalence and/
or exclusive-OR gates.
REFERENCES
1. Rhyne, V . T., Fundamentals of Digital Systems Design. Englewood Cliffs, N.J.: Prentice-Hall. Inc., 
1973.
2. Peatman, J. P ., The Design of Digital Systems. New Y ork: McGraw-Hill Book Co., 1972.
3. Nagle, H. T. Jr., B. D. Carrol, and J. D. Irwin, An Introduction to Computer Logic. Englewood Cliffs, 
N. J.: Prentice-Hall. Inc., 1975.
4. Hill, F . J., and G. R. Peterson, Introduction to Switching Theory and Logical Design, 2nd. ed. New 
Y ork: John Wiley & Sons. Inc. 1974.
5. Maiey, G. A., and J. Earle, The Logic Design of Transistor Digital Computers. Englewood Cliffs, N. J.: Prentice-Hall. Inc., 1963.
6. Friedman, A. D., and P . R. Menon, Theory and Design of Switching Circuits. Woodland Hills, Calif.: Computer Science Press. Inc., 1975.
PROBLEMS
4-1 A combinational circuit has four inputs and one output. The output is equal to 1 when (1) all the inputs are equal to 1 or (2) none of the inputs are equal to 1 or (3) an odd number of inputs are equal to I. 
(a) Obtain the truth table. 
(b) Find the simplified output function in sum of products.
(c) Find the simplified output function in product of sums.
(d) Draw the two logic diagrams.
4-2. Design a combinational circuit that accepts a three-bit number and generates an output binary num-ber equal to the square of the input number.
4-3. It is necessary to multiply two binary numbers, each two bits long, in order to form their product in binary. Let the two numbers be represented by a
1, a0 and b1, b0, where subscript 0 denotes the least 
significant bit.
(a) Determine the number of output lines required.
(b) Find the simplified Boolean expressions for each output.
4-4. Repeat problem 4-3 to form the sum (instead of the product) of the two binary numbers.
4-5. Design a combinational circuit with four input lines that represent a decimal digit in BCD and four 
output lines that generate the 9’ s complement of the input digit.
4-6. Design a combinational circuit whose input is a four-bit number and whose output is the 2’ s comple-
ment of the input number.
4-7. Design a combinational circuit that multiplies by 5 an input decimal digit represented in BCD. The output is also in BCD. Show that the outputs can be obtained from the input lines without using any logic gates.
4-8. Design a combinational circuit that detects an error in the representation of a decimal digit in BCD. 
In other words, obtain a logic diagram whose output is logic-1 when the inputs contain an unused 
combination in the code.
134 Chapter 4 
4-9. Implement a full-subtractor with two half-subtractors and an OR gate.
4-10. A BCD-to-seven-segment decoder is a combinational circuit that accepts a decimal digit in BCD 
and generates the appropriate outputs for selection of segments in a display indicator used for dis-
playing the decimal digit. The seven outputs of the decoder (a, b, c, d, e, f, g) select the corresponding  
segments in the display as shown in Fig. P4-14(a). The numeric designation chosen to repre-
sent the decimal digit is shown in Fig. P4-14(b). Design the BCD-to-seven-segment decoder  
circuit.
 a
bbf
edccg
          (a) Segment designation               (b) Numerical designation for display
Figure P4.14
A
CB
F1F2
Figure P4.15 
4-11. Analyze the two-output combinational circuits shown in Fig. P4-15. Obtain the Boolean functions 
for the two outputs and explain the circuit operation.
4-12. Derive the truth table of the circuit shown in Fig, P4-15.
4-13. Using the block diagram method, convert the logic diagram of Fig. 4-8 to a NAND implementation.
4-14. Repeat problem 4-15 for NOR implementation.
4-15. Obtain the NAND logic diagram of a full-adder from the Boolean functions:
 C = x y + xz + yz
 S = C′(x + y + z) + x yz
4-16. Determine the Boolean function for the output F of the circuit in Fig. P4-20. Obtain an equivalent 
circuit with fewer NOR gates.
Combinational Logic  135 
 A’
B’
B’
B’C
AF
Figure P4-20
4-17. Determine the output Boolean functions of the circuits in Fig, F4-21.
4-18. Obtain the truth table for the circuits in Fig. P4-21.
4-19. Obtain the equivalent AND-OR logic diagram of Fig. P4-21(a).
4-20. Obtain the equivalent AND-OR logic diagram of Fig P4-21(b).
4-21. Obtain the logic diagram of a two-input equivalence function using (a) AND, OR, and NOT gates; 
(b) NOR gates; and (c) NAND gates.
4-22. Show that the circuit in Fig. 4-21(b) is an exclusive-OR.
4-23. Show that A  B  C  D = ∑(0, 3, 5, 6, 9, 10, 12, 15).
4-24. Design a combinational circuit that converts a four-bit reflected-code number (Table 1-4) to a four-bit binary number. Implement the circuit with exclusive-OR gates.
4-25. Design a combinational circuit to check for even parity of four bits. A logic-1 output is required when the four bits do not constitute an even parity.
 
F1z
x
y
F2
(a)
A
B
CF
(b)
Figure P4-21
136 Chapter 4 
4-26. Implement the four Boolean functions listed using three half-adder circuits (Fig. 4-2e). 
 D = A ⊕ B ⊕ C
 E = A′BC + AB′C
 F = ABC′ + (A′ + B′)C
 G = ABC
4.27. Design a combinational circuit which accepts a two-bit number and generates an output binary nu-
mber equal to the cube of the input number.
4.28. Implement a combinational circuit which convert four bit excess 3 code to four bit BCD code.
4.29. Implement full adder with the help of (a) NAND gates (b) NOR gates.
4.30. Design a combinational circuit which convert BCD number to its corresponding 7 bit ASCII bit. Implement your circuit with NAND gates only.
4.31. What are universal gates? Why are they called so? 
4.32. Write short notes on
(a) Parity generator and checker
(b) Realization of full-subtractor with the help of full-adder
(c) Multilevel realization of gates.
(d) Equivalence functions
4.33. Covert Excess 3 code to Biquinary (5043210).
4.34. Implement  following Boolean function using exclusive or and AND gates
 F = ABCD + A′B′C′D′ + ABC′D′ + A′B′CD
5Chapter
Combinational Logic with MSI and LSI5.1 Introduction
The purpose of Boolean function simplification is to obtain an algebraic expression that, when 
implemented, results in a low-cost circuit. However, the criteria that determine a low-cost circuit or system must be defined if we are to evaluate the success of the achieved simplification. The design procedure for combinational circuits presented in Section 4-2 minimizes the number of gates required to implement a given function. This classical procedure assumes that, given two circuits that perform the same function, the one that requires fewer gates is preferable because it will cost less. This is not necessarily true when integrated circuits are used.
Since several logic gates are included in a single IC package, it becomes economical to use 
as many of the gates from an already used package even if, by doing so. we increase the total number of gates. Moreover, some of the interconnections among gates in many ICs are internal to the chip and it is more economical to use as many internal interconnections as possible in order to minimize the number of wires between external pins. With integrated circuits, it is not the count of gates that determines the cost but the number and type of ICs employed and the number of external interconnections needed to implement the given function.
There are numerous occasions where the classical method of Section 4-2 will not produce 
the best combinational circuit for implementing a given function. Moreover, the truth table and the simplification procedure in this method become too cumbersome if the number of input variables is excessively large. The final circuit obtained dictates that it be implemented with a random connection of SSI gates, which may require a relatively large number of ICs and inter -
connecting wires. In many cases the application of an alternate design procedure can produce a combinational circuit for a given function which is far better than the one obtained by following the classical design method. The possibility of an alternate design procedure depends on the particular problem and the ingenuity of the designer. The classical method constitutes a general procedure that, if followed, guarantees to produce a result. However, before applying the classical method, it is always wise to investigate the possibility of an alternate method which may be more efficient for the particular problem at hand.
The first question that must be answered before going through a detailed design of a com-
binational circuit is whether the function is already available in an IC package. Numerous MSI 
138 Chapter 5
devices are available commercially. These devices perform specific digital functions commonly 
employed in the design of digital computer systems. If an MSI device cannot be found to produce exactly the function needed, a resourceful designer may be able to formulate a method so as to incorporate an MSI device in his circuit. The selection of MSI components in preference to SSI gates is extremely important, since it would invariably result in a considerable reduction of IC packages and interconnecting wires.
The first half of this chapter presents examples of combinational circuits designed by meth-
ods other than the classical procedure. All of the examples demonstrate the internal construction of existing MSI functions. Thus we present new design tools and at the same time acquaint the reader with existing MSI functions. Familiarity with available MSI functions is very important not only in the design of combinational circuits, but also in the design of more complicated digital  
computer systems.
Occasionally one finds MSI and LSI circuits that can be applied directly to the design and 
implementation of any combinational circuit. Four techniques of combinational logic design by means of MSI and LSI are introduced in the second half of the chapter. These techniques make use of the general properties of decoders, multiplexers, read-only memories (ROM), and pro-grammable logic arrays (PLA). These four IC components have a large number of applications. Their use in implementing combinational circuits as described here is just one of many other applications.
5.2 Binary Parallel Adder
The full-adder introduced in Section 4-3 forms the sum of two bits and a previous carry. Two bi-nary numbers of n bits each can be added by means of this circuit. To demonstrate with a specific 
example, consider two binary numbers, A = 1011 and B = 0011, whose sum is S = 1110. When 
a pair of bits are added through a full-adder, the circuit produces a carry to be used with the pair of bits one significant position higher. This is shown in the following table:
Subscript i 4 3 2 1Full-adder 
of Fig. 4-5
Input carry 0 1 1 0 Ciz
Augend 1 0 1 1 Aix
Addend 0 0 1 1 Biy
Sum 1 1 1 0 SiS
Output carry 0 0 1 1 Ci+1C
The bits are added with full-adders, starting from the least significant position (subscript i), 
to form the sum bit and carry bit. The inputs and outputs of the full-adder circuit of Fig. 4-5 are also indicated above. The input carry C
1 in the least significant position must be 0. The value of 
Ci+1 in a given significant position is the output carry of the full-adder. This value is transferred 
into the input carry of the full-adder that adds the bits one higher significant position to the left. The sum bits are thus generated starting from the rightmost position and are available as soon as the corresponding previous carry bit is generated.
Combinational Logic with MSI and LSI  139 
The sum of two n-bit binary numbers, A and B, can be generated in two ways: either in a 
serial fashion or in parallel. The serial addition method uses only one full-adder circuit and a 
storage device to hold the generated output carry. The pair of bits in A and B are transferred seri-
ally, one at a time, through the single full-adder to produce a string of output bits for the sum. 
The stored output carry from one pair of bits is used as an input carry for the next pair of bits.  
The parallel method uses n full-adder circuits, and all bits of A and B are applied simultaneously. 
The output carry from one full-adder is connected to the input carry of the full-adder one posi-tion to its left. As soon as the carries are generated, the correct sum bits emerge from the sum outputs of all full-adders.
A. binary parallel adder is a digital function that produces the arithmetic sum of two binary 
numbers in parallel. It consists of full-adders connected in cascade. with the output carry from one full-adder connected to the input carry of the next full-adder.
Figure 5-1 shows the interconnection of four full-adder (FA) circuits to provide a 4-bit 
binary parallel adder. The augend bits of A and the addend bits of B are designated by subscript 
numbers from right to left, with subscript 1 denoting the low-order bit. The carries are connected in a chain through the full-adders. The input carry to the adder is C
1 and the output carry is C5. 
The S outputs generate the required sum bits. When the 4-bit full-adder circuit is enclosed within 
an IC package, it has four terminals for the augend bits, four terminals for the addend bits, four terminals for the sum bits, and two terminals for the input and output carries.
*
An n-bit parallel adder requires n full-adders. It can be constructed from 4-bit, 2-bit, and 
1-bit full-adders ICs by cascading several packages. The output carry from one package must be connected to the input carry of the one with the next higher-order bits.
The 4-bit full-adders is a typical example of an MSI function. It can be used in many ap-
plications involving arithmetic operations. Observe that the design of this circuit by the classical method would require a truth table with 2
9 = 512 entries, since there are nine inputs to the circuit. 
By using an iterative method of cascading an already known function, we were able to obtain a simple and well-organized implementation.
The application of this MSI function to the design of a combinational circuit is demon-
strated in the following example.
*An example of a 4-bit full-adders is the TTL type 74283 IC.C1
S1 S2 S3 S4A1
C2B1 A2B2 A3B3 A4B4
FA FA FA FAC3 C4 C5
Figure 5-1 4-bit full-adders
140 Chapter 5
EXAMPLE 5-1: Design a BCD-to-excess-3 code converter.
This circuit was designed in Section 4-5 by the classical method. The circuit obtained 
from this design is shown in Fig. 4-8 and requires 11 gates. When implemented with SSI 
gates, it requires 3 IC packages and 14 internal wire connections (not including input and 
output connections). Inspection of the truth table immediately reveals that the excess-3 equiv-alent code can be obtained from the BCD code by the addition of binary 0011. This addition can be easily implemented by means of a 4-bit full-adders MSI circuit, as shown in Fig. 5-2. The BCD digit is applied to inputs A. Inputs B are set to a constant 0011. This is done by ap-
plying logic-1 B
1 and B2 and logic-0 to B3, B4, and C1. Logic-1 and logic-0 are physical signals 
whose values depend on the IC logic family used. For TTL circuits, logic-1 is equivalent to 3.5 volts and logic-0 is equivalent to ground. The S outputs from the circuit give the excess-3 
equivalent code of the input BCD digit. This implementation requires one IC package and five wire connections, not including input and output wiring.
5.2.1 Carry Propagation
The addition of two binary numbers in parallel implies that all the bits of the augend and the addend are available for computation at the same time. As in any combinational circuit, the signal must propagate through the gates before the correct output sum is available in the output terminals. The total propagation time is equal to the propagation delay of a typical gate times the number of gate levels in the circuit. The longest propagation delay time in a parallel adder is the time it takes the carry to propagate through the full-adders. Since each bit of the sum output depends on the value of the input carry, the value of S
i in any given stage in the adder will be in 
its steady-state final value only after the input carry to that stage has been propagated. Consider output S
4 in Fig. 5-1. Inputs A4 and B4 reach a steady value as soon as input signals are applied C1C5
Excess-3
outputBCD
inputNot used
A1
B1A2
B2A3
B3A4
B4S1
S2
S3
S4 1
0
Figure 5-2 BCD-to-excess-3 code converter
Combinational Logic with MSI and LSI  141 
to the adder. But input carry C4 does not settle to its final steady-state value until C3 is available 
in its steady-state value. Similarly C3 has to wait for C2, and so on down to C1. Thus only after 
the carry propagates through all stages will the last output S4 and carry C5 settle to their final 
steady-state value.
The number of gate levels for the carry propagation can be found from the circuit of the 
full-adder. This circuit was derived in Fig. 4-5 and is redrawn in Fig. 5-3 for convenience. The 
input and output variables use the subscript i to denote a typical stage in the parallel adder. The 
signals at Pi and Gi settle to their steady-state value after the propagation through their respective 
gates. These two signals are common to all full-adders and depend only on the input augend and addend bits. The signal from the input carry, C
i, to the output carry, Ci+1, propagates through an Ai
Bi
CiPi
GiSi
Ci + 1
Figure 5-3 Full-adder crcuit
C1G1G2
P1P2G3P3
C2C3C4
Figure 5-4 Logic diagram of a look-ahead carry generator
142 Chapter 5
AND gate and an OR gate, which constitute two gate levels. If there are four full-adders in the 
parallel adder, the output carry C5 would have 2 × 4 = 8 gate levels from C1 to C5. The total pro-
pagation time in the adder would be the propagation time in one half-adder plus eight gate levels. For an n-bit parallel adder, there are 2n gate levels for the carry to propagate through.
The carry propagation time is a limiting factor on the speed with which two numbers are 
added in parallel. Although a parallel adder, or any combinational circuit, will always have some value at its output terminals, the outputs will not be correct unless the signals are given enough time to propagate through the gates connected from the inputs to the outputs. Since all other arithmetic operations are implemented by successive additions, the time consumed during the addition process is very critical. An obvious solution for reducing the carry propagation delay time is to employ faster gates with reduced delays. But physical circuits have a limit to their capability. Another solution is to increase the equipment complexity in such a way that the carry delay time is reduced. There are several techniques for reducing the carry propagation time in a parallel adder. The most widely used technique employs the principle of look-ahead carry and 
is described below.
Consider the circuit of the full-adder shown in Fig. 5-3. If we define two new binary vari-
ables:
P
i = Ai ⊕ Bi
Gi = AiBi
the output sum and carry can be expressed as:
Si = Pi ⊕ Ci
Ci + 1 = Gi + PiCi
Gi is called a carry generate and it produces an output carry when both Ai and Bi are one, regard-
less of the input carry. Pi is called a carry propagate because it is the term associated with the 
propagation of the carry from Ci to Ci+1.
We now write the Boolean function for the carry output of each stage and substitute for 
each Ci its value from the previous equations:
C2= G1+ P1C1
C3= G2 + P2C2 = G2 + P2(G1 + P1C1) = G2 + P2G1 + P2 P1C1
C4= G3 + P3C3 = G3 + P3G2 + P3P2G1 + P3P2P1C1
Since the Boolean function for each output carry is expressed in sum of products, each function 
can be implemented with one level of AND gates followed by an OR gate (or by a two-level NAND). The three Boolean functions for C
2, C3, and C4 are implemented in the look-ahead carry 
generator shown in Fig. 5-4. Note that C4 does not have to wait for C3 and C2 to propagate; in fact, 
C4 is propagated at the same time as C2 and C3.†
The construction of a 4-bit parallel adder with a look-ahead carry scheme is shown in  
Fig. 5-5. Each sum output requires two exclusive-OR gates. The output of the first exclusive-OR gate generate the P
i variable, and the AND gale generates the Gi variable. All the P’ s and G’ s are 
† A typical look-ahead carry generator is the IC type 74182. It is implemented with AND-OR-INVERT 
gates. It also has two outputs, G and P,  to generate C5 = G + PC1.
Combinational Logic with MSI and LSI  143 
generated in two gate levels. The carries are propagated through the look-ahead carry generator 
(similar to that in Fig. 5-4) and applied as inputs to the second exclusive-OR gate. After the P and 
G signals settle into their steady-state values, all output carries are generated after a delay of two levels of gates. Thus, outputs S
2 through S4 have equal propagation delay times. The two-level 
circuit for the output carry C5 is not shown in Fig 5-4. This circuit can be easily derived by the 
equation-substitution method as done above (see Problem 5-4).
5.3 Decimal Adder
Computers or calculators that perform arithmetic operations directly in the decimal number sys-tem represent decimal numbers in binary-coded form. An adder for such a computer must em-ploy arithmetic circuits that accept coded decimal numbers and present results in the accepted code. For binary addition, it was sufficient to consider a pair of significant bits at a time, together with a previous carry. A decimal adder requires a minimum of nine inputs and five outputs, since 
four bits are required to code each decimal digit and the circuit must have an input carry and out-put carry. Of course, there is a wide variety of possible decimal adder circuits, dependent upon the code used to represent the decimal digits.
The design of a nine-input, five-output combinational circuit by the classical method 
requires a truth table with 2
9 = 512 entries. Many of the input combinations are don’t-care  S1S2S3S4
C2
C1 C1A4B4
G4
Look-ahead     carr y
  generat orP
4
G3P3
G2P2
G1P1A3B3
A2B2
A1B1C5
C3C4P4
P3
P2
P1C5
Figure 5-5 4-bit full-adders with look-ahead carry
144 Chapter 5
conditions, since each binary code input has six combinations that are invalid. The simplified 
Boolean functions for the circuit may be obtained by a computer-generated tabular method, and the result would probably be a connection of gates forming an irregular pattern. An alternate procedure is to add the numbers with full-adder circuits, taking into consideration the fact that six combinations in each 4-bit input are not used. The output must be modified so that only those binary combinations which are valid combinations of the decimal code are generated.
5.3.1 BCD adder
Consider the arithmetic addition of two decimal digits in BCD, together with a possible carry from a previous stage. Since each input digit does not exceed 9, the output sum cannot be greater 
than 9 + 9 + 1 = 19, the 1 in the sum being an input carry. Suppose we apply two BCD digits to a 4-bit binary adder. The adder will form the sum in binary and produce a result which may range 
from 0 to 19. These binary numbers are listed in Table 5-1 and are labeled by symbols K, Z
8, Z4, 
Z2, and Z1. K is the carry, and the subscripts under the letter Z represent the weights 8, 4, 2, and 1 
that can be assigned to the four bits in the BCD code. The first column in the table lists the binary sums as they appear in the outputs of a 4-bit binary adder. The output sum of two decimal digits 
Table 5-1 Derivation of a BCD adder
Binary sum BCD sum Decimal
K Z8Z4Z2Z1C S8S4S2S1
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 1 1
0 0 0 1 0 0 0 0 1 0 2
0 0 0 1 1 0 0 0 1 1 3
0 0 1 0 0 0 0 1 0 0 4
0 0 1 0 1 0 0 1 0 1 5
0 0 1 1 0 0 0 1 1 0 6
0 0 1 1 1 0 0 1 1 1 7
0 1 0 0 0 0 1 0 0 0 8
0 1 0 0 1 0 1 0 0 1 9
0 1 0 1 0 1 0 0 0 0 10
0 1 0 1 1 1 0 0 0 1 11
0 1 1 0 0 1 0 0 1 0 12
0 1 1 0 1 1 0 0 1 1 13
0 1 1 1 0 1 0 1 0 0 14
0 1 1 1 1 1 0 1 0 1 15
1 0 0 0 0 1 0 1 1 0 16
1 0 0 0 1 1 0 1 1 1 17
1 0 0 1 0 1 1 0 0 0 18
1 0 0 1 1 1 1 0 0 1 19
Combinational Logic with MSI and LSI  145 
must be represented in BCD and should appear in the form listed in the second column of the 
table. The problem is to find a simple rule by which the binary number in the first column can be converted to the correct BCD-digit representation of the number in the second column.
In examining the contents of the table, it is apparent that when the binary sum is equal to 
or less than 1001, the corresponding BCD number is identical, and therefore no conversion is 
needed. When the binary sum is greater than 1001, we obtain a nonvalid BCD representation. The addition of binary 6 (0110) to the binary sum converts it to the correct BCD representation and also produces an output carry as required.
The logic circuit that detects the necessary correction can be derived from the table entries. 
It is obvious that a correction is needed when the binary sum has an output carry K = 1. The other 
six combinations from 1010 to 1111 that need a correction have a 1 in position Z
8. To distinguish 
them from binary 1000 and 1001 which also have a 1 in position Z8, we specify further that either 
Z4 or Z2 must have a 1. The condition for a correction and an output carry can be expressed by 
the Boolean function:
C = K + Z8Z4 + Z8Z2
when C = 1, it is necessary to add 0110 to the binary sum and provide an output carry for the 
next stage.
A BCD adder is a circuit that adds two BCD digits in parallel and produces a sum digit also 
in BCD. A BCD adder must include the correction logic in its internal construction. To add 0110 to the binary sum, we use a second 4-bit binary adder as shown in Fig. 5-6. The two decimal digits, together with the input carry, are first added in the top 4-bit binary adder to produce the binary sum. When the output carry is equal to zero, nothing is added to the binary sum. When it is equal to one, binary 0110 is added to the binary sum through the bottom 4-bit binary adder. The output carry generated from the bottom binary adder can be ignored, since it supplies infor -
mation already available at the output-carry terminal.
The BCD adder can be constructed with three IC packages. Each of the 4-bit adders is an 
MSI function and the three gates for the correction logic need one SSI package. However, the BCD adder is available in one MSI circuit.
‡ To achieve shorter propagation delays, an MSI BCD 
adder includes the necessary circuits for look-ahead carries. The adder circuit for the correction does not need all four full-adders, and this circuit can be optimized within the IC package.
A decimal parallel adder that adds n decimal digits needs n BCD adder stages. The output 
carry from one stage must be connected to the input carry of the next higher-order stage.
5.4 Magnitude Comparator
The comparison of two numbers is an operation that determines if one number is greater than, less than, or equal to the other number. A magnitude comparator is a combinational circuit that 
compares two numbers. A and B, and determines their relative magnitudes. The outcome of the 
comparison is specified by three binary variables that indicate whether A > B, A = B. or A < B.
The circuit for comparing two n-bit numbers has 2
2n entries in the truth table and be-
comes too cumbersome even with n = 3. On the other hand, as one may suspect, a comparator circuit possesses a certain amount of regularity. Digital functions which possess an inherent  
‡TTL IC type 82S83 is a BCD adder.
146 Chapter 5
well-defined regularity can usually be designed by means of an algorithmic procedure if one is 
found to exist. An algorithm is a procedure that specifics a finite set of steps which, if followed, 
give the solution to a problem. We illustrate this method here by deriving an algorithm for the design of a 4-bit magnitude comparator.
The algorithm is a direct application of the procedure a person uses to compare the relative 
magnitudes of two numbers. Consider two numbers, A and B, with four digits each. Write the 
coefficients of the numbers with descending significance as follows:
A = A
3A2A1A0
B = B3B2B1B0
where each subscripted letter represents one of the digits in the number. The two numbers are equal if all pairs of significant digits are equal i.e., if A
3 = B3 and A2 = B2 and A1 = B1 and A0 = B0. 
When the numbers are binary, the digits are either 1 or 0 and the equality relation of each pair of bits can be expressed logically with an equivalence function:
x
i = AiBi + A′i B′i        i = 0, 1, 2, 3
where xi = 1 only if the pair of bits in position i are equal, i.e., if both are 1’ s or both are 0’ s.S1 S2 S4 S8Z1 Z2 Z4 Z8
0
4-bit binar y adder4-bit binar y adder Carry
   inCarry
  out
Output  carr
yAddend Augend
Figure 5-6 Block diagram of a BCD adder
Combinational Logic with MSI and LSI  147 
The equality of the two numbers, A and B, is displayed in a combinational circuit by an 
output binary variable which we designate by the symbol (A = B). This binary variable is equal to 
1 if the input numbers, A and B, are equal, and it is equal to 0 otherwise. For the equality condi-
tion to exist, all xi variables must be equal to 1. This dictates an AND operation of all variables:
(A = B) = x3 x2 x1 x0
the binary variable (A = B) is equal to 1 only if all pairs of digits of the two numbers are equal.
To determine if A is greater than or less than B, we inspect the relative magnitudes of pairs 
of significant digits starting from the most significant position. If the two digits are equal, we 
compare the next lower significant pair of digits. This comparison continues until a pair of un-equal digits is reached. If the corresponding digit of A is 1 and that of B is 0, we conclude that 
A > B. If the corresponding digit of A is 0 and that of B is 1, we have that A < B. The sequential 
comparison can be expressed logically by the following two Boolean functions:
(A > B) = A
3B′3 + x3A2B′2 + x3x2A1B′1 + x3x2x1A0B′0
(A < B) = A′3B3 + x3A′2B2 + x3x2A′1B1 + x3x2x1A′0B0
the symbols (A > B) and (A < B) are binary output variables which are equal to 1 when A > B or 
A < B, respectively.
The gate implementation of the three output variables just derived is simpler than it seems 
because it involves a certain amount of repetition. The “unequal” outputs can use the same gates that are needed to generate the “equal” output. The logic diagram of the 4-bit magnitude com-parator is shown in Fig. 5-7.
§ The four x outputs are generated with equivalence (exclusive-NOR) 
circuits and applied to an AND gate to give the output binary variable (A = B). The other two 
outputs use the x variables to generate the Boolean functions listed above. This is a multilevel 
implementation and, as clearly seen, it has a regular pattern. The procedure for obtaining magni-
tude comparator circuits for binary numbers with more than four bits should be obvious from this example. The same circuit can be used to compare the relative magnitudes of two BCD digits.
5.5 Decoders
Discrete quantities of information are represented in digital systems with binary codes. A binary 
code of n bits is capable of representing up to 2n distinct elements of the coded information. 
A decoder is a combinational circuit that converts binary information from n input lines to a 
maximum of 2n unique output lines. If the n-bit decoded information has unused or don’t-care 
combinations, the decoder output will have less than 2n outputs.
The decoders presented here are called n-to-m line decoders where m ≤ 2n Their purpose 
is to generate the 2n (or less) minterms of n input variables. The name decoder is also used in 
conjunction with some code converters such as a BCD-to-seven-segment decoder (see Problem 
4-14).
As an example, consider the 3-to-8 line decoder circuit of Fig. 5-8. The three inputs are de-
coded into eight outputs, each output representing one of the minterms of the 3-input variables. 
§ TTL type 7485 is a 4-bit magnitude comparator. It has three more inputs for connecting comparators in 
cascade (see Problem 5-14).
148 Chapter 5
The three inverters provide the complement of the inputs, and each one of the eight AND gates 
generates one of the minterms. A particular application of this decoder would be a binary-to-octal conversion. The input variables may represent a binary number, and the outputs will then represent the eight digits in the octal number system. However, a 3-to-8 line decoder can be used for decoding any 3-bit code to provide eight outputs, one for each element of the code.
The operation of the decoder may be further clarified from its input-output relationships, 
listed in Table 5-2. Observe that the output variables are mutually exclusive because only one output can be equal to 1 at any one time. The output line whose value is equal to 1 represents the minterm equivalent of the binary number presently available in the input lines.
¶
¶ IC type 74138 is a 3-to-8 line decoder. It is constructed with NAND gates. The outputs are the 
complements of the values shown in Table 5-2.(A = B)(A > B)A1
x1
x0B1
A1
B0A2
x2
B2A3
x3
B3
(A < B)
Figure 5-7 4-bit magnitude comparator 
Combinational Logic with MSI and LSI  149 
EXAMPLE 5-2: Design a BCD-to-decimal decoder.
The elements of information in this case are the ten decimal digits represented by the 
BCD code. The code itself has four bits. Therefore, the decoder should have four inputs to 
accept the coded digit and ten outputs, one for each decimal digit. This will give a 4-line to 10-line BCD-to-decimal decoder.
There is really no need to design such a decoder because it can be found in IC form as 
an MSI function. We will design it anyway for two reasons. First, it gives insight on what to expect in such an MSI function. Second, this is a good example for demonstrating the practi-cal consequences of don’t-care conditions.
Since the circuit has ten outputs, it would be necessary to draw ten maps to simplify each 
one of the output functions. There are six don’t-care conditions here, and they must be taken into consideration when we simplify each of the output functions. Instead of drawing ten maps, we will draw only one map and write each of the output variables, D
0 to D9, inside its 
corresponding minterm square as shown in Fig. 5-9. Six input combinations will never occur, so we mark their corresponding minterm squares with X’ s.
It is the designer’ s responsibility to decide on how to treat the don’t-care conditions. As-
sume that it is decided to use them in such a way as to simplify the functions to the minimum xyzD0 = x´y´z´
D1 = x´y´z
D2 = x´yz´
D3 = x´yz
D4 = xy´z´
D5 = xy´z
D6 = xyz´
D7 = xyz
Figure 5-8 A 3-to-8-line decoder 
150 Chapter 5
number of literals. D0 and D1 cannot be combined with any don’t-care minterms. D2 can be 
combined with the don’t care minterm m10 to give:
D2 = x’yz’
The square with D9 can be combined with three other don’t-care squares to give:
D9 = wz
Using the don’t-care terms for the other outputs, we obtain the circuit shown in Fig. 5-10. 
Thus the don’t-care terms cause a reduction in the number of inputs in most of the AND gates.
A careful designer should investigate the effect of the above minimization. Although it is 
true that under normal operating conditions the invalid six combina tions will never occur, what 
if there is a malfunction and they do occur? An analysis of the circuit of Fig. 5-10 shows that the Table 5-2 Truth table of a 3-to-8 line decoder
Inputs Outputs
x y z D0D1D2D3D4D5D6D7
0 0 0 1 0 0 0 0 0 0 0
0 0 1 0 1 0 0 0 0 0 0
0 1 0 0 0 1 0 0 0 0 0
0 1 1 0 0 0 1 0 0 0 0
1 0 0 0 0 0 0 1 0 0 0
1 0 1 0 0 0 0 0 1 0 0
1 1 0 0 0 0 0 0 0 1 0
1 1 1 0 0 0 0 0 0 0 1
yz
wx 00
0001
0111
1110
10y
zx
wD0 D1 D3 D2
D4 D5 D7 D6
XX XX
D8 D9 XX
Figure 5-9 Map for simplifying a BCD-to-decimal decoder
Combinational Logic with MSI and LSI  151 
six invalid input combinations will produce outputs as listed in Table 5-3. The reader can look at 
the table and decide whether this is a good or bad design.
Another reasonable design decision would be to make all outputs equal to 0 when an invalid 
input combination occurs.** This would require ten 4-input AND gates. Other possibilities may 
be considered. In any case, one should not treat don’t-care conditions indiscriminately but should try to investigate their effect once the circuit is in operation.
5.5.1 Combinational Logic Implementation
A decoder provides the 2n minterm of n input variables. Since any Boolean function can be ex-
pressed in sum of minterms canonical form, one can use a decoder to generate the minterms and an external OR gate to form the sum. In this way, any combinational circuit with n inputs and m outputs can be implemented with an n-to-2
 n line decoder and m OR gates.
The procedure for implementing a combinational circuit by means of a decoder and OR 
gates requires that the Boolean functions for the circuit be expressed in sum of minterms. This form can be easily obtained from the truth table or by expanding the functions to their sum of minterms (see Section 2-5). A decoder is then chosen which generates all the minterms of the n input variables. The inputs to each OR gate are selected from the decoder outputs according to the minterm list in each function.
** IC type 7442 is a BCD-to-decimal decoder. The selected outputs are in the 0 state, and all the invalid 
combinations give an output of all 1’ s.D0 = w´x´y´z´
D1 = w´x´y´z
D2 = x´yz´
D3 = x´yz
D4 = xy´z´
D5 = xy´z
D6 = xyz´
D7 = xyz
D8 = wz´
D9 = wzw
x
y
z
Figure 5-10 BCD-to-decimal decoder
152 Chapter 5
EXAMPLE 5-3: Implement a full-adder circuit with a decoder and two OR gates.
From the truth table of the full-adder (Section 4-3), we obtain the functions for this 
combinational circuit in sum of minterms:
 S(x, y, z) = ∑(1, 2, 4, 7)
C(x, y, z,) = ∑(3, 5, 6, 7)
Since there are three inputs and a total of eight minterms, we need a 3-to-8 line decoder. The 
implementation is shown in Fig. 5-11. The decoder generates the eight minterms for x, y, z. The OR gate for output S forms the sum of minterms 1, 2, 4, and 7. The OR gate for output C forms the sum of minterms 3, 5, 6, and 7.
A function with a long list of minterms requires an OR gate with a large number of inputs. 
A function F having a list of k minterms can be expressed in its complemented form F′ with 2n - 
k minterms. If the number of minterms in a function is greater than 2n /2, then F′ can be expressed 
with fewer minterms than required for F.  In such a case, it is advantageous to use a NOR gate to 
sum the minterms of F′. The output of the NOR gate will generate the normal output F.  Table 5-3 Partial truth table for the circuit of Fig, 5-10
Inputs Outputs
w x y       z D0D1D2D3D4D5D6D7D8D9
1 0 1      0 0 0 1 0 0 0 0 0 1 0
1 0 1      1 0 0 0 1 0 0 0 0 0 1
1 1 0      0 0 0 0 0 1 0 0 0 1 0
1 1 0      1 0 0 0 0 0 1 0 0 0 1
1 1 1      0 0 0 0 0 0 0 1 0 1 0
1 1 1      1 0 0 0 0 0 0 0 1 0 1
x
222
3×8
decoder21
201
S
C0
y
43
5z
76
Figure 5-11 Implementation of a full-adder with a decoder
Combinational Logic with MSI and LSI  153 
The decoder method can be used to implement any-combinational circuit. However, its 
implementation must be compared with all other possible implementations to determine the best 
solution. In some cases this method may provide the best implementation, especially if the com-binational circuit has many outputs and if each output function (or its complement) is expressed with a small number of minterms.
5.5.2 Demultiplexers
Some IC decoders are constructed with NAND gates. Since a NAND gate produces the AND operation with an inverted output, it becomes more economical to generate the decoder minterms in their complemented form. Most, if not all, IC decoders include one or more enable inputs 
to control the circuit operation. A 2-to-4 line decoder with an enable input constructed with NAND gates is shown in Fig, 5-12. All outputs are equal to 1 if enable input E is 1, regardless of the values of inputs A and B. When the enable input is 0, the circuit operates as a decoder with 
complemented outputs. The truth table lists these conditions. The X’ s under A and B are don’t-
care conditions. Normal decoder operation occurs only with E = 0, and the outputs are selected when they are in the 0 state.
The block diagram of the decoder is shown in Fig. 5-13(a). The small circle at input E in-
dicates that the decoder is enabled when E = 0. The small circles at the outputs indicate that all 
outputs are complemented.
A decoder with an enable input can function as a demultiplexer. A demultiplexer is a circuit 
that receives information on a single line and transmits this information on one of 2
 n possible 
output lines. The selection of a specific output line is controlled by the bit values of n selection 
lines. The decoder of Fig. 5-12 can function as a demultiplexer if the E line is taken as a data 
input line and lines A and B are taken as the selection lines. This is shown in Fig. 5-13(b). The 
single input variable E has a path to all four outputs, but the input information is directed to only 
one of the output lines, as specified by the binary value of the two selection lines A and B. This 
can be verified from the truth table of this circuit, shown in Fig. 5-12(b). For example, if the 
selection lines AB = 10, output D2 will be the same as the input value E, while all other outputs 
are maintained at 1. Because decoder and demultiplexer operations are obtained from the same 
AD0
D1
D2
D3B
E     D0 E
1    X    X
0    0    0
0    1    10    1    00    0    11      1       1      1
0      1       1      1
1      0       1      1
1      1       0      1
1      1       1      0AB D1D2D3
                                      (a) Logic diagram                             (b) Truth table
Figure 5-12 A 2-to-4 line decoder with enable (E) input
154 Chapter 5
circuit, a decoder with an enable input is referred to as a decoder/demultiplexer. It is the enable 
input that makes the circuit a demultiplexer; the decoder itself can use AND, NAND, or NOR 
gates.
Decoder/demultiplexer circuits can be connected together to form a larger decoder circuit. 
Figure 5-14 shows two 3×8 decoders with enable inputs connected to form a 4 × 16 decoder. 
When w = 0, the top decoder is enabled and the other is disabled. The bottom decoder outputs 
are all 0’ s, and the top eight outputs generate minterms 0000 to 0111. When w = 1, the enable 
conditions are reversed; the bottom decoder outputs generate minterms 1000 to 1111, while the outputs of the top decoder are all 0’ s. This example demonstrates the usefulness of enable inputs in ICs. In general, enable lines are a convenient feature for connecting two or more IC packages for the purpose of expanding the digital function into a similar function with more inputs and outputs.
5.5.3 Encoders
An encoder is a digital function that produces a reverse operation from that of a decoder. An en-
coder has 2n (or less) input lines and n output lines. The output lines generate the binary code for 
the 2n input variables. An example of an encoder is shown in Fig. 5-15. The octal-to-binary en-A
  2⋅4
decoder
B
E
Enab leInputsD0
D1
D2
D3
       D0
D1
D2E
Input
SelectD3
A       1×4
demultipl exer
B
                         (a) Decoder with enable                                 (b) Demultiplexer
Figure 5-13 Block diagrams for the circuit of Fig. 5-12
D0 to D7x
y
z
wE3×8
decoder
E3×8
decoder D8 to D15
Figure 5-14 A 4 × 16 decoder constructed with two 3 × 8 decoders
Combinational Logic with MSI and LSI  155 
coder consists of eight inputs, one for each of the eight digits, and three outputs that generate the 
corresponding binary number. It is constructed with OR gates whose inputs can be determined from the truth table given in Table 5-4. The low-order output bit z is 1 if the input octal digit is 
odd. Output y is 1 for octal digits 2, 3, 6, or 7. Output x is a 1 for octal digits 4, 5, 6, or 7. Note 
that D
0 is not connected to any OR gate; the binary output must be all 0’ s in this case. An all 0’ s 
output is also obtained when all inputs are all 0’ s. This discrepancy can be resolved by providing one more output to indicate the fact that all inputs are not 0’ s.
The encoder in Fig. 5-15 assumes that only one input line can be equal to 1 at any time; 
otherwise the circuit has no meaning. Note that the circuit has eight inputs and could have 2
8 = 
256 possible input combinations. Only eight of these combinations have any meaning. The other input combinations are don’t-care conditions.
Encoders of this type (Fig. 5-15) are not available in IC packages, since they can be easily 
constructed with OR gates. The type of encoder available in IC form is called a priority encoder
†† 
††For example, IC type 74148.D0
D1
D2
D3
D4
D5
D6
D7x = D4 + D5 + D6 + D7
y = D2 + D3 + D6 + D7
z = D1 + D3 + D5 + D7
Figure 5-15 Octal-to-binary encoder
Table 5-4 Truth table ol octai-to-binary encoder
Inputs Outputs
D0D1D2D3D4D5D6D7x y z
1 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 1
0 0 1 0 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 1 1
0 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 1 0 0 1 0 1
0 0 0 0 0 0 1 0 1 1 0
0 0 0 0 0 0 0 1 1 1 1
156 Chapter 5
These encoders establish an input priority to ensure that only the highest-priority input line is 
encoded. Thus, in Table 5-4, if priority is given to an input with a higher subscript number over one with a lower subscript number, then if both D
2 and D5 are logic-1 simultaneously, the output 
will be 101 because D5 has a higher priority over D2. Of course, the truth table of a priority enco-
der is different from the one in Table 5-4 (see Problem 5-21).
5.6 Multiplexers
Multiplexing means transmitting a large number of information units over a smaller number of 
channels or lines. A digital multiplexer is a combinational circuit that selects binary information from one of many input lines and directs it to a single output line. The selection of a particular input line is controlled by a set of selection lines. Normally, there are 2
n input lines and n selec-
tion lines whose bit combinations determine which input is selected.
A 4-line to 1-line multiplexer is shown in Fig. 5-16. Each of the four input lines, I0 to I3, is 
applied to one input of an AND gate. Selection lines s1 and s0 are decoded to select a particular 
AND gate. The function table in the figure lists the input-to-output path for each possible bit combination of the selection lines. When this MSI function is used in the design of a digital sys-tem, it is represented in block diagram form as shown in Fig. 5-16(c). To demonstrate the circuit operation, consider the case when s
1s0 = 10. The AND gate associated with input I2 has two of 
its inputs equal to 1 and the third input connected to I2. The other three AND gates have at least 
one input equal to 0, which makes their output equal to 0. The OR-gale output is now equal to the value of I
2, thus providing a path from the selected input to the output. A multiplexer is also 
called a data selector, since it selects one of many inputs and steers the binary information to the output line.
l0
s1
s0l1
l2
l3YInputs Output
Select0
1
2
3       4×1
      MUX
s1 s0
l0s1 s0 Y
l1
l2 0        0
 0        1 1        0 1        1 l
3
                                (b) Block diagram                                                    (c) Function table
Figure 5-16 A 4-to-1 line multiplexer(a) Logic diagram
Combinational Logic with MSI and LSI  157 
The AND gates and inverters in the multiplexer resemble a decoder circuit and, indeed, they 
decode the input selection lines. In general, a 2n-to-1 line multiplexer is constructed from an n-to-
2n decoder by adding to it 2n input lines, one to each AND gate. The outputs of the AND gates are 
applied to a single OR gate to provide the 1-line output. The size of a multiplexer is specified by 
the number 2n of its input lines and the single output line. It is then implied that it also contains 
n selection lines. A multiplexer is often abbreviated as MUX.
As in decoders, multiplexer ICs may have an enable input to control the operation of the 
unit. When the enable input is in a given binary state, the outputs are disabled, and when it is in the other state (the enable state), the circuit functions as a normal multiplexer. The enable input (sometimes called strobe) can be used to expand two or more multiplexer ICs to a digital multi-
plexer with a larger number of inputs.
In some cases two or more multiplexers are enclosed within one IC package. The selection 
and enable inputs in multiple-unit ICs may be common to all multiplexers. As an illustration, a quadruple 2-line to 1-line multiplexer IC is shown in Fig. 5-17.
‡‡ It has four multiplexers, each 
capable of selecting one of two input lines. Output Y1 can be selected to be equal to either A1 
or B1. Similarly, output Y2 may have the value of A2 or B2, and so on. One input selection line, 
S, suffices to select one of two lines in all four multiplexers. The control input E enables the 
multiplexers in the 0 state and disables them in the 1 state. Although the circuit contains four 
multiplexers, we may think of it as a circuit that selects one in a pair of 4-tnput lines. As shown in the function table, the unit is selected when E = 0. Then, if S = 0, the four A inputs have a path 
to the outputs. On the other hand, if S = 1, the four B inputs are selected. The outputs have all 0’ s 
when E = 1, regardless of the value of S.
The multiplexer is a very useful MSI function and has a multitude of applications. It is 
used for connecting two or more sources to a single destination among computer units, and it is 
useful for constructing a common bus system. These and other uses of the multiplexer are dis-cussed in later chapters in conjunction with their particular applications. Here we demonstrate 
the general properties of this device and show that it can be used to implement any Boolean  
function.
5.6.1 Boolean Function Implementation
It was shown in the previous section that a decoder can be used to implement a Boolean function by employing an external OR gale. A quick reference to the multiplexer of Fig. 5-16 reveals that 
it is essentially a decoder with the OR gate already available. The minterms out of the decoder to be chosen can be controlled with the input lines. The minterms to be included with the func-tion being implemented are chosen by making their corresponding input lines equal to 1, those minterms not included in the function are disabled by making their input lines equal to 0. This gives a method for implementing any Boolean function of n variables with a 2
n-to-l multiplexer. 
However, it is possible to do better than that.
If we have a Boolean function of n + 1 variables, we lake n of these variables and connect 
them to the selection lines of a multiplexer. The remaining single variable of the function is used for the inputs of the multiplexer. If A is this single variable, the inputs of the multiplexer are 
chosen to be either A or A′ or 1 or 0. By judicious use of these four values for the inputs and by 
connecting the other variables to the selection lines, one can implement any Boolean function 
‡‡This is similar to IC type 74157.
158 Chapter 5
with a multiplexer. In this way it is possible to generate any function of n + I variables with a 2n 
-to-l multiplexer.
To demonstrate this procedure with a concrete example, consider the function of three 
variables:
F(A, B, C) = ∑(1,3,5,6)
The function can be implemented with a 4-to-l multiplexer as shown in Fig. 5-18. Two of the 
variables, B and C are applied to the selection lines in that order, i.e.. B is connected to s1 and C 
to s0. The inputs of the multiplexer are 0, 1, A, and A′. When BC = 00, output F = 0 since I0 = 0. 
Therefore, both minterms m0 = A′B′C′ and m4 = AB′C′ produce a 0 output, since the output is 0 
when BC = 00 regardless of the value of A. When BC = 01, output F = 1, since I1 = 1, Therefore, 
both minterms m1 = A′B′C and m5 = AB′C produce a 1 output, since the output is 1 when BC = A1
A2
A3
A4Y1
Y2
Y3
Y4
B1
B2
B3
B4
S
(Select)
E
(Enab le)••
••
•
•
••
•
•
••••
Function table
E S Output Y
1 x .all 0’ s
0 0 select A
0 1 select B
Figure 5-17 Quadruple 2-to-1 line multiplexers
Combinational Logic with MSI and LSI  159 
01 regardless of the value of A, When BC = 10, input I2 is selected. Since A is connected to this 
input, the output will be equal to 1 only for minterm m6 = ABC. but not for minterm m2 = A′BC′, 
because when A′ = 1, then A = 0, and since I2 = 0, we have F = 0. Finally, when BC = 11, input 
I3 is selected. Since A′ is connected to this input, the output will be equal to 1 only for minterm 
m3 = A′BC. but not for m7 = ABC. This information is summarized in Fig. 5-18(b), which is the 
truth table of the function we want to implement.
The above discussion shows by analysis that the multiplexer implements the required func-
tion. We now present a general procedure for implementing any Boolean function of n variables 
with a 2n-1-to-l multiplexer.
First, express the function in its sum of minterms form. Assume that the ordered sequence 
of variables chosen for the minterms is ABCD …, where A is the leftmost variable in the ordered 
sequence of n variables and BCD … are the remaining n - 1 variables. Connect the n - 1 variables 
to the selection lines of the multiplexer with B connected to the high-order selection line, C to the 
next lower selection line, and so on down to the last variable, which is connected to the lowest-
order selection line s0. Consider now the single variable A. Since this variable is in the highest-
order position in the sequence of variables, it will be complemented in minterms 0 to (2n/2) - 1 
which comprise the first half in the list of minterms. The second half of the minterms will have their A variable uncomplemented. For a three-variable function, A, B, C, we have eight minterms. 
Variable A is complemented in minterms 0 to 3 and uncomplemented in minterms 4 to 7.
List the inputs of the multiplexer and under them list all the minterms in two rows. The first 
row lists all those minterms where A is complemented, and the second row all the minterms with 
A uncomplemented, as shown in Fig. 5-l8(c). Circle all the minterms of the function and inspect 
each column separately.
If the two minterms in a column are not circled, apply 0 to the corresponding multiplexer 
input.
If the two minterms are circled, apply 1 to the corresponding multiplexer input.If the bottom minterm is circled and the top is not circled, apply A to the corresponding 
multiplexer input.
If the top minterm is circled and the bottom is not circled, apply A′ to the corresponding 
multiplexer input.
This procedure follows from the conditions established during the previous analysis.       4×1
      MUXl0
s0F Y0
1
A
A´
B
Cl1
s1l2
l3
     F A
0
1
2
3
4
5
6
700
0
0
1
1
1
10
0
1
1
0
0
1
10
1
0
10
1
0
10
1
0
1
0
1
1
0Minterm BC
     0
01 AA
A´A´ 23 1
46 7 5l0 l1 l2 l3
            (a) Multiplexer implementation                    (b) Truth table          (c) Implementation table
Figure 5-18 Implementing F(A,B,C) = ∑ (1,3,5,6,) with a miltiplexer 
160 Chapter 5
Figure 5-l8(c) shows the implementation table for the Boolean function;
F(A, B,C) = ∑(1,3,5,6)
from which we obtain the multiplexer connections of Fig, 5-18(a), Note that B must be connected 
to s1 and C to s0.
It is not necessary to choose the leftmost variable in the ordered sequence of a variable list 
for the inputs to the multiplexer. In fact, we can choose any one of the variables for the inputs 
of the multiplexer, provided we modify the multiplexer implementation table. Suppose we want to implement the same function with a multiplexer, but using variables A and B for selection 
lines s
1 and s0 and variable C for the inputs of the multiplexer. Variable C is complemented in 
the even-numbered minterms and uncomplemented in the odd-numbered minterms, since it is the last variable in the sequence of listed variables. The arrangement of the two minterm rows in this case must be as shown in Fig. 5-19(a). By circling the minterms of the function and using the rules stated above, we obtain the multi plexer connection for implementing the function as in 
Fig. 5-19(b).
In a similar fashion, it is possible to use any single variable of the function for use in the 
multiplexer inputs. One can formulate various combinations for imple menting a Boolean func-
tion with multiplexers. In any case, all the input variables, except one, are applied to the selection 
lines. The remaining single variable, or its complement, or 0 or 1, are then applied to the inputs of the multiplexer.
EXAMPLE 5-4: Implement the following function with a multiplexer:
F(A, B, C, D) = ∑(0, 1, 3, 4, 8, 9, 15)
This is a four-variable function and therefore we need a multiplexer with three selection lines 
and eight inputs. We choose to apply variables B, C, and D to the selection lines. The imple-
mentation table is then as shown in Fig. 5-20, The first half of the minterms are associated with A’ and the second half with A. By circling the minterms of the function and applying 
the rules for finding values for the multiplexer inputs, we obtain the implementation shown.0
CC CC
C´C´ 46 2
1 57 3l0l1l2l3
             4×1
      MUXl0
s0F Y
A
BC
l1
s1l2
l3
                    (a) Implementation table                (b) Multiplexer connection
Figure 5-19 Alternate Implementation for F(A,B,C) = ∑ (1,3,5,6,)
Combinational Logic with MSI and LSI  161 
Let us now compare the multiplexer method with the decoder method for implementing 
combinational circuits. The decoder method requires an OR gate for each output function, but 
only one decoder is needed to generate all minterms. The multiplexer method uses smaller-size units but requires one multiplexer for each output function. It would seem reasonable to assume that combinational circuits with a small number of outputs should be implemented with multi-plexers. Combinational circuits with many output functions would probably use fewer ICs with the decoder method.
Although multiplexers and decoders may be used in the implementation of combinational 
circuits, it must be realized that decoders are mostly used for decoding binary information and multiplexers are mostly used to form a selected path between multiple sources and a single des-tination. They should be considered when designing small, special combinational circuits which are not otherwise available as MSI functions. For large combinational circuits with multiple inputs and outputs, there is a more suitable IC component, and it is presented in the following section.
5.7 Read-Only Memory (ROM)
We saw in Section 5-5 that a decoder generates the 2n minterms of the n input variables. By in-
serting OR gates to sum the minterms of Boolean functions, we were able to generate any desired combinational circuit. A read-only memory (ROM) is a device that includes both the decoder and the OR gates within a single IC package. The connections between the outputs of the decoder and the inputs of the OR gates can be specified for each particular configuration by “programming” the ROM. The ROM is very often used to implement a complex combinational circuit in one IC package and thus eliminate all interconnecting wires.
A ROM is essentially a memory (or storage) device in which a fixed set of binary informa-
tion is stored. The binary information must first be specified by the user and is then embedded in the unit to form the required interconnection pattern. ROMs come with special internal links 0
110A
A´ A´00 AA´ 21 34 6 5 7
8 109 1112 14 13 15l0 l1 l2 l3 l4 l5l6 l7
               8×1
      MUX F Yl0
s0l1
s1 s2A1
0
B
C
Dl2
l3
l4
l5
l6
l7
Figure 5-20 Implementing F(A, B, C, D) = ∑(0, 1, 3, 4, 8, 9, 15)
162 Chapter 5
that can be fused or broken. The desired interconnection for a particular application requires that 
certain links be fused to form the required circuit paths. Once a pattern is established for a ROM, it remains fixed even when power is turned off and then on again.
A block diagram of a ROM is shown in Fig. 5-21. It consists of n input lines and m output 
lines. Each bit combination of the input variables is called an address. Each bit combination that 
comes out of the output lines is called a word. The number of bits per word is equal to the number 
of output lines m. An address is essentially a binary number that denotes one of the minterms of n 
variables. The number of distinct addresses possible with n input variables is 2
n. An output word 
can be selected by a unique address, and since there are 2n distinct addresses in a ROM, there are 
2n distinct words which are said to be stored in the unit. The word available on the output lines at 
any given time depends on the address value applied to the input lines. A ROM is characterized by the number of words 2
n and the number of bits per word m. This terminology is used because 
of the similarity between the read-only memory and the read-write memory which is presented 
in Section 7-7.
Consider a 32 × 8 ROM. The unit consists of 32 words of 8 bits each. This means that there 
are eight output lines and that there are 32 distinct words stored in the unit, each of which may be 
applied to the output lines. The particular word selected that is presently available on the output lines is determined from the five input lines. There are only five inputs in a 32 × 8 ROM because 2
5 = 32, and with five variables we can specify 32 addresses or minterms. For each address input, 
there is a unique selected word. Thus, if the input address is 00000, word number 0 is selected and it appears on the output lines. If the input address is 11111, word number 31 is selected and applied to the output lines. In between, there are 30 other addresses that can select the other 30 words.
The number of addressed words in a ROM is determined from the fact that n input lines are 
needed to specify 2
n words. A ROM is sometimes specified by the total number of bits it contains, 
which is 2n × m. For example, a 2048-bit ROM may be organized as 512 words of 4 bits each. 
This means that the unit has 4 output lines and 9 input lines to specify 29 = 512 words. The total 
number of bits stored in the unit is 512 × 4 = 2048.
Internally, the ROM is a combinational circuit with AND gates connected as a decoder and 
a number of OR gates equal to the number of outputs in the unit. Figure 5-22 shows the internal logic construction of a 32 × 4 ROM. The five input variables are decoded into 32 lines by means 
of 32 AND gates and 5 inverters. Each output of the decoder represents one of the minterms of a 2n×m
ROMn inputs
m outputs
Figure 5-21 ROM block diagram
Combinational Logic with MSI and LSI  163 
function of five variables. Each one of the 32 addresses selects one and only one output from the 
decoder. The address is a 5-bit number applied to the inputs, and the selected minterm out of the decoder is the one marked with the equivalent decimal number. The 32 outputs of the decoder are connected through links to each OR gate. Only four of these links are shown in the diagram, 
but actually each OR gate has 32 inputs and each input goes through a link that can be broken as desired.
The ROM is a two-level implementation in sum of minterms form. It does not have to be an 
AND-OR implementation, but it can be any other possible two-level minterm implementation. 
The second level is usually a wired-logic connection (see Section 3-7) to facilitate the fusing of links.
ROMs have many important applications in the design of digital computer systems. Their 
use for implementing complex combinational circuits is just one of these applications. Other uses of ROMs are presented in other parts of the book in conjunction with their particular ap-plications.
5.7.1 Combinational Logic Implementation
From the logic diagram of the ROM, it is clear that each output provides the sum of all the mint-erms of the n input variables. Remember that any Boolean function can be expressed in sum-of-
minterms form. By breaking the links of those minterms not included in the function, each ROM 
output can be made to represent the Boolean function of one of the output variables in the com-binational circuit. For an n-input, m-output combinational circuit, we need a 2
n × m ROM. The        5×32
      decor derA0Address inputMinterms
128 links0
1
2
31A1
A2
A3
A4
F1 F2 F3 F4
Figure 5-22 Logic construction of a 32 × 4 ROM
164 Chapter 5
opening of the links is referred to as programming the ROM. The designer need only specify a 
ROM program table that gives the information for the required paths in the ROM. The actual pro-
gramming is a hardware procedure which follows the specifications listed in the program table.
Let us clarify the process with a specific example. The truth table in Fig. 5-23(a) specifies a 
combinational circuit with two inputs and two outputs. The Boolean functions can be expressed 
in sum of minterms:
F1(A1, A0) = ∑ (1, 2, 3)
F2(A1, A0) = ∑ (0, 2)
When a combinational circuit is implemented by means of a ROM, the functions must be 
expressed in sum of minterms or, better yet, by a truth table. If the output functions are simpli-fied, we find that the circuit needs only one OR gate and an inverter. Obviously, this is too simple a combinational circuit to be implemented with a ROM. The advantage of a ROM is in complex A0 A1
0
0
1
10
1
0
10
1
1
11
0
1
0F2 F1
(a) Truth table
       2 × 4
      decoder
A100
01
10
11A0
F1 F2        2 × 4
      decoder
A100
01
10
11A0
F1F2
             (b) ROM with AND - OR gates                       (c) ROM with AND - OR - INVERT gates
Figure 5-23 Combinational-circuit implementaion with a 4 × 2 ROM
Combinational Logic with MSI and LSI  165 
combinational circuits. This example merely demonstrates the procedure and should not be con-
sidered in a practical situation.
The ROM that implements the combinational circuit must have two inputs and two outputs; 
so its size must be 4 × 2. Figure 5-23(b) shows the internal construction of such a ROM. It is 
now necessary to determine which of the eight available links must be broken and which should 
be left in place. This can be easily done from the output functions listed in the truth table. Those minterms that specify an output of 0 should not have a path to the output through the OR gate. Thus, for this particular case the truth table shows three 0’ s, and their corresponding links to the OR gates must be removed. It is obvious that we must assume here that an open input to an OR gate behaves as a 0 input.
Some ROM units come with an inverter after each of the OR gates and, as a consequence, 
they are specified as having initially all 0’ s at their outputs. The programming procedure in such 
ROMs requires that we open the link paths of the minterms (or addresses) that specify an output of l in the truth table. The output of the OR gate will then generate the complement of the func-tion, but the inverter placed after the OR gate complements the function once more to provide the normal output. This is shown in the ROM of Fig. 5-23(c).
The previous example demonstrates the general procedure for implementing any combina-
tional circuit with a ROM. From the number of inputs and outputs in the combinational circuit, 
we first determine the size of ROM required. Then we must obtain the programming truth table of the ROM; no other manipulation or simplification is required. The 0’ s (or 1’ s) in the output func-tions of the truth table directly specify those links that must be removed to provide the required combinational circuit in sum of minterms form.
In practice, when one designs a circuit by means of a ROM, it is not necessary to show the 
internal gate connections of links inside the unit as was done in Fig. 5-23. This was shown here 
for demonstration purposes only. All the designer has to do is specify the particular ROM (or its designation number) and provide the ROM truth table as in Fig. 5-23(a). The truth table gives all the information for programming the ROM. No internal logic diagram is needed to accompany the truth table.
EXAMPLE 5-5: Design a combinational circuit using a ROM. The circuit accepts a 3-bit 
number and generates an output binary number equal to the square of the input number.
The first step is to derive the truth table for the combinational circuit. In most cases this 
is all that is needed. In some cases we can fit a smaller truth table for the ROM by using cer -
tain properties in the truth table of the combinational circuit. Table 5-5 is the truth table for the combinational circuit. Three inputs and six outputs are needed to accommodate all possible numbers. We note that output B
0 is always equal to input A0; so there is no need to generate 
B0 with a ROM since it is equal to an input variable. Moreover, output B1 is always 0, so this 
output is always known. We actually need to generate only four outputs with the ROM; the other two are easily obtained. The minimum size ROM needed must have three inputs and four outputs. Three inputs specify eight words, so the ROM size must be 8 × 4. The ROM implementation is shown in Fig. 5-24. The three inputs specify eight words of four bits each. The other two outputs of the combinational circuit are equal to 0 and A
0. The truth table in  
Fig. 5-24 specifies all the information needed for programming the ROM, and the block dia-gram shows the required connections.
166 Chapter 5
5.7.2 Types of ROMs
The required paths in a ROM may be programmed in two different ways. The first is called mask 
programming and is done by the manufacturer during the last fabrication process of the unit. The 
procedure for fabricating a ROM requires that the customer fill out the truth table he wishes the 
ROM to satisfy. The truth table may be submitted on a special form provided by the manufactu-rer. More often, it is submitted on paper tape or punch cards in the format specified on the data sheet of the particular ROM. The manufacturer makes the corresponding mask for the paths to produce the 1’ s and 0’ s according to the customer’ s truth table. This procedure is costly because the vendor charges the customer a special fee for custom masking a ROM. For this reason, mask programming is economical only if large quantities of the same ROM configuration are to be manufactured.
For small quantities, it is more economical to use a second type of ROM called a program-
mable read-only memory or PROM. When ordered, PROM units contain all 0’ s (or all l’ s) in 
every bit of the stored words. The links in the PROM are broken by application of current pulses through the output terminals. A broken link defines one binary state and an unbroken link rep-resents the other state. This allows the user to program the unit in his own laboratory to achieve the desired relationship between input addresses and stored words. Special units called PROM programmers are available commercially to facilitate this procedure. In any case, all procedures 
for programming ROMs are hardware procedures even though the word programming is used.
The hardware procedure for programming ROMs or PROMs is irreversible and, once pro-
grammed the fixed pattern is permanent and cannot be altered. Once a bit pattern has been established, the unit must be discarded if the bit pattern is to be changed. A third type of unit available is called erasable PROM or EPROM. EPROMs can be restructured to the initial value (all 0’ s or all 1’ s) even though they have been changed previously. When an EPROM is placed under a special ultraviolet light for a given period of time, the short-wave radiation discharges the internal gates that serve as contacts. After erasure, the ROM returns to its initial state and can be reprogrammed. Certain ROMs can be erased with electrical signals instead of ultraviolet light, and these are sometimes called electrically alterable ROMs or EAROMs.
The function of a ROM can be interpreted in two different ways. The first interpretation is of 
a unit that implements any combinational circuit. From this point of view, each output terminal Table: 5-5 Truth table for circuit of Example 5-5
Inputs Outputs Decimal
A2A1A0B5B4B3B2B1B0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 1 1
0 1 0 0 0 0 1 0 0 4
0 1 1 0 0 1 0 0 1 9
1 0 0 0 1 0 0 0 0 16
1 0 1 0 1 1 0 0 1 25
1 1 0 1 0 0 1 0 0 36
I 1 1 1 1 0 0 0 1 49
Combinational Logic with MSI and LSI  167 
is considered separately as the output of a Boolean function expressed in sum of minterms. The 
second interpretation considers the ROM to be a storage unit having a fixed pattern of bit strings called words. From this point of view, the inputs specify an address to a specific stored word 
which is then applied to the outputs. For example, the ROM of Fig. 5-24 has three address lines which specify eight stored words as given by the truth table. Each word is four bits long. This is the reason why the unit is given the name read-only memory. Memory is commonly used to designate a storage unit. Read is commonly used to signify that the contents of a word specified 
by an address in a storage unit is placed at the output terminals. Thus, a ROM is a memory unit with a fixed word pattern that can be read out upon application of a given address. The bit pattern in the ROM is permanent and cannot be changed during normal operation.
ROMs are widely used to implement complex combinational circuits directly from their 
truth tables. They are useful for converting from one binary code to another (such as ASCII to EBCDIC and vice versa), for arithmetic functions such as multipliers, for display of characters in a cathode-ray tube, and in many other applications requiring a large number of inputs and out-puts. They are also em ployed in the design of control units of digital systems. As such, they are 
used to store fixed bit patterns that represent the sequence of control variables needed to enable the various operations in the system. A control unit that utilizes a ROM to store binary control information is called a microprogrammed control unit. Chapter 10 deals with this subject in more detail.
5.8 Programmable Logic Array (PLA)
A combinational circuit may occasionally have don’t-care conditions. When imple mented with 
a ROM, a don’t-care condition becomes an address input that will never occur. The words at the don’t-care addresses need not be programmed and may be left in their original state (all 0’ s or all 1’ s). The result is that not all the bit patterns available in the ROM are used, which may be considered a waste of available equipment.
Consider, for example, a combinational circuit that converts a 12-bit card code to a 6-bit 
internal alphanumeric code as listed in Table 1-5. The input card code consists of 12 lines desig-nated by 0, 1, 2…….,9, 11, 12. The size of the ROM for implementing the code converter must 8×4
ROM
B1B00
B2A1A0 A2
B3 B4F4 F3 F2 F1
B5        A1 A2 A0
0
0
0
01
1
1
10
0
1
10
0
1
10
1
0
10
1
0
10
0
0
00
0
1
10
0
0
01
1
0
10
0
0
10
1
0
00
0
1
00
0
1
0F2 F1 F4 F3
                             (a) Block diagram                                 (b) ROM truth table
Figure 5-24 ROM implementaion of Example 5-5
168 Chapter 5
be 4096 × 6, since there are 12 inputs and 6 outputs. There are only 47 valid entries for the card 
code; all other input combinations are don’t-care conditions. Thus only 47 words of the 4096 available are used. The remaining 4049 words of ROM are not used and are thus wasted.
For cases where the number of don’t-care conditions is excessive, it is more economical to 
use a second type of LSI component called programmable logic array or PLA. A PLA is similar to a ROM in concept; however, the PLA does not provide full decoding of the variables and does not generate all the minterms as in the ROM. In the PLA, the decoder is replaced by a group of 
AND gates, each of which can be programmed to generate a product term of the input variables. The AND and OR gates inside the PLA are initially fabricated with links among them. The spe-cific Boolean functions are implemented in sum of products form by opening appropriate links and leaving the desired connections.
A block diagram of the PLA is shown in Fig. 5-25. It consists of n inputs, m outputs, k 
product terms, and m sum terms. The product terms constitute a group of k AND gates and the 
sum terms constitute a group of m OR gates. Links are inserted between all n inputs and their 
complement values to each of the AND gates. Links are also provided between the outputs of the AND gates and the inputs of the OR gates. Another set of links in the output inverters allows the 
output function to be generated either in the AND-OR form or in the AND-OR-INVERT form. With the inverter link in place, the inverter is bypassed, giving an AND-OR implementation. With the link broken, the inverter becomes part of the circuit and the function is implemented in the AND-OR-INVERT form.
The size of the PLA is specified by the number of inputs, the number of product terms, and 
the number of outputs (the number of sum terms is equal to the number of outputs). A typical 
PLA has 16 inputs, 48 product terms, and 8 outputs.
§§ The number of programmed links is 2n × 
k + k × m + m, whereas that of a ROM is 2n × m.
Figure 5-26 shows the internal construction of a specific PLA. It has three inputs, three 
product terms, and two outputs. Such a PLA is too small to be available commercially; it is pre-sented here merely for demonstration purposes. Each input and its complement are connected through links to the inputs of all AND gates. The outputs of the AND gates are connected through links to each input of the OR gates. Two more links are provided with the output inverters. By breaking selected links and leaving others in place, it is possible to implement Boolean functions in their sum of products form.
As with a ROM, the PLA may be mask-programmable or field programmable. With a mask-
programmable PLA, the customer must submit a PLA program table to the manufacturer. This table is used by the vendor to produce a custom-made PLA that has the required internal paths 
§§TTL IC type 82S100.n×k
links
n×k
linksk×mlinks  m
links
k product
     te rms
(AND ga tes)    m sum     te rms
(OR ga tes)
    n
inputs    m
output
Figure 5-25 PLA block diagram
Combinational Logic with MSI and LSI  169 F111
2
32 F2A
B
C
Figure 5-26 PLA with 3 inputs, 3 product terms, and 2 outputs; it implements the combinational cir -
cuit specified in Fig. 5-27
170 Chapter 5
between inputs and outputs. A second type of PLA available is called a field programmable logic 
array or FPLA. The FPLA can be programmed by the user by means of certain recommended 
procedures. Commercial hardware programmer units are available for use in conjunction with certain FPLAs.
5.8.1 PLA Program Table
The use of a PLA must be considered for combinational circuits that have a large number of inputs and outputs. It is superior to a ROM for circuits that have a large number of don’t-care conditions. The example presented below demonstrates how a PLA is programmed. Bear in mind 
when going through the example that such a simple circuit will not require a PLA because it can be implemented more economically with SSI gates.
Consider the truth table of the combinational circuit, shown in Fig. 5-27(a). Although a 
ROM implements a combinational circuit in its sum of minterms form, a PLA implements the 
functions in their sum of products form. Each product term in the expression requires an AND gate. Since the number of AND gates in a PLA is finite, it is necessary to simplify the function to a minimum number of product terms in order to minimize the number of AND gates used. The 
simplified functions in sum of products are obtained from the maps of Fig. 5-27(b):
F
1 = AB′ + AC
F2 = AC + BC
There are three distinct product terms in this combinational circuit: AB′, AC, and BC. The 
circuit has three inputs and two outputs; so the PLA of Fig. 5-26 can be used to implement this combinational circuit.
Programming the PLA means that we specify the paths in its AND-OR-NOT pattern. A 
typical PLA program table is shown in Fig. 5-27(c). It consists of three columns. The first col-
umn lists the product terms numerically. The second column specifies the required paths between inputs and AND gates. The third column specifies the paths between the AND gates and the OR gates. Under each output variable, we write a T (for true) if the output inverter is to be bypassed, 
and C (for complement) if the function is to be complemented with the output inverter. The Bool-
ean terms listed at the left are not part of the table: they are included for reference only.
For each product term, the inputs are marked with 1, 0, or - (dash). If a variable in the prod-
uct term appears in its normal form (unprimed), the corresponding input variable is marked with a 1. If it appears complemented (primed), the corresponding input variable is marked with a 0. If the variable is absent in the product term, it is marked with a dash. Each product term is associ-ated with an AND gate. The paths between the inputs and the AND gates are specified under the column heading inputs. A 1 in the input column specifies a path from the corresponding input to 
the input of the AND gate that forms the product term, A 0 in the input column specifies a path 
from the corresponding complemented input to the input of the AND gate. A dash specifies no connection. The appropriate links are broken, and the ones left in place form the desired paths, as shown in Fig. 5-26, It is assumed that the open terminals in the AND gate behave like a 1 input.
The paths between the AND and OR gates are specified under the column heading outputs. 
The output variables are marked with l’ s for all those product terms that formulate the function. In the example of Fig. 5-27, we have:
F
1 = AB′ + AC
Combinational Logic with MSI and LSI  171 
so F1 is marked with 1’ s for product terms 1 and 2 and with a dash for product term 3. Each 
product term that has a 1 in the output column requires a path from the corresponding AND gate 
to the output OR gate. Those marked with a dash specify no connection. Finally, a T (true) output 
dictates that the link across the output inverter remains in place, and a C (complement) specifies that the corre sponding link be broken. The internal paths of the PLA for this circuit are shown 
in Fig. 5-26. It is assumed that an open terminal in an OR gate behaves like a 0, and that a short circuit across the output inverter does not damage the circuit.
When designing a digital system with a PLA, there is no need to show the internal connec-
tions of the unit as was done in Fig. 5-26. All that is needed is a PLA program table from which the PLA can be programmed to supply the appropriate paths.
When implementing a combinational circuit with PLA, careful investigation must be un-
dertaken in order to reduce the total number of distinct product terms, since a given PLA would 
have a finite number of AND terms. This can be done by simplifying each function to a minimum number of terms. The number of literals in a term is not important since we have available all input variables. Both the true value and the complement of the function should be simplified to see which one can be expressed with fewer product terms and which one provides product terms that are common to other functions.B AC
0
0
0
01
1
1
10
0
1
10
0
1
10
1
0
10
1
0
10
0
0
01
1
0
10
0
0
10
1
0
1F2 F1
     B
C1 1 A
F1 = AB´ + AC1
B
C11
A
F2 = AC  + BC1
                                        (a) Truth table               (b) Map simplification.
Product
  term    Inputs  
A     B     COutputs  
 F1    F2     
1
2
31
1
-1
1
-0
-
1-1
1-
1
1
TT T/CAB´
AC
BC
(c) PLA program table.
Figure 5-27 Steps required in PLA implementation
172 Chapter 5
EXAMPLE 5-6: A combinational circuit is defined by the functions:
F1(A, B, C) = ∑(3, 5, 6, 7) 
F2(A, B, C) = ∑(0, 2, 4, 7)
Implement the circuit with a PLA having three inputs, four product terms, and two outputs.
The two functions are simplified in the maps of Fig. 5-28. Both the true values and the com-plements of the functions are simplified. The combinations that gives a minimum number of product terms are:
F
1 = (B′C + A′C′ + A′B′)’
F2 = B′C + A′C′ + ABC
This gives only four distinct product terms: B′C, A′C′, A′B′, and ABC. The PLA program 
table for this combination is shown in Fig. 5-28. Note that output F1 is the normal (or true) 
output even though a C is marked under it. This is because F′1 is generated prior to the output 
inverter. The inverter complements the function to produce F1 in the output.B
C11 11
A
F1 = AC  + AB + BC         B
C1
11
A
F2 = B´C´ + A´C´ + ABC1
B
C0
000
A
F´1 = B´C´ + A´C´ + A´B´        B
C0
0 00
A
F´2  = B´C´ + A´C + ABC´
Product
  termPLA program ta ble
    Inputs  
A     B     COutputs   F
1    F2     
12
3
411
1
-11
-
100
-
10-
0
1-0
0
1
CT T/CB´C´
A´C´
A´B´
ABC
Figure 5-28 Solution to Example 5-6
Combinational Logic with MSI and LSI  173 
The combinational circuit for this example is too small for practical implementation with 
a PLA. It was presented here merely for demonstration purposes. A typical commercial PLA 
would have over 10 inputs and about 50 product terms. The simplification of Boolean functions with so many variables should be carried out by means of a tabulation method or other computer-assisted simplification method. This is where a computer program may aid in the design of com-plex digital systems. The computer program should simplify each function of the combinational circuit and its complement to a minimum number of terms. The program then selects a minimum number of distinct terms that cover all functions in their true or complement form.
5.9 Concluding Remarks
This chapter presented a variety of design methods for combinational circuits. It also presented and explained a number of MSI and LSI circuits that can be used when designing more com-plicated digital systems. The emphasis here was on combinational logic MSI and LSI functions. Sequential logic MSI functions are discussed in Chapter 7. Processor and control MSI and LSI functions are pre sented in Chapters 9 and 10. Microcomputer LSI components are introduced in 
Chapter 12.
The MSI functions presented here and others available commercially are described in data 
books or catalogs. IC data books contain exact descriptions of many MSI and other integrated circuits. Some of these data books are listed in the following References.
MSI and LSI circuits can be used in a variety of applications. Some of these applications 
were discussed throughout the chapter, some are included in Problems, and others will be found in succeeding chapters in conjunction with their particular applications. Resourceful designers may find many other applications to suit their particular needs. Manufacturers of integrated cir -
cuits publish numerous application notes to suggest possible utilization of their products. A list 
of available application notes can be obtained by writing to manufacturers directly or by inqui-ring of their local representatives.
REFERENCES
1. Mano, M. M., Computer System Architecture. Englewood Cliffs, N. J.: Prentice-Hall, Inc., 1976.
2. Morris, R. L. and J. R. Miller, eds., Designing with TTL Integrated Circuits. New Y ork: McGraw-Hill 
Book Co., 1971.
3. Blakeslee, T. R., Digital Design with Standard MSI and LSI. New Y ork: John Wiley & Sons, 1975.
4. Barna A., and D. I. Porat, Integrated Circuits in Digital Electronics. New Y ork: John Wiley & Sons, 1973.
5. Lee, S. C., Digital Circuits and Logic Design, Englewood Cliffs, N. J. Prentice-Hall, Inc., 1976.
6. Semiconductor Manufacturers Data Books (Consult latest edition):
(a) The TTL Data Book for Design Engineers. Dallas, Texas: Texas Instruments, Inc.
(b) The Fairchild Semiconductor TTL Data Book. Mountain View, Calif.; Fairchild Semiconductor.
(c) Digital Integrated Circuits. Santa Clara, Calif.: National Semiconductor Corp.
(d) Signetics Digital, Linear, MOS. Sunnyvale, Calif.: Signetics.
(e) MECL Integrated Circuits Data Book. Phoenix, Ariz; Motorola Semiconductor Products, Inc.
(f) RCA Solid State Data Book Series. Somerville, N. J.: RCA Solid State Div.
174 Chapter 5
PROBLEMS
5-1. Design an excess-3-to-BCD code converter using a 4-bit full-adders MSI circuit.
5-2. Using four MSI circuits, construct a binary parallel adder to add two 16-bit binary numbers. Label 
all carries between the MSI circuits.
5-3. Using 4 exclusive-OR gates and a 4-bit full-adders MSI circuit, construct a 4-bit parallel adder/
subtractor. Use an input select variable V so that when V = 0, the circuit adds and when V = 1, the 
circuit subtracts. (Hint: Use 2’ s complement subtraction.)
5-4. Derive the two-level equation for the output carry C5 shown in the look-ahead carry generator of  
Fig. 5-5.
5-5. (a)  Using the AND-OR-1NVERT implementation procedure described in Section 3-7, show that the 
output carry in a full-adder circuit can be expressed as:
 Ci + 1 = Gi + PiCi = (Gi′Pi′ + Gi′Ci′)
 (b)  IC type 74182 is a look-ahead carry generator MSI circuit that generates the carries with AND-
OR-INVERT gates. The MSI circuit assumes that the input terminals have the complements of the G’ s, the P’ s, and of C
1. Derive the Boolean functions for the look-ahead carries C2, C3, and C4 
in this IC. (Hint: Use the equation substitution method to derive the carries in terms of C ′1).
5-6. (a)  Redefine the carry propagate and carry generate as follows:
 Pi = Ai + Bi
 Gi = Ai Bi
       Show that the output carry and output sum of a full-adder becomes:
 Ci + 1 = (Ci′Gi′ + Pi′) = Gi + PiCi
     Si = (PiGi′) ⊕ Ci
 (b)  The logic diagram of the first stage of a 4-bit parallel adder as implemented in IC type 74283 is 
shown in Fig. P5-6. Identify the P1′ and G1′ terminals as defined in (a) and show that the circuit 
implements a full-adder circuit.
B1
A1
C1C2
S1
Figure P5-6 First stage of a parallel adder 
Combinational Logic with MSI and LSI  175 
 (c)  Obtain the output carries C3 and C4 as a function of P′1, P′2, P′3, G′1, G′2, G′3, and C in AND-OR-
INVERT form, and draw the two-level look-ahead circuit for this IC. [Hint: Use the equation-
substitution method as done in the text when deriving Fig. 5-4, but use the AND-OR-INVERT 
function given in (a) for Ci + 1].
5-7. (a)  Assume that the exclusive-OR gate has a propagation delay of 20 ns and that the AND or OR 
gates have a propagation delay of 10 ns. What is the total propagation delay time in the 4-bit adder 
of Fig. 5-5?
 (b)  Assume that C5 is propagated in the box of Fig. 5-5 at the same time as the other carries (see 
problem 5-4). What will be the propagation delay time of the 16-bit adder of problem 5-2?
5-8. Design a binary multiplier that multiplies a 4-bit number B = b3b2b1b0 by a 3-bit number A = a2 a1 a0 
to form the product C = c6c5c4c3c2c1c0. This can be done with 12 gates and two 4-bit parallel adders. 
The AND gates are used to form the products of pairs of bits. For example, the product of a0 and b0 
can be generated by ANDing a0 with b0. The partial products formed by the AND gates are summed 
with the parallel adders.
5-9. How many don’t-care inputs are there in a BCD adder?
5-10. Design a combinational circuit that generates the 9’ s complement of a BCD digit.
5-11. Design a decimal arithmetic unit with two selection variables, V1 and V0, and two BCD digits, A 
and B. The unit should have four arithmetic operations which depend on the values of the selection 
variables as shown below.
V1V0Output function
0 0 A + 9’ s complement of B
0 1 A + B
1 0 A + 10’ s complement of B
1 1 A + 1 (add 1 to A)
 Use MSI functions in the design and the 9’ s complementer of problem 5-10.
5-12. It is necessary to design a decimal adder for two digits represented in the excess-3 code (Table 1-2). Show that the correction after adding the two digits with a 4-bit binary adder is as follows:
(a) The output carry is equal to the carry out of the binary adder.
(b) If output carry = 1, add 0011.
(c) If output carry = 0, add 1101.
 Construct the adder with two 4-bit binary adders and an inverter.
5-13. Design a circuit that compares two 4-bit numbers, A and B, to check if they are equal. The circuit has 
one output x, so that x =1 if A = B, and x = 0 if A ≠ B.
5-14. The 74L85 IC is a 4-bit magnitude comparator similar to that in Fig. 5-7, except that it has three more inputs and internal circuits that perform the equivalent logic as shown in Fig. P5-14. With these ICs, numbers of greater length may be compared by connecting comparators in cascade. The A < B, 
A > B, and A = B outputs of a stage handling less-significant bits are connected to the corresponding 
A < B, A > B, and A = B inputs of the next stage handling more-significant bits. The stage that handles 
the least-significant bits must be a circuit as shown in Fig. 5-7. If the 74L85 IC is used, a 1 must be applied to the A = B input and a 0 to the A < B and A > B inputs in the IC that handles the four least 
significant bits. Using one circuit as in Fig. 5-7 and one 74L85 IC, obtain a circuit to compare two 8-bit numbers. Justify the circuit operation.
176 Chapter 5
5-15. Modify the BCD-to-decimal decoder of Fig. 5-10 to give an output of all 0’ s when any invalid input 
combination occurs.
5-16. Design a BCD-to-excess-3 code converter with a BCD-to-decimal decoder and four OR gates.
5-17. A combinational circuit is defined by the following three functions:
 F1 = x′ y′ + xyz′ 
 F2 = x′ + y
 F3 = xy + x′y′
 Design the circuit with a decoder and external gates.
5-18. A combinational circuit is defined by the following two functions:
 F1(x, y) = ∑(0, 3)
 F2(x, y) = ∑(1, 2, 3)
 Implement the combinational circuit by means of the decoder shown in Fig. 5-12 and external NAND gates.
5-19. Construct a 5 × 32 decoder with four 3×8 decoder/demultiplexers and a 2 × 4 decoder. Use a block diagram construction as in Fig. 5-14.
5-20. Draw the logic diagram of a 2-line to 4-line decoder/demultiplexer using NOR gates only.
5-21. Specify the truth table of an octal-to-binary priority encoder. Provide an output to indicate if at least 
one of the inputs is a 1. The table can be listed with 9 rows, and some of the inputs will have don’t-
care values.
5-22. Design a 4-line to 2-line priority encoder. Include an output E to indicate that at least one input  
is a 1.
5-23. Implement the Boolean function of Example 5-4 with an 8 × 1 multiplexer with A, B, and D connec-
ted to selection lines s
2, s1, and s0, respectively.   Cir cuit
      of
    Fig.5-7A0A1A2A3
A < BA < BA < B
A > B
A = B
A > BA > B
A = BA = BB0B1B2B3
Figure P5-14 Logically equivalent circuit of IC type 74L85
Combinational Logic with MSI and LSI  177 
5-24. Implement the combinational circuit specified in problem 5-17 with a dual 4-line to 1-line multiple-
xers, an OR gate, and inverter.
5-25. The 32 × 6 ROM together with the 20 line as shown in Fig. P5-25 converts a 6-bit binary number 
to its corresponding 2-digit BCD number. For example, binary 100001 converts to BCD 011 0011 (decimal 33). Specify the truth table for the ROM.
5-26. Prove that a 32 × 8 ROM can be used to implement a circuit that generates the binary square of an input 5-bit number with B
0 = A0 and B1 = 0 as in Fig. 5-24(a). Draw a block diagram of the circuit 
and list the first four and the last four entries of the ROM truth table.
5-27. What size ROM would it take to implement:
(a) A BCD adder/subtracior with a control input to select between the addition and subtraction.
(b) A binary multiplier that multiplies two 4-bit numbers.
(c) Dual 4-line to 1-line multiplexers with common selection inputs.
5-28. Each output inverts in the PLA of Fig. 5-26 is replaced by an exclusive-OR gate. Each exclusive-OR gate has two inputs. One output is connected to the output of the OR gate, and the other input is connected through links to a signal equivalent to either 0 or 1. Show how to select the true/comple-
ment output in this configuration.
5-29. Derive the PLA program table for a combinational circuit that squares a 3-bit number. Minimize the 
number of product terms. (See Fig. 5-24 for the equivalent ROM implementation.)
5-30. List the PLA program table for the BCD-to-excess-3 code convener defined in Section 4-5.
5-31. Design a combinational circuit using a ROM which accepts a 2-bit number and generate a binary 
number equal to the cube of the input binary number.
5-32. Using 3 
× 8 decoder and two OR gates design a full-subtractor.
5-33. With 2 × 1 mux implement XOR gate and AND gate.
5-34. Construct 16x1 mux using five 4 × 1 only.
5-35. Implement full-subtractor circuit with multiplexer.
5-36. A combinational circuit is defined by the functions
 F1(A, B, C) = ∑(1, 2, 3, 5)
 F2(ABC) = ∑(O, 2, 4, 6)
 Implement the circuit with PLA having three inputs, four product terms, and two outputs.32×6 RO M
F4F5F6 F3F2F1AB CD E22 23 24 25 21 20
100 101
Figure P5-25 Binary-to-decimal converter
178 Chapter 5
5-37. Differentiate between
(a)   PLA and ROM
(b)   MUX, DECODER
MORE SOL vED ExAMPLES
1. With 2 × 1 mux implement NOT gate and OR gate  
 AF(A) = A' 1
0I0
   2 X 1 MUX
I1
                NOT gate
 
 AF(A) = A + BB
1I0
   2 X 1 MUX
I1
                A B Y
0 0 0
0 1 1 
1 0 1
1 1 1
                 OR gate                                                  Truth Table
       
 I0 I1
B' 0 2
   
B 1 3
B 1
6Chapter
Sequential Logic6.1 Introduction
The digital circuits considered thus far have been combinational, i.e., the outputs at any instant of 
time are entirely dependent upon the inputs present at that time. Although every digital system is likely to have combinational circuits, most systems encountered in practice also include memory elements, which require that the system be described in terms of sequential logic.
A block diagram of a sequential circuit is shown in Fig. 6-1. It consists of a combinational 
circuit to which memory elements are connected to form a feedback path. The memory elements are devices capable of storing binary information within them. The binary information stored in the memory elements at any given time defines the state of the sequential circuit. The sequential 
circuit receives binary information from external inputs. These inputs, together with the pres-ent state of the memory elements, determine the binary value al the output terminals. They also determine the condition for changing the state in the memory elements. The block diagram dem-onstrates that the external outputs in a sequential circuit are a function not only of external inputs but also of the present state of the memory elements. The next state of the memory elements is also a function of external inputs and the present state. Thus, a sequential circuit is specified by a time sequence of inputs, outputs, and internal states.
There are two main types of sequential circuits. Their classification depends on the timing 
of their signals. A synchronous sequential circuit is a system whose behavior can be defined 
from the knowledge of its signals at discrete instants of time. The behavior of an asynchronous 
sequential circuit depends upon the order in which its input signals change and can be affected at any instant of time. The memory elements commonly used in asynchronous sequential circuits are time-delay devices. The memory capability of a time-delay device is due to the fact that it 
 
  Combinational
        cir cuit
Memor y
elementsInputs Outputs
Figure 6.1 Block diagram of a sequential circuit
180 Chapter 6
takes a finite time for the signal to propagate through the device. In practice, the internal propa-
gation delay of logic gates is of sufficient duration to produce the needed delay, so that physical time-delay units may be unnecessary. In gate-type asynchronous systems, the memory elements of Fig. 6-1 consist of logic gates whose propagation delays constitute the required memory. Thus, an asynchronous sequential circuit may be regarded as a combinational circuit with feedback. Because of the feedback among logic gates, an asynchronous sequential circuit may, at times, become unstable. The instability problem imposes many difficulties on the designer. Hence they are not as commonly used as synchronous systems.
A synchronous sequential logic system, by definition, must employ signals that affect the 
memory elements only at discrete instants of time. One way of achieving this goal is to use pulses of limited duration throughout the system so that one pulse amplitude represents logic-1 and another pulse amplitude (or the absence of a pulse) represents logic-0. The difficulty with a system of pulses is that any two pulses arriving from separate independent sources to the inputs of the same gate will exhibit unpredictable delays, will separate the pulses slightly, and will result in unreliable operation.
Practical synchronous sequential logic systems use fixed amplitudes such as voltage levels 
for the binary signals. Synchronization is achieved by a timing device called a master-clock gen-erator which generates a periodic train of clock pulses. The clock pulses are distributed through-
out the system in such a way that memory elements are affected only with the arrival of the synchronization pulse. In practice, the clock pulses are applied into AND gates together with the signals that specify the required change in memory elements. The AND gate outputs can transmit signals only at instants which coincide with the arrival of clock pulses. Synchronous sequential circuits that use clock pulses in the inputs of memory elements are called clocked sequential cir -
cuits. Clocked sequential circuits are the type encountered most frequently. They do not manifest 
instability problems and their timing is easily broken down into independent discrete steps, each of which is considered separately. The sequential circuits discussed in this book are exclusively of the clocked type.
The memory elements used in clocked sequential circuits are called flip-flops. These circuits 
are binary cells capable of storing one bit of information. A flip-flop circuit has two outputs, one 
for the normal value and one for the complement value of the bit stored in it. Binary information can enter a flip-flop in a variety of ways, a fact which gives rise to different types of flip-flops. 
In the next section we examine the various types of flip-flops and define their logical properties.
6.2 Flip-Flops
A flip-Hop circuit can maintain a binary state indefinitely (as long as power is delivered to the circuit) until directed by an input signal to switch states. The major differences among various types of flip-flops are in the number of inputs they possess and m the manner in which the inputs affect the binary state. The most common types of flip-flops are discussed below,
6.2.1 Basic Flip-Flop Circuit
It was mentioned in Sections 4-7 and 4-8 that a flip-flop circuit can be constructed from two NAND gates or two NOR gates. These constructions are shown in the logic diagrams of Figs. 6-2 and 6-3. Each circuit forms a basic flip-flop upon which other more complicated types can be built. The cross-coupled connection from the output of one gate to the input of the other gate constitutes a feedback path. For this reason, the circuits are classified as asynchronous sequential 
Sequential Logic  181 
circuits. Each flip-flop has two outputs, Q and Q′, and two inputs, set and reset. This type of flip-
flop is sometimes called a direct-coupled RS flip-flop or SR latch. The R and S are the first letters 
of the two input names.
To analyze the operation of the circuit of Fig, 6-2, we must remember that the output of a 
NOR gate is 0 if any input is 1, and that the output is 1 only when all inputs are 0. As a starting 
point, assume that the set input is 1 and the reset input is 0. Since gate 2 has an input of 1, its output Q′ must be 0, which puts both inputs of gate 1 at 0, so that output Q is 1. When the set 
input is returned to 0, the outputs remain the same, because output Q remains a 1, leaving one 
input of gate 2 at 1. That causes output Q′ to stay at 0, which leaves both inputs of gate number 
1 at 0, so that output Q is a 1. In the same manner it is possible to show that a 1 in the reset input 
changes output Q to 0 and Q′ to 1. When the reset input returns to 0, the outputs do not change.
When a 1 is applied to both the set and the reset inputs, both Q and Q′ outputs go to 0. This 
condition violates the fact that outputs Q and Q′ are the complements of each other. In normal 
operation this condition must be avoided by making sure that l’ s are not applied to both inputs simultaneously.
A flip-flop has two useful states. When Q = 1 and Q′ = 0, it is in the set state (or I-state). 
When Q = 0 and Q′ = 1, it is in the clear state (or 0-state). The outputs Q and Q′ are complements 
of each other and are referred to as the normal and complement outputs, respectively. The binary state of the flip-flop is taken to be the value of the normal output.
Under normal operation, both inputs remain at 0 unless the state of the flip-flop has to be 
changed. The application of a momentary 1 to the set input causes the flip-flop to go to the set state. The set input must go back to 0 before a 1 is applied to the reset input. A momentary 1 applied to the reset input causes the flip-flop to go the clear state. When both inputs are initially 0, a 1 applied to the set input while the flip-flop is in the set state or a 1 applied to the reset input while the flip-flop is in the clear state leaves the outputs unchanged. When a 1 is applied to both 0 R(reset)1
0 S(set)1Q
Q´1
2Q´ S
(after S = 1, R = 0)
(after S = 0, R = 1)R
1
0
0
0
100
1
0
111
0
0
000
1
1
0Q
                            (a) Logic diragram             (b) Truth table
Figure 6.2 Basic flip–flop circuit with NOR gates
0 R(reset)10 S(set)1
Q
Q´1
2Q´ S
(after S = 1, R = 0)
(after S = 0, R = 1)R
11
0
1
00
1
1
1
00
0
1
1
11
1
0
0
1Q
  (a) Logic diagram                (b) Truth table
Figure 6.3 Basic flip – flop circuit with NAND gates
182 Chapter 6
the set and the reset inputs, both outputs go to 0. This state is undefined and is usually avoided. 
If both inputs now go to 0, the state of the flip-flop is indeterminate and depends on which input remains a 1 longer before the transition to 0.
The NAND basic flip-flop circuit of Fig, 6-3 operates with both inputs normally at 1 unless 
the state of the flip-flop has to be changed. The application of a momentary 0 to the set input causes output Q to go to 1 and Q′ to go to 0, thus putting the flip-flop into the set state. After the 
set input returns to 1, a momentary 0 to the reset input causes a transition to the clear state. When both inputs go to 0, both outputs go to 1—a condition avoided in normal flip-flop operation.
6.2.2 Clocked RS Flip-Flop
The basic flip-flop as it stands is an asynchronous sequential circuit. By adding gates to the inputs of the basic circuit, the flip-flop can be made to respond to input levels during the occur -
rence of a clock pulse. The clocked RS flip-flop shown in Fig. 6-4(a) consists of a basic NOR 
flip-flop and two AND gates. The outputs of the two AND gates remain at 0 as long as the clock pulse (abbreviated CP) is 0, regardless of the S and R input values. When the clock pulse goes 
to 1, information from the S and R inputs is allowed to reach the basic flip-flop. The set state is 
reached with S = 1, R = 0. and CP = 1. To change to the clear state, the inputs must be S = 0,  
R = 1, and CP = 1. With both S = 1 and R = 1, the occurrence of a clock pulse causes both outputs 
to momentarily go to 0. When the pulse is removed, the state of the flip-flop is indeterminate, 
i.e., either state may result, depending on whether the set or the reset input of the basic flip-flop remains a 1 longer before the transition to 0 at the end of the pulse.
The graphic symbol for the clocked RS flip-flop is shown in Fig, 6-4(b). It has three inputs: 
S, R, and CP . The CP input is not written within the box because it is recognized from the marked 
QR
SCP
(Cloc k
pulses)Q´S QR
0
0
0
0
1
1
1
10
0
1
1
0
0
1
10
1
0
1
0
1
0
10
0
1
indet erminat e
1
0
1
indet erminat eQ(t+1)
(a) Logic diagram (c) Characteristic table
Q
RSQ´
CP
(b) Graphic symbolSR
00 01 11 10S
R
Q(r+1) = S+R´Q0
111X
X1
QQ
SR = 0
(d) Characteristic equation
Figure 6.4 Clocked RS flip-flop
Sequential Logic  183 
small triangle. The triangle is a symbol for a dynamic indicator and denotes the fact that the flip-
flop responds to an input clock transition from a low-level (binary 0) to a high-level (binary 1) 
signal. The outputs of the flip-flop are marked with Q and Q′ within the box. The flip-flop can be 
assigned a different variable name even though Q, is written inside the box. In that case the letter 
chosen for the flip-flop variable is marked outside the box along the output line. The state of the 
flip-flop is determined from the value of its normal output Q. If one wishes to obtain the com-
plement of the normal output, it is not necessary to insert an inverter, because the complemented value is available directly from output Q′.
The characteristic table for the flip-flop is shown in Fig. 6-4(c). This table summarizes the 
operation of the flip-flop in a tabular form. Q is the binary state of the flip-flop at a given time 
(referred to as present state), the S and R columns give the possible values of the inputs, and  
Q(t + 1) is the state of the flip-flop after the occurrence of a clock pulse (referred to as next state).
The characteristic equation of the flip-flop is derived in the map of Fig. 6-4(d). This equa-
tion specifies the value of the next state as a function of the present state and the inputs. The 
characteristic equation is an algebraic expression for the binary information of the characteristic table. The two indeterminate states are marked by X’ s in the map, since they may result in either a 1 or a 0. However, the relation SR = 0 must be included as pan of the characteristic equation to specify that both S and R cannot equal 1 simultaneously.
6.2.3 D Flip-Flop
The D flip-flop shown in Fig. 6-5 is a modification of the clocked RS flip-flop. NAND gates 1 
and 2 form a basic flip-flop and gates 3 and 4 modify it into a clocked RS flip-flop. The D input 
goes directly to the S input, and its complement, through gate 5, is applied to the R input. As long 
as the clock pulse input is at 0, gates 3 and 4 have a 1 in their outputs, regardless of the value of the other inputs. This conforms to the requirement that the two inputs of a basic NAND flip-flop 
QD
CP
Q´13
452
(a) Logic diagram with NAND gates
Q
DQ´
CP
(b) Graphic symbolQD
0
0
1
101
0
10
1
0
1Q(t + 1)
(c) Characteristic table0 1
Q(t + 1) = D0
111
QD
(d) Characteristic equation
Figure 6.5 Clocked D flip-flop
184 Chapter 6
(Fig. 6-3) remain initially at the 1 level. The D input is sampled during the occurrence of a clock 
pulse, if it is 1, the output of gate 3 goes to 0, switching the flip-flop to the set state (unless it 
was already set). If it is 0, the output of gate 4 goes to 0, switching the flip-flop to the clear state.
The D flip-flop receives the designation from its ability to transfer “data” into a flip-flop. It 
is basically an RS flip-flop with an inverter in the R input. The added inverter reduces the number 
of inputs from two to one. This type of flip-flop is sometimes called a gated D-latch. The CP 
input is often given the variable designation G (for gate) to indicate that this input enables the 
gated latch to make possible the data entry into the flip-flop.
The symbol for a clocked D flip-flop is shown in Fig. 6-5(b). The characteristic table is 
listed in part (c) and the characteristic equation is derived in part (d), The characteristic equation shows that the next state of the flip-flop is the same as the D input and is independent of the value 
of the present state.
6.2.4 JK Flip-Flop
A JK flip-flop is a refinement of the RS flip-flop in that the indeterminate state of the RS type is 
defined in the JK type. Inputs J and K behave like inputs S and R to set and clear the flip-flop 
(note that in a JK flip-flop, the letter J is for set and the letter K is for clear). When inputs are QK
JCP
Q´
(a) Logic diagram
Q
KJQ´
CP
(b) Graphic symbolJ QK
0
0
0
0
1
1
1
10
0
1
1
0
0
1
10
1
0
1
0
1
0
10
0
1
11
0
1
0Q(t+1)
 (c) Characteristic table JK
00 01 11 10J
Q
Q
K0
1 1 111
Q(j+1) + JQ´ − K´Q
(d) Characteristic equation
Figure 6.6 Clocked JK flip–flop
Sequential Logic  185 
applied to both J and K simultaneously, the flip-flop switches to its complement state, that is, if 
Q = 1, it switches to Q = 0, and vice versa.
A clocked JK flip-flop is shown in Fig. 6-6(a). Output Q is ANDed with K and CP inputs 
so that the flip-flop is cleared during a clock pulse only if Q was previously 1. Similarly, output 
Q′ is ANDed with J and CP inputs so that the flip-flop is set with a clock pulse only if Q′ was 
previously I.
As shown in the characteristic table in Fig. 6-6(c), the JK flip-flop behaves like an RS 
flip-flop, except when both J and K are equal to 1. When both J and K are 1, the clock pulse is 
transmitted through one AND gate only—the one whose input is connected to the flip-flop out-
put which is presently equal to 1. Thus, if Q = 1, the output of the upper AND gate becomes 1 
upon application of a clock pulse, and the flip-flop is cleared. If Q′ = 1, the output of the lower 
AND gate becomes a 1 and the flip-flop is set. In either case, the output state of the flip-flop is complemented.
The inputs in the graphic symbol for the JK flip-flop must be marked with a J (under Q) and 
K (under (Q′). The characteristic equation is given in Fig. 6-4(d) and is derived from the map of 
the characteristic table.
Note that because of the feedback connection in the JK flip-flop, a CP signal which remains 
a 1 (while J = K = 1) after the outputs have been complemented once will cause repeated and 
continuous transitions of the outputs. To avoid this undesirable operation, the clock pulses must have a time duration which is shorter than the propagation delay through the flip-flop. This is a restrictive requirement, since the operation of the circuit depends on the width of the pulses. For this reason, JK flip-flops are never constructed as shown in Fig, 6-6(a). The restriction on the 
pulse width can be eliminated with a master-slave or edge-triggered construction, as discussed in the next section. The same reasoning applies to the T flip-flop presented below.
The T flip-flop is a single-input version of the JK flip-flop. As shown in Fig. 6-7(a), the T 
flip-flop is obtained from a JK type if both inputs are tied together. The designation T comes from 
the ability of the flip-flop to “toggle,” or change state. Regardless of the present state of the flip-flop, it assumes the complement state when the clock pulse occurs while input T is logic-1. The 
symbol, characteristic table, and characteristic equation of the T flip-flop are shown in Fig. 6-7, 
parts (b), (c), and (d), respectively.
The flip-flops introduced in this section are the most common types available commercially. 
The analysis and design procedures developed in this chapter are applicable for any clocked flip-flop once its characteristic table is defined.
6.3 Triggering of Flip-flops
The state of a flip-flop is switched by a momentary change in the input signal. This momentary change is called a trigger and the transition it causes is said to trigger the flip-flop. Asynchronous 
flip-flops, such as the basic circuits of Figs. 6-2 and 6-3, require an input trigger defined by a change of signal level. This level must be returned to its initial value (0 in the NOR and 1 in the 
NAND flip-flop) before a second trigger is applied. Clocked flip-flops are triggered by pulses. A pulse starts from an initial value of 0, goes momentarily to 1, and after a short time, returns to its initial 0 value. The time interval from the application of the pulse until the output transition occurs is a critical factor that needs further investigation.
As seen from the block diagram of Fig. 6-1, a sequential circuit has a feedback path be-
tween the combinational circuit and the memory elements. This path can produce instability if 
186 Chapter 6
the outputs of memory elements (flip-flops) are changing while the outputs of the combinational 
circuit that go to flip-flop inputs are being sampled by the clock pulse. This timing problem can be prevented if the outputs of flip-flops do not start changing until the pulse input has returned to 0. To ensure such an operation, a flip-flop must have a signal propagation delay from input to output in excess of the pulse duration. This delay is usually very difficult to control if the designer depends entirely on the propagation delay of logic gates. One way of ensuring the proper delay is to include within the flip-flop circuit a physical delay unit having a delay equal to or greater than the pulse duration. A better way to solve the feedback timing problem is to make the flip-flop sensitive to the pulse transition rather than the pulse duration.
A clock pulse may be either positive or negative. A positive clock source remains at 0 dur -
ing the interval between pulses and goes to 1 during the occurrence of a pulse. The pulse goes through two signal transitions; from 0 to 1 and the return from 1 to 0. As shown in Fig. 6-8, the positive transition is defined as the positive edge and the negative transition as the negative edge. This definition applies also to negative pulses.
The clocked flip-flops introduced in Section 6-2 are triggered during the positive edge of 
the pulse, and the state transition starts as soon as the pulse reaches the logic-1 level. The new state of the flip-flop may appear at the output terminals while the input pulse is still 1. If the other inputs of the flip-flop change while the clock is still 1, the flip-flop will start responding to these new values and a new output state may occur. When this happens, the output of one flip-flop cannot be applied to the inputs of another flip-flop when both are triggered by the same clock QT
CP
Q´
(a)  Logic diagram
Q
TQ´
CP
(b) Graphic symbolQT
0
0
1
101
0
10
1
1
0Q(t+1)
(c) Characteristic table 0 1
Q(t − 1) = TQ´ − T´Q0
111
QT
(d) Characteristic equation
Figure 6.7 Clocked T flip-flop
Sequential Logic  187 
pulse. However, if we can make the flip-flop respond to the positive (or negative) edge transition 
only, instead of the entire pulse duration, then the multiple-transition problem can be eliminated.
One way to make the flip-flop respond only to a pulse transition is to use capacitive cou-
pling. In this configuration, an RC (resistor-capacitor) circuit is inserted in the clock input of 
the flip-flop. This circuit generates a spike in response to a momentary change of input signal. A positive edge emerges from such a circuit with a positive spike, and a negative edge emerges with a negative spike. Edge triggering is achieved by designing the flip-flop to neglect one spike and trigger on the occurrence of the other spike. Another way to achieve edge triggering is to use a master-slave or edge-triggered flip-flop as discussed below.
6.3.1 Master-Slave Flip-Flop
A master-slave flip-flop is constructed from two separate flip-flops. One circuit serves as a master and the other as a slave, and the overall circuit is referred to as a master-stave flip-flop. The logic diagram of an RS master-slave flip-flop is shown in Fig. 6-9. It consists of a master flip-flop, a 
slave flip-flop, and an inverter. When clock pulse CP is 0, the output of the inverter is 1. Since the 0Positiv e pulse
Positiv e 
 edgeNegative 
 edge1Negative pulse
Positiv e 
edgeNegative 
edge
Figure 6.8 Definition of clock pulse transition
Mast er
MASTER-SLA VE FLIP -FLOPS
RSYQ
Q´Y´RS
R
CPSlave
Figure 6.9 Logic diagram of master-slave flip-flop
188 Chapter 6
clock input of the slave is 1, the flip-flop is enabled and output Q is equal to Y, while Q′ is equal 
to Y′. The master flip-flop is disabled because CP = 0. When the pulse becomes 1, the informa-
tion then at the external R and S inputs is transmitted to the master flip-flop. The slave flip-flop, 
however, is isolated as long as the pulse is at its 1 level, because the output of the inverter is 0. 
When the pulse returns to 0, the master flip-flop is isolated, which prevents the external inputs from affecting it. The slave flip-flop then goes to the same state as the master flip-flop.
The timing relationships shown in Fig. 6-10 illustrate the sequence of events that occur in 
a master-slave flip-flop. Assume that the flip-flop is in the clear state prior to the occurrence of a pulse, so that Y = 0 and Q = 0. The input conditions are S = 1, R = 0, and the next clock pulse 
should change the flip-flop to the set state with Q = 1. During the pulse transition from 0 to 1, 
the master flip-flop is set and changes Y to 1. The slave flip-flop is not affected because its CP 
input is 0. Since the master flip-flop is an internal circuit, its change of state is not noticeable in the outputs Q and Q′. When the pulse returns to 0, the information from the master is allowed to 
pass through to the slave, making the external output Q = 1. Note that the external S input can be 
changed at the same time that the pulse goes through its negative edge transition. This is because, once the CP reaches 0, the master is disabled and its R and S inputs have no influence until the 
next clock pulse occurs. Thus, in a master-slave flip-flop, it is possible to switch the output of the flip-flop and its input information with the same clock pulse. It must be realized that the S input 
could come from the output of another master-slave flip-flop that was switched with the same clock pulse.
The behavior of the master-slave flip-flop just described dictates that the state changes in all 
flip-flops coincide with the negative edge transition of the pulse. However, some IC master-slave flip-flops change output states in the positive edge transition of clock pulses. This happens in flip-flops that have an additional inverter between the CP terminal and the input of the master. Such 
flip-flops are triggered with negative pulses (see Fig. 6-8), so that the negative edge of the pulse affects the master and the positive edge affects the slave and the output terminals.
The master-slave combination can be constructed for any type of flip-flop by adding a 
clocked RS flip-flop with an inverted clock to form the slave. An example of a master-slave JK 
flip-flop constructed with NAND gates is shown in Fig. 6-11. It consists of two flip-flops; gates 1 through 4 form the master flip-flop, and gates 5 through 8 form the slave flip-flop. The infor -SCP
Y
Q
Figure 6.10 Timing relationships in a master-slave flip-flop
Sequential Logic  189 
mation present at the J and K inputs is transmitted to the master flip-flop on the positive edge of 
a clock pulse and is held there until the negative edge of the clock pulse occurs, after which it 
is allowed to pass through to the slave flip-flop. The clock input is normally 0, which keeps the outputs of gates 1 and 2 at the 1 level. This prevents the J and K inputs from affecting the master 
flip-flop. The slave flip-flop is a clocked RS type, with the master flip-flop supplying the inputs 
and the clock input being inverted by gate 9. When the clock is 0, the output of gate 9 is 1, so that output Q is equal to Y. and Q′ is equal to Y′. When the positive edge of a clock pulse occurs, 
the master flip-flop is affected and may switch states. The slave flip-flop is isolated as long as the clock is at the 1 level, because the output of gate 9 provides a 1 to both inputs of the NAND basic flip-flop of gates 7 and 8. When the clock input returns to 0, the master flip-flop is isolated from the J and K inputs and the slave flip-flop goes to the same state as the master flip-flop.
Now consider a digital system containing many master-slave flip-flops, with the outputs of 
some flip-flops going to the inputs of other flip-flops. Assume that clock pulse inputs to all flip-flops are synchronized (occur at the same time). At the beginning of each clock pulse, some of the master elements change state, but all flip-flop outputs remain at their previous values. After 
the clock pulse returns to 0. some of the outputs change state, but none of these new states have an effect on any of the master elements until the next clock pulse. Thus the states of flip-flops in the system can be changed simultaneously during the same clock pulse, even though outputs of flip-flops are connected to inputs of flip-flops. This is possible because the new state appears at the output terminals only after the clock pulse has returned to 0. Therefore, the binary content of one flip-flop can be transferred to a second flip-flop and the content of the second transferred to the first, and both transfers can occur during the same clock pulse.
6.3.2 Edge-Triggered Flip-Flop
Another type of flip-flop that synchronizes the state changes during a clock pulse transition is the 
edge-triggered flip-flop. In this type of flip-flop, output transitions occur at a specific level of the 
clock pulse. When the pulse input level exceeds this threshold level, the inputs are locked out and the flip-flop is therefore unresponsive to further changes in inputs until the clock pulse returns to 0 and another pulse occurs. Some edge-triggered flip-flops cause a transition on the positive edge of the pulse, and others cause a transition on the negative edge of the pulse.Q
KJ 1
23
45Y
Y´67
8
9 CPQ´
Figure 6.11 Clocked master-slave JK flip-flop
190 Chapter 6
The logic diagram of a D-type positive-edge-triggered flip-flop is shown in Fig. 6-12. It 
consists of three basic flip-flops of the type shown in Fig, 6-3. NAND gates 1 and 2 make up 
one basic flip-flop and gates 3 and 4 another. The third basic flip-flop comprising gates 5 and 6 provides the outputs to the circuit. Inputs 5 and R of the third basic flip-flop must be maintained 
at logic-1 for the outputs to remain in their steady-state values, When S = 0 and R = 1, the output 
goes to the set state with Q = 1. When S = 1 and R = 0, the output goes to the clear state with Q = 
0. Inputs S and R are determined from the states of the other two basic flip-flops. These two basic 
flip-flops respond to the external inputs D (data) and CP (clock pulse).
The operation of the circuit is explained in Fig. 6-13, where gates 1-4 are redrawn to show 
all possible transitions. Outputs S and R from gates 2 and 3 go to gates 5 and 6, as shown in Fig. 
6-12, to provide the actual outputs of the flip-flop. Figure 6-13(a) shows the binary values at the outputs of the four gates when CP = 0. Input D may be equal to 0 or 1. In either case, a CP of 0 
causes the outputs of gates 2 and 3 to go to I, thus making S = R = 1, which is the condition for a steady-state output. When D = 0, gate 4 has a 1 output, which causes the output of gate 1 to go 
to 0. When D = 1, gate 4 goes to 0, which causes the output of gate 1 to go to 1. These are the 
two possible conditions when the CP terminal, being 0, disables any changes at the outputs of the 
flip-flop, no matter what the value of D happens to be.
There is a definite time, called the setup time, in which the D input must be maintained at 
a constant value prior to the application of the pulse. The setup time is equal to the propagation 
delay through gates 4 and 1 since a change in D causes a change in the outputs of these two gates. 
Assume now that D does not change during the setup time and that input CP becomes 1. This 
situation is depicted in Fig. 6-13(b). If D = 0 when CP becomes I. then S remains 1 but R changes 
to 0. This causes the output of the flip-flop Q to go to 0 (in Fig, 6-12). If now, while CP = 1, there 
is a change in the D input, the output of gate 4 will remain at 1 (even if D goes to 1), since one 
of the gate inputs comes from R which is maintained at 0. Only when CP returns to 0 can the 
output of gate 4 change; but then both R and S become 1, disabling any changes in the output Q
DS1
5
62
3
4RCP
Q´
Figure 6.12 D-type positive-edge-triggered flip-flop
Sequential Logic  191 
of the flip-flop. However, there is a definite time, called the hold time, that the D input must not 
change after the application of the positive-going transition of the pulse. The hold time is equal 
to the propagation delay of gate 3, since it must be ensured that R becomes 0 in order to maintain 
the output of gate 4 at 1, regardless of the value of D.
If D = 1 when CP = 1, then S changes to 0 but R remains at 1, which causes the output of 
the flip-flop Q to go to 1. A change in D while CP = 1 does not alter S and R because gate t is 
maintained at 1 by the 0 signal from S. When CP goes to zero, both S and R go to 1 to prevent the 
output from undergoing any changes.
In summary, when the input clock pulse makes a positive-going transition, the value of D 
is transferred to Q. Changes in D when CP is maintained at a steady 1 value do not affect Q. 
Moreover, a negative pulse transition does not affect the output, nor does it when CP = 0. Hence, 
the edge-triggered flip-flop eliminates any feedback problems in sequential circuits just as a master-slave flip-flop does. The setup time and hold time must be taken into consideration when using this type of flip-flop.1
CP = 0S0
1
1
1R
D = 02
3
41
CP = 0S1
1
1
0R
D = 12
3
4
1
CP = 0S0
1
0
1R
D = 02
3
41
CP = 1S1
0
1
0R
D = 12
3
4(a) With CP = 0
(b) With CP = 1
Figure 6.13 Operation of the D-type edge-triggered flip-flop
192 Chapter 6
When using different types of flip-flops in the same sequential circuit, one must ensure that 
all flip-flop outputs make their transitions at the same time, i.e., during either the negative edge 
or the positive edge of the pulse. Those flip-flops that behave opposite from the adopted polarity transition can be changed easily by the addition of inverters in their clock inputs. An alternate procedure is to provide both positive and negative pulses (by means of an inverter), and then ap-ply the positive pulses to flip-flops that trigger during the negative edge and negative pulses to flip-flops that trigger during the positive edge, or vice versa.
6.3.3 Direct Inputs
Flip-flops available in IC packages sometimes provide special inputs for setting or clearing the flip-flop asynchronously. These inputs are usually called direct preset and direct clear. They af-
fect the flip-flop on a positive (or negative) value of the input signal without the need for a clock 
pulse. These inputs are useful for bringing all flip-flops to an initial state prior to their clocked operation. For example, after power is turned on in a digital system, the states or its flip-flops are indeterminate. A clear switch clears all the flip-flops to an initial cleared state and a start switch 
begins the system’ s clocked operation. The clear switch must clear all flip-flops asynchronously without the need for a pulse.
The graphic symbol of a master-slave flip-flop with direct clear is shown in Fig. 6-14. The 
clock or CP input has a circle under the small triangle to indicate that the outputs change during 
the negative transition of the pulse. (The absence of the small circle would indicate a positive-
edge-triggered flip-flop.) The direct clear input also has a small circle to indicate that, normally, this input must be maintained at 1. If the clear input is maintained at 0, the flip-flop remains cleared, regardless of the other inputs or the clock pulse. The function table specifies the circuit operation. The X’s are don’t-care conditions which indicate that a 0 in the direct clear input dis-
ables all other inputs. Only when the clear input is 1 would a negative transition of the clock have an effect on the outputs. The outputs do not change if J = K = 0. The flip-flop toggles or comple-
ments when J = K = 1. Some flip-flops may also have a direct preset input which sets the output 
Q to 1 (and Q′ to 0) asynchronously.
When direct asynchronous inputs are available in a master-slave flip-flop, they must con-
nect to both the master and the stave in order to override the other inputs and the clock. A direct clear in the JK master-slave flip-flop of Fig. 6-10 is connected to the inputs of gales 1, 4, and 8. 
A direct clear in the D edge-triggered flip-flop of Fig. 6-12 is connected to the inputs of gates 2 
and 6.Q
KJQ´
CPClearClear
0
1
1
11X↓
↓
↓↓X0
0
11X0
1
01ClockJ
0       1
0       1
1       0
ToggleOutputs Inputs
Function tabl e
No changeKQ Q´
Figure 6.14 JK flip-flop with direct clear
Sequential Logic  193 
6.4 Analysis of Clocked Sequential Circuits
The behavior of a sequential circuit is determined from the inputs, the outputs, and the states 
of its flip-flops. Both the outputs and the next state are a function of the inputs and the present state. The analysis of sequential circuits consists of obtain ing a table or a diagram for the time 
sequence of inputs, outputs, and internal states. It is also possible to write Boolean expressions 
that describe the behavior of sequential circuits. However, these expressions must include the necessary time sequence either directly or indirectly.
A logic diagram is recognized as the circuit of a sequential circuit if it includes flip-flops. 
The flip-flops may be of any type and the logic diagram may or may not include combinational 
gates. In this section, we first introduce a specific example of a clocked sequential circuit and then present various methods for describing the behavior of sequential circuits. The specific ex-ample will be used throughout the discussion to illustrate the various methods.
6.4.1 An Example of a Sequential Circuit
An example of a clocked sequential circuit is shown in Fig. 6-15. It has one input variable x, one 
output variable y, and two clocked RS flip-flops labeled A and B. The cross-connections from 
outputs of flip-flops to inputs of gates are not shown by line drawings so as to facilitate the trac-ing of the circuit. Instead, the connections are recognized from the letter symbol marked in each input. For example, the input marked x′ in gate 1 designates an input from the complement of x. 
The second input marked A designates a connection to the normal output of flip-flop A. 
We shall assume negative edge triggering in both flip-flops and in the source that produces 
the external input x. Therefore, the signals for a given present, state are available during the time 
from the termination of a clock pulse to the termination of the next clock pulse, at which time the circuit goes to the next state.x
A
B´y
x´
A1
2
3
4x
A´
x
B´
x´
BRQ ´ B´CP
B
A´ASQ
RQ ´
SQ
Figure 6.15 Example of a clocked sequential circuit
194 Chapter 6
6.4.2 State Table
The time sequence of inputs, outputs, and flip-flop states may be enumerated in a state table.* The 
state table for the circuit of Fig. 6-15 is shown in Table 6-1. It consists of three sections labeled 
present state, next state, and output. The present state designates the states of flip-flops before the 
occurrence of a clock pulse. The next state shows the states of flip-flops after the application of a clock pulse, and the output section lists the values of the output variables during the present state. 
Both the next state and output sections have two columns, one for x = 0 and the other for x = 1.
The derivation of the state table starts from an assumed initial state. The initial state of most 
practical sequential circuits is defined to be the state with 0’ s in all flip-flops. Some sequential circuits have a different initial state and some have none at all. In either case, the analysis can always start from any arbitrary state. In this example, we start deriving the state table from the  
initial state 00.
When the present state is 00, A = 0 and B = 0. From the logic diagram, we see that with 
both flip-flops cleared and x = 0, none of the AND gates produce a logic-1 signal. Therefore, the next state remains unchanged. With AB = 00 and x = 1, gate 2 produces a logic-1 signal at the S 
input of flip-flop B and gate 3 produces a logic-1 signal at the R input of flip-flop A. When a clock 
pulse triggers the flip-flops, A is cleared and B is set, making the next state 01. This information 
is listed in the first row of the state table.
In a similar manner, we can derive the next state starting from the other three possible pres-
ent states. In general, the next state is a function of the inputs, the present state, and the type of flip-flop used. With RS flip-flops, for example, we must remember that a 1 in input S sets the 
flip-flop and a 1 in input R clears the flip-flop, regardless of its previous state. A 0 in both the S’ 
and R inputs leaves the flip-flop unchanged, whereas a 1 in both the S and R inputs shows a bad 
design and an indeterminate state table.
The entries for the output section are easier to derive. In this example, output y is equal to 
1 only when x = 1, A = 1, and B = 0. Therefore, the output columns are marked with 0’ s, except 
when the present state is 10 and input x = 1, for which y is marked with a 1.
The state table of any sequential circuit is obtained by the same procedure used in the ex-
ample. In general, a sequential circuit with m flip-flops and n input variables will have 2
m rows, 
one for each state. The next state and output sections each will have 2n columns, one for each 
input combination.
* Switching circuit theory books call this table a transition table. They reserve the name state table for a 
table with internal states represented by arbitrary symbols.Table 6-1 State table for circuit of Fig. 6-15
Next state Output
Present State x = 0 x = 1 x = 0 x = 1
AB AB AB y y
00 00 01 0 0
01 11 01 0 0
10 10 00 0 1
11 10 11 0 0
Sequential Logic  195 
The external outputs of a sequential circuit may come from logic gates or from memory ele-
ments. The output section in the state table is necessary only if there are outputs from logic gates. 
Any external output taken directly from a flip-flop is already listed in the present state column of the state table. Therefore, the output section of the state table can be excluded if there are no external outputs from logic gates.
6.4.3 State Diagram
The information available in a state table may be represented graphically in a state diagram. In this diagram, a state is represented by a circle, and the transition between states is indicated by directed lines connecting the circles. The state diagram of the sequential circuit of Fig. 6-15 is shown in Fig. 6-16. The binary number inside each circle identifies the state the circle represents. The directed lines are labeled with two binary numbers separated by a /. The input value that causes the state transition is labeled first; the number after the symbol / gives the value of the output during the present state. For example, the directed line from state 00 to 01 is labeled 1/0, meaning that the sequential circuit is in a present state 00 while x = 1 and x = 0, and that on the termination of the next clock pulse, the circuit goes to next state 01. A directed line connecting 
a circle with itself indicates that no change of state occurs. The state diagram provides the same information as the state table and is obtained directly from Table 6-1.
There is no difference between a state table and a state diagram except in the manner of 
representation. The state table is easier to derive from a given logic diagram and the state diagram 
follows directly from a state table. The state diagram gives a pictorial view of state transitions and is in a form suitable for human interpretation of the circuit operation. The state diagram is often used as the initial design specification of a sequential circuit.
6.4.4 State Equations
A state equation (also known as an application equation) is an algebraic expression that specifies 
the conditions for a flip-flop state transition. The left side of the equation denotes the next state of a flip-flop and the right side, a Boolean function that specifies the present state conditions 00
011/0
1/01/1
0/00/0
0/01/00/0
10
11
Figure 6.16 State diagram for the circuit of Fig. 6.16
196 Chapter 6
that make the next state equal to 1. A state equation is similar in form to a flip-flop characteristic 
equation, except that it specifies the next state conditions in terms of external input variables and other flip-flop values. The state equation is derived directly from a state table. For example, the state equation for flip-flop A is derived from inspection of Table 6-1. From the next state columns, 
we note that flip-flop A goes to the 1 state four times: when x = 0 and AB = 01 or 10 or 11, or when 
x = 1 and AB = 11. This can be expressed algebraically in a state equation as follows:
A(t + 1) = (A′B + AB′ + AB) x′ + ABx
The right-hand side of the state equation is a Boolean function for a present state. When this 
function is equal to 1, the occurrence of a clock pulse causes flip-flop A to have a next state of 1. 
When the function is equal to 0, the clock pulse causes A to have a next state of 0. The left side 
of the equation identifies the flip-flop by its letter symbol, followed by the time function designa-tion (t + 1), to emphasize that this value is to be reached by the flip-flop one pulse sequence later.
The state equation is a Boolean function with time included. It is applicable only in clock 
sequential circuits, since A (t + 1) is defined to change value with the occurrence of a clock pulse 
at discrete instants of time.
The state equation for flip-flop A is simplified by means of a map as shown in Fig. 6-17(a). 
With some algebraic manipulation, the function can be expressed in the following form:
A (t + 1) = B′x + (B′x)′A
If we let Bx′ = S and B′ x = R. we obtain the relationship:
A (t + 1) = S + R′A
which is the characteristic equation of an RS flip-flop [Fig. 6-4(d)]. This relationship between 
the state equation and the flip-flop characteristic equation can be justified from inspection of the logic diagram of Fig. 6-15. In it we see that the S input of flip-flop A is equal to the Boolean 
function Bx′ and the R input is equal to B′x. Substituting these functions into the flip-flop charac-
teristic equation results in its state equation for this sequential circuit.
The state equation for a flip-flop in a sequential circuit may be derived from a state table or 
from a logic diagram. The derivation from the state table consists of obtaining the Boolean func-tion specifying the conditions that make the next state of the flip-flop a 1. The derivation from a Bx
00 01 11 10B
A
x0
11 1
11
B(t + 1) = A´x + (A´+ x)B
          = Ax + (Ax´)´BBx
00 01 11 10B
A
A
x01 1 1 11
A(t+1) = Bx´ + (B + x´)A
          = Bx´ + (B´x)´A
Figure 6.17 State equation for flip-flops A and B
Sequential Logic  197 
logic diagram consists of obtaining the functions of the flip-flop inputs and substituting them into 
the flip-flop characteristic equation.
The derivation of the state equation for flip-flop B from the state table is shown in the map 
of Fig. 6-17(b). The 1’ s marked in the map are the present state and input combinations that cause the flip-flop to go to a next state of 1. These conditions are obtained directly from Table 6-1. The simplified form obtained in the map is manipulated algebraically, and the state equation obtained is:
B(t + 1) = A′x + (Ax′)′ B
The state equation can be derived directly from the logic diagram. From Fig. 6-15, we see 
that the signal for input S of flip-flop B is generated by the function A′ x and the signal for input 
R by the function Ax′. Substituting S = A′ x and R = Ax′ into an RS flip-flop characteristic equa-
tion given by:
B (t + 1) = S + R′B
we obtain the state equation derived above.
The state equations of all flip-flops, together with the output functions, fully specify a se-
quential circuit. They represent, algebraically, the same information a state table represents in tabular form and a state diagram represents in graphical form.
6.4.5 Flip-flop Input Functions
The logic diagram of a sequential circuit consists of memory elements and gates. The type of flip-flops and their characteristic table specify the logical properties of the memory elements. The interconnections among the gates form a combinational circuit and may be specified al-gebraically with Boolean functions. Thus, knowledge of the type of flip-flops and a list of the Boolean functions of the combinational circuit provide all the information needed to draw the logic diagram of a sequential circuit. The part of the combinational circuit that generates exter -
nal outputs is described algebraically by the circuit output functions. The part of the circuit that generates the inputs to flip-flops are described algebraically by a set of Boolean functions called flip-flop input functions or sometimes input equations.
We shall adopt the convention of using two letters to designate a flip-flop input variable: the 
first to designate the name of the input and the second the name of the flip-flop. As an example, consider the following flip-flop input functions:
JA = BC′ x + B′Cx′
   KA = B + y
JA and KA designate two Boolean variables. The first letter in each denotes the J and K input, 
respectively, of a JK flip-flop. The second letter A is the symbol name of the flip-flop. The right 
side of each equation is a Boolean function for the corresponding flip-flop input variable. The implementation of the two input functions is shown in the logic diagram of Fig. 6-18. The JK flip-
flop has an output symbol A and two inputs labeled J and K. The combinational circuit drawn in 
the diagram is the implementation of the algebraic expression given by the input functions. The outputs of the combinational circuit are denoted by JA and KA in the input functions and go to 
the J and K inputs, respectively, of flip-flop A.
198 Chapter 6
From this example, we see that a flip-flop input function is an algebraic expression for a 
combinational circuit. The two-letter designation is a variable name for an output of the combi-
national circuit. This output is always connected to the input (designated by the first letter) of a 
flip-flop (designated by the second letter).
The sequential circuit of Fig. 6-15 has one input x, one output y and two RS flip-flops 
denoted by A and B. The logic diagram can be expressed algebraically with four flip-flop input 
functions and one circuit output function as follows:
SA = Bx′  RA = B′x
SB = A′x  RB = Ax′
   y = AB′x  
This set of Boolean functions fully specifies the logic diagram, Variables SA and RA specify 
an RS flip-flop labeled A; variables SB and RB specify a second RS flip-flop labeled B. Variable 
y denotes the output. The Boolean expressions for the variables specify the combinational circuit 
part of the sequential circuit.
The flip-flop input functions constitute a convenient algebraic form for specifying a logic 
diagram of a sequential circuit. They imply the type of flip-flop from the first letter of the input 
variable and they fully specify the combinational circuit that drives the flip-flop. Time is not in-cluded explicitly in these equations but is implied from the clock pulse operation. It is sometimes convenient to specify a sequential circuit algebraically with circuit output functions and flip-flop input functions instead of drawing the logic diagram.
6.5 State Reduction and Assignment†
The analysis of sequential circuits starts from a circuit diagram and culminates in a state table or diagram. The design of a sequential circuit starts from a set of specifications and culminates in a logic diagram. Design procedures are presented starting from Section 6-7. This section discusses certain properties of sequential circuits that may be used to reduce the number of gates and flip-flops during the design.
†This section may be omitted without loss of continuity.BB
yCP
xC´A´
A
B´
x´CKQ ´
JQ
Figure 6.18 Implementation of the flip-flop input functions JA = BC ′ x + B′Cx′ and KA = B + y
Sequential Logic  199 
6.5.1 State Reduction
Any design process must consider the problem of minimizing the cost of the final circuit. The 
two most obvious cost reductions are reductions in the number of flip-flops and the number of gates. Because these two items seem the most obvious, they have been extensively studied and investigated. In fact, a large portion of the subject of switching theory is concerned with finding algorithms for minimizing the number of flip-flops and gates in sequential circuits.
The reduction of the number of flip-flops in a sequential circuit is referred to as the state 
reduction problem. State reduction algorithms are concerned with procedures for reducing the 
number of states in a state table while keeping the external input-output requirements unchan-ged. Since m flip-flops produce 2
m states, a reduction in the number of states may (or may not) 
result in a reduction in the number of flip-flops. An unpredictable effect in reducing the number of flip-flops is that sometimes the equivalent circuit (with less flip-flops) may require more com-binational gates.
We shall illustrate the need for state reduction with an example. We start with a sequential 
circuit whose specification is given in the state diagram of Fig. 6-19. In this example, only the input-output sequences are important; the internal states are used merely to provide the required sequences. For this reason, the states marked inside the circles are denoted by letter symbols instead of by their binary values. This is in contrast to a binary counter, where the binary value sequence of the states themselves are taken as the outputs.
There are an infinite number of input sequences that may be applied to the circuit; each 
results in a unique output sequence. As an example, consider the input sequence 01010110100 starting from the initial state a. Each input of 0 or 1 produces an output of 0 or 1 and causes the 
circuit to go to the next state. From the state diagram, we obtain the output and state sequence for the given input sequence as follows: With the circuit in initial state a, an input of 0 produces 
an output of 0 and the circuit remains in state a. With present state a, and input of 1, the output 
1/0
1/01/0
1/1
1/11/1
1/10/0
0/0
0/0
0/00/0a
b
dc
g
fe0/00/0
Figure 6-19 State diagram
200 Chapter 6
is 0 and the next state is b. With present state b and input of 0, the output is 0 and next state is c. 
Continuing this process, we find the complete sequence to be as follows:
state a a b c d e f f g f g a
input 0 1 0 1 0 1 1 0 1 0 0
output 0 0 0 0 0 1 1 0 1 0 0
In each column, we have the present state, input value, and output value. The next state is writ-
ten on top of the next column. It is important to realize that in this circuit the states themselves are of secondary importance because we are interested only in output sequences caused by input sequences.
Now let us assume that we have found a sequential circuit whose state diagram has less than 
seven states and we wish to compare it with the circuit whose state diagram is given by Fig. 6-19. If identical input sequences are applied to the two circuits and identical outputs occur for all input sequences, then the two circuits are said to be equivalent (as far as the input-output is concerned) and one may be replaced by the other. The problem of state reduction is to find ways of reducing the number of states in a sequential circuit without altering the input-output relationships.
We shall now proceed to reduce the number of states for this example. First, we need the 
state table; it is more convenient to apply procedures for state reduction here than in state dia-grams. The state table of the circuit is listed in Table 6-2 and is obtained directly from the state diagram of Fig. 6-19.
An algorithm for the state reduction of a completely specified state table is given here 
without proof: “Two states are said to be equivalent if, for each member of the set of inputs, they give exactly the same output and send the circuit either to the same state or to an equivalent state. When two states are equivalent, one of them can be removed without altering the input-output relationships.”
We shall apply this algorithm to Table 6-2. Going through the state table, we look for two 
present states that go to the same next state and have the same output for both input combina-tions. States g and e are two such states; they both go to states a and f and have outputs of 0 and 
1 for x = 0 and x = 1, respectively. Therefore, states g and e are equivalent; one can be removed. Table 6-2 State table
Next state Output
Present state x = 0 x = 1 x = 0 x = 1
a a b 0 0
b c d 0 0
c a d 0 0
d e f 0 1
e a f 0 1
f g f 0 1
g a f 0 1
Sequential Logic  201 
The procedure of removing a state and replacing it by its equivalent is demonstrated in Table 6-3. 
The row with present state g is crossed out and state g is replaced by state e each time it occurs 
in the next state columns.
Present state f now has next states e and f and outputs 0 and 1 for x = 0 and x = 1, respec-
tively. The same next states and outputs appear in the row with present state d. Therefore, states f 
and d are equivalent; state f can be removed and replaced by d. The final reduced table is shown 
in Table 6-4. The state diagram for the reduced table consists of only five states and is shown in Fig. 6-20. This state diagram satisfies the original input-output specifications and will produce the required output sequence for any given input sequence. The following list derived from the state diagram of Fig. 6-20 is for the input sequence used previously. We note that the same output sequence results although the state sequence is different:
state a a b c d e d d e d e a
input 0 1 0 1 0 1 1 0 1 0 0
output 0 0 0 0 0 1 1 0 1 0 0
In fact, this sequence is exactly the same as that obtained for Fig. 6-19, if we replace e by  
g and d by f.
It is worth noting that the reduction in the number of states of a sequential circuit is possible 
if one is interested only in external input-output relationships. When external outputs are taken Next state Output
Present state x = 0 x = 1 x = 0 x = 1
a a b 0 0
b c d 0 0
c a d 0 0
d e f d 0 1
e a f d 0 1
f g e f 0 1
g a f 0 1Table 6-3 Reducing the state table
Table 6-4 Reduced state table
Next state Output
Present state x = 0 x = 1 x = 0 x = 1
a a b 0 0
b c d 0 0
c a d 0 0
d e d 0 1
e a d 0 1
202 Chapter 6
directly from flip-flops, the outputs must be independent of the number of states before state 
reduction algorithms are applied.
The sequential circuit of this example was reduced from seven to five states. In either case, 
the representation of the states with physical components requires that we use three flip-flops, because m flip-flops can represent up to 2
m distinct states. With three flip-flops, we can formulate 
up to eight binary states denoted by binary numbers 000 through 111, with each bit designating the state of one flip-flop. If the state table of Table 6-2 is used, we must assign binary values to seven states; the remaining state is unused. If the state table of Table 6-4 is used, only five states need binary assignment, and we are left with three unused states, Unused states are treated as don’t-care conditions during the design of the circuit. Since don’t-care conditions usually help in obtaining a simpler Boolean function, it is more likely that the circuit with five states will require fewer combinational gates than the one with seven states. In any case, the reduction from seven to five states does not reduce the number of flip-flops. In general, reducing the number of states in a state table is likely to result in a circuit with less equipment. However, the fact that a state table has been reduced to fewer states does not guarantee a saving in the number of flip-flops or the number of gates.
6.5.2 State Assignment
The cost of the combinational circuit part of a sequential circuit can be reduced by using the known simplification methods for combinational circuits. However, there is another factor, known as the state assignment problem, that comes into play in minimizing the combinational gates. State assignment procedures are concerned with methods for assigning binary values to states in such a way as to reduce the cost of the combinational circuit that drives the flip-flops. This is particularly helpful when a sequential circuit is viewed from its external input-output terminals. Such a circuit may follow a sequence of internal states, but the binary values of the individual states may be of no consequence as long as the circuit produces the required sequence of outputs for any given sequence of inputs. This does not apply to circuits whose external out-puts are taken directly from flip-flops with binary sequences fully specified.
The binary state assignment alternatives available can be demonstrated in conjunction with 
the sequential circuit specified in Table 6-4. Remember that, in this example, the binary values 1/01/0
1/01/1
1/10/0
0/0
0/0
0/00/0
b
dc ea
Figure 6-20 Reduced state diagram
Sequential Logic  203 
of the states are immaterial as long as their sequence maintains the proper input-output rela-
tionships. For this reason, any binary number assignment is satisfactory as long as each state is assigned a unique number. Three examples of possible binary assignments are shown in Table 6-5 for the five states of the reduced table. Assignment 1 is a straight binary assignment for the sequence of states from a through e. The other two assignments are chosen arbitrarily. In fact, 
there are 140 different distinct assignments for this circuit (11).
Table 6-6 is the reduced state table with binary assignment 1 substituted for the letter sym-
bols of the five states.
‡ It is obvious that a different binary assignment will result in a state table 
with different binary values for the states, while the input-output relationships remain the same. The binary form of the state table is used to derive the combinational circuit part of the sequen-tial circuit. The complexity of the combinational circuit obtained depends on the binary state assignment chosen. The design of the sequential circuit presented in this section is completed in Example 6-1 of Section 6-7.
Various procedures have been suggested that lead to a particular binary assignment from 
the many available. The most common criterion is that the chosen assignment should result in a simple combinational circuit for the flip-flop inputs. However, to date, there are no state assign-ment procedures that guarantee a minimal-cost combinational circuit. State assignment is one of the challenging problems of switching theory. The interested reader will find a rich and growing literature on this topic. Techniques for dealing with the state assignment problem are beyond the scope of this book.
‡A state table with binary assignment is sometimes called a transition table.Table 6-5 Three possible binary state assignments
State Assignment I Assignment 2 Assignment 3
a 001 000 000
b 010 010 100
c 011 011 010
d 100 101 101
e 101 111 011
Table 6-6 Reduced state table with binary assignment 1
Next state Output
Present state x = 0 x = 1 x = 0 x = 1
001 001 010 0 0
010 011 100 0 0
011 001 100 0 0
100 101 100 0 1
101 001 100 0 1
204 Chapter 6
6.6 Flip-flop Excitation Tables
The characteristic tables for the various flip-flops were presented in Section 6-2. A characteris-
tic table defines the logical property of the flip-flop and completely characterizes its operation. Integrated-circuit flip-flops are sometimes defined by a characteristic table tabulated somewhat differently. This second form of the char acteristic tables for RS, JK, D, and T flip-flops is shown 
in Table 6-7. They represent the same information as the characteristic tables of Figs. 6-4(c) through 6-7(c).
Table 6-7 defines the state of each flip-flop as a function of its inputs and previous state. Q 
(t) refers to the present state and Q(t + 1) to the next state after the occurrence of a clock pulse. 
The characteristic table for the RS flip-flop shows that the next state is equal to the present state 
when inputs S and R are both 0. When the R input is equal to 1, the next clock pulse clears the 
flip-flop. When the S input is equal to 1, the next clock pulse sets the flip-flop. The question mark 
for the next state when S and R are both equal to 1 simultaneously designates an indeterminate 
next state.
The table for the JK flip-flop is the same as that for the RS when J and K are replaced by 
S and R, respectively, except for the indeterminate case. When both A and K are equal to 1, the 
next state is equal to the complement of the present state, i.e., Q(t + 1) = Q′(t). The next state of 
the D flip-flop is completely dependent on the input D and independent of the present state. The 
next state of the T flip-flop is the same as the present state if T = 0 and complemented if T = 1.
The characteristic table is useful for analysis and for defining the operation of the flip-flop. 
It specifies the next state when the inputs and present state are known. During the design process we usually know the transition from present state to next state and wish to find the flip-flop input conditions that will cause the required transition. For this reason, we need a table that lists the required inputs for a given change of state. Such a list is called an excitation table.
Table 6-8 presents the excitation tables for the four flip-flops. Each table consists of two 
columns, Q (t) and Q(t + 1), and a column for each input to show how the required transition 
is achieved. There are four possible transitions from present state to next state. The required in-put conditions for each of the four transitions are derived from the information available in the 
Table 6-7 Flip-flop characteristic tables
S R Q(t + 1) J K Q(t + 1)
0 0 Q(t) 0 0 Q (t)
0 1 0 0 1 0
1 0 1 1 0 1
1 1 ? 1 1 Q′(t)
    (a) RS           (b) JK
D Q (t + 1) T Q (t + 1)
0 0 0 Q (t)
1 1 1 Q′(t)
        (c) D               (d) T
Sequential Logic  205 
characteristic table. The symbol X in the tables represents a don’t-care condition, i.e., it does not 
matter whether the input is 1 or 0.
6.6.1 RS Flip-flop
The excitation table for the RS flip-flop is shown in Table 6-8(a). The first row shows the flip-flop 
in the 0-state at time t. It is desired to leave it in the 0-state after the occurrence of the pulse. 
From the characteristic table, we find that if S and R are both 0, the flip-flop will not change state. 
Therefore, both S and R inputs should be 0. However, it really doesn’t matter if R is made a 1 
when the pulse occurs, since it results in leaving the flip-flop in the 0-state. Thus, R can be 1 or 
0 and the flip-flop will remain in the 0-state at t + 1, Therefore, the entry under R is marked by 
the don’t-care condition X.
If the flip-flop is in the 0-state and it is desired to have it go to the l-state, then from the char -
acteristic table, we find that the only way to make Q(t + 1) equal to 1 is to make S = 1 and R = 0. 
If the flip-flop is to have a transition from the 1-state to the 0-state, we must have S = 0 and R = 1.
The last condition that may occur is for the flip-flop to be in the 1-state and remain in the 
1-state. Certainly R must be 0; we do not want to clear the flip-flop. However, S may be either 
a 0 or a 1. If it is 0, the flip-flop does not change and remains in the 1-state; if it is 1, it sets the 
flip-flop to the 1-state as desired. Therefore, S is listed as a don’t-care condition.
6.6.2 JK Flip-Flop
The excitation table for the JK flip-flop is shown in Table 6-8(b). When both present state and 
next state are 0, the J input must remain at 0 and the K input can be either 0 or 1. Similarly, when 
both present state and next state are 1, the K input must remain at 0 while the J input can be 0 or 
1. If the flip-flop is to have a transition from the 0-state to the 1-state. J must be equal to 1 since the J input sets the flip-flop. However, input K may be either 0 or a 1. If K = 0, the J = 1 condition Table 6-8 Flip-flop excitation tables
Q(t) Q(t + 1) S R Q(t) Q(t + 1) J K
0 0 0 X 0 0 0 X
0 1 1 0 0 1 1 X
1 0 0 1 1 0 X 1
1 1 X 0 1 1 X 0
                                        (a) RS         (b) JK
Q(t) Q(t + 1) D Q(t) Q(t + 1) T
0 0 0 0 0 0
0 1 1 0 l 1
1 0 0 1 0 1
1 1 1 1 1 0
          (c) D                 (d) T
206 Chapter 6
sets the flip-flop as required; if K = 1 and J =1, the flip-flop is complemented and goes from the 
0-state to the 1-state as required. Therefore the K input is marked with a don’t-care condition for 
the 0-to-1 transition. For a transition from the 1-state to the 0-state, we must have K = 1, since 
the K input clears the flip-flop. However, the J input may be either 0 or 1, since J = 0 has no ef-
fect, and J = 1 together with K = 1 complements the flip-flop with a resultant transition from the 
1-state to the 0-state.
The excitation table for the JK flip-flop illustrates the advantage of using this type when 
designing sequential circuits. The fact that it has so many don’t-care conditions indicates that the combinational circuits for the input functions are likely to be simpler because don’t-care terms usually simplify a function.
6.6.3 D Flip-Flop
The excitation table for the D flip-flop is shown in Table 6-8(c). From the characteristic table, 
Table 6-7(c), we note that the next state is always equal to the D input and independent of the 
present state. Therefore, D must be 0 if Q(t + 1) has to be 0, and 1 if Q(t + 1) has to be 1, regard-
less of the value of Q (t).
6.6.4 T Flip-Flop
The excitation table for the T flip-flop is shown in Table 6-8(d). From the characteristic table, 
Table 6-7(d), we find that when input T = 1, the state of the flip-flop is complemented; when  
T = 0, the state of the flip-flop remains unchanged. Therefore, when the state of the flip-flop must 
remain the same, the requirement is that T = 0. When the state of the flip-flop has to be comple-
mented, T must equal 1.
6.6.5 Other Flip-Flops
The design procedure to be described in this chapter can be used with any flip-flop. It is neces-
sary that the flip-flop characteristic table, from which it is possible to develop a new excitation table, be known. The excitation table is then used to determine the flip-flop input functions, as explained in the next section.
6.7 Design Procedure
The design of a clocked sequential circuit starts from a set of specifications and culminates in a logic diagram or a list of Boolean functions from which the logic diagram can be obtained. In contrast to a combinational circuit, which is fully specified by a truth table, a sequential circuit requires a state table for its specification. The first step in the design of sequential cir -
cuits is to obtain a state table or an equivalent representation, such as a state diagram or state  
equations.
A synchronous sequential circuit is made up of flip-flops and combinational gates. The 
design of the circuit consists of choosing the flip-flops and then finding a combinational gate structure which, together with the flip-flops, produces a circuit that fulfills the stated specifica-tions. The number of flip-flops is determined from the number of states needed in the circuit. The combinational circuit is derived from the state table by methods presented in this chapter. In fact, once the type and number of flip-flops are determined, the design process involves a  
Sequential Logic  207 
transformation from the sequential circuit problem into a combinational circuit problem. In this 
way the techniques of combinational circuit design can be applied.
This section presents a procedure for the design of sequential circuits. Although intended to 
serve as a guide for the beginner, this procedure can be shortened with experience. The procedure is first summarized by a list of consecutive recommended steps as follows:
1. The word description of the circuit behavior is stated. This may be accompanied by a state diagram, a timing diagram, or other pertinent information.
2. From the given information about the circuit, obtain the state table.
3. The number of states may be reduced by state reduction methods if the sequential circuit can be characterized by input-output relationships independent of the number of states.
4. Assign binary values to each state if the state table obtained in step 2 or 3 contains letter symbols.
5. Determine the number of flip-flops needed and assign a letter symbol to each.
6. Choose the type of flip-flop to be used.
7. From the state table, derive the circuit excitation and output tables.
8. Using the map or any other simplification method, derive the circuit output functions and the flip-flop input functions.
9. Draw the logic diagram.
The word specification of the circuit behavior usually assumes that the reader is familiar 
with digital logic terminology. It is necessary that the designer use intuition and experience to arrive at the correct interpretation of the circuit specifications, because word descriptions may be incomplete and inexact. However, once such a specification has been set down and the state table obtained, it is possible to make use of the formal procedure to design the circuit.
The reduction of the number of states and the assignment of binary values to the states were 
discussed in Section 6-5. The examples that follow assume that the number of states and the bi-nary assignment for the states are known. As a consequence, steps 3 and 4 of the design will not be considered in subsequent discussions.
It has already been mentioned that the number of flip-flops is determined from the number 
of states. A circuit may have unused binary states if the total number of states is less than 2
m. The 
unused states are taken as don’t-care conditions during the design of the combinational circuit part of the circuit.
The type of flip-flop to be used may be included in the design specifications or may depend 
on what is available to the designer. Many digital systems are constructed entirely with JK flip-
flops because they are the most versatile available. When many types of flip-flops are available, it is advisable to use the RS or D flip-flop for applications requiring transfer of data (such as shift 
registers), the T type for applications involving complementation (such as binary counters), and 
the JK type for general applications.
The external output information is specified in the output section of the state table. From it 
we can derive the circuit output functions. The excitation table for the circuit is similar to that of the individual flip-flops, except that the input conditions are dictated by the information available in the present state and next state columns of the state table. The method of obtaining the excita-tion table and the simplified flip-flop input functions is best illustrated by an example.
208 Chapter 6
We wish to design the clocked sequential circuit whose state diagram is given in Fig. 6-21. 
The type of flip-flop to be used is JK.
The state diagram consists of four states with binary values already assigned. Since the di-
rected lines are marked with a single binary digit without a /, we conclude that there is one input 
variable and no output variables. (The state of the flip-flops may be considered the outputs of the circuit.) The two flip-flops needed to represent the four states are designated A and B. The input 
variable is designated x.
The state table for this circuit, derived from the state diagram, is shown in Table 6-9. Note 
that there is no output section for this circuit. We shall now show the procedure for obtaining the excitation table and the combinational gate structure.
The derivation of the excitation table is facilitated if we arrange the state table in a different 
form. This form is shown in Table 6-10, where the present state and input variables are arranged in the form of a truth table. The next state value for each present state and input conditions is copied from Table 6-9. The excitation table of a circuit is a list of flip-flop input conditions that will cause the required state transitions and is a function of the type of flip-flop used. Since this example specified JK flip-flops, we need columns for the J and K inputs of flip-flops A (denoted 
by JA and KA) and B (denoted by JB and KB).
The excitation table for the JK flip-flop was derived in Table 6-8(b). This table is now used 
to derive the excitation table of the circuit. For example, in the first row of Table 6-10 we have a transition for flip-flop A from 0 in the present state to 0 in the next state. In Table 6-8(b) we find 
that a transition of states from 0 to 0 requires that input J = 0 and input K = X. So 0 and X are  00
1
11
1
0
000
11
1001
Figure 6-21 State diagram
Table 6-9 State table
Next state
Present state x = 0 x = 1
A B A B A B
0 0 0 0 0 1
0 1 1 0 0 1
1 0 1 0 1 1
1 1 1 1 0 0
Sequential Logic  209 
copied in the first row under JA and KA, respectively. Since the first row also shows a transition 
for flip-flop B from 0 in the present state to 0 in the next state, 0 and X are copied in the first row 
under JB and KB. The second row of Table 6-10 shows a transition for flip-flop B from 0 in the 
present state to 1 in the next state. From Table 6-8(b) we find that a transition from 0 to 1 requires 
that input J = 1 and input K = X. So 1 and X are copied in the second row under JB and KB, 
respectively. This process is continued for each row of the table and for each flip-flop, with the input conditions as specified in Table 6-8(b) being copied into the proper row of the particular flip-flop being considered.
Let us now pause and consider the information available in an excitation table such as Table 
6-10. We know chat a sequential circuit consists of a number of flip-flops and a combinational circuit. Figure 6-22 shows the two JK flip-flops needed for the circuit and a box to represent the 
combinational circuit. From the block diagram, it is clear that the outputs of the combinational circuit go to flip-flop inputs and external outputs (if specified). The inputs to the combinational circuit are the external inputs and the present state values of the flip-flops. Moreover, the Bool-ean functions that specify a combinational circuit are derived from a truth table that shows the input-output relations of the circuit. The truth table that describes the combinational circuit is available in the excitation table. The combinational circuit inputs are specified under the present state and input columns, and the combinational circuit outputs are specified under the flip-flop 
input columns. Thus, an excitation table transforms a state diagram to the truth table needed for the design of the combinational circuit part of the sequential circuit.
The simplified Boolean functions for the combinational circuit can now be derived. The 
inputs are the variables A, B, and x; the outputs are the variables JA, KA, JB, and KB. The infor -
mation from the truth table is transferred into the maps of Fig. 6-23, where the four simplified flip-flop input functions are derived:
JA = Bx′ KA = Bx
JB = x  KB = A  x
The logic diagram is drawn in Fig. 6-24 and consists of two flip-flops, two AND gates, one equivalence gate, and one inverter.Table 6-10 Excitation table
Inputs of combinational circuit
Next stateOutputs of combinational circuit
Present state Input Flip-flop inputs
A B X A B JA KA JB KB
0 0 0 0 0 0 X 0 X
0 0 1 0 1 0 X 1 X
0 1 0 1 0 1 X X 1
0 1 1 0 1 0 X X 0
1 0 0 1 0 X 0 0 X
1 0 1 1 1 X 0 1 X
1 1 0 1 1 X 0 X 0
I 1 1 0 0 X 1 X 1
210 Chapter 6
Q
KJQ´ Q
KJQ´
CPB
BxB´KA JA KB
Combinational
circuit
External
inputsExternal
outputs
(none)JBB´ A´
A´A
A
Figure 6-22 Block digram of sequential circuit
Bx
00 01 11 10B
A
A
x0
1 X X X X1
JA = Bx´ KA = BxX X
1X X
JB = xX X
X X 11
KB = A⊙xX1 X
1 XX
Figure 6-23 Maps for combinational circuit
Sequential Logic  211 
With some experience, it is possible to reduce the amount of work involved in the design 
of the combinational circuit. For example, it is possible to obtain the information for the maps of 
Fig. 6-23 directly from Table 6-9, without having to derive Table 6-10. This is done by systemati-cally going through each present state and input combination in Table 6-9 and comparing it with the binary values of the corresponding next state. The required input conditions as specified by the flip-flop excitation in Table 6-8 is then determined. Instead of inserting the 0, 1, or X thus 
obtained into the excitation table, it can be written down directly into the appropriate square of the appropriate map.
The excitation table of a sequential circuit with m flip-flops, k inputs per flip-flop, and n 
external inputs consists of m + n columns for the present state and input variables and up to  
2
m + n rows listed in some convenient binary count. The next state section has m columns, one 
for each flip-flop. The flip-flop input values are listed in mk columns, one for each input of each 
flip-flop. If the circuit contains j outputs, the table must include j columns. The truth table of 
the combinational circuit is taken from the excitation table by considering the m + n present 
state and input columns as inputs and the mk + j flip-flop input values and external outputs as  
outputs.
6.7.1 Design with Unused States
A circuit with m flip-flops would have 2m states. There are occasions when a sequential circuit 
may use less than this maximum number of states. States that are not used in specifying the se-quential circuit are not listed in the state table. When simplifying the input functions to flip-flops, the unused states can be treated as don’t-care conditions.
EXAMPLE 6-1: Complete the design of the sequential circuit presented in Section 6-5. Use 
the reduced state table with assignment 1 as given in Table 6-6. The circuit is to employ RS flip-flops.
The state table of Table 6-6 is redrawn in Table 6-11 in the form convenient for obtaining 
the excitation table. The flip-flop input conditions are derived from the present state and next state columns of the state table. Since RS flip-flops are used, we need to refer to Table 6-8(a) 
for the excitation conditions of this type of flip-flop. The three flip-flops are given variable names A, B, and C. The input variable is x and the output variable is y. The excitation table of 
the circuit provides all the information needed for the design.
There are three unused states in this circuit: binary states 000, 110, and 111. When an 
input of 0 or 1 is included with these unused states, we obtain six don’t-care minterms: 0, 1, 12, 13, 14, and 15. These six binary combinations are not listed in the table under present state and input and are treated as don’t-care terms.
The combinational circuit part of the sequential circuit is simplified in the maps of  
Fig. 6-25. There are seven maps in the diagram. Six maps are for simplifying the input func-tions for the three RS flip-flops. The seventh map is for simplifying the output y. Each map has 
six X’s in the squares of the don’t-care minterms 0, 1, 2, 13, 14, and 15. The other don’t-care 
terms in the maps come from the X’s in the flip-flop input columns of the table. The simplified 
functions are listed under each map. The logic diagram obtained from these Boolean func-tions is drawn in Fig. 6-26.
212 Chapter 6
One factor neglected up to this point in the design is the initial state of a sequential circuit. 
When power is first turned on in a digital system, one does not know in what state the flip-flops 
will settle. It is customary to provide a master-reset input whose purpose is to initialize the states 
of all flip-flops in the system. Typically, the master reset is a signal applied to all flip-flops asyn-chronously before the clocked operations start. In most cases flip-flops are cleared to 0 by the 
master-reset signal, but some may be set to 1. For example, the circuit of Fig. 6-26 may initially be reset to a state ABC = 001, since state 000 is not a valid state for this circuit.
But what if a circuit is not reset to an initial valid state? Or worse, what if, because of a 
noise signal or any other unforeseen reason, the circuit finds itself in one of its invalid states? Q
KJQ’A
Q
KJQ’B
xCP
Figure 6-24 Logic diagram of  sequential circuit
Table 6-11 Excitation table for Example 6-1
Present state Input Next state Flip-flop inputs Output
A B C x A B C SA RA SB RB SC RC y
0 0 1 0 0 0 1 0 X 0 X X 0 0
0 0 1 1 0 1 0 0 X 1 0 0 1 0
0 1 0 0 0 1 1 0 X X 0 1 0 0
0 1 0 1 1 0 0 1 0 0 1 0 X 0
0 1 1 0 0 0 1 0 X 0 1 X 0 0
0 1 1 1 1 0 0 1 0 0 1 0 1 0
1 0 0 0 1 0 1 X 0 0 X 1 0 0
1 0 0 1 1 0 0 X 0 0 X 0 X 1
1 0 1 0 0 0 1 0 1 0 X X 0 0
1 0 1 1 1 0 0 X 0 0 X 0 1 1
Sequential Logic  213 
In that case it is necessary to ensure that the circuit eventually goes into one of the valid states 
so it can resume normal operation. Otherwise, if the sequential circuit circulates among invalid states, there will be no way to bring it back to its intended sequence of state transitions. Although one can assume that this undesirable condition is not supposed to occur, a careful designer must ensure that this situation never occurs.
It was stated previously that unused states in a sequential circuit can be treated as don’t-care 
conditions. Once the circuit is designed, the m flip-flops in the system can be in any one of 2
m 
possible states. If some of these states were taken as don’t-care conditions, the circuit must be 
investigated to determine the effect of these unused states. The next state from invalid states can Cx
AB 00
0001
11
XX
XXX X
XXX
0111
1110
10C
x
SA = BxABX
X
XX XXX
X
1X
X
RA = Cx´X
X
XX XXX 1
SB = A´B´x
RB = BC + Bx111
XX
XX XXX
X
XXX X
1X
X 1
XXX
X
XX
X
SC = x´ RC = xX 11
XX
X1X XXX
Y = AxXX X
11XXX
Figure 6-25 Maps for simplifying the sequential circuit of Example 6-1
214 Chapter 6
be determined from the analysis of the circuit. In any case, it is always wise to analyze a circuit 
obtained from a design to ensure that no mistakes were made during the design process.
EXAMPLE 6-2: Analyze the sequential circuit obtained in Example 6-1 and determine the 
effect of the unused states.
The unused states are 000, 110, and 111. The analysis of the circuit is done by the 
method outlined in Section 6-4. The maps of  Fig. 6-25 may also help in the analysis. What is needed here is to start with the circuit diagram of Fig. 6-26 and derive the state table or dia-gram. If the derived state table is identical to Table 6-6 (or the state-table part of Table 6-11), then we know that the design is correct. In addition, we must determine the next states from the unused states 000. 110, and 111.
The maps of Fig. 6-25 can help in finding the next state from each of the unused states. 
Take, for instance, the unused state 000. If the circuit, for some reason, happens to be in the present state 000, an input x = 0 will transfer the circuit to some next state and an input x = 1 
will transfer it to another (or the same) next state. We first investigate minterm ABCx = 0000. From the maps, we see that this minterm is not included in any function except for SC, i.e., 
the set input of flip-flop C. Therefore, flip-flops A and B will not change but flip-flop C will Ry
A
B
C´
CPA´
B´Q´SQ
RQ´SQ
RQ ´SQx
Figure 6-26 Logic diagram for Example 6-1
Sequential Logic  215 
be set to 1. Since the present state is ABC = 000, the next state will be ABC = 001. The maps 
also show that minterm ABCx = 0001 is included in the functions for SB and RC. Therefore, 
B will be set and C will be cleared. Starting with ABC = 000 and setting B, we obtain the next 
state ABC = 010 (C is already cleared). Investigation of the map for outputs y shows that y 
will be 0 for these two minterms.
The result of the analysis procedure is shown in the state diagram of Fig. 6-27. The cir -
cuit operates as intended, as long as it stays within the states 001, 010, 011, 010, and 101. If it ever finds itself in one of the invalid states 000, 110, or 111, it goes to one of the valid states within one or two clock pulses. Thus the circuit is self-starting and self-correcting, since it eventually goes to a valid state from which it continues to operate as required.
An undesirable situation would have occurred if the next state of 110 for x = 1 happened 
to be 111 and the next state of 111 for x = 0 or 1 happened to be 110. Then, if the circuit starts 
from 110 or 111, it will circulate and stay between these two states forever. Unused states that cause such undesirable behavior should be avoided; if they are found to exist, the circuit should be redesigned. This can be done most easily by specifying a valid next state for any unused state that is found to circulate among invalid states.
6.8 Design of Counters
A sequential circuit that goes through a prescribed sequence of states upon the application of input pulses is called a counter. The input pulses, called count pulses, may be clock pulses, or 
they may originate from an external source and may occur at prescribed intervals of time or at random. In a counter, the sequence of states may follow a binary count or any other sequence of states. Counters are found in almost all equipment containing digital logic. They are used for counting the number of occurrences of an event and are useful for generating timing sequences to control operations in a digital system.
Of the various sequences a counter may follow, the straight binary sequence is the simplest 
and most straightforward. A counter that follows the binary sequence is called a binary counter, 1/01/0
1/0
1/01/1
1/1
1/1 1/1001
000
011 010
100
1111101010/00/0
0/00/0
0/00/00/0
0/0
Figure 6-27 State diagram for the circuit of Fig. 6-26
216 Chapter 6
An n-bit binary counter consists of n flip-flops and can count in binary from 0 to 2n - 1. As an 
example, the state diagram of a 3-bit counter is shown in Fig. 6-28. As seen from the binary states 
indicated inside the circles, the flip-flop outputs repeat the binary count sequence with a return to 000 after 111. The directed lines between circles are not marked with input-output values as in other state diagrams. Remember that state transitions in clocked sequential circuits occur during a clock pulse; the flip-flops remain in their present states if no pulse occurs. For this reason, the clock pulse variable CP does not appear explicitly as an input variable in a state diagram or state 
table. From this point of view, the state diagram of a counter does not have to show input-output values along the directed lines. The only input to the circuit is the count pulse, and the outputs are directly specified by the present states of the flip-flops. The next state of a counter depends en-tirely on its present state, and the state transition occurs every time the pulse occurs. Because of this property, a counter is completely specified by a list of the count sequence, i.e., the sequence of binary states that it undergoes.
The count sequence of a 3-bit binary counter is given in Table 6-12. The next number in the 
sequence represents the next state reached by the circuit upon the application of a count pulse. 000
001
010
011
100101110111
Figure 6-28 State diagram of a 3-bit binary counter
Table 6-12 Excitation table for a 3-bit binary counter
Count sequence Flip-flop inputs
A2A1A0TA2TA1TA0
0 0 0 0 0 1
0 0 1 0 1 1
0 1 0 0 0 1
0 1 1 1 1 1
1 0 0 0 0 I
1 0 1 0 1 I
1 1 0 0 0 1
1 1 1 1 1 1
Sequential Logic  217 
The count sequence repeats after it reaches the last value, so that state 000 is the next state after 
111. The count sequence gives all the information needed to design the circuit. It is not neces-sary to list the next states in a separate column because they can be read from the next number in the sequence. The design of counters follows the same procedure as that outlined in Section 6-7, except that the excitation table can be obtained directly from the count sequence.
Table 6-12 is the excitation table for the 3-bit binary counter. The three flip-flops are given 
variable designations A
2, A1, and A0. Binary counters are most efficiently constructed with T 
flip-flops (or JK flip-flop with J and K lied together). The flip-flop excitation for the T inputs is 
derived from the excitation table of the T flip-flop and from inspection of the state transition from 
a given count (present state) to the next below it (next state). As an illustration, consider the flip-flop input entries for row 001. The present state here is 001 and the next state is 010, which is the next count in the sequence. Comparing these two counts, we note that A
2 goes from 0 to 0; so TA2 
is marked with a 0 because flip-flop A2 must remain unchanged when a clock pulse occurs. A1 
goes from 0 to 1; so TA1 is marked with a 1 because this flip-flop must be complemented in the 
next clock pulse. Similarly, A0 goes from 1 to 0, indicating that it must be complemented; so TA0 
is marked with a 1. The last row with present state 111 is compared with the first count 000 which is its next state. Going from all 1’ s to all 0’ s requires that all three flip-flops be complemented.
The flip-flop input functions from the excitation tables are simplified in the maps of Fig. 
6-29. The Boolean functions listed under each map specify the combinational-circuit part of the counter. Including these functions with the three flip-flops, we obtain the logic diagram of the counter as shown in Fig. 6-30.
A counter with n flip-flops may have a binary sequence of less than 2
n numbers. A BCD 
counter counts the binary sequence from 0000 to 1001 and returns to 0000 to repeat the  A2
A0
TA2 = A1A0A1
11
TA1=A011
11
TA0=111
11
11
11 Figure 6-29 Maps for a 3-bit binary counter
Q
TQ
TQ
T
1A2 A1 A0
Count
pulses
Figure 6-30 Logic diagram of 3-bit binary counter
218 Chapter 6
sequence. Other counters may follow an arbitrary sequence which may not be the straight binary 
sequence. In any case, the design procedure is the same. The count sequence is listed and the excitation table is obtained by comparing a present count with the next count listed below it. A tabulated count sequence always assumes a repeated count, so that the next state of the last entry is the first count listed.
EXAMPLE 6-3: Design a counter that has a repeated sequence of six states as listed in Table 
6-13.
In this sequence, flip-flops B and C repeat the binary count 00, 01, 10, while flip-flop A 
alternates between 0 and 1 every three counts. The count sequence for A, B, C is not straight binary and two states, 011 and 111, are not used. The choice of JK flip-flops results in the 
excitation table of Table 6-13. Inputs KB and KC have only 1’ s and X’s in their columns, so 
these inputs are always 1. The other flip-flop input functions can be simplified using minterms 3 and 7 as don’t-care conditions. The simplified functions are:
J A = B KA = B
JB = C  KB = 1
JC= B′  KC = 1
The logic diagram of the counter is shown in Fig, 6-31(a). Since there are two unused 
states, we analyze the circuit to determine their effect. The state diagram so obtained is drawn 
in Fig. 6-31(b). If the circuit ever goes to an invalid state, the next count pulse transfers it to one of the valid states, and it continues to count correctly. Thus the counter is self-starting. A self-starting counter is one that can start from any state but eventually reaches the normal count sequence.
6.9 Design with State Equations
A sequential circuit can be designed by means of state equations rather than an excitation table. 
As shown in Section 6-4, a state equation is an algebraic expression that gives the conditions for the next state as a function of the present state and input variables. The state equations of a sequential circuit express in algebraic form the same information which is expressed in tabular form in a state table.
Table 6-13 Excitation table for Example 6-3
Count sequence Flip-flop inputs
A B C JA KA JB KB JC KC
0 0 0 0 X 0 X 1 X
0 0 1 0 X 1 X X 1
0 1 0 1 X X 1 0 X
1 0 0 X 0 0 X 1 X
1 0 1 X 0 1 X X 1
1 1 0 X 1 X 1 0 X
Sequential Logic  219 
The state equation method is convenient when the circuit is already specified in this form 
or when the state equations are easily derived from the state table. This is the preferred method 
when D flip-flops are used. The method may sometimes be convenient to use with JK flip-flops. 
The application of this procedure to circuits with RS or T flip-flops is possible but involves a con-
siderable amount of algebraic manipulation. Here we will show the application of this method to sequential circuits employing D or JK flip-flops. The starting point in each case is the flip-flop 
characteristic equation derived in Section 6-2.
6.9.1 Sequential Circuits with D Flip-flops
The characteristic equation of the D flip-flop is derived in Fig, 6-5(d):
Q(t + 1) = D
This equation states that the next state of the flip-flop is equal to the present value of its D input 
and is independent of the value of the present state. This means that the entries for the next state 
in the state table are exactly the same as the D inputs. Therefore, it is not necessary to derive the Q
KAB
1C
JQ Q´
KJQ
KJ
Count
pulses
000
001
010
100101110111
011(a) Logic diagram of counter
(b) State diagram of counter
Figure 6-31 Solution to Example 6-3
220 Chapter 6
flip-flop input conditions for the excitation table because this information is already available in 
the next state columns.
Take, for example, the excitation table of Table 6-10. The next state column for A has four 
1’ s, and so does the column for the next state of B. To design this circuit with D flip-flops, we 
write the state equations and equate them to the corresponding D inputs:
A(t + 1) = DA (A, B, x) = ∑(2,4,5,6) 
B(t + 1) = DB(A, B, x) = ∑(1,3,5.6)
where DA and DB are the flip-flop input functions for D flip-flops A and B, respectively, and each 
function is expressed as the sum of four minterms. The simplified functions can be obtained by 
means of two three-variable maps. The simplified flip-flop input functions are:
DA = AB′ + Bx′
DB = A′ x + B′ x + A B x′
If there are unused states in the sequential circuit, they must be considered, together with 
the inputs, as don’t-care combinations. The don’t-care minterms thus obtained can be used to simplify the state equations of the D flip-flop input functions.
EXAMPLE 6-4: Design a sequential circuit with four flip-flops, A, B, C, and D. The next 
states of B, C, and D are equal to the present states of A, B, and C. respectively. The next state 
of A is equal to the exclusive-OR, of the present states of C and D.
From the statement of the problem, it is convenient to first write the state equations for 
the circuit:
A(t + 1) = C ⊕ D
B(t + 1) = AC(t +1) = BD(t + 1) = C
This circuit specifies a feedback shift register. In a feedback shift register, each flip-flop trans-
fers or shifts its content to the next flip-flop when a clock pulse occurs, but the next state of the first flip-flop (A in this case) is some function of the present state of other flip-flops. Since 
the state equations are very simple, the most convenient flip-flop to use is the D type.
The flip-flop input functions for this circuit are taken directly from the state equations, 
with the next state variable replaced by the flip-flop input variable:
DA = C ⊕ D
DB = A
DC = BDD = C
The circuit can be constructed with four D flip-flops and one exclusive-OR gate.
Sequential Logic  221 
6.9.2 State Equations with JK Flip-flops§
The characteristic equation for the JK flip-flop is derived in Fig. 6-6(d):
Q(t + 1) = (J)Q′ + (K′)Q
Input variables J and K are enclosed in parentheses so as not to confuse the AND terms of 
the characteristic equation with the two-letter convention which has been used to represent the 
flip-flop input variables.
The sequential circuit can be derived directly from the state equations without having to 
draw the excitation table. This is done by means of a matching process between the state equa-tion for each flip-flop and the general characteristic equation of the JK flip-flop. The matching 
process consists of manipulating each state equation until it is in the form of the characteristic equation. Once this is done, the functions for inputs J and K can be extracted and simplified. This 
must be done for each state equation listed, and its flip-flop variable name A, B, C, etc., must replace the letter Q in the characteristic equation.
A given state equation for Q(t + 1) may be already expressed as a function of Q and Q′. 
More often, either Q or Q′ or both would be absent in the Boolean expression. It is then necessary 
to manipulate the expression algebraically until both Q and Q′ are included in the expression. 
The following example demonstrates all the possibilities that may be encountered.
EXAMPLE 6-5: Design a sequential circuit with JK flip-flops to satisfy the following state 
equations:
A(t + 1) = A′B′CD + A′B′C + ACD + AC′D′
B(t + 1) = A′C + CD′ + A′BCC(t + 1) = BD(t + 1) = D′
The input functions for flip-flop A are derived by this method by arranging the state 
equation and matching it with the characteristic equation as follows:
A(t + 1) = (B′CD + B′C)A′ + (CD + C′D′)A             = (J)A′+ (K′)A
From the equality of the two equations, we deduce the input functions for flip-flop A to be:
 J = B′CD + B′C= B′CK = (CD + C′D′)′ = CD′ + CD
The state equation for flip-flop B can be arranged as follows:
B(t + 1) = (A′C + CD′) + (A′C′)B
§This part may be omitted without loss of continuity.
222 Chapter 6
However, this form is not suitable for matching with the characteristic equation because the 
variable B′ is missing. If the first quantity in parentheses is ANDed with (B′ + B), the equation 
remains the same but with the variable B′ included. Thus:
B(t + 1) = (A′C + CD′)(B′ + B) + (A′C′)B              = (A′C + CD′)B′ + (A′C + CD′ + A′C′)B               = (J)B′ + (K′)B
From the equality of the two equations, we deduce the input functions for flip-flop B:
 J = A′C + CD′K = (A′C + CD′ + A′C′)′ = AC ′ + AD
The state equation for flip-flop C can be manipulated as follows:
C(t + 1′) = B = B(C′ + C) = BC′ + BC
               = (J)C′ + (K′)C
The input functions for flip-flop C are:
 J = BK = B’
Finally, the state equation for flip-flop D may be manipulated for the purpose of match-
ing as follows:
D(t + 1) = D′ = 1.D′ + O.D              = (J)D′ + (K′)D
which gives the input function:
J = K = 1
The derived input functions can be accumulated and listed together. The two-letter conven-tion to designate the flip-flop input variable, not used in the above derivation, is used below:
JA = B′C  KA = CD′ + C′D
JB = A′C + CD′ KB = AC′ + AD
JC = B  KC = B′
JD = 1   KD = 1
The design procedure introduced here is an alternative method for determining the flip-flop 
input functions of a sequential circuit when JK flip-flops are employed. To use this procedure 
when a state diagram or state table is initially specified, it is necessary that the state equations be derived by the procedure outlined in Section 6-4. The state-equation method for finding flip-flop input functions can be extended to cover unused states which are considered as don’t-care conditions. The don’t-care minterms are written in the form of a state equation and manipulated 
Sequential Logic  223 
until they are in the form of the characteristic equation for the particular flip-flop considered. The 
J and K functions in the don’t-care state equation are then taken as don’t-care minterms when 
simplifying the input functions for a particular flip-flop.
REFERENCES
1. Marcus, M. P ., Switching Circuits for Engineers, 3rd ed. Englewood Cliffs, NJ.; Prentice-Hall, 1975.
2. McCluskey, E. J., Introduction to the Theory of Switching Circuits. New Y ork: McGraw-Hill Book 
Co., 1965.
3. Miller, R. E., Switching Theory, two volumes. New Y ork: John Wiley and Sons, 1965.
4. Krieger, M., Basic Switching Circuit Theory. New Y ork: The Macmillan Co., 1967.
5. Hill. F . J., and G. R. Peterson, Introduction to Switching Theory and Logical Design. New Y ork: John 
Wiley and Sons, 1974,
6. Givone, D. D., Introduction to Switching Circuit Theory. New Y ork: McGraw-Hill Book Co., 1970.
7. Kohavi, Z., Switching and Finite Automata Theory. New Y ork: McGraw-Hill Book Co., 1970.
8. Phister M., The Logical Design of Digital Computers. New Y ork: John Wiley and Sons, 1958.
9. Paull, M. C. and S. H. Unger, “Minimizing the Number of States in Incompletely Specified Sequen-tial Switching Functions.” IRE Trans on Electronic Computers, V ol. EC-8, No. 3 (September 1959), 
356-66.
10.  Hartmanis, J., “On the State Assignment Problem for Sequential Machines I.” IRE Trans, on Electro-nic Computers, V ol. EC-10, No. 2 (June 1961), 157-65.
11. McCluskey, E. J., and S. H. Unger, “A Note on the Number of Internal Assignments for Sequential 
Circuits.” IRE Trans. on Electronic Computer, V ol. EC-8, No. 4 (December 1959), 439-40.
PROBLEMS
6-1. Show the logic diagram of a clocked RS flip-flop with four NAND gates.
6-2. Show the logic diagram of a clocked D flip-flop with AND and NOR gates.
6-3. Show that the clocked D flip-flop of Fig. 6-5(a) can be reduced by one gate.
6-4. Consider a JK′ flip-flop, i.e., a JK flip-flop with an inverter between external input K′ and internal 
input K.
(a) Obtain the flip-flop characteristic table.
(b) Obtain the characteristic equation.
(c) Show that tying the two external inputs together forms a D flip-flop.
6-5. A set-dominate flip-flop has a set and a reset input. It differs from a conventional RS flip-flop in that 
an attempt to simultaneously set and reset results in setting the flip-flop.
(a) Obtain the characteristic table and characteristic equation for the set-dominate flip-flop.
(b) Obtain a logic diagram for an asynchronous set-dominate flip-flop.
6-6. Obtain the logic diagram of a master-slave JK flip-flop with AND and NOR gates. Include a provi-
sion for setting and clearing the flip-flop asynchronously (without a clock).
224 Chapter 6
6-7. This problem investigates the operation of the master-slave JK flip-flop through the binary transition 
in the internal gales of Fig. 6-11. Evaluate the binary values (0 or 1) in the outputs of the nine gates 
when the inputs to the circuit go through the following sequence:
(a) CP = 0, Y = 0, Q = 0, and J = K = 1.
(b) After CP goes to 1 (Y should go to 1; Q remains at 0).
(c) After CP goes to 0 and immediately after that J goes to 0(Q should go to 1; Y is  unaffected).
(d) After CP goes to 1 again (Y should go to 0).
(e) After CP goes back to 0 and immediately after that K goes to 0 (Q should go to 0).
(f) All succeeding pulses have no effect as long as J and K remain at 0.
6-8. Connect an asynchronous clear terminal to the inputs of gates 2 and 6 of the flip-flop in Fig. 6-12.
(a) Show that when the clear input is 0, the flip-flop is cleared, and remains cleared, regardless of 
the values of CP and D inputs.
(b) Show that when the clear input is 1, it has no effect on the normal clocked operations.
6-9. The full-adder of Fig. P6-10 receives two external inputs x and y; the third input z comes from the 
output of a D flip-flop. The carry output is transferred to the flip-flop every clock pulse. The external 
S output gives the sum of x, y, and z. Obtain the state table and state diagram of the sequential circuit.
Q
Dx
y CFull
adder
CPS
z
Figure P6-10
6-10. Derive the state table and state diagram of the sequential circuit of Fig. P6-11. What is the function 
of the circuit?
Q Q´
TA´ AB ´ B
Q Q´
T
CP
Figure P6-11
Sequential Logic  225 
6-11. A sequential circuit has four flip-flops A, B, C, D and an input x. It is described by the following state 
equations:
A(t + 1) = (CD′ + C′D)x + (CD + C′D′)x′
B(t +1) =A
C(t + 1) = B
D(t + 1) = C
(a) Obtain the sequence of states when x = 1, starting from state ABCD = 0001.
(b) Obtain the sequence of states when x = 0, starting from state ABCD = 0000.
6-12. A sequential circuit has two flip-flops (A and B), two inputs (x and y) and an output (z). The flip-flop 
input functions and the circuit output function are as follows:
JA = xB + y′B′ KA = xy′ B′
JB = xA′  KB = xy′ + A
  z = xyA + x′y′B
 Obtain the logic diagram, state table, state diagram, and state equations.
6-13. Reduce the number of states in the following state table and tabulate the reduced state table.
Present state Next state Output
x = 0 x = 1 x = 0 x = 1
a f b 0 0
b d c 0 0
c f e 0 0
d g a 1 0
e d c 0 0
f f b 1 1
g g h 0 1
h g a 1 0
6-14. Starting from state a of the state table in problem 6-14, find the output sequence generated with an 
input sequence 01110010011.
6-15. Repeal problem 6-15 using the reduced table of problem 6-14. Show that the same output sequence 
is obtained.
6-16. Substitute binary assignment 2 of Table 6-5 to the states in Table 6-4 and obtain the binary state table. 
Repeal with binary assignment 3.
6-17. Obtain the excitation table of the JK′ flip-flop described in problem 6-4.
6-18. Obtain the excitation table of the set-dominate flip-flop described in problem 6-5.
6-19. A sequential circuit has one input and one output. The state diagram is shown in Fig. P6-20. Design the sequential circuit with (a) T flip-flops, (b) RS flip-flops, and (c) JK flip-flops.
6-20. Design the circuit of a 4-bit register that converts the binary number stored in the register to its 2’ s complement value when input x = 1. The flip-flops of the register are of the RST type. This flip-flop 
has three inputs: two inputs have RS capabilities and one has a T capability. The RS inputs are used 
to transfer the 4-bit number when an input y = 1. Use the T input for the conversion.
6-21. Repeat Example 6-1 with binary assignment 3 of Table 6-5. Use JK flip-flops.
226 Chapter 6
6-22. Design a BCD counter with JK flip-flops.
 001
100 011
010
0001/01/1
1/1
1/11/10/0
0/00/0
0/00/0
Figure P6-20
6-23. Design a counter that counts the decimal digits according to the 2, 4, 2, 1 code (Table 1-2). Use T 
flip-flops.
6-24. Verify the circuit obtained in Example 6-5 by using the excitation table method.
6-25. Design the sequential circuit described by the following state equations. Use JK flip-flops.
A(t + 1) = xAB + yA′C + xy
B(t + 1) = xAC + y′BC′
C(t + 1) = x′B + yAB′
6-26. (a) Derive the state equations for the sequential circuit specified by Table 6-6, Section 6-5. List the 
don’t-care terms. (b) Derive the flip-flop input functions from the state equations (and don’t-care 
terms) using the method outlined in Example 6-5. Use JK flip-flops.
6-27. Differentiate between sequential circuit and combinational circuit. 
6-28. What is the problem found in RS flip-flop? Explain how it is solved in JK flip flop.
6-29. What is the necessity of mater-slave flip-flop? Explain working of D master-slave flip-flip.  Realize with all NOR gates.
6-30. Covert t flip-flip to D flip-flop.
6-31. With help of JK flip-flop design a counter which counts following binary sequence 2, 3, 1, 7, 4, 0 and repeat. 
6-32. With help of RS flip-flop design a counter which counts following binary sequence 1, 3, 5, 7, 9 and repeat.
6-33. With help of T flip-flop design a counter which counts following binary sequence 0, 2, 4, 6, 8 and repeat.
6-34. With help of D flip-flop design a counter which counts following binary sequence 1, 2, 6, 4, 3 and repeat.
6-35. What is lock out in a counter? How it can be avoided?
6-36. Bring out the differences between edge triggered and level triggered flip-flip.
6-37. Design a counter with JK flip-flip which counts binary sequence of 7, 4, 2, 1, 5….. . Is there a chance of lockout? Explain why. How can you improve that? Explain with your design.
6-38. Explain up-down counter which counts decimal digits according to 84-2-1 with JK flip-flop. Use one control bit for up and down counter.
Sequential Logic  227 
SOLvED ExAMPLE
With the help of SR flip-flip, realize T flip-flop.
Step 1 – (Logic Diagram)
Q
Q´T Conversion 
Logic
RSR Flip-f lopS
Step 2
Truth Table of required (T) flip-flop
FF input Present state Next State
T QnQn + 1
0 0 0
1 0 1
1 1 0
0 1 1
Excitation table of given (SR) flip-flop
Present state Next State Flip-flop inputs
QnQn + 1S R
0 0 0 X
0 1 1 0
1 0 0 1
1 1 X 0
Step 3
Truth table of the required flip-flip (combining truth table and excitation table)
FF input Present state Next State Flip-flop inputs
T QnQn + 1S R
0 0 0 0 X
1 0 1 1 0
1 1 0 0 1
0 1 1 X 0
228 Chapter 6
Step 4
Finding the expression of given flip in terms of required flip-flop
0 1Qn
0
11T
X
R = TQ
0 1Qn
0
11T
X
S = TQ′
Step 5
Logic Diagram of the converted Flip-flop.
C SR FF
Qn´Q´Q S
T
RQn
7Chapter
registers, Counters, and the  
Memory Unit7.1 Introduction
A clocked sequential circuit consists of a group of flip-flops and combinational gates connected 
to form a feedback path. The flip-flops are essential because, in their absence, the circuit reduces to a purely combinational circuit (provided there is no feedback path). A circuit with only flip-flops is considered a sequential circuit even in the absence of combinational gates.
An MSI circuit that contains storage cells within it is, by definition, a sequential circuit. 
MSI circuits that include flip-flops or other storage cells are usually classified by the function they perform rather than by the name “sequential circuit.”  These MSI circuits are classified in one of three categories: registers, counters, or random-access memory. This chapter presents various registers and counters available in IC form and explains their operation. The organization of the random-access memory is also presented.
A register is a group of binary storage cells suitable for holding binary information. A 
group of flip-flops constitutes a register, since each flip-flop is a binary cell capable of storing one bit of information. An n-bit register has a group of n flip-flops and is capable of storing any 
binary information containing n bits. In addition to the flip-flops, a register may have combi-
national gates that perform certain data-processing tasks. In its broadest definition, a register consists of a group of flip-flops and gates that effect their transition. The flip-flops hold binary information and the gates control when and how new information is transferred into the register.
Counters were introduced in Section 6-8. A counter is essentially a register that goes 
through a predetermined sequence of states upon the application of input pulses. The gates in a counter are connected in such a way as to produce a prescribed sequence of binary states in the register. Although counters are a special type of register, it is common to differentiate them by giving them a special name.
A memory unit is a collection of storage cells together with associated circuits needed to 
transfer information in and out of storage. A random-access memory (RAM) differs from a read-only memory (ROM) in that a RAM can transfer the stored information out (read) and is also capable of receiving new information in for storage (write). A more appropriate name for such a memory would be read-write memory.
Registers, counters, and memories are extensively used in the design of digital systems in 
general and digital computers in particular. Registers can also be used to facilitate the design of sequential circuits. Counters are useful for generating timing variables to sequence and control 
230 Chapter 7
the operations in a digital system. Memories are essential for storage of programs and data in a 
digital computer. Knowledge of the operation of these components is indispensable for the un-derstanding of the organization and design of digital systems.
7.2 Registers
Various types of registers are available in MSI circuits. The simplest possible register is one that consists of only flip-flops without any external gates. Figure 7-1 shows such a register con-structed with four D-type flip-flops and a common clock pulse input. The clock pulse input, CP , 
enables all flip-flops so that the information presently available at the four inputs can be trans-ferred into the 4-bit register. The four outputs can be sampled to obtain the information presently stored in the register.
The way that the flip-flops in a register are triggered is of primary importance. If the flip-
flops are constructed with gated D-type latches as in Fig, 6-5, then information present at a data (D) input is transferred to the Q output when the enable (CP) is 1, and the Q output follows the 
input data as long as the CP signal remains 1. When CP goes to 0, the information that was 
present at the data input just before the transition is retained at the Q output. In other words, the 
flip-flops are sensitive to the pulse duration, and the register is enabled for as long as CP = 1. A 
register that responds to the pulse duration is commonly called a gated latch, and the CP input is 
frequently labeled with the variable G (instead of CP). Latches are suitable for use as temporary 
storage of binary information that is to be transferred to an external destination. They should not be used in the design of sequential circuits that have feedback connections.
As explained in Section 6-3, a flip-flop can be used in the design of clocked sequential cir -
cuits provided it is sensitive to the pulse transition rather than the pulse duration. This means that the flip-flops in the register must be of the edge-triggered or master-slave type. Normally, it is not possible to distinguish from a logic diagram whether a flip-flop is a gated latch, edge-triggered, or master-slave, because the graphic symbols for all three are the same. The distinction must be made from the name given to the unit. A group of flip-flops sensitive to pulse duration is usually called a latch, whereas a group of flip-flops sensitive to pulse transition is called a register.
* A 
register can always replace a latch, but the converse should be done with caution to make sure that outputs from a latch never go to other flip-flop inputs that are triggered with the same com-mon clock pulse. In subsequent discussions, we will always assume that any group of flip-flops 
*For example, IC type 7475 is a 4-bit latch, whereas type 74175 is a 4-bit register.Q
DQA4 A3 A2 A1
l4CP
l3 l2 l1DQD QD
Figure 7-1 4-bit register
Registers, Counters, and the Memory Unit  231 
drawn constitutes a register and that all flip-flops are of the edge-triggered or master-slave type. 
If the register is sensitive to the pulse duration, it will be referred to as a latch.
7.2.1 Register with Parallel Load
The transfer of new information into a register is referred to as loading the register. If all the 
bits of the register are loaded simultaneously with a single clock pulse, we say that the loading 
is done in parallel. A pulse applied to the CP input of the register of Fig. 7-1 will load all four 
inputs in parallel. In this configuration, the clock pulse must be inhibited from the CP terminal if 
the content of the register must be left unchanged. In other words, the CP input acts as an enable 
signal which controls the loading of new information into the register. When CP goes to 1, the 
input information is loaded into the register. If CP remains at 0, the content of the register is not 
changed. Note that the change of state in the outputs occurs at the positive edge of the pulse. If a flip-flop changes state at the negative edge, there will be a small circle under the triangle symbol in the CP input of the flip-flop.
Most digital systems have a master-clock generator that supplies a continuous train of clock 
pulses. All clock pulses are applied to all flip-flops and registers in the system. The master-clock generator acts like a pump that supplies a constant beat to all parts of the system. A separate control signal then decides what specific clock pulses will have an effect on a particular register. In such a system, the clock pulses must be ANDed with the control signal, and the output of the AND gate is then applied to the CP terminal of the register shown in Fig. 7-1. When the control 
signal is 0, the output of the AND gate is 0, and the stored information in the register remains unchanged. Only when the control signal is a 1 does the clock pulse pass through the AND gate and into the CP terminal for new information to be loaded into the register. Such a control vari-
able is called a load control input.
Inserting an AND gate in the path of clock pulses means that logic is performed with clock 
pulses. The insertion of logic gates produces propagation delays between the master-clock gen-erator and the clock inputs of flip-flops. To fully synchronize the system, we must ensure that all clock pulses arrive at the same time to all inputs of alt flip-flops so that they can all change simul-taneously. Performing logic with clock pulses inserts variable delays and may throw the system out of synchronism. For this reason, it is advisable (but not necessary, as long as the delays are taken into consideration) to apply clock pulses directly to all flip-flops and control the operation of the register with other inputs, such as the R and S inputs of an RS flip-flop.
A 4-bit register with a load control input using RS flip-flops is shown in Fig. 7-2. The CP 
input of the register receives continuous synchronized pulses which are applied to ail flip-flops. The inverter in the CP path causes all flip-flops to be triggered by the negative edge of the incom-
ing pulses. The purpose of the inverter is to reduce the loading of the master-clock generator. This is because the CP input is connected to only one gate (the inverter) instead of the four-gate inputs that would have been required if the connections were made directly into the flip-flop clock inputs (marked with small triangles).
The clear input goes to a special terminal in each, flip-flop through a noninverting buffer 
gate. When this terminal goes to 0, the flip-flop is cleared asynchronously. The clear input is useful for clearing the register to all 0’ s prior to its clocked operation. The clear input must be maintained at 1 during normal clocked operations (see Fig. 6-14).
The load input goes through a buffer gate (to reduce loading) and through a series of AND 
gates to the R and S inputs of each flip-flop. Although clock pulses are continuously present, it is 
232 Chapter 7
the load input that controls the operation of the register. The two AND gates and the inverter as-
sociated with each input I determine the values of R and S. If the load input is 0, both R and S are 
0, and no change of state occurs with any clock pulse. Thus, the load input is a control variable which can prevent any information change in the register as long as its input is 0. When the load control goes to 1, inputs I
1, through I4 specify what binary information is loaded into the register 
on the next clock pulse. For each I that is equal to 1, the corresponding flip-flop inputs are S = 1, 
R = 0. For each I that is equal to 0, the corresponding flip-flop inputs are S = 0, R = 1, Thus, the 
input value is transferred into the register provided the load input is 1, the clear input is 1, and a clock pulse goes from 1 to 0. This type of transfer is called a parallel-load transfer because all 
bits of the register are loaded simultaneously. If the buffer gate associated with the load input is changed to an inverter gate, then the register is loaded when the load input is 0 and inhibited when the load input is 1.
A register with parallel load can be constructed with D flip-flops as shown in Fig. 7-3. 
The clock and clear inputs are the same as before. When the load input is 1, the I inputs are  
transferred into the register on the next clock pulse. When the load input is 0, the circuit inputs are inhibited and the D flip-flops are reloaded with their present value, thus maintaining the con-S
RA1
A2
A3
A4l1Load
l2
l3
l4Q
S
RQ
S
RQ
S
RQ
CP
Clear
Figure 7-2 4-bit register with parallel load
Registers, Counters, and the Memory Unit  233 
tent of the register. The feedback connection in each Flip-flop is necessary when D type is used 
because a D flip-flop does not have a “no-change” input condition. With each clock pulse, the D 
input determines the next state of the output. To leave the output unchanged, it is necessary to 
make the D input equal to the present Q output in each flip-flop.
7.2.2 Sequential Logic Implementation
We saw in Chapter 6 that a clocked sequential circuit consists of a group of flip-flops and com-binational gates. Since registers are readily available as MSI circuits, it becomes convenient at times to employ a register as part of the sequential circuit. A block diagram of a sequential circuit that uses a register is shown in Fig. 7-4. The present state of the register and the external inputs determine the next state of the register and the values of external outputs. Part of the combinatio-nal circuit determines the next state and the other part generates the outputs. The next state value from the combinational circuit is loaded into the register with a clock pulse. If the register has a load input, it must be set to I; otherwise, if the register has no load input (as in Fig. 7-1), the next state value will be transferred automatically every clock pulse.D A1
A2
A3
A4l1Load
l2
l3
l4Q
DQ
DQ
DQ
CP
Clear
Figure 7-3 Register with parallel load using D flip-flops
234 Chapter 7
The combinational circuit part of a sequential circuit can be implemented by any of the 
methods discussed in Chapter 5. It can be constructed with SSI gates, with ROM, or with a 
programmable logic array (PLA). By using a register, it is possible to reduce the design of a sequential circuit to that of a combinational circuit connected to a register.
EXAMPLE 7-1: Design the sequential circuit whose state table is listed in Fig, 7-5(a).
The state table specifies two flip-flops A
1 and A2, one input x, and one output y. The next 
state and output information is obtained directly from the table:
   A1(t + 1) = ∑(4,6)
   A2(t + 1) = ∑(1, 2, 5, 6)
y(A1, A2, x) = ∑ (3, 7)
The minterm values are for variables A1, A2, and x, which are the present state and input vari-
ables. The functions for the next state and output can be simplified by means of maps to give:
A1(t + 1) = A1x’
A2(t + 1) = A2 ⊕ x
           y = A2x
The logic diagram is shown in Fig. 7-5(b).
EXAMPLE 7-2: Repeat Example 7-1, but now use a ROM and a register.
The ROM can be used to implement the combinational circuit and the register will 
provide the flip-flops. The number of inputs to the ROM is equal to the number of flip-flops plus the number of external inputs. The number of outputs of the ROM is equal to the number of flip-flops plus the number of external outputs. In this case we have three inputs and three outputs for the ROM; so its size must be 8 × 3. The implementation is shown in Fig. 7-6. The ROM truth table is identical to the state table with “present state” and “inputs” specifying the address of ROM and “next state” and “outputs” specifying the ROM outputs. The next state values must be connected from the ROM outputs to the register inputs.Next stat e value
Register
Inputs OutputsCPCombinational
      cir cuit
Figure 7-4 Block diagram of a sequential circuit
Registers, Counters, and the Memory Unit  235 
7.3 Shift Registers
A register capable of shifting its binary information either to the right or to the left is called a shift 
register. The logical configuration of a shift register consists of a chain of flip-flops connected in 
cascade, with the output of one flip-flop connected to the input of the next flip-flop. All flip-flops receive a common clock pulse which causes the shift from one stage to the next.
The simplest possible shift register is one that uses only flip-flops, as shown in Fig. 7-7. The 
Q output of a given flip-flop is connected to the D input of the flip-flop at its right. Each clock 
pulse shifts the contents of the register one bit position to the right. The serial input determines A1A2 A1A2 y x
0
0
0
01
1
1
10
0
1
10
0
1
10
1
0
10
1
0
10
0
0
01
0
1
00
1
1
00
1
1
00
0
0
10
0
0
1stateInputPresent
Output  Next
  stat e
A1
A2
yx
                       (a) State Table       (b) Logic Diagram
Figure 7-5 Example of sequential-circuit implementation
12 31 23
0
0
0
0
1
1
1
10
0
1
1
0
0
1
10
1
0
1
0
1
0
10
0
0
01
0
1
00
1
1
00
1
1
00
0
0
10
0
0
1Address Outputs
ROM tr uth ta ble
A1
 8×3
ROM A21
2
31
2
3 y x
Figure 7-6 Sequential circuit using a register and a ROM 
DQ DQ DQ DQSO
CPSerial
outputSerial
inputSl
Figure 7-7 Shift register
236 Chapter 7
what goes into the leftmost flip-flop during the shift. The serial output is taken from the output of 
the rightmost flip-flop prior to the application of a pulse. Although this register shifts its contents to the right, if we turn the page upside down, we find that the register shifts its contents to the left. Thus a unidirectional shift register can function either as a shift-right or as a shift-left register.
The register in Fig. 7-7 shifts its contents with every clock pulse during the negative edge 
of the pulse transition. (This is indicated by the small circle associated with the clock input in all flip-flops.) If we want to control the shift so that it occurs only with certain pulses but not with others, we must control the CP input of the register. It will be shown later that the shift opera-
tions can be controlled through the D inputs of the flip-flops rather than through the CP input. 
If, however, the shift register in Fig. 7-7 is used, the shift can easily be controlled by means of an external AND gate as shown below.
7.3.1 Serial Transfer
A digital system is said to operate in a serial mode when information is transferred and manipu-lated one bit at a time. The content of one register is transferred to another by shifting the bits from one register to the other. The information is transferred one bit at a time by shifting the bits out of the source register into the destination register.
The serial transfer of information from register A to register B is done with shift registers, 
as shown in the block diagram of Fig. 7-8(a). The serial output (SO) of register A goes to the se-
rial input (SI) of register B. To prevent the loss of information stored in the source register, the 
A register is made to circulate its information by connecting the serial output to its serial input 
SO SO Sl SlShift regist er A Shift regist er B
CPClock
Shift
contr ol
(a) Block diagram
T1T2T3T4CPCloc k
Shift
contr olWord-time
(b) Timing diagram
Figure 7-8 Serial transfer from register A to register B
Registers, Counters, and the Memory Unit  237 
terminal. The initial content of register B is shifted out through its serial output and is lost unless 
it is transferred to a third shift register. The shift-control input determines when and by how many 
times the registers are shifted. This is done by the AND gate that allows clock pulses to pass into the CP terminals only when the shift-control is 1.
Suppose the shift registers have four bits each. The control unit that supervises the transfer 
must be designed in such a way that it enables the shift registers, through the shift-control signal, for a fixed time duration equal to four clock pulses. This is shown in the timing diagram of Fig. 7-8(b). The shift-control signal is synchronized with the clock and changes value just after the negative edge of a clock pulse. The next four clock pulses find the shift-control signal in the I state, so the output of the AND gate connected to the CP terminals produces the four pulses T
1, 
T2, T3, and T4. The fourth pulse changes the shift control to 0 and the shift registers are disabled.
Assume that the binary content of A before the shift is 1011 and that of B, 0010. The serial 
transfer from A to B will occur in four steps as shown in Table 7-1. After the first pulse T1, the 
rightmost bit of A is shifted into the leftmost bit of B and, at the same time, this bit is circulated 
into the leftmost position of A. The other bits of A and B are shifted once to the right. The previ-
ous serial output from B is lost and its value changes from 0 to 1. The next three pulses perform 
identical operations, shifting the bits of A into S, one at a time. After the fourth shift, the shift 
control goes to 0 and both registers A and B have the value 1011. Thus, the content of A is trans-
ferred into B while the content of A remains unchanged.
The difference between serial and parallel modes of operation should be apparent from this 
example. In the parallel mode, information is available from all bits of a register and all bits can be transferred simultaneously during one clock pulse. In the serial mode, the registers have a single serial input and a single serial output. The information is transferred one bit at a time while the registers are shifted in the same direction.
Computers may operate in a serial mode, a parallel mode, or in a combination of both. Se-
rial operations are slower because of the time it takes to transfer information in and out of shift registers. Serial computers, however, require less hardware to perform operations because one common circuit can be used over and over again to manipulate the bits coming out of shift regis-ters in a sequential manner. The time interval between clock pulses is called the bit time, and the time required to shift the entire contents of a shift register is called the word time. These timing sequences are generated by the control section of the system. In a parallel computer, control signals are enabled during one clock pulse interval. Transfers into registers are in parallel, and they occur upon application of a single clock pulse. In a serial computer, control signals must be maintained for a period equal to one word time. The pulse applied every bit time transfers the Timing pulse Shift register A  Shift register B Serial output of B
Initial value           1          0          1          1          0          0          1          0 0
After T1          1          1          0          1          1          0          0          1 1
After T2          1          1          1          0          1          1          0          0 0
After T1          0          1          1          1          0          1          1          0 0
After T4          1          0          1          1          1          0          1          1 1Table 7-1 Serial transfer example
238 Chapter 7
result of the operation, one at a time, into a shift register. Most computers operate in a parallel 
mode because this is a faster mode of operation.
7.3.2 Bidirectional Shift Register with Parallel Load
Shift registers can be used for convening serial data to parallel data, and vice versa. If we have access to all the flip-flop outputs of a shift register, then information entered serially by shifting can be taken out in parallel from the outputs of the flip-flops. If a parallel load capability is added to a shift register, then data entered in parallel can be taken out in serial fashion by shifting the data stored in the register.
Some shift registers provide the necessary input and output terminals for parallel transfer. 
They may also have both shift-right and shift-left capabilities. The most general shift register has all the capabilities listed below. Others may have only some of these functions, with at least one shift operation.
1. A clear control to clear the register to 0.
2. A CP input for clock pulses to synchronize all operations.
3. A shift-right control to enable the shift-right operation and the serial input and output lines 
associated with the shift-right.
4. A shift-left control to enable the shift-left operation and the serial input and output lines 
associated with the shift-left.
5. A parallel-bad control to enable a parallel transfer and the n input lines associated with the 
parallel transfer.
6. n parallel output lines.
7. A control state that leaves the information in the register unchanged even though clock pulses are continuously applied.
A register capable of shifting both right and left is called a bidirectional shift register. One 
that can shift in only one direction is called a unidirectional shift register. If the register has both shift and parallel-load capabilities, it is called a shift register with parallel load.
The diagram of a shift register that has all the capabilities listed above is shown in  
Fig. 7-9.
† It consists of four D flip-flops, although RS flip-flops could be used provided an inverter 
is inserted between the S and R terminals. The four multiplexers (MUX) are part of the register 
and are drawn here in block diagram form. (See Fig. 5-16 for the logic diagram of the multi-plexer.) The four multiplexers have two common selection variables, s
1 and s0. Input 0 in each 
MUX is selected when s1s0 = 00, input 1 is selected when s1s0 = 01, and similarly for the other 
two inputs to the multiplexers.
The s1 and s0 inputs control the mode of operation of the register as specified in the function 
entries of Table 7-2. When s1s0 = 00. the present value of the register is applied to the D inputs of 
the flip-flops. This condition forms a path from the output of each flip-flop into the input of the same flip-flop. The next clock pulse transfers into each flip-flop the binary value it held previ-ously, and no change of state occurs. When s
1s0 = 01, terminals 1 of the multiplexer inputs have 
a path to the D inputs of the flip-flops. This causes a shift-right operation, with the serial input 
†This is similar to IC type 74194.
Registers, Counters, and the Memory Unit  239 l4s1
s0
l3 l2 l1Q
D
3210 3210 3210 3210A4
ClearParallel outputs
CPQA3
DA2
Q
DA1
QD
4⋅1
MUX4⋅1MUX
  Ser ial
input fo r
shift-left  Ser ial
input fo r
shift-right4⋅1MUX4⋅1MUX
Parallel inputs
Figure 7-9 4-bit bidirectional shift register with parallel load
240 Chapter 7
transferred into flip-flop A4. When s1s0= 10, a shift-left operation results, with the other serial 
input going into flip-flop A1. Finally, when s1s0 = 11, the binary information on the parallel input 
lines is transferred into the register simultaneously during the next clock pulse.
A bidirectional shift register with parallel load is a general-purpose register capable of per -
forming three operations: shift left, shift right, and parallel load. Not all shift registers available 
in MSI circuits have all these capabilities. The particular application dictates the choice of one MSI shift register over another.
7.3.3 Serial Addition
Operations in digital computers are mostly done in parallel because this is a faster mode of op-eration. Serial operations are slower but require less equipment. To demonstrate the serial mode of operation, we present here the design of a serial adder. The parallel counterpart was discussed in Section 5-2.
The two binary numbers to be added serially are stored in two shift registers. Bits are added 
one pair at a time, sequentially, through a single full-adder (FA) circuit, as shown in Fig. 7-10. The carry out of the full-adder is transferred to a D flip-flop. The output of this flip-flop is then 
used as an input carry for the next pair of significant bits. The two shift registers are shifted to the right for one word-time period. The sum bits from the S output of the full-adder could be trans-ferred into a third shift register. By shifting the sum into A white the bits of A are shifted out, it 
is possible to use one register for storing both the augend and the sum bits. The serial input (SI) of register B is able to receive a new binary number while the addend bits are shifted out during 
the addition.
The operation of the serial adder is as follows. Initially, the A register holds the augend, the 
B register holds the addend, and the carry flip-flop is cleared to 0. The serial outputs (SO)  of A 
and B provide a pair of significant bits for the full-adder at x and y. Output Q of the flip-flop gives 
the input carry at z . The shift-right control enables both registers and the carry flip-flop; so at the 
next clock pulse, both registers are shifted once to the right, the sum bit from S enters the leftmost 
flip-flop of A, and the output carry is transferred into flip-flop Q. The shift-right control enables 
the registers for a number of clock pulses equal to the number of bits in the registers. For each succeeding clock pulse, a new sum bit is transferred to A, a new carry is transferred to Q, and both 
registers are shifted once to the right. This process continues until the shift-right control is dis-abled. Thus, the addition is accomplished by passing each pair of bits together with the previous carry through a single full-adder circuit and transferring the sum, one bit at a time, into register A.
If a new number has to be added to the contents of register A, this number must be first 
transferred serially into register B. Repeating the process once more will add the second number 
to the previous number in A.Table 7-2 Function table for the register of Fig. 7-9
Mode control Register operation
s1 s0
0 0
0 1
1 0
1 1No change Shirt right 
Shift left 
Parallel load
Registers, Counters, and the Memory Unit  241 
Comparing the serial adder with the parallel adder described in Section 5-2, we note the 
following differences. The parallel adder must use registers with parallel-load capability, whereas 
the serial adder uses shift registers. The number of full-adder circuits in the parallel adder is equal to the number of bits in the binary numbers, whereas the serial adder requires only one full-adder circuit and a carry flip-flop. Excluding the registers, the parallel adder is a purely combinational circuit, whereas the serial adder is a sequential circuit. The sequential circuit in the serial adder consists of a full-adder circuit and a flip-flop that stores the output carry. This is typical in serial operations because the result of a bit-time operation may depend not only on the present inputs but also on previous inputs.
To show that bit-time operations in serial computers may require a sequential circuit, we 
will redesign the serial adder by considering it a sequential circuit.
EXAMPLE 7-3: Design a serial adder using a sequential-logic procedure.
First, we must stipulate that two shift registers are available to store the binary numbers 
to be added serially. The serial outputs from the registers are designated by variables x and y. 
The sequential circuit to be designed will not include the shift registers; they will be inserted later to show the complete unit. The sequential circuit proper has two inputs, x and y, that 
provide a pair of significant bits, an output S that generates the sum bit, and flip-flop Q for 
storing the carry. The present state of Q provides the present value of the carry. The clock 
pulse that shifts the registers enables flip-flop Q to load the next carry. This carry is then used 
with the next pair of bits in x and y. The state table that specifies the sequential circuit is given 
in Table 7-3.DQ
ClearSI
SO
x
y
zS
C
SOSICPShift-regist er A
Shift-regist er BShift-right
External
  input
Figure 7-10 Serial adder
242 Chapter 7
The present state of Q is the present value of the carry. The present carry in Q is added 
together with inputs x and y to produce the sum bit in output S. The next state of Q is equiva-
lent to the output carry. Note that the state table entries are identical to the entries in a full-
adder truth table, except that the input carry is now the present state of Q and the output carry 
is now the next state of Q.
If we use a D flip-flop for Q, we obtain the same circuit as in Fig. 7-10 because the input 
requirements of the D input are the same as the next state values. If we use a JK flip-flop for 
Q, we obtain the input excitation requirements listed m Table 7-3. The three Boolean func-
tions of interest are the flip-flop input functions for JQ and KQ and output S. These functions 
are specified in the excitation table and can be simplified by means of maps:
 JQ = xy
KQ = x¢y¢ = (x + y)’
    S = x ⊕ y ⊕ Q
As shown in Fig. 7-11, the circuit consists of three gates and a JK flip-flop. The two shift reg-
isters are also included in the diagram to show the complete serial adder. Note that output S is 
a function not only of x and y but also of the present state of Q, The next state of Q is a func-
tion of the present values of x and y that come out of the serial outputs of the shift registers.
7.4 RIPPLE COUNTERS
MSI counters come in two categories: ripple counters and synchronous counters. In a ripple counter, the flip-flop output transition serves as a source for triggering other flip-flops. In other words, the CP inputs of all flip-flops (except the first) are triggered not by the incoming pulses 
but rather by the transition that occurs in other flip-flops. In a synchronous counter, the input pulses are applied to all CP inputs of all flip-flops. The change of state of a particular flip-flop 
is dependent on the present state of other flip-flops. Synchronous MSI counters are discussed in the next section. Here we present some common MSI ripple counters and explain their operation.Table 7-3 Excitation table for serial adder
Present state Inputs Next state Output Flip-flop inputs
Q x y Q S JQ KQ
0 0 0 0 0 0 X
0 0 1 0 1 0 X
0 1 0 0 1 0 X
0 1 1 1 0 1 X
1 0 0 0 1 X 1
1 0 1 1 0 X 0
1 1 0 1 0 X 0
1 1 1 1 1 X 0
Registers, Counters, and the Memory Unit  243 
7.4.1 Binary Ripple Counter
A binary ripple counter consists of a series connection of complementing flip-flops (T or JK 
type), with the output of each flip-flop connected to the CP input of the next higher-order flip-
flop. The flip-flop holding the least significant bit receives the incoming count pulses. The dia-gram of a 4-bit binary ripple counter is shown in Fig. 7-12. All J and K inputs are equal to 1. 
The small circle in the CP input indicates that the flip-flop complements during a negative-going 
transition or when the output to which it is connected goes from 1 to 0. To understand the opera-tion of the binary counter, refer to its count sequence given in Table 7-4. It is obvious that the lowest-order bit A
1 must be complemented with each count pulse. Every time A1 goes from 1 to 
0, it complements A2. Every time A2 goes from 1 to 0, it complements A3, and so on. For example, 
take the transition from count 0111 to 1000. The arrows in the table emphasize the transitions in this case, A
1 is complemented with the count pulse. Since A1 goes from 1 to 0, it triggers A2 and 
complements it. As a result, A2 goes from 1 to 0, which in turn complements A3, A3 now goes 
from 1 to 0, which complements A4. The output transition of A4, if connected to a next stage, will 
not trigger the next flip-flop since it goes from 0 to 1. The flip-flops change one at a time in rapid succession, and the signal propagates through the counter in a ripple fashion. Ripple counters are 
sometimes called asynchronous counters.Q
KJ
ClearSI
SO = x
SO = ySIS
CPShift-regist er A
Shift-regist er BShift-right
External
  input
Figure 7-11 Second form of a serial adder
A4 A3 A2 A1
QJ
KK KKQ 1 J QJ QJ
Count
pulsesTo next
  stage
11
11
11
1
Figure 7-12 4-bit binary ripple counter
244 Chapter 7
A binary counter with a reverse count is called a binary down-counter. In a down-counter, 
the binary count is decremented by 1 with every input count pulse. The count of a 4-bit down-
counter starts from binary 15 and continues to binary counts 14, 13, 12, .... 0 and then back to 15. The circuit of Fig. 7-12 will function as a binary down-counter if the outputs are taken from the complement terminals Q’ of all flip-flops. If only the normal outputs of flip-flops are available, 
the circuit must be modified slightly as described below.
A list of the count sequence of a count-down binary counter shows that the lowest-order bit 
must be complemented with every count pulse. Any other bit in the sequence is complemented if its previous lower-order bit goes from 0 to 1. Therefore, the diagram of a binary down-counter looks the same as in Fig. 7-12, provided all flip-flops trigger on the positive edge of the pulse. (The small circles in the CP inputs must be absent.) If negative-edge-triggered flip-flops are 
used, then the CP input of each flip-flop must be connected to the Q’ output of the previous flip-flop. Then when Q goes from 0 to 1. Q’ will go from 1 to 0 and complement the next flip-flop as 
required.
7.4.2 BCD Ripple Counter
A decimal counter follows a sequence of ten states and returns to 0 after the count of 9. Such a counter must have at least four flip-flops to represent each decimal digit, since a decimal digit is represented by a binary code with at least four bits. The sequence of states in a decimal counter is dictated by the binary code used to represent a decimal digit. If BCD is used, the sequence of states is as shown in the state diagram of Fig. 7-13. This is similar to a binary counter, except that the state after 1001 (code for decimal digit 9) is 0000 (code for decimal digit 0).
The design of a decimal ripple counter or of any ripple counter not following the binary 
sequence is not a straightforward procedure. The formal tools of logic design can serve only as a guide. A satisfactory end product requires the ingenuity and imagination of the designer.Table 7-4 Count sequence for a binary ripple counter
Count sequence Conditions for complementing flip-flops
A4A3A2A1
0 0 0 0 Complement A1
0 0 0 1 Complement A1A1 will go from 1 to 0 and complement   A2
0 0 1 0 Complement A1
0 0 1 1 Complement A1A1 will go from 1 to 0 and complement  A2;
A2 will go from 1 to 0 and complement  A3
0 1 0 0 Complement A1
0 1 0 1 Complement A1A1 will go from 1 to 0 and complement   A2
0 1 1 0 Complement A1
0 1 1 1 Complement A1A1 will go from 1 to 0 and complement  A2;
A2 will go from 1 to 0 and complement  A3;
A3 will go from 1 to 0 and complement  A4
1 0 0 0 and so on…
Registers, Counters, and the Memory Unit  245 
The logic diagram of a BCD ripple counter is shown in Fig, 7-14.‡ The four outputs are 
designated by the letter symbol Q with a numeric subscript equal to the binary weight of the 
corresponding bit in the BCD code. The flip-flops trigger on the negative edge, i.e., when the CP 
signal goes from 1 to 0. Note that the output of Q1, is applied to the CP inputs of both Q2 and Q8 
and the output of Q2 is applied to the CP input of Q4. The J and K inputs are connected either to 
a permanent 1 signal or to outputs of flip-flops, as shown in the diagram.
A ripple counter is an asynchronous sequential circuit and cannot be described by Boolean 
equations developed for describing clocked sequential circuits. Signals that affect the flip-flop transition depend on the order in which they change from 1 to 0. The operation of the counter can be explained by a list of conditions for flip-flop transitions. These conditions are derived from the logic diagram and from knowledge of how a JK flip-flop operates. Remember that when the 
CP input goes from 1 to 0, the flip-flop is set if J = 1, is cleared if K = 1, is complemented if J 
= K = 1. and is left unchanged if J = K = 0. The following are the conditions for each flip-flop state transition:
1. Q
1 is complemented on the negative edge of every count pulse.
2. Q2 is complemented if Q8 = 0 and Q1 goes from 1 to 0. Q2 is cleared if Q8 = 1 and Q1 goes 
from 1 to 0.
‡This circuit is similar to IC type 7490.10010000
10000001
01110010
01100011
01010100
Figure 7-13 State diagram of a decimal BCD counter
QJ
KQ´Count
pulsesQJKQJKKQJK
11 1 11 1Q8 Q4 Q2 Q1
Figure 7-14 Logic diagram of a BCD ripple counter
246 Chapter 7
3. Q4 is complemented when Q2 goes from 1 to 0.
4. Q8 is complemented when Q4Q2 = 11 and Q1 goes from 1 to 0. Q8 is cleared if either Q4 or 
Q2 is 0 and Q1 goes from 1 to 0.
To verify that these conditions result in the sequence required by a BCD ripple counter, it 
is necessary to verify that the flip-flop transitions indeed follow a sequence of states as specified 
by the state diagram of Fig. 7-13. Another way to verify the operation of the counter is to derive the timing diagram for each flip-flop from the conditions listed above. This diagram is shown in  Fig. 7-15 with the binary states listed after each clock pulse. Q
1 changes state after each clock 
pulse. Q2 complements every time Q1 goes from 1 to 0 as long as Q8 = 0. When Q8 becomes 1, 
Q2 remains cleared at 0. Q4 complements every time Q2 goes from 1 to 0. Q8 remains cleared as 
long as Q2 or Q1 is 0. When both Q2 and Q4 become 1’ s, Q8 complements when Q1 goes from 1 to 
0. Q8 is cleared on the next transition of Q1.
The BCD counter of Fig. 7-14 is a decade counter, since it counts from 0 to 9. To count in 
decimal from 0 to 99, we need a two-decade counter. To count from 0 to 999, we need a three-decade counter. Multiple-decade counters can be constructed by connecting BCD counters in cascade, one for each decade. A three-decade counter is shown in Fig. 7-16. The inputs to the second and third decades come from Q
8 of the previous decade. When Q8 in one decade goes 
from 1 to 0, it triggers the count for the next higher-order decade while its own decade goes from 9 to 0. For instance, the count after 399 will be 400.Count
pulses
Q100101010101
Q4
Q800 0 00 00 1111Q200 11 00 00 0 11
00 00 0 000 0 11
Figure 7-15 Timing diagram for the decimal counter of Fig. 7-14
Q1
BCD
CounterBCDCounterBCDCounterCount
pulsesQ4Q8 Q2 Q1 Q4Q8
102 digit 101 digit 100 digitQ2 Q1 Q4Q8 Q2
Figure 7-16 Block diagram of a 3-decade decimal BCD counter
Registers, Counters, and the Memory Unit  247 
7.5 Synchronous-counters
Synchronous counters are distinguished from ripple counters in that clock pulses are applied to 
the CP inputs of all flip-flops. The common pulse triggers all the flip-flops simultaneously, rather 
than one at a lime in succession as in a ripple counter. The decision whether a flip-flop is to be complemented or not is determined from the values of the J and K inputs at the time of the pulse. 
If J = K = 0, the flip-flop remains unchanged. If J = K = 1, the flip-flop complements.
A design procedure for any type of synchronous counter was presented in Section 6-8. The 
design of a 3-bit binary counter was carried out in detail and is illustrated in Fig. 6-30. In this section, we present some typical MSI synchronous counters and explain their operation. It must be realized that there is no need to design a counter if it is already available commercially in IC form.
7.5.1 Binary Counter
The design of synchronous binary counters is so simple that there is no need to go through a rigorous sequential-logic design process. In a synchronous binary counter, the flip-flop in the lowest-order position is complemented with every pulse.
This means that its J and K inputs must be maintained at logic-1. A flip-flop in any other 
position is complemented with a pulse provided all the bits in the lower-order positions are equal to 1, because the lower-order bits (when all l’ s) will change to 0’ s on the next count pulse. The binary count dictates that the next higher-order bit be complemented. For example, if the present state of a 4-bit counter is A
4A3A2A1 = 0011, the next count will be 0100. A1 is always comple-
mented. A1 is complemented because the present state of A1 = 1. A3 is complemented because the 
present state of A2A1 = 11. But A4 is not complemented because the present state of A3A2A1= 011, 
which does not give an all-1’ s condition.
Synchronous binary counters have a regular pattern and can easily be constructed with 
complementing flip-flops and gates. The regular pattern can be clearly seen from the 4-bit coun-ter depicted in Fig. 7-17. The CP terminals of all flip-flops are connected to a common clock-
pulse source. The first stage A
1 has its J and K equal to 1 if the counter is enabled. The other J and 
K inputs are equal to 1 if all previous low-order bits are equal to 1 and the count is enabled. The 
chain of AND gates generates the required logic for the J and K inputs in each stage. The counter 
can be extended to any number of stages, with each stage having an additional flip-flop and an AND gate that gives an output of 1 if all previous flip-flop outputs are 1’ s.
Note that the flip-flops trigger on the negative edge of the pulse. This is not essential here 
as it was with the ripple counter. The counter could also be triggered on the positive edge of the pulse.
7.5.2 Binary Up-Down Counter
In a synchronous count-down binary counter, the flip-flop in the lowest-order position is comple-mented with every pulse. A flip-flop in any other position is complemented with a pulse provided all the lower-order bits are equal to 0. For example, if the present state of a 4-bit count-down binary counter is A
4A3A2A1 = 1100, the next count will be 1011, A1 is always complemented. A2 
is complemented because the present state of A1 = 0. A3 is complemented because the present 
state of A2A1 = 00. But A4 is not complemented because the present state of A3A2A1 = 100, which 
is not an all-0’ s condition.
248 Chapter 7
KJQ
KJQ
KJQ
KJQA2 A3 A4
  To
next
stageA1
Count
enab leCP
Figure 7-17 4-bit synchronous binary counter
Registers, Counters, and the Memory Unit  249 
A count-down binary counter can be constructed as shown in Fig. 7-17, except that the 
inputs to the AND gates must come from the complement outputs Q’ and not from the normal 
outputs Q of the previous flip-flops. The two operations can be combined in one circuit. A binary 
counter capable of counting either up or down is shown in Fig. 7-18. The T flip-flops employed 
in this circuit may be considered as JK flip-flops with the J and K terminals tied together. When 
the up input control is 1, the circuit counts up, since the T inputs are determined from the previ-
ous values of the normal outputs in Q. When the down input control is 1, the circuit counts down, 
since the complement outputs Q’ determine the states of the T inputs. When both the up and down 
signals are 0’ s, the register does not change state but remains in the same count.
7.5.3 BCD Counter
A BCD counter counts in binary-coded decimal from 0000 to 1001 and back to 0000. Because 
of the return to 0 after a count of 9, a BCD counter does not have a regular pattern as in a straight binary count. To derive the circuit of a BCD synchronous counter, it is necessary to go through a design procedure as discussed in Section 6-8.
The count sequence of a BCD counter is given in Table 7-5. The excitation for the T flip-
flops is obtained from the count sequence. An output y is also shown in the table. This output is equal to 1 when the counter present state is 1001. In this way, y can enable the count of the 
next-higher-order decade while the same pulse switches the present decade from 1001 to 0000.
The flip-flop input functions from the excitation table can be simplified by means of maps. 
The unused states for minterms 10 to 15 are taken as don’t-care terms. The simplified functions are listed below:
TQ
1 = 1
TQ2 = Q8Q1
TQ4 = Q2Q1
TQ8 = Q8Q1 + Q4Q2Q1
    y = Q8Q1
The circuit can he easily drawn with four T flip-flops, five AND gates, and one OR gate.
Synchronous BCD counters can be cascaded to form a counter for decimal numbers of any 
length. The cascading is done as in Fig. 7-16, except that output y must be connected to the count input of the next-higher-order decade.
7.5.4 Binary Counter with Parallel Load
Counters employed in digital systems quite often require a parallel-load capability for transfer -
ring an initial binary number prior to the count operation. Figure 7-19 shows the logic diagram of a register that has a parallel-load capability and can also operate as a counter.
§ The input load 
control, when equal to 1, disables the count sequence and causes a transfer of data from inputs I
1 through I4 into flip-flops A1 through A4, respectively. If the load input is 0 and the count input 
control is 1, the circuit operates as a counter. The clock pulses then cause the state of the flip-flops to change according to the binary count sequence. If both control inputs are 0, clock pulses do not change the state of the register.
§This is similar but not identical to IC type 74161.
250 Chapter 7
Figure 7-18 4-bit up-down binary counterQ
Q
Q
T T T
QQ´ Q´ Q´A2 A3 A4
To next
 stageA1
Up
DownCPTQ´
Registers, Counters, and the Memory Unit  251 
The carry-out terminal becomes a 1 if all flip-flops are equal to 1 while the count input is 
enabled. This is the condition for complementing the flip-flop holding the next-higher-order bit. 
This output is useful for expanding the counter to more than four bits. The speed of the counter is increased if this carry is generated directly from the outputs of all four flip-flops instead of going through a chain of AND gates. Similarly, each flip-flop is associated with an AND gate that receives all previous flip-flop outputs directly to determine when the flip-flop should he complemented.
The operation of the counter is summarized in Table 7-6. The four control inputs: clear, CP , 
load, and count determine the next output state. The clear input is asynchronous and, when equal to 0, causes the counter to be cleared to all 0’ s, regardless of the presence of clock pulse’ s or other inputs. This is indicated in the table by the X entries, which symbolize don’t-care conditions for 
the other inputs, so their value can be either 0 or 1. The clear input must go to the 1 state for the clocked operations listed in the next three entries in the table. With the load and count inputs both at 0, the outputs do not change, whether a pulse is applied in the CP terminal or not. A load 
input of 1 causes a transfer from inputs I
1 - I4 into the register during the positive edge of an input 
pulse. The input information is loaded into the register regardless of the value of the count input, because the count input is inhibited when the load input is 1. If the load input is maintained at 0, the count input controls the operation of the counter. The outputs change to the next binary count on the positive-edge transition of every clock pulse, but no change of state occurs if the count input is 0.
The 4-bit counter shown in Fig. 7-19 can be enclosed in one IC package. Two ICs are neces-
sary for the construction of an 8-bit counter; four ICs for a 16-bit counter; and so on. The carry output of one IC must be connected to the count input of the IC holding the four next-higher-order bits of the counter.
Counters with parallel-load capability having a specified number of bits are very useful in 
the design of digital systems. Later we will refer to them as registers with load and increment Table 7-5 Excitation table for a BCD counter
Count sequence Flip-flop inputs Output carry
Q8Q4Q2Q1TQ8TQ4TQ2TQ1y
0 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 1 0
0 0 1 0 0 0 0 1 0
0 0 1 1 0 1 1 1 0
0 1 0 0 0 0 0 1 0
0 1 0 1 0 0 1 1 0
0 1 1 0 0 0 0 1 0
0 1 1 1 1 1 1 1 0
1 0 0 0 0 0 0 1 0
1 0 0 1 1 0 0 1 1
252 Chapter 7
J
K
K
K
KQ
JQ
JQ
JQ A4A3A2A1
l4l3l2l1Count 
Load
Clear
Carry-outCP
Figure 7-19 4-bit binary counter with parallel loadTable 7-6 Function table for the counter of Fig. 7-19
Clear CP Load Count Function
0 X X X Clear to 0
1 X 0 0 No change
1 ↑ 1 X Load inputs
1 ↑ 0 1 Count next binary state
Registers, Counters, and the Memory Unit  253 
capabilities. The increment function is an operation that adds 1 to the present content of a regis-
ter. By enabling the count control during one clock pulse period, the content of the register can 
be incremented by 1.
A counter with parallel load can be used to generate any desired number of count sequenc-
es. A modulo- N (abbreviated mod N) counter is a counter that goes through a repeated sequence 
of N counts. For example, a 4-bit binary counter is a mod-16 counter. A BCD counter is a mod-10 
counter. In some applications, one may not be concerned with the particular N states that a mod-
N counter uses. If this is the case, then a counter with parallel load can be used to construct any 
mod-N counter, with N being any value desired. This is shown in the following example.
EXAMPLE 7-4: Construct a mod-6 counter using the MSI circuit specified in Fig. 7-19.
Figure 7-20 shows four ways in which a counter with parallel load can be used to gen-
erate a sequence of six counts. In each case the count control is set to 1 to enable the count through the pulses in the CP input. We also use the facts that the load control inhibits the 
count and that the clear operation is independent of other control inputs.
The AND gate in Fig. 7-20(a) detects the occurrence of state 0101 in the output. When 
the counter is in this state, the load input is enabled and an all-0’ s input is loaded into the register. Thus, the counter goes through binary states 0, 1, 2, 3, 4, and 5 and then returns to 0. This produces a sequence of six counts.
The clear input of the register is asynchronous, i.e., it does not depend on the clock. In 
Fig. 7-20(b), the NAND gate detects the count of 0110, but as soon as this count occurs, the register is cleared. The count 0110 has no chance of staying on for any appreciable time be-cause the register goes immediately to 0. A momentary spike occurs in output A
2 as the count 
goes from 0101 to 0110 and immediately to 0000. This momentary spike may be undesirable and for this reason this configuration is not recommended. If the counter has a synchronous clear input, it would be possible to clear the counter with the clock after an occurrence of the 0101 count.
Instead of using the first six counts, we may want to choose the last six counts from 10 
to 15. In this case it is possible to take advantage of the output carry to load a number in the register. In Fig. 7-20(c), the counter starts with count 1010 and continues to 1111. The out-put carry generated during the last state enables the load control, which then loads the input which is set at 1010.
It is also possible to choose any intermediate count of six states. The mod-6 counter of 
Fig. 7-20(d) goes through the count sequence 3, 4, 5, 6, 7, and 8. When the last count 1000 is reached, output A
4 goes to 1 and the load control is enabled. This loads into the register the 
value of 0011, and the binary count continues from this state.
7.6 Timing Sequences
The sequence of operations in a digital system are specified by a control unit. The control unit that supervises the operations in a digital system would normally consist of timing signals that determine the time sequence in which the operations are executed. The timing sequences in the control unit can be easily generated by means of counters or shift registers. This section demon-strates the use of these MSI functions in the generation of timing signals for a control unit.
254 Chapter 7
7.6.1 Word-time Generation
First, we demonstrate a circuit that generates the required timing signal for serial mode of opera-
tion. Serial transfer of information was discussed in Section 7-3, with an example depicted in Fig. 7-8. The control unit in a serial computer must generate a word-time signal that stays on for 
a number of pulses equal to the number of bits in the shift registers. The word-time signal can be generated by means of a counter that counts the required number of pulses.
Assume that the word-time signal to be generated must stay on for a period of eight clock 
pulses. Figure 7-21(a) shows a counter circuit that accomplishes this task. Initially, the 3-bit counter is cleared to 0. A start signal will set flip-flop Q. The output of this flip-flop supplies the 
word-time control and also enables the counter. After the count of eight pulses, the flip-flop is re-set and Q goes to 0. The timing diagram of Fig. 7-21(b) demonstrates the operation of the circuit. 
The start signal is synchronized with the clock and stays on for one clock pulse period. After Q is set to 1, the counter starts counting the clock pulses. When the counter reaches the count of 7 (binary 111), it sends a stop signal to the reset input of the flip-flop. The stop signal becomes a 1 after the negative-edge transition of pulse 7. The next clock pulse switches the counter to the 000 state and also clears Q. Now the counter is disabled and the word-time signal stays at 0. Note that 
the word-time control stays on for a period of eight pulses. Note also that the stop signal in this A1
  Counter
of Fig. 7-19A3A4 A2
LoadCount = 1
Clear = 1
Inputs = 0CPA1
  Counter
of Fig. 7-19A3A4 A2
ClearCount = 1
Load = 0
Inputs ha ve no ef fectCP
              (a) Binary states 0, 1, 2, 3, 4, 5.    (b) Binary states 0, 1, 2, 3, 4, 5.
A1
  Counter
of Fig. 7-19A3 A4
10 10A2
l1 l3l4 l2LoadCount = 1Carry-out
Clear = 1
CPA1
  Counter
of Fig. 7-19A3 A4
00 11A2
l1 l3l4 l2Load
Count = 1
Clear = 1CP
            (c) Binary states 10, 11, 12, 13, 14, 15.  (d) Binary states 3, 4, 5, 6, 7, 8.
Figure 7-20 Four ways to achieve a mod-6 counter using a counter with parallel load 
Registers, Counters, and the Memory Unit  255 
circuit can be used to start another word-count control in another circuit just as the start signal 
is used in this circuit.
7.6.2 Timing Signals
In a parallel mode of operation, a single clock pulse can specify the time at which an operation should be executed. The control unit in a digital system that operates in the parallel mode must generate timing signals that stay on for only one clock pulse period, but these timing signals must be distinguished from each other.
Timing signals that control the sequence of operations in a digital system can be generated 
with a shift register or a counter with a decoder. A ring counter is a circular shift register with only one flip-flop being set at any particular lime; all others are cleared. The single bit is shifted from one flip-flop lo the other to produce the sequence of timing signals. Figure 7-22(a) shows a 4-bit shift register connected as a ring counter. The initial value of the register is 1000, which produces the variable T
0. The single bit is shifted right with every clock pulse and circulates back 
from T3 to T0. Each flip-flop is in the 1 state once every four clock pulses and produces one of 
the four timing signals shown in Fig. 7-22(c). Each output becomes a 1 after the negative-edge transition of a clock pulse and remains 1 during the next clock pulse.
The liming signals can be generated also by continuously enabling a 2-bit counter that goes 
through four distinct states. The decoder shown in Fig. 7-22(b) decodes the four states of the counter and generates the required sequence of timing signals.
The liming signals, when enabled by the clock pulses, will provide multiple-phase clock 
pulses. For example, if T
0 is ANDed with CP , the output of the AND gate will generate clock 
pulses at one-fourth the frequency of the master-clock pulses. Multiple-phase clock pulses can be used for controlling different registers with different time scales.Q
RS
CP
CPCount enab leWord-time
   contr ol
3-bit-count erStart
Stop
(a) Circuit diagram
StopCP1 234 5670
Start
Word-time=8 pulses Q
(b) Timing diagram
Figure 7-21 Generation of a word-time control for serial operations
256 Chapter 7
To generate 2n timing signals, we need either a shift register with 2n flip-flops or an n-bit 
counter together with an n-to-2n line decoder. For example, 16 timing signals can be generated 
with a 16-bit shift register connected as a ring counter or with a 4-bit counter and a 4-to-16 line 
decoder, in the first case, we need 16 flip-flops. In the second case, we need four flip-flops and 16 4-input AND gates for the decoder. It is also possible to generate the timing signals with a combination of a shift register and a decoder. In this way, the number of flip-flops is less than in a ring counter, and the decoder requires only 2-input gates. This combination is sometimes called a Johnson counter.
7.6.3 Johnson Counter
A k-bit ring counter circulates a single bit among the flip-flops to provide k distinguishable states. 
The number of states can be doubled if the shift register is connected as a switch-tail ring counter. 
A switch-tail ring counter is a circular shift register with the complement output of the last flip-flop connected to the input of the first flip-flop. Figure 7-23(a) shows such a shift register. The T0Shift
rightT1T2T3
          T0T1T2T3
   2 ¥ 4
decoder
2-bit count erCount
enab le
                  (a) Ring-counter (initial value = 1000)           (b) Counter and decoder
CP
T0
T1
T2
T3
(c) Sequence of four timing signals
Figure 7-22 Generation of timing signals
Registers, Counters, and the Memory Unit  257 
circular connection is made from the complement output of the rightmost flip-flop to the input 
of the leftmost flip-flop. The register shifts us contents once to the right with every clock pulse, and at the same time, the complement value of the E flip-flop is transferred into the A flip-flop. 
Starting from a cleared state, the switch-tail ring counter goes through a sequence of eight states as listed in Fig. 7-23(b). In general, a k-bit switch-tail ring counter will go through a sequence 
of 2k states. Starting from all 0’ s, each shift operation inserts 1’ s from the left until the register 
is filled with all 1’ s. In the following sequences, 0’ s are inserted from the left until the register is again filled with all 0’ s.
A Johnson counter is a k-bit switch-tail ring counter with 2k decoding gates to provide out-
puts for 2k timing signals. The decoding gates are not shown in Fig. 7-23 but are specified in the 
last column of the table. The eight AND gates listed in the table, when connected to the circuit, will complete the construction of the Johnson counter. Since each gate is enabled during one particular state sequence, the outputs of the gates generate eight timing sequences in succession.
The decoding of a k-bit switch-tail ring counter to obtain 2k timing sequences follows a 
regular pattern. The all-0’ s state is decoded by taking the complement of the two extreme flip-flop outputs. The all-l’ s state is decoded by taking the normal outputs of the two extreme flip-flops. All other states are decoded from an adjacent 1, 0 or 0, 1 pattern in the sequence. For example, sequence 7 has an adjacent 0, 1 pattern in flip-flops B and C. The decoded output is then obtained 
by taking the complement of B and the normal output of C, or B’C.
One disadvantage of the circuit in Fig. 7-23(a) is that, if it finds itself in an unused state, 
it will persist in moving from one invalid state to another and never find its way to a valid state. This difficulty can be corrected by modifying the circuit to avoid this undesirable condition. One DQ
Q´ A´
CPB´ C´E
E´C B ADQ
Q´DQ
Q´DQ
Q´
(a) 4-stage switch-tail ring counter
A
0
1
1
11
0
0
0B
0
0
1
11
1
0
0C
0
0
0
11
1
1
0D
0
0
0
01
1
1
11
2
3
45
6
7
8Sequence
numberAND ga te require d
      fo r output
Flip-f lop outputs
A´E´
AB´
BC´
CE´
AE
A´B
B´C
C´E
(b) Count sequence and required decoding
Figure 7-23 Construction of a Johnson counter
258 Chapter 7
correcting procedure is to disconnect the output from flip-flop B that goes to the D input of flip-
flop C, and instead enable the input of flip-flop C by the function:¶
DC = (A + C)B
where DC is the flip-flop input function for the D input of flip-flop C.
Johnson counters can be constructed for any number of timing sequences. The number of 
flip-flops needed is one-half the number of timing signals. The number of decoding gates is equal 
to the number of timing signals and only 2-input gates are employed.
7.7 The Memory Unit
The registers in a digital computer may be classified as either operational or storage type. An operational register is capable of storing binary information in its flip-flops and, in addition, 
has combinational gates capable of data-processing tasks. A storage register is used solely for 
temporary storage of binary information. This information cannot be altered when transferred in and out of the register. A memory unit is a collection of storage registers together with the associ-ated circuits needed to transfer information in and out of the registers. The storage registers in a memory unit are called memory registers.
The bulk of the registers in a digital computer are memory registers, to which information 
is transferred for storage and from which information is available when needed for processing. Comparatively few operational registers are found in the processor unit. When data processing takes place, the information from selected registers in the memory unit is first transferred to the operational registers in the processor unit. Intermediate and final results obtained in the opera-tional registers are transferred back to selected memory registers. Similarly, binary information received from input devices is first stored in memory registers; information transferred to output devices is taken from registers in the memory unit.
The component that forms the binary cells of registers in a memory unit must have certain 
basic properties, the most important of which are: (1). It must have a reliable two-state property for binary representation. (2) It must be small in size. (3) The cost per bit of storage should be as low as possible. (4) The time of access to a memory register should be reasonably fast. Examples of memory unit components are magnetic cores, semiconductor ICs, and magnetic surfaces on tapes, drums, or disks.
A memory unit stores binary information in groups called words, each word being stored 
in a memory register. A word in memory is an entity of n bits that moves in and out of storage as a unit. A memory word may represent an operand, an instruction, a group of alphanumeric characters, or any binary-coded information. The communication between a memory unit and its environment is achieved through two control signals and two external registers. The control sig-nals specify the direction of transfer required, that is, whether a word is to be stored in a memory register or whether a word previously stored is to be transferred out of a memory register. One external register specifies the particular memory register chosen out of the thousands available; the other specifies the particular bit configuration of the word in question. The control signals and the registers are shown in the block diagram of Fig. 7-24.
The memory address register specifies the memory word selected. Each word in memory is 
assigned a number identification starting from 0 up to the maximum number of words available. 
¶This is the way it is done in IC type 4022.
Registers, Counters, and the Memory Unit  259 
To communicate with a specific memory word its location number, or address, is transferred to 
the address register. The internal circuits of the memory unit accept this address from the register 
and open the paths needed to select the word called. An address register with n bits can specify up 
to 2n memory words. Computer memory units can range from 1024 words, requiring an address 
register of 10 bits, to 1,048,576 = 220 words, requiring a 20-bit address register.
The two control signals applied to the memory unit are called read and write. A write signal 
specifies a transfer-in function; a read signal specifies a transfer-out function. Each is referenced from the memory unit. Upon accepting one of the control signals, the internal control circuits inside the memory unit provide the desired function. Certain types of storage units, because of their component characteristics, destroy the information stored in a cell when the bit in that cell is read out. Such a unit is said to be a destructive read-out memory, as opposed to a nondestruc-
tive memory where the information remains in the cell after it is read out. In either case, the old information is always destroyed when new information is written. The sequence of internal con-trol in a destructive read-out memory must provide control signals that will cause the word to be restored into its binary cells if the application calls for a nondestructive function.
The information transfer to and from registers in memory and the external environment is 
communicated through one common register called the memory buffer register (other names are information register and storage register). When the memory unit receives a write control signal, 
the internal control interprets the contents of the buffer register to be the bit configuration of the word to be stored in a memory register. With a read control signal, the internal control sends the 
word from a memory register into the buffer register. In each case the contents of the address register specify the particular memory register referenced for writing or reading.
Let us summarize the information transfer characteristics of a memory unit by an example. 
Consider a memory unit of 1024 words with eight bits per word. To specify 1024 words, we need MEMOR Y UNI T
Memor y addr ess
       r egist er
Input addr ess
In out
InformationControl
Signalsread
writen wo rds
m bits per wo rld
Memor y buffer
       r egist er
Figure 7-24 Block diagram of a memory unit showing communication with environment
260 Chapter 7
an address of ten bits, since 210 = 1024. Therefore, the address register must contain ten flip-flops. 
The buffer register must have eight flip-flops to store the contents of words transferred into and 
out of memory. The memory unit has 1024 registers with assigned address numbers from 0 to 1023.
Figure 7-25 shows the initial contents of three registers; memory address register (MAR), 
memory buffer register (MBR), and the memory register addressed by MAR. Since the equiva-lent binary number in MAR is decimal 42, the memory register addressed by MAR is the one with address number 42.
The sequence of operations needed to communicate with the memory unit for the purpose 
of transferring a word out to the MBR is:
1. Transfer the address bits of the selected word into MAR.
2. Activate the read control input.
The result of the read operation is depicted in Fig. 7-26(a). The binary information presently stored in memory register 42 is transferred into MBR.
The sequence of operations needed to store a new word into memory is:
1. Transfer the address bits of the selected word into MAR.
2. Transfer the data bits of the word into MBR.
3. Activate the write control input.
The result of the write operation is depicted in Fig. 7-26(b), The data bits from MBR are 
stored in memory register 42.
In the above example, we assumed a memory unit with nondestructive read-out property. Such 
memories can be constructed with semiconductor ICs. They retain the information in the memo-ry register when the register is sampled during the reading process so that no loss of information Memor y unit
Memor y addr ess
regist er (MAR)
Memor y buffer regist er (MAR)Address
0-1023
1 0 0 1 0 0 1 00 1 1 0 1 1 1 0 0 0 0 0 1 0 1 0 1 0 42
41
4043
Figure 7-25 Initial values of registers
Registers, Counters, and the Memory Unit  261 
occurs. Another component commonly used in memory units is the magnetic core. A magnetic 
core characteristically has destructive read-out, i.e., it loses the stored binary information dur -
ing the reading process. Examples of semiconductor and magnetic-core memories are presented  
in Section 7-8.
Because of its destructive read-out property, a magnetic-core memory must provide addi-
tional control functions to restore the word into the memory register.
A read control signal applied to a magnetic-core memory transfers the content of the ad-
dressed word into an external register and, at the same time, the memory register is automatically cleared. The sequence of internal control in a magnetic-core memory then provides appropriate signals to cause the restoration of the word into the memory register. The information transfer in a magnetic-core memory during a read operation is depicted in Fig. 7-27. A destructive read operation transfers the selected word into MBR but leaves the memory register with all 0’ s. Nor -
mal memory operation requires that the content of the selected word remain in memory after a read operation. Therefore, it is necessary to go through a restore operation that writes the value 
in MBR into the selected memory register. During the restore operation, the contents of MAR and MBR must remain unchanged.
A write control input applied to a magnetic-core memory causes a transfer of information 
as depicted in Fig. 7-28. To transfer new information into a selected register, the old information Memor y unit
MAR = 42
MBR0 1 1 0 1 1 1 0
0 1 1 0 1 1 1 0Memor y unit
MAR = 42
MBR1 0 0 1 0 0 1 0
1 0 0 1 0 0 1 0
     (a) Read operation      (b) Write operation
Figure 7-26 Information transfer during read and write operations
0 1 1 0 1 1 1 0Memor y unit
InitialAnythingMAR = 42
MBR 0 1 1 0 1 1 1 0
Destr uctive read0 0 0 0 0 0 0 0Memor y unit
Restore cont ents0 1 1 0 1 1 1 00 1 1 0 1 1 1 0Memor y unit
Figure 7-27 Information transfer in a magnetic-core memory during a read operation
262 Chapter 7
must first be erased by clearing all the bits of the word to 0. After this is done, the content of MBR 
can be transferred to the selected word. MAR must not change during the operation to ensure that the same selected word that is cleared is the one that receives the new information.
A magnetic-core memory requires two half-cycles either for reading or writing. The time it 
takes for the memory to go through both half-cycles is called the memory-cycle time.
The mode of access of a memory system is determined by the type of components used. In 
a random-access memory, the registers may be thought of as being separated in space, with each 
register occupying one particular spatial location as in a magnetic-core memory. In a sequential-access memory, the information stored in some medium is not immediately accessible but is 
available only at certain intervals of time. A magnetic-tape unit is of this type. Each memory location passes the read and write heads in turn, but information is read out only when the requested word has been reached. The access time of a memory is the time required to select a word and either read or write it. In a random-access memory, the access time is always the same regardless of the word’ s particular location in space. In a sequential memory, the access time de-pends on the position of the word at the time of request. If the word is just emerging from storage at the time it is requested, the access time is just the time necessary to read or write it. But, if the word happens to be in the last position, the access time also includes the time required for all the other words to move past the terminals. Thus, the access time in a sequential memory is variable.
Memory units whose components lose stored information with time or when the power is 
turned off are said to be volatile. A semiconductor memory unit is of this category since its binary 
cells need external power to maintain the needed signals. In contrast, a nonvolatile memory unit, such as magnetic core or magnetic disk, retains its stored information after removal of power. This is because the stored information in magnetic components is manifested by the direction of magnetization, which is retained when power is turned off. A nonvolatile property is desirable in digital computers because many useful programs are left permanently in the memory unit. When power is turned off and then on again, the previously stored programs and other information are not lost but continue to reside in memory.
7.8 Examples of Random-access Memories
The internal construction of two different types of random-access memories are presented dia-gramatically in this section. The first is constructed with flip-flops and gates and the second with magnetic cores. To be able to include the entire memory unit in one diagram, a limited storage 0 1 1 0 1 1 1 0
1 0 0 1 0 0 1 0Memor y unit
InitialMAR = 42
MBR0 0 0 0 0 0 0 0
1 0 0 1 0 0 1 0Memor y unit
Clear wo rd1 0 0 1 0 0 1 0
1 0 0 1 0 0 1 0Memor y unit
Write wo rd
Figure 7-28 Information transfer in a magnetic-core memory during a write operation
Registers, Counters, and the Memory Unit  263 
capacity must be used. For this reason, the memory units presented here have a small capacity 
of 12 bits arranged in four words of three bits each. Commercial random-access memories may have a capacity of thousands of words and each word may range somewhere between 8 and 64 bits. The logical construction of large-capacity memory units would be a direct extension of the configuration shown here.
7.8.1 Integrated-circuit Memory
The internal construction of a random-access memory of m words with n bits per word consists 
of m × n binary storage cells and the associated logic for selecting individual words. The binary 
storage cell is the basic building block of a memory unit. The equivalent logic of a binary cell that stores one bit of information is shown in Fig. 7-29. Although the cell is shown to include 
gates and a flip-flop, internally it is constructed with two transistors having multiple inputs. A binary storage cell must be very small in order to be able to pack as many cells as possible in the small area available in the integrated-circuit chip. The binary cell has three inputs and one output. The select input enables the cell for reading or writing. The read/write input determines the cell operation when it is selected. A 1 in the read/write input forms a path from the flip-flop to the output terminal. The information in the input terminal is transferred into the flip-flop when the read/write control is 0. Note that the flip-flop operates without clock pulses and that its purpose is to store the information bit in the binary cell.
Integrated-circuit memories sometimes have a single line for the read and write control. 
One binary state in the single line specifies a read operation and the other state specifies a write 
RSelect
Output Input
Read /wr iteQS
(a) Logic diagram
Select
Output Input
Read /wr iteBC
(b) Block diagram
Figure 7-29 Memory cell
264 Chapter 7
operation. In addition, one or more enable lines are included to provide means for selecting the 
IC and for expanding several packages into a memory unit with a larger number of words. The logical construction of an IC RAM is shown in Fig. 7-30. It consists of 4 words of 3 bits each, for a total of 12 binary cells. The small boxes labeled BC represent a binary cell, and the three inputs and one output in each BC are as specified in the diagram of Fig. 7-29.
The two address input lines go through an internal 2-to-4 line decoder. The decoder is en-
abled with the memory-enable input. When the memory enable is 0, all the outputs of the decoder are 0 and none of the memory words are selected. With the memory enable at 1, one of the four words is selected, depending on the value of the two address lines. Now, with the read/write con-trol at 1, the bits of the selected word go through the three OR gates to the output terminals. The nonselected binary cells produce 0’ s in the inputs of the OR gates and have no effect on the out-BC BC BC
BC BC BC
BC BC BC
BC BC BCData
inputs
Word 0
   2 ¥ 4decoderD
0
D1
D2
D3Address
  inputs
Memor y
  enab leWord 1
Word 2
Read/ wr iteWord 3
 Data
outputs
Figure 7-30 Integrated-circuit memory
Registers, Counters, and the Memory Unit  265 
puts. With the read/write control at 0, the information available on the input lines is transferred 
into the binary cells of the selected word. The nonselected binary cells in the other words are disabled by their selection inputs and their previous values remain unchanged. With the memory-enable control at 0, the contents of all cells in the memory remain unchanged, regardless of the value of the read/write control.
IC RAMs are constructed internally with cells having a wired-OR capability. This elimi-
nates the need for the OR gates in the diagram. The external output lines can also form wired logic to facilitate the connection of two or more IC packages to form a memory unit with a larger number of words.
7.8.2 Magnetic-core Memory
A magnetic-core memory uses magnetic cores to store binary information. A magnetic core is a doughnut-shaped toroid made of magnetic material. In contrast to a semiconductor flip-flop that needs only one physical quantity such as voltage for its operation, a magnetic core employs three physical quantities; current, magnetic flux, and voltage. The signal that excites the core is a current pulse in a wire passing through the core. The binary information stored is represented by 
the direction of magnetic flux within the core. The output binary information is extracted from a wire linking the core in the form of a voltage pulse.
The physical property that makes a magnetic core suitable for binary storage is its hyster -
esis loop, shown in Fig. 7-31(c). This is a plot of current vs magnetic flux, and it has the shape of a square loop. With zero current, a flux which is either positive (counter clockwise direction) 
or negative (clockwise direction) remains in the magnetized core. One direction, say counter clockwise magnetization, is used to represent a 1 and the other to represent a 0.
A pulse of current applied to the winding through the core can shift the direction of 
magnetization. As shown in Fig. 7-31(a), current in the downward direction produces flux in the clockwise direction, causing the core to go to the 0 state. Figure 7-31(b) shows the current and flux directions for storing a 1. The path that the flux takes when the current pulse is applied is indicated by arrows in the hysteresis loop.
Reading out the binary information stored in the core is complicated by the fact that flux 
cannot be detected when it is not changing. However, if flux is changing with respect to time, it induces a voltage in a wire that links the core. Thus, read-out could be accomplished by applying a current in the negative direction as shown in Fig. 7-32. If the core is in the 1 state, the current 
Negative
  flux
Negative
  curr entPositiv e
  flux
Positiv e
  curr entFlux
1
0Curr ent
         (a) Store 0                (b) Store 1           (c) Hysteresis loop
Figure 7-31 Storing a bit into a magnetic core
266 Chapter 7
reverses the direction of magnetization, and the resulting change of flux produces a voltage pulse 
in the sense wire. If the core is already in the 0 state, the negative current leaves the core magne-tized in the same direction, causing a very slight disturbance of magnetic flux which results in a very small output voltage in the sense wire. Note that this is a destructive read-out, since the read current always returns the core to the 0 state. The previously stored value is lost.
Figure 7-33 shows the organization of S magnetic-core memory containing four words with 
three bits each. Comparing it with the IC memory unit of Fig. 7-30, we note that the binary cell now is a magnetic core and the wires linking it. The excitation of the core is accomplished by means of a current pulse generated in a driver (DR). The output information goes through a sense amplifier (SA) whose outputs set corresponding flip-flops in the buffer register. Three wires link each core. The word wire is excited by a word driver and goes through the three cores of a word. A bit wire is excited by a bit driver and goes through four cores in the same bit position. The sense wire links the same cores as the bit wire and is applied to a sense amplifier that shapes the voltage pulse when a 1 is read and rejects the small disturbance when a 0 is read.
During a read operation, a word-driver current pulse is applied to the cores of the word se-
lected by the decoder. The read current is in the negative direction (Fig. 7-32) and causes all cores of the selected word to go to the 0 state, regardless of their previous state. Cores which previously contained a 1 switch their flux and induce a voltage into their sense wire. The flux of cores which already contained a 0 is not changed. The voltage pulse on a sense wire of cores with a previous 1 is amplified in the sense amplifier and sets the corresponding flip-flop in the buffer register.
During a write operation, the buffer register holds the information to be stored in the word 
specified by the address register. We assume that all cores in the selected word are initially cleared, i.e., all are in the 0 state so that cores requiring a 1 need to undergo a change of state. A current pulse is generated simultaneously in the word driver selected by the decoder and in the bit driver, whose corresponding buffer register flip-flop contains a 1. Both currents are in the posi-tive direction, but their magnitude is only half that needed to switch the flux to the 1 state. This half-current by itself is too small to change the direction of magnetization. But the sum of two half-currents is enough to switch the direction of magnetization to the 1 state. A core switches to the 1 state only if there is a coincidence of two half-currents from a word driver and a bit driver. The direction of magnetization of a core does not change if it receives only half-current from one of the drivers. The result is that the magnetization of cores is switched to the 1 state only if the word and bit wires intersect, that is only in the selected word and only in the bit position in which the buffer register is a 1.Read
currentSense
wireVolts
Read 0Read 1
Time
Output of sense wir e
Figure 7-32 Reading a bit from a magnetic core
Registers, Counters, and the Memory Unit  267 
The read and write operations described above are incomplete, because the information 
stored in the selected word is destroyed by the reading process and the write operation works 
properly only if the cores are initially cleared. As mentioned in Section 7-7, a read operation must be followed by another cycle that restores the values previously stored in the cores. A write operation is preceded by a cycle that clears the cores of the selected word.D0
1
D
11100100
0
1
D
B1 B2 B30 1D
0 1D
0 1
Address
regist erDecoderWord 0W ord 1W ord 2W ord 3
WriteRead
DR = Dr iver
S.A = Sense amplif ierbit 1 bit 2 bit 3  
Input
addressInput
information
Buffer
regist er
Output inf ormationDR
DR
DR
DR
D R
S  AS   AS   AD RD  R
Figure 7-33 Magnetic-core memory unit
268 Chapter 7
The restore operation during a read cycle is equivalent to a write operation which, in effect, 
writes the previously read information from the buffer register back into the word selected. The 
clear operation during a write cycle is equivalent to a read operation which destroys the stored information but prevents the read information from reaching the buffer register by inhibiting the sense amplifier. Restore and clear cycles are normally initiated by the memory internal control, so that the memory unit appears to the outside as having a nondestructive read-out property.
REFERENCES
1. The TTL Data Book for Design Engineers. Dallas, Texas: Texas Instruments, Inc., 1976.
2. Blakeslee, T. R., Digital Design with Standard MSI and LSI. New Y ork: John Wiley & Sons, 1975.
3. Barna A., and D. I. Porat, Integrated Circuits in Digital Electronics. New Y ork: John Wiley & Sons, 
1973.
4. Taub, H., and D. Schilling, Digital Integrated Electronics. New Y ork: McGraw-Hill Book Co., 1977.
5. Grinich, V . H., and H. G. Jackson, Introduction to Integrated Electronics. New Y ork: McGraw-Hill 
Book Co., 1975.
6. Kostopoulos, G. K., Digital Engineering. New Y ork: McGraw-Hill Book Co., 1975.
7. Scott, N. R., Electronic Computer Technology. New Y ork: McGraw-Hill Book Co., 1970, Chap. 10.
8. Kline, R. M., Digital Computer Design. Englewood Cliffs. N.J.: Prentice-Hall, Inc., 1977, Chap. 9.
PROBLEMS
7-1. The register of Fig. 7-1 transfers the input information into the flip-flops when the CP input goes 
through a positive-edge transition. Modify the circuit so that the input information is transferred into the register when a clock pulse goes through a negative-edge transition, provided a load input control 
is equal to binary 1.
7-2. The register of Fig. 7-3 loads the inputs during a negative transition of a clock pulse. What internal 
changes are necessary for the inputs to be loaded during the positive edge of a pulse?
7-3. Verify the circuit of Fig. 7-5 using maps to simplify the next-state equations.
7-4. Design a sequential circuit whose state diagram is given in Fig. 6-27 using a 3-bit register and a  
16 × 4 ROM.
7-5. The content of a 4-bit shift register is initially 1101. The register is shifted six times to the right, with the serial input being 101101. What is the content of the register after each shift?
7-6. What is the difference between serial and parallel transfer? What type of register is used in each case?
7-7.  The 4-bit bidirectional shift register of Fig. 7-9 is enclosed within one IC package. 
(a)  Draw a block diagram of the IC showing all inputs and outputs. 
(b)  Draw a block diagram using three ICs to produce a 12-bit bidirectional shift register.
7-8. The serial adder of Fig. 7-10 uses two 4-bit shift registers. Register A holds the binary number 0101 
and register B holds 0111. The carry flip-flop Q is initially cleared. List the binary values in register 
A and flip-flop Q after each shift.
7-9. What changes are needed in the circuit of Fig. 7-11 to convert it to a circuit that subtracts the content 
of B from the content of A?
7-10. Design a serial counter; in other words, determine the circuit that must be included externally with a 
shift register in order to obtain a counter that operates in a serial fashion.
Registers, Counters, and the Memory Unit  269 
7-11. A flip-flop has a 20-ns delay from the time its CP input goes from 1 to 0 to the tune the output is 
complemented. What is the maximum delay in a 10-bit binary ripple counter that uses these flip-
flops? What is the maximum frequency the counter can operate at reliably?
7-12. How many flip-flops must be complemented in a 10-bit binary ripple counter to reach the next count 
after 0111111111?
7-13. Draw the diagram of a 4-bit binary ripple down-counter using flip-flops that trigger on the (a) posi-
tive-edge transition and (b) negative-edge transition.
7-14. Draw a timing diagram similar to that in Fig. 7-15 for the binary ripple counter of Fig. 7-12.
7-15. Determine the next state for each of the six unused states in the BCD ripple counter of Fig. 7-14. Is the counter self-starting?
7-16. The ripple counter shown in Fig. P7-18 uses flip-flops that trigger on the negative-edge transition of the CP input. Determine the count sequence of the counter. Is the counter self-starting?
 QA BC
J 1
1 KQ´ Q´QJ
KQ
Count
pulsesJ
K
Figure P7-18 Ripple counter
7-17. What happens to the counter of Fig. 7-18 if both the up and down inputs are equal to 1 at the same 
time? Modify the circuit so that it will count up if this condition occurs.
7-18. Verify the flip-flop input functions of the synchronous BCD counter specified in Table 7-5. Draw the logic diagram of the BCD counter and include a count-enable control input.
7-19. Show the external connections of four IC binary counters with parallel load (Fig. 7-19) to produce a 16-bit binary counter. Use a block diagram for each IC.
7-20. Construct a BCD counter using the MSI circuit of Fig. 7-19.
7-21. Construct a mod-12 counter using the MSI circuit specified in Fig. 7-19. Give four alternatives.
7-22. Using two MSI circuits as specified in Fig. 7-19, construct a binary counter that counts from 0 to 
binary 64.
7-23. Using the stop variable from Fig. 7-21 as a start signal, construct a second word-time control that 
stays on for a period of 16 clock pulses.
7-24. Show that an n-bit binary counter connected to an n-to-2
n line decoder if equivalent to a ring counter 
with 2n flip-flops. Draw the block diagrams of both circuits for n = 3. How many timing signals are 
generated?
7-25. Include an enable input to the decoder of Fig. 7-22(b) and connect it to the clock pulses. Draw the 
timing signals that are now generated at the outputs of the decoder.
7-26. Complete the design of the Johnson counter of Fig. 7-23, showing the outputs of the eight timing 
signals.
7-27. (a) List the eight unused states in the switch-tail ring counter of Fig. 7-23. Determine the next state 
for each unused state and show that, if the circuit finds itself in an invalid state, it does not return to a valid state, (b) Modify the circuit as recommended in the text and show that (1) the circuit produces the same sequence of states as listed in Fig. 7-23(b), and (2) the circuit reaches a valid state from any 
one of the unused states.
270 Chapter 7
7-28. Construct a Johnson counter with ten timing signals.
7-29. (a)     The memory unit of Fig. 7-24 has a capacity of 8192 words of 32 bits per word. How many 
flip-flops are needed for the memory address register and memory buffer register? 
 (b)   How many words will the memory unit contain if the address register has 15 bits?
7-30. When the number of words to be selected in a memory is too large, it is convenient to use a binary storage cell with two select inputs; one X (horizontal) and one Y (vertical) select input. Both X and Y 
must be enabled to select the cell.
(a) Draw a binary cell similar to that in Fig. 7-29 with X and Y select inputs.
(b) Show how two 4 × 16 decoders can be used to select a word in a 256-word memory.
7-31. (a)   Draw a block diagram of the 4 × 3 memory of Fig. 7-30, showing all inputs and outputs.
 (b)   Construct an 8 × 3 memory using two such units. Use a block diagram construction.
7-32. It is required to construct a memory with 256 words, 16 bits per word, organized as in Fig. 7-33. 
Cores are available in a matrix of 16 rows and 16 columns.
(a) How many matrices are needed?
(b) How many flip-flops are in the address and buffer registers?
(c) How many cores receive current during a read cycle?
(d) How many cores receive at least half-current during a write cycle?
7-33. Differentiate between Ripple counter and synchronous counter.
7-34. Write short notes on
(a) Registers
(b) Johnson counter
(c) Ring counter
(d) Random access memory
(e) Parallel in Serial Out (PISO) Shift registrar
7-35. Design a synchronous counter up-down with JK flip-flop which counts the odd number from 1 to 15 in binary.
7-36. Design a sequential circuit whose table is given bellow
Present
Sate Input
A1 A2 xNext
State
A1 A2Out put
y
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 10 11 11 01 1
1 1
0 11 00 00011
1
000
7-37. Repeat the problem 4 with ROM and a register.
7-38. Design a MOD 10 synchronous binary up counter using T flip-flop and other necessary logic gates. 
Draw the timing diagram.
7-39. Design a 4-bit up/ down asynchronous counter using JK flip-flops and other necessary logic gates. 
Use one directional control input. If P = 0, the counter will count up and for P = 1, the counter will 
count down.
8Chapter
register-t ransfer Logic8.1 Introduction
A digital system is a sequential logic system constructed with flip-flops and gates. It was shown 
in previous chapters that a sequential circuit can be specified by means of a state table. To specify a large digital system with a state table would be very difficult, if not impossible, because the number of states would be prohibitively large. To overcome this difficulty, digital systems are invariably designed using a modular approach. The system is partitioned into modular subsys-tems, each of which performs some functional task. The modules are constructed from such digital functions as registers, counters, decoders, multiplexers, arithmetic elements, and control logic. The various modules are interconnected with common data and control paths to form a digital computer system. A typical digital system module would be the processor unit of a digital computer.
The interconnection of digital functions to form a digital system module cannot be de-
scribed by means of combinational or sequential logic techniques. These techniques were devel-oped to describe a digital system at the gate and flip-flop level and are not suitable for describing the system at the digital function level. To describe a digital system in terms of functions such as adders, decoders, and registers, it is necessary to employ a higher-level mathematical nota-tion. The register-transfer logic method fulfills this requirement. In this method, the registers are selected to be the primitive components in the digital system, rather than the gates and flip-flops as in sequential logic. In this way it is possible to describe, in a concise and precise manner, the information flow and processing tasks among the data stored in the registers. The register-transfer logic method uses a set of expressions and statements which resemble the statements used in programming languages. This notation provides the necessary tools for specifying a prescribed set of interconnections between various digital functions. An important characteristic of the register-transfer logic method of presentation is that it is closely related to the way people would prefer to specify the operations of a digital system.
The basic components of this method are those that describe a digital system from the op-
erational level. The operation of a digital system is best described by specifying:
1. The set of registers in the system and their functions.
2. The binary-coded information stored in the registers.
3. The operations performed on the information stored in the registers.
4. The control functions that initiate the sequence of operations.
272 Chapter 8 
These four components form the basis of the register-transfer logic method for describing 
digital systems.
A register, as defined in the register-transfer logic notation, not only implies a register as 
defined in Chapter 7, but also encompasses all other types of registers, such as shift registers, 
counters, and memory units. A counter is considered to be a register whose function is to incre-ment by 1 the information stored within it. A memory unit is considered to be a collection of storage registers where information can be stored. A flip-flop standing alone is taken to be a 1-bit register. In fact, the flip-flops and associated gates of any sequential circuit are called a register by this method of designation.
The binary information stored in registers may be binary numbers, binary-coded decimal 
numbers, alphanumeric characters, control information, or any other binary-coded information. The operations that are performed on the data stored in registers depend on the type of data encountered. Numbers are manipulated with arithmetic operations, whereas control information is usually manipulated with logic operations such as setting and clearing specified bits in the register.
The operations performed on the data stored in registers are called microoperations. A mi-
crooperation is an elementary operation that can be performed in parallel during one clock pulse period. The result of the operation may replace the previous binary information of a register or may be transferred to another register. Examples of microoperations are shift, count, add, clear, and load. The digital functions introduced in Chapter 7 are registers that implement microop-erations. A counter with parallel load is capable of performing the microoperations increment and load. A bidirectional shift register is capable of performing the shift-right and shift-left mi-crooperations. The combinational MSI functions introduced in Chapter 5 can be used in some applications to perform microoperations. A binary parallel adder is useful for implementing the add microoperation on the contents of two registers that hold binary numbers. A microoperation 
requires only one clock pulse for execution if the operation is done in parallel. In serial comput-ers, a microoperation requires a number of pulses equal to the word time in the system. This is equal to the number of bits in the shift registers that transfer the information serially while a microoperation is being executed.
The control functions that initiate the sequence of operations consist of timing signals that 
sequence the operations one at a time. Certain conditions which depend on results of previous operations may also determine the state of control functions. A control function is a binary vari-able that, when in one binary state, initiates an operation and, when in the other binary state, inhibits the operation.
The purpose of this chapter is to introduce the components of the register-transfer logic 
method in some detail. The chapter introduces a symbolic notation for representing registers, for specifying operations on the contents of registers, and for specifying control functions. This symbolic notation is sometimes called a register-transfer language or computer hardware de-
scription language. The register-transfer language adopted here is believed to be as simple as possible. It should be realized, however, that no standard symbology exists for a register-transfer language, and different sources adopt different conventions.
A statement in a register-transfer language consists of a control function and a list of mi-
crooperations. The control function (which may be omitted sometimes) specifies the control condition and timing sequence for executing the listed micro-operations. The microoperations specify the elementary operations to be performed on the information stored in registers. The 
Register-Transfer Logic  273 
types of microoperations most often encountered in digital systems can be classified into four  
categories:
1. Interregister-transfer microoperations do not change the information content when the 
binary information moves from one register to another.
2. Arithmetic microoperations perform arithmetic on numbers stored in registers.
3. Logic microoperations perform operations such as AND and OR on individual pairs of 
bits stored in registers.
4. Shift microoperations specify operations for shift registers.
Sections 8-2 through 8-4 define a basic set of microoperations. Special symbols are as-
signed to the microoperations in the set, and each symbol is shown to be associated with cor -
responding digital hardware that implements the stated microoperation. It is important to realize 
that the register-transfer logic notation is directly related to, and cannot be separated from, the registers and the digital functions that it defines.
The microoperations performed on the information stored in registers depend on the type 
of data that reside in the registers. The binary information commonly found in registers of digital computers can be classified into three categories:
1. Numerical data such as binary numbers or binary-coded decimal numbers used in arith-metic computations.
2. Nonnumerical data such as alphanumeric characters or other binary-coded symbols used for special applications.
3. Instruction codes, addresses, and other control information used to specify the data-
processing requirements in the system.
Sections 8-5 through 8-9 discuss the representation of numerical data and their relationship 
to the arithmetic microoperations. Section 8-10 explains the use of logic microoperations for 
processing nonnumerical data. The representation of instruction codes and their manipulation with microoperations are presented in Sections 8-11 and 8-12.
8.2 Interregister Transfer
The registers in a digital system are designated by capital letters (sometimes followed by numer -
als) to denote the function of the register. For example, the register that holds an address for the memory unit is usually called the memory address register and is designated MAR. Other designations for registers are A, B, R1, R2. and IR. The cells or flip-flops of an n-bit register are 
numbered in sequence from 1 to n (or from 0 to n − 1) starting either from the left or from the 
right. Figure 8-1 shows four ways to represent a register in block diagram form. The most com-mon way to represent a register is by a rectangular box with the name of the register inside, as shown in Fig. 8-1(a). The individual cells can be distinguished as in (b), with each cell assigned a letter with a subscript number. The numbering of cells from right to left can be marked on top of the box as in the 12-bit register MBR in (c). A 16-bit register is partitioned into two parts in (d). 
Bits 1 through 8 are assigned the symbol letter L (for low) and bits 9 through 16 are assigned the 
symbol letter H (for high). The name of the 16-bit register is PC. The symbol PC(H) refers to the 
eight high-ordered cells and PC(L) refers to the eight low-ordered cells of the register.
274 Chapter 8 
Registers can be specified in a register-transfer language with a declaration statement. For 
example, the registers of Fig. 8-1 can be defined with declaration statements such as:
DECLARE REGISTER     A(8), MBR(12), PC(16)
DECLARE SUBREGISTER     PC(L) = PC(1−8), PC(H) = PC(9−16)
However, in this book we will not use declaration statements to define registers; instead, the registers will be shown in block diagram form as in Fig. 8-1. Registers shown in a block diagram can be easily converted into declaration statements for simulation purposes.
Information transfer from one register to another is designated in symbolic form by means 
of the replacement operator. The statement:
A ← B
denotes the transfer of the contents of register B into register A. It designates a replacement of 
the contents of A by the contents of B. By definition, the contents of the source register B do not 
change after the transfer.
A statement that specifies a register transfer implies that circuits are available from the out-
puts of the source register to the cell inputs of the destination register. Normally, we do not want this transfer to occur with every clock pulse, but only under a predetermined condition. The con-dition that determines when the transfer is to occur is called a control junction. A control func-tion is a Boolean function that can be equal to 1 or 0. The control function is included with the  
statement as follows:
x′T
1: A ← B
The control function is terminated with a colon. It symbolizes the requirement that the transfer operation be executed by the hardware only when the Boolean function x′T
1 = 1, i.e., when vari-
able x = 0 and timing variable T1= 1.
Every statement written in a register-transfer language implies a hardware construction for 
implementing the transfer. Figure 8-2 shows the implementation of the statement written above. The outputs of register B are connected to the inputs of register A, and the number of lines in this 
connection is equal to the number of bits in the registers. Register A must have a load control 
input so that it can be enabled when the control function is 1. Although not shown, it is assumed 
that register A has an additional input that accepts continuous synchronized clock pulses. The 
control function is generated by means of an inverter and an AND gate. It is also assumed that the A       A2A1 A4A3 A6A5 A8A7
         (a) Register A                                 (b) Showing individual cells
        12                                              1       16                   9  8                    1
MBR       PC(H) PC(L)
  (c) Numbering of cells                       (d) Portions of a register
Figure 8.1 Block diagram of registers
Register-Transfer Logic  275 
control unit that generates the timing variable T1, is synchronized with the same clock pulses that 
are applied to register A. The control function stays on during one clock pulse period (when the 
timing variable is equal to 1), and the transfer occurs during the next transition of a clock pulse.
The basic symbols of the register-transfer logic are listed in Table 8-1. Registers are de-
noted by capital letters, and numerals may follow the letters. Subscripts are used to distinguish 
individual cells of the register. Parentheses are used to define a portion of a register. The arrow denotes a transfer of information and the direction of transfer. A colon terminates a control func-tion, and the comma is used to separate two or more operations that are executed at the same time. The statement:
T
3: A ← B,       B ← A
denotes an exchange operation that swaps the contents of two registers during one common clock pulse. This simultaneous operation is possible in registers with master-slave or edge-triggered flip-flops.
The square brackets are used in conjunction with memory transfer. The letter M designates 
a memory word, and the register enclosed inside the square brackets provides the address for the memory. This is explained in more detail below.
There are occasions when a destination register receives information from two sources, but 
evidently not at the same time. Consider the two statements:
T
1: C ← A
T5: C ← BRegister B
Load
T1Control
x
Register A
Figure 8.2 Hardware implementation of the statement x′T1: A ← B
Table 8-1 Basic symbol for register-transfer logic
Symbol Description Examples
Letters (and numerals) Denotes a register A, MBR, R2
Subscript Denotes a bit of a register A2, B6
Parentheses ( ) Denotes a portion of a register PC(H), MBR(OP)
Arrow ← Denotes transfer of information A ← B
Colon : Terminates a control function x′T0:
Comma , Separates two microoperations A ← B, B ← A
Square brackets [ ] Specifies an address for memory transfer MBR ← M[MAR]
276 Chapter 8 
The first line states that the contents of register A are to be transferred to register C when timing 
variable T1 occurs. The second statement uses the same destination register as the first, but with a 
different source register and a different timing variable. The connection of two source registers to 
the same destination register cannot be done directly, but requires a multiplexer circuit to select between two possible paths. The block diagram of the circuit that implements the two statements is shown in Fig. 8-3. For registers with four bits each, we need a quadruple 2-to-l line multiplexer, similar to the one previously given in Fig. 5-17, in order to select either register A or register B. 
When T
5 = 1, register B is selected, but when T1 = 1, register A is selected (because T5 must be 
0 when T1 is 1). The multiplexer and the load input of register C are enabled every time T1 or T5 
occurs. This causes a transfer of information from the selected source register into the destina-tion register.
8.2.1 Bus Transfer
Quite often a digital system has many registers, and paths must be provided to transfer informa-tion from one register to another register. Consider, for example, the requirement for transfer among three registers as shown in Fig. 8-4. There are six data paths, and each register requires a multiplexer to select between two sources. If each register consists of n flip-flops, there is a need 
for 6n lines and three multiplexers. As the number of registers increases, the number of intercon-nection lines and multiplexers increases. If we restrict the transfer to one at a time, the number of paths among the registers can be reduced considerably. This is shown in Fig. 8-5, where the Register B
Quad 2×1
      MUX
   (Fig. 5-17)Register A
Register CSelect
Enab le
Load
T1T51 41
0 14 1 4
Figure 8.3 Use of a multiplexer to transfer information from two sources into a single  
destination
R1 R2 R3
Figure 8.4 Transfer among three registers
Register-Transfer Logic  277 
output and input of each flip-flop is connected to a common line through an electronic circuit that 
acts like a switch. All the switches are normally open until a transfer is required. For a transfer from F
1 to F3, for example, switches S1 and S4 are closed to form the required path. This scheme 
can be extended to registers with n flip-flops, and it requires n common lines.
A group of wires through which binary information is transferred one at a time among reg-
isters is called a bus. For parallel transfer, the number of lines in the bus is equal to the number 
of bits in the registers. The idea of a bus transfer is analogous to a central transportation system used to bring commuters from one point to another. Instead of each commuter using private transportation to go from one location to another, a bus system is used, and the commuters wait in line until transportation is available.
A common-bus system can be constructed with multiplexers, and a destination register for 
the bus transfer can be selected by means of a decoder. The multiplexers select one source regis-ter for the bus, and the decoder selects one destination register to transfer the information from the bus. The construction of a bus system for four registers is depicted in Fig. 8-6. The four bits in the same significant position in the registers go through a 4-to-l line multiplexer to form one line of the bus. Only two multiplexers are shown in the diagram: one for the low-order significant bits and one for the high-order significant bits. For registers of n bits, n multiplexers are needed 
to produce an n-line bus. The n lines in the bus are connected to the n inputs of ail registers. The 
transfer of information from the bus into one destination register is accomplished by activating the load control of that register. The particular load control activated is selected by the outputs of the decoder when enabled. If the decoder is not enabled, no information will be transferred, even though the multiplexers place the contents of a source register onto the bus.
To illustrate with a particular example, consider the statement:
C ← A
The control function that enables this transfer must select register A for the bus and register C for 
the destination. The multiplexers and decoder select inputs must be:
Select source = 00  (MUXs select register A)
Select destination = 10  (decoder selects register C)
Decoder enable = 0  (decoder is enabled)
On the next clock pulse, the contents of A, being on the bus, are loaded into register C.
8.2.2 Memory Transfer
The operation of a memory unit was described in Section 7-7. The transfer of information from 
a memory register to the outside environment is called a read operation. The transfer of new S3
S4S2
S5S1
S6F1 F2 F3
Figure 8.5 Transfer through one common line
278 Chapter 8 
information into a memory register is called a write operation. In both operations, the memory 
register selected is specified by an address.
A memory register or word is symbolized by the letter M. The particular memory regis-
ter among the many available in a memory unit is selected by the memory address during the 
transfer. It is necessary to specify the address of M when writing memory-transfer statements. In 0
1
2
3
0
1
2
3Select
4⋅1
MUX
No. 1
(Fig.
5-16)
4⋅1
MUX
No. 1
(Fig.
5-16)Load
Register A
Register B
Register C
Register D
Line No . n
n BUS LINES
   Line NO . 1D1DnC1CnB1BnA1An
01
Select
Enab leDestination
   decoder23
Figure 8.6 Bus system for four registers
Register-Transfer Logic  279 
some applications, only one address register is connected to the address terminals of the memory. 
In other applications, the address lines form a common-bus system to allow many registers to specify an address. When only one register is connected to the memory address, we know that this register specifies the address and we can adopt a convention that will simplify the notation. If the letter M stands by itself in a statement, it will always designate a memory register selected 
by the address presently in MAR. Otherwise, the register that specifies the address (or the address 
itself) will be enclosed within square brackets after the symbol M.
Consider a memory unit that has a single address register, MAR, as shown in Fig. 8-7. The 
diagram also shows a single memory buffer register MBR used to transfer data into and out of 
memory. There are two memory-transfer operations: read and write. The read operation is a transfer from the selected memory register M into MBR. This is designated symbolically by the 
statement:
R: MBR ← M
R is the control function that initiates the read operation. This causes a transfer of information 
into MBR from the selected memory register M specified by the address in MAR. The write 
operation is a transfer from MBR to the selected memory register M. This is designated by the 
statement:
W: M  ← MBR
W is the control function that initiates the write operation. This causes a transfer of information 
from MBR into the memory register M selected by the address presently in MAR.
The access time of a memory unit must be synchronized with the master clock pulses in 
the system that triggers the processor registers. In fast memories, the access time may be shorter than or equal to a clock pulse period. In slow memories, it may be necessary to wait for a number of clock pulses for the transfer to be completed. In magnetic-core memories, the processor reg-isters must wait for the memory cycle time to be completed. For a read operation, the cycle time includes the restoration of the word after reading. For a write operation, the cycle time includes the clearing of the memory word prior to writing.
In some systems, the memory unit receives addresses and data from many registers con-
nected to common buses. Consider the case depicted in Fig. 8-8. The address to the memory unit comes from an address bus. Four registers are connected to this bus and any one may supply an address. The output of the memory can go to any one of four registers which are selected by a de-coder. The data input to the memory comes from the data bus, which selects one of four registers. A memory word is specified in such a system by the symbol M followed by a register enclosed in Memor y unitRead
Write
MBRMAR
Figure 8.7 Memory unit that communicates with two external registers
280 Chapter 8 
square brackets. The contents of the register within the square brackets specify the address for M. 
The transfer of information from register B2 to a memory word selected by the address in register 
A1 is symbolized by the statement:
W: M [A1]← B2
This is a write operation, with register A1 specifying the address. The square brackets after the letter M give the address register used for selecting the memory register M. The statement does 
not specify the buses explicitly. Nevertheless, it implies the required selection inputs for the two multiplexers that form the address and data buses.
The read operation in a memory with buses can be specified in a similar manner. The state-
ment:
R: B0 ← M[A3]Memor y
   unitMUX
Outputs
SelectSelectSelect
LoadData bu sInputs
ReadA0
A1
A2
A3WriteAddress bu s
MUX
Destination   decoderB
0
B1
B2
B3
Figure 8.8 Memory unit that communicates with multiple registers
Register-Transfer Logic  281 
symbolizes a read operation from a memory register whose address is given by A3. The binary 
information coming out of memory is transferred to register B0. Again, this statement implies 
the required selection inputs for the address multiplexer and the selection variables for the des-
tination decoder.
8.3 Arithmetic, Logic, and Shift Microoperations
The interregister-transfer microoperations do not change the information content when the bi-nary information moves from the source register to the destination register. All other microop-erations change the information content during the transfer. Among all possible operations that can exist in a digital system, there is a basic set from which all other operations can be obtained. In this section, we define a set of basic microoperations, their symbolic notation, and the digital hardware that implements them. Other microoperations with appropriate symbols can be defined if necessary to suit a particular application.
8.3.1 Arithmetic Microoperations
The basic arithmetic microoperations are add, subtract, complement, and shift. Arithmetic shifts are explained in Section 8-7 in conjunction with the type of binary data representation. All other arithmetic operations can be obtained from a variation or a sequence of these basic microopera-tions.
The arithmetic microoperation defined by the statement:
F ← A + B
specifies an add operation. It states that the contents of register A are to be added to the contents 
of register B, and the sum transferred to register F.  To implement this statement, we require three 
registers, A, B, and F,  and the digital function that performs the addition operation, such as a par -
allel adder. The other basic arithmetic operations are listed in Table 8-2. Arithmetic subtraction implies the availability of a binary parallel subtractor composed of full-subtractor circuits con-nected in cascade. Subtraction is most often implemented through complementation and addition as specified by the statement:
F ← A + 
B + 1
Table 8-2 Arithmetic microoperations
Symbolic designation Description
F ← A + B Contents of A plus B transferred to F
F ← A − B Contents of A minus B transferred to F
B ← B Complement register B (1’ s complement)
B ← B + 1 Form the 2’ s complement of the contents of register B
F ← A + B + 1 A plus the 2’ s complement of B transferred to F
A ← A + 1 Increment the contents of A by 1 (count up)
A ← A − 1 Decrement the contents of A by 1 (count down)
282 Chapter 8 
B is the symbol for the 1’ s complement of B. Adding 1 to the 1’ s complement gives the 2’ s 
complement of B. Adding A to the 2’ s complement of B produces A minus B.
The increment and decrement microoperations are symbolized by a plus-one or minus-one 
operation executed on the contents of a register. These microoperations are implemented with an 
up-counter or down-counter, respectively.
There must be a direct relationship between the statements written in a register-transfer 
language and the registers and digital functions which are required for their implementation. To illustrate this relationship, consider the two statements:
T
2: A ← A + B
T5 A ← A +1
Timing variable T2 initiates an operation to add the contents of register B to the present con-
tents of A. Timing variable T5 increments register A. The incrementing can be easily done with a 
counter, and the sum of two binary numbers can be generated with a parallel adder. The transfer of the sum from the parallel adder into register A can be activated with a load input in the register. 
This dictates that the register be a counter with parallel-load capability. The implementation of the above two statements is shown in block diagram form in Fig. 8-9. A parallel adder receives input information from registers A and B. The sum bits from the parallel adder are applied to the 
inputs of A, and timing variable T
2 loads the sum into register A. Timing variable T5 increments 
the register by enabling the increment input (or count input, as in Fig. 7-19).
Note that the arithmetic operations multiply and divide are not listed in Table 8-2. The mul-
tiplication operation can be represented by the symbol *, and the division by a /. These two opera-tions are valid arithmetic operations but are not included in the basic set of microoperations. The only place where these operations can be considered as microoperations is in a digital system where they are implemented by means of combinational circuits. In such a case, the signals that perform these operations propagate through gates, and the result of the operation can be trans-ferred into a destination register by a clock pulse as soon as the output signals progagate through the combinational circuit. In most computers, the multiplication operation is implemented with a sequence of add and shift microoperations. Division is implemented with a sequence of subtract and shift microoperations. To specify the hardware implementation in such a case requires a list of statements that use the basic microoperations of add, subtract, and shift.Regist er B
LoadSum
T2
T5IncrementParallel adder
    (Fig. 5-1)
Regist er A
(Fig. 7-19)
Figure 8.9 Implementation for the add and increment microoperations
Register-Transfer Logic  283 
8.3.2 Logic Microoperations
Logic microoperations specify binary operations for a string of bits stored in registers. These 
operations consider each bit in the registers separately and treat it as a binary variable. As an il-
lustration, the exclusive-OR microoperation is symbolized by the statement:
F ← A ⊕ B
It specifies a logic operation that considers each pair of bits in the registers as binary variables. If the content of register A is 1010 and that of register B 1100, the information transferred to 
register F is 0110:
1010 content of A
1100 content of B
0110 content of F ← A ⊕ B
There are 16 different possible logic operations that can be performed with two binary 
variables. These logic operations are listed in Table 2-6. All 16 logic operations can be expressed 
ill terms of the AND, OR, and complement operations. Special symbols will be adopted for these three microoperations to distinguish them from the corresponding symbols used to express 
Boolean functions. The symbol ∨  will be used to denote an OR microoperation and the symbol 
∧ to denote an AND microoperation. The complement microoperation is the same as the 1’ s 
complement and uses a bar on top of the letter (or letters) that denotes the register. By using 
these symbols, it will be possible to differentiate between a logic microoperation and a control (or Boolean) function. The symbols for the four logic microoperations are summarized in Table 8-3. The last two symbols are for the shift microoperations discussed below.
A more important reason for adopting a special symbol for the OR microoperation is to 
differentiate the symbol +, when used as an arithmetic plus, from a logic OR operation. Although the + symbol has two meanings, it will be possible to distinguish between them by noting where the symbol occurs. When this symbol occurs in a microoperation, it denotes an arithmetic plus. When it occurs in a control (or Boolean) function, it denotes a logic OR operation. For example, 
in the statement:
T
1 + T2: A←A+B, C ← D ∨ F
Table 8-3 Logic and shift microoperations
Symbolic designation Description
A ← AComplement all bits of register A
F←A∨B Logic OR microoperation
F←A∧B Logic AND microoperation
F←A⊕B Logic exclusive-OR microoperation
A ← shl A Shift-left register A
A ← shr A Shift-right register A
284 Chapter 8 
the + between T1 and T2 is an OR operation between two timing variables of a control function. 
The + between A and B specifies an add microoperation. The OR microoperation is designated 
by the symbol ∨ between registers D and F.
The logic microoperations can be easily implemented with a group of gates. The comple-
ment of a register of n bits is obtained from n inverter gates. The AND microoperation is obtained 
from a group of AND gates, each of which receives a pair of bits from the two source registers. 
The outputs of the AND gates are applied to the inputs of the destination register. The OR micro-operation requires a group of OR gates arranged in a similar fashion.
8.3.3 Shift Microoperations
Shift microoperations transfer binary information between registers in serial com puters. They 
are also used in parallel computers for arithmetic, logic, and control operations. Registers can be shifted to the left or to the right. There are no conventional symbols for the shift operations. In this book, we adopt the symbols shl and shr for the shift-left and shift-right operations, respec-
tively, For example:
A ← shl A,      B ← shr B
are two microoperations that specify a l-bit shift to the left of register A and a 1-bit shift to the 
right of register B. The register symbol must be the same on both sides of the arrow as in the 
increment operation.
While the bits of a register are shifted, the extreme flip-flops receive information from the 
serial input. The extreme flip-flop is in the leftmost position of the register during a shift-right operation and in the rightmost position during a shift-left operation. The information transferred into the extreme flip-flops is not specified by the shl and shr symbols. Therefore, a shift microop-
eration statement must be accompanied with another microoperation that specifies the value of the serial input for the bit transfer into the extreme flip-flop. For example:
A ← shl A,  A
1 ← An
is a circular shift chat transfers the leftmost bit from An into the rightmost flip-flop A1 Similarly:
A ← shr A,  An ← E
is a shift-right operation with the leftmost flip-flop An receiving the value of the 1-bit register E.
8.4 Conditional Control Statements
It is sometimes convenient to specify a control condition by a conditional statement rather than a Boolean control function. A conditional control statement is symbolized by an if-then-else state-
ment in the following manner:
P: If (condition) then [microoperation(s)] else [microoperation(s)]
The statement is interpreted to mean that if the control condition stated within the parentheses after the word if is true, then the microoperation (or microoperations) enclosed within the paren-
theses after the word then is executed. If the condition is not true, the microoperation listed after 
Register-Transfer Logic  285 
the word else is executed. In any case, the control function P must occur for anything to be done. 
If the else part of the statement is missing, then nothing is executed if the condition is not true.
The conditional control statement is more of a convenience than a necessity. It enables the 
writing of clearer statements that are easier for people to interpret. It can always be rewritten in 
a conventional statement without an if-then-else form. As an example, consider the conditional control statement:
T
2: If (C = 0) then (F ← 1) else (F ← 0)
F is assumed to be a 1-bit register (flip-flop) that can be set or cleared. If register C is a 1-bit 
register, the statement is equivalent to the following two statements:
C′T2: F ← 1
CT2: F ← 0
Note that the same timing variable can occur in two separate control functions. The variable C 
can be either 0 or 1; therefore, only one of the microoperations will be executed during T2, de-
pending on the value of C.
If register C has more than one bit, the condition C = 0 means that all bits of C must be 0. 
Assume that register C has four bits C1, C2, C3, and C4. The condition for C = 0 can be expressed 
with a Boolean function:
x = C′1C′2C′3C′4 = (C1 + C2 + C3 + C4)′
Variable x can be generated with a NOR gate. Using the definition of x as above, the conditional 
control statement is now equivalent to the two statements;
xT2:           F ← 1
x′T2:           F ← 0
Variable x = 1 if C = 0 but is equal to 0 if C ≠ 0.
When writing conditional control statements, one must realize that the condition stated 
after the word if is part of the control function and not part of a microoperation statement. The 
condition must be clearly stated and must be implementable with a combinational circuit,
8.5 Fixed-point Binary Data
The binary information found in registers represents either data or control infor  mation. Data 
are operands and other discrete elements of information operated on to achieve required results. 
Control information is a bit or group of bits that specify the operations to be done. A unit of control information stored in digital computer registers is called an instruction and is a binary 
code that specifies the operations to be performed on the stored data. Instruction codes and their representation in registers are presented in Section 8-11. Some commonly used types of data and their representation in registers are presented in this and the following sections.
8.5.1 Sign and Radix-Point Representation
A register with n flip-flops can store a binary number of n bits; each flip-flop represents one bi-
nary digit. This represents the magnitude of the number but does not give information about its 
286 Chapter 8 
sign or the position of the binary point. The sign is needed for arithmetic operations, as it shows 
whether the number is positive or negative. The position of the binary point is needed to represent integers, fractions, or mixed integer-fraction numbers.
The sign of a number is a discrete quantity of information having two values: plus and mi-
nus. These two values can be represented by a code of one bit. The convention is to represent a plus with a 0 and a minus with a 1. To represent a sign binary number in a register, we need n = 
k + 1 flip-flops, k flip-flops for the magnitude and one for storing the sign of the number.
The representation of the binary point is complicated by the fact that it is characterized by 
a position between two flip-flops in the register. There are two possible ways of specifying the 
position of the binary point in a register: by giving it a fixed-point position or by employing a 
floating-point representation. The fixed-point method assumes that the binary point is always 
fixed in one position. The two positions most widely used are (1) a binary point in the extreme left of the register to make the stored number a fraction, and (2) a binary point in the extreme right of the register to make the stored number an integer. In both cases, the binary point is not physically visible but is assumed from the fact that the number stored in the register is treated as a fraction or as an integer. The floating-point representation uses a second register to store a number that designates the position of the binary point in the first register. Floating-point repre-sentation is explained in Section 8-9.
8.5.2 Signed Binary Numbers
When a fixed-point binary number is positive, the sign is represented by 0 and the magnitude by a positive binary number. When the number is negative, the sign is represented by 1 and the rest of the number may be represented in any one of three different ways. These are:
1. Sign-magnitude.
2. Sign-1’ s complement.
3. Sign-2’ s complement.
In the sign-magnitude representation, the magnitude is represented by a positive binary number. 
In the other two representations, the number is in either 1’ s or 2’ s complement. If the number is positive, the three representations are the same.
As an example, the binary number 9 is written below in the three representations. It is as-
sumed that a 7-bit register is available to store the sign and the magnitude of the number.
    + 9  − 9Sign-magnitude  0 001001 1 001001
Sign-1’ s complement 0 001001 1 110110
Sign-2’ s complement 0 001001 1 110111
A positive number in any representation has a 0 in the leftmost bit for a plus, followed by a posi-tive binary number. A negative number always has a 1 in the leftmost bit for a minus, but the magnitude bits are represented differently. In the sign-magnitude representation, these bits are the positive number; in the 1’ s-complement representation, these bits are the complement of the binary number; and in the 2’ s-complement representation, the number is in its 2’ s-complement form.
Register-Transfer Logic  287 
The sign-magnitude representation of − 9 is obtained from +9 (0 001001) by complement-
ing only the sign bit. The sign-1’ s-complement representation of − 9 is obtained by complement-
ing all the bits of 0 001001 (+ 9), including the sign bit. The sign-2’ s-complement representation 
is obtained by taking the 2’ s complement of the positive number, including its sign bit.
8.5.3 Arithmetic Addition
The reason for using the sign-complement representation for negative numbers will become ap-
parent after we consider the steps involved in forming the sum of two signed numbers. The sign-magnitude representation is the one used in everyday calculations. For example, +23 and −35 are represented with a sign, followed by the magnitude of the number. To add these two numbers, it is necessary to subtract the smaller magnitude from the larger magnitude and to use the sign of the larger number for the sign of the result, i.e., ( + 23) + (− 35) = − (35 − 23) = − 12. The process of adding two signed numbers when negative numbers are represented in sign-magnitude form requires that we compare their signs. If the two signs are the same, we add the two magnitudes. If the signs are not the same, we compare the relative magnitudes of the numbers and then sub-tract the smaller from the larger. It is necessary also to determine the sign of the result. This is a process that, when implemented with digital hardware, requires a sequence of control decisions as well as circuits that can compare, add, and subtract numbers.
Now compare the above procedure with the procedure that forms the sum of two signed 
binary numbers when negative numbers are in l’ s- or 2’ s-complement representation. These pro-cedures are very simple and can be stated as follows:
Addition with sign-2 ’ s-complement representation. The addition of two signed binary num-
bers with negative numbers represented by their 2’ s complement is obtained from the addition of the two numbers including their sign bits. A carry in the most significant (sign) bit is discarded.
Addition with sign-1 ’ s-complement representation. The addition of two signed binary num-
bers with negative numbers represented by their 1’ s complement is obtained from the addition of the two numbers, including their sign bits. If there is a carry out of the most significant (sign) bit, the result is incremented by 1 and its carry is discarded.
Numerical examples for addition with negative numbers represented by their 2’ s comple-
ment are shown below. Note that negative numbers must be initially in 2’ s-complement represen-tation and that the sum obtained after addition is always in the required representation.
+ 6 0 000110 − 6 1 111010
+ +
+ 9 0 001001 + 9 0 001001
+ 15 0 001111 + 3 0 000010
+ 6 0 000110 + − 9 1 110111
+
− 9 1 110111 − 9 1 110111
− 3 1 111101 − 18 1 101110
288 Chapter 8 
The two numbers in the four examples are added, including their sign bits. Any carry out 
of the sign bit is discarded, and negative results are automatically in their 2’ s-complement form.
The four examples are repeated below with negative numbers represented by their l’ s 
complement. The carry out of the sign bit is returned and added to the least significant bit  
(end-around carry).
+ 6 0 000110 −  6 1 111001
+ +
+ 9 0 001001 +  9 0 001001
+15 0 001111 10 000010
+
1
+  3 0 000011
+ 6 0 000110 + −  9 1 110110
+
− 9 1 110110 −  9 1 110110
− 3 1 111100 11 101100
+
1
−  18 1 101101
The advantage of the sign-2’ s-complement representation over the sign-1’ s-complement 
form (and the sign-magnitude form) is that it contains only one type of zero. The other two rep-
resentations have both a positive zero and a negative zero. For example, adding + 9 to − 9 in the 
1’ s-complement representation, one obtains:
+ 9 0 001001
− 9 1 110110
− 0 1 111111
and the result is a negative zero, i.e., the complement of 0 000000 (positive zero). A zero with 
an associated sign bit will appear in a register in one of the following forms, depending on the representation used for negative numbers:
+ 0 − 0
In sign-magnitude 0 0000000 1  0000000
In sign-1’ s complement 0 0000000 1  1111111
In sign-2’ s complement 0 0000000 none
Both the sign-magnitude and the 1’ s-complement representations have associated with them the possibility of a negative zero. The sign-2’ s-complement representation has only a posi-
tive zero. This occurs because the 2’ s complement of 0 000000 (positive zero) is 0 000000 and 
Register-Transfer Logic  289 
may be obtained from the 1’ s complement plus 1 (i.e., 1 111111 + 1) provided the end carry is  
discarded.
The range of binary integer numbers that can be accommodated in a register of n = k + 1 
bits is ± (2k − 1), where k bits are reserved for the number and one bit for the sign. A register 
with 8 bits can store binary numbers in the range of ± (27 − 1) = ± 127. However, since the 
sign-2’ s-complement representation has only one zero, it should accommodate one more num-
ber than the other two representations. Consider the representation of the largest and smallest  
numbers:
sign-1’ s complement sign-2’s complement
+ 126 = 0 1111110 − 126 = 1 0000001 1  0000010
+ 127 = 0 1111111 − 127 = 1 0000000 1  0000001
+ 128 (impossible) − 128 (impossible) 1  0000000
In the sign-2’ s-complement representation, it is possible to represent −128 with eight bits. In general, the sign-2’ s-complement representation can accommodate numbers in the range  
+ (2
k − 1) to −2k, where k = n − 1 and n is the number of bits in the register.
8.5.4 Arithmetic Subtraction
Subtraction of two signed binary numbers when negative numbers are in the 2’ s-complement form is very simple and can be stated as follows: Take the 2 ’s  complement of the subtrahend (in-
cluding the sign bit) and add it to the minuend (including sign bit). This procedure uses the fact 
that a subtraction operation can be changed to an addition operation if the sign of the subtrahend is changed. This is demonstrated by the following relationships (B is the subtrahend):
(± A) − (− B) = (± A) + (+ B)
(± A) − (+ B) = (± A) + (− B)
But changing a positive number to a negative number is easily done by taking its 2’ s complement (including the sign bit). The reverse is also true because the complement of the complement restores the number to its original value.
The subtraction with l’ s-complement numbers is similar except for the end-around carry. 
Subtraction with sign-magnitude requires that only the sign bit of the subtrahend be comple-mented. Addition and subtraction of binary numbers in sign-magnitude representation is demon-strated in Section 10-3.
Because of the simple procedure for adding and subtracting binary numbers when negative 
numbers are in sign-2’ s-complement form, most computers adopt this representation over the more familiar sign-magnitude form. The reason 2’ s complement is usually chosen over the 1’ s complement is to avoid the end-around carry and the occurrence of a negative zero.
8.6 Overflow
When two numbers of n digits each are added and the sum occupies n + 1digits, we say that an 
overflow occurs. This is true for binary numbers or decimal numbers whether signed or unsigned. 
When one performs the addition with paper and pencil, an overflow is not a problem, since we 
290 Chapter 8 
are not limited by the width of the page to write down the sum. An overflow is a problem in a 
digital computer because the lengths of all registers, including memory registers, are of finite length. A result of n + 1 bits cannot be accommodated in a register of standard length n. For this 
reason, many computers check for the occurrence of an overflow, and when it occurs, they set an overflow flip-flop for the user to check.
An overflow cannot occur after an addition if one number is positive and the other is nega-
tive, since adding a positive number to a negative number produces a result (positive or nega-tive) which is smaller than the larger of the two original numbers. An overflow may occur if the two numbers are added and both are positive or both are negative. When two numbers in sign-magnitude representation are added, an overflow can be easily detected from the carry out of the number bits. When two numbers in sign-2’ s-complement representation are added, the sign bit is treated as part of the number and the end carry does not necessarily indicate an  
overflow.
The algorithm for adding two numbers in sign-2’ s-complement representation, as previ-
ously stated, gives an incorrect result when an overflow occurs. This arises because an overflow of the number bits always changes the sign of the result and gives an erroneous n-bit answer. To see how this happens, consider the following example. Two signed binary numbers, 35 and 40, are stored in two 7-bit registers. The maximum capacity of the register is (2
6 − 1) = 63 and the 
minimum capacity is −26 = −64. Since the sum of the numbers is 75, it exceeds the capacity of the 
register. This is true if the numbers are both positive or both negative. The operations in binary are shown below together with the last two carries of the addition:
         carries: 0 1                 carries: 1 0
+ 35 0 100011 − 35 1 011101
+ 40 0 101000 − 40 1 011000
+ 75 1 001011 − 75 0 110101
In either case, we see that the 7-bit result that should have been positive is negative, and vice versa. Obviously, the binary answer is incorrect and the algorithm for adding binary numbers represented in 2’ s complement as stated previously fails to give correct results when an overflow occurs. Note that if the carry out of the sign-bit position is taken as the sign for the result, then the 8-bit answer so obtained will be correct.
An overflow condition can be detected by observing the carry into the sign-bit position 
and the carry out of the sign-bit position. If these two carries are not equal, an overflow condi-
tion is produced. This is indicated in the example above where the two carries are explicitly shown. The reader can try a few examples of numbers that do not produce an overflow to see that these two carries will always come out to be either both 0’ s or both 1’ s. If the two carries are applied to an exclusive-OR gate, an overflow would be detected when the output of the gate  
is 1.
The addition of two signed binary numbers when negative numbers are represented in sign-
2’ s-complement form is implemented with digital functions as shown in Fig. 8-10. Register A 
holds the augend, with the sign bit in position A
n. Register B holds the addend, with the sign bit 
in Bn. The two numbers are added by means of an n-bit parallel adder. The full-adder (FA) circuit 
in stage n (the sign bits) is shown explicitly. The carry going into this full-adder is Cn. The carry 
Register-Transfer Logic  291 
out of the full-adder is Cn + 1. The exclusive-OR of these two carries is applied to an overflow 
flip-flop V.  If, after the addition, V = 0, then the sum loaded into A is correct. If V = 1, there is an 
overflow and the n-bit sum is incorrect. The circuit shown in Fig. 8-10 can be specified by the 
following statement:
T: A←A + B,          V ← Cn + Cn + l
The variables in the statement are defined in Fig. 8-10. Note that variables Cn and Cn + 1 do not 
represent registers; they represent output carries from a parallel adder.
8.7 Arithmetic Shifts
An arithmetic shift is a microoperation that shifts a signed binary number to the left or right. An 
arithmetic shift-left multiplies a signed binary number by 2. An arithmetic shift-right divides the number by 2. Arithmetic shifts must leave the sign unchanged because the sign of the number remains the same when it is multiplied or divided by 2.
The leftmost bit in a register holds the sign bit, and the remaining bits hold the number. 
Figure 8-11 shows a register of n bits. Bit A
n in the leftmost position holds the sign bit and is 
designated by A(S). The number bits are stored in the portion of the register designated by A(N). 
A1 refers to the least significant bit, An - 1 refers to the most significant position in the number bits, 
and A refers to the entire register.Regist er Load
TVRegist er 
Parallel adderCn+1FA
AnBn
Cn
AB
Figure 8.10 Addition of sign-2’s-complement numbers
A(S)n 1 n×1
Number bits Sign
bitA(N)
       1 n
Regist er A
Figure 8.11 Defining register A for arithmetic shifts
292 Chapter 8 
Binary fixed-point numbers can be represented in three different ways. The manner of shift-
ing the number stored in a register is different for each representation.
Consider first the arithmetic shift-right that divides a number by 2. This can be symbolized 
by one of the following statements:
A(N) ← shr A(N), An - 1 ←  0  for sign-magnitude
A ← shr A,   A(A) ← A(S)  for sign-1’ s or sign-2’ s complement
In the sign-magnitude representation, the arithmetic shift-right requires a shift of the number bits 
with 0 inserted into the most significant position. The sign bit is not affected. In the sign-1’ s- or 2’ s-complement representation, the entire register is shifted while the sign bit remains unaltered. This is because a positive number must insert a 0 in the most significant position but a negative number must insert a 1. The following numerical examples demonstrate the procedure.
Positive number +12: 0 01100 +6: 0 00110
Sign-magnitude −12: 1 01100 −6: 1 00110
Sign-1’ s complement −12: 1 10011 −6: 1 11001
Sign-2’ s complement −12: 1 10100 −6: 1 11010
In each case the arithmetic shift-right of 12 produces a 6 without altering the sign.
For positive numbers, the result is the same in all three representations. A number in sign-
magnitude, whether positive or negative, when shifted, receives a 0 in the most significant posi-tion. In the two sign-complement representations, the most significant position receives the sign bit. The latter case is sometimes called shifting with sign extension.
Consider now the arithmetic shift-left that multiplies a number by 2. This can be symbol-
ized by one of the following statements:
A(N) ← shl A(N),  A
1 ← 0  for sign-magnitude
A ← shl A,  A1 ← A(S)  for sign-1’ s complement
A ← shl A,  A1 ← 0  for sign-2’ s complement
In the sign-magnitude representation, the number bits are shifted left with 0 inserted in the least significant position. In the sign-l’ s complement, the entire register is shifted and the sign bit is inserted into the least significant position. The sign-2’ s complement is similar, except that 0 is shifted into the least significant position. Consider the number 12 shifted to the left to  
produce 24:
Positive number    0 01100 0 11000
Sign-magnitude    1 01100 1 11000
Sign-1’ s complement   1 10011 1 00111
Sign-2’ s complement   1 10100 1 01000
Register-Transfer Logic  293 
A number shifted to the left may cause an overflow to occur. An overflow will occur after 
the shift if the following condition exists before the shift:
An − 1 = 1       for sign-magnitude
A n ⊕ An − 1 = 1        for sign-1’ s or sign-2’ s complement
In the sign-magnitude case, a 1 in the most significant position will be shifted out and lost. In the 
sign-complement case, overflow will occur if the sign bit A n = A(S) is not the same as the most 
significant bit. Consider the following numerical example with sign-1’ s-complement numbers:
Initial value     9:  0 1001      Initial value  − 9: 1 0110
shift-left       − 2:  1 0010      Shift-left  +2: 0 1101
The shift-left should produce 18, but since the original sign is lost, we obtain an incorrect result with a sign reversal. If the sign bit after the shift is not the same as the sign bit before the shift, an overflow occurs. The correct result would be a number of n + 1 bits, with the (n + l)th bit position containing the original sign of the number which is lost after the shift.
8.8 Decimal Data
The representation of decimal numbers in registers is a function of the binary code used to represent a decimal digit. A four-bit decimal code, for example, requires four flip-flops for each decimal digit. The representation of +4385 in BCD requires at least 17 flip-flops: one flip-flop for the sign and four for each digit. This number is represented in a register with 25 flip-flops as  
follows:
0 3 0 5 8 4
+
 0    0    0    0   0   0    0    0     0     0     1     0     0      0    0    1    1      1     0     0    0    0    1     0    1
By representing numbers in decimal, we waste a considerable amount of storage space 
since the number of flip-flops needed to store a decimal number in a binary code is greater than the number of flip-flops needed for its equivalent binary representation. Also, the circuits required to perform decimal arithmetic are much more complex. However, there are some ad-vantages in the use of decimal representation, mostly because computer input and output data are generated by people that always use the decimal system. A computer that uses binary representa-tion for arithmetic operations requires data conversion from decimal to binary prior to perform-ing calculations. Binary results must be converted back to decimal for output. This procedure is time consuming; it is worth using provided the amount of arithmetic operations is large, as is the case with scientific applications. Some applications, such as business data processing, require small amounts of arithmetic calculations. For this reason, some computers perform arithmetic calculations directly on decimal data (in binary code) and thus eliminate the need for conversion to binary and back to decimal. Large-scale computer systems usually have hardware for perform-ing arithmetic calculations both in binary and in decimal representation. The user can specify by programmed instructions whether the computer is to perform calculations on binary or decimal data. A decimal adder was introduced in Section 5-3.
294 Chapter 8 
There are three ways to represent negative fixed-point decimal numbers. They are similar to 
the three representations of a negative binary number except for the radix change:
1. Sign-magnitude.
2. Sign-9’ s complement.
3. Sign-10’ s complement.
For all three representations, a positive decimal number is represented by 0 (for plus) followed by 
the magnitude of the number. It is in regard to negative numbers that the representations differ. The sign of a negative number is represented by 1, and the magnitude of the number is positive in sign-magnitude representation. In the other two representations, the magnitude is represented by the 9’ s or 10’ s complement.
The sign of a decimal number is sometimes taken as a 4-bit quantity to conform with the 
4-bit representation of digits. It is customary to represent a plus with four O’ s and a minus with the BCD equivalent of 9, i.e., 1001. In this way all procedures developed for sign-2’ s-comple-ment numbers apply also to the sign-10’ s-complement numbers. The addition is done by adding all digits, including the sign digit, and discarding the end carry. For example, +375 + (− 240) is done with sign-10’ s-complement representation as follows:
     0 375+     9 760     0 135
The 9 in the second number represents a minus, and 760 is the 10’ s complement of 240. An overflow is detected in this representation from the exclusive-OR of the carries into and out of the sign digits position.
Decimal arithmetic operations may employ the same symbols as binary operations provided 
the base of the numbers is understood to be 10 instead of 2. The statement:
A ← A + 
B +1
can be used to express the addition of the decimal number stored in register A to the 10’ s comple-
ment of the decimal number in register B. B in this case denotes the 9’ s complement of the deci-
mal number. The arithmetic shifts are also applicable to decimal numbers, except that a shift-left corresponds to a multiplication by 10 and a shift-right to a division by 10. The sign-9’ s comple-ment is similar to the sign-1’ s complement, and the sign-magnitude representation in both radix representations have similar arithmetic procedures.
If the adoption of similar symbols for binary and decimal operations were not acceptable, it 
would be necessary to formulate different symbols for the operations with decimal data. Some-times the register-transfer operations are used to simulate the system by means of a computer program. In that case the two types of data can be specified by declaration statements as is done in programming languages.
8.9 Floating-point Data
Floating-point representation of numbers needs two registers. The first represents a signed fixed-point number and the second, the position of the radix point. For example, the representation of 
Register-Transfer Logic  295 
the decimal number +6132.789 is as follows:
sign
0 0 4
(exponent)sign
(coefficient)0 6 1 3 2 7 8 9Initial decimal point
first region second region
The first register has a 0 in the most significant flip-flop position to denote a plus. The magnitude 
of the number is stored in a binary code in 28 flip-flops, with each decimal digit occupying 4 flip-flops. The number in the first register is considered a fraction, so the decimal point in the first register is fixed at the left of the most significant digit. The second register contains the decimal number +4 (in binary code) to indicate that the actual position of the decimal point is 
four decimal positions to the right. This representation is equivalent to the number expressed by a fraction times 10 to an exponent, i.e., +6132.789 is represented as +.6132789 × 10
+4. Because of 
this analogy, the contents of the first register are called the coefficient (and sometimes mantissa or 
fractional part) and the contents of the second register are called the exponent (or characteristic).
The position of the actual decimal point may be outside the range of digits of the coefficient 
register. For example, assuming sign-magnitude representation, the following contents:
coefficient0 2 6 0 1 0 0 0 1 0 4
exponent
represent the number +.2601000 × 10−4 = + .000026010000, which produces four more 0’ s on the 
left. On the other hand, the following contents:
coefficient1 2 6 0 1 0 0 0 0 1 2
exponent
represent the number −.2601000 × 1012 = − 260100000000, which produces five more 0’ s on the 
right.
In these examples, we have assumed that the coefficient is a fixed-point fraction. Some 
computers assume it to be an integer, so the initial decimal point in the coefficient register is to the right of the least significant digit.
Another arrangement used for the exponent is to remove its sign bit altogether and consider 
the exponent as being “biased.” For example, numbers between 10
+49 and 10−50 can be represented 
with an exponent of two digits (without sign bit) and a bias of 50. The exponent register always contains the number E + 50, where E is the actual exponent. The subtraction of 50 from the con-
tents of the register gives the desired exponent. This way, positive exponents are represented in the register in the range of numbers from 50 to 99. The subtraction of 50 gives the positive values from 00 to 49. Negative exponents are represented in the register in the range of 00 to 49. The 
296 Chapter 8 
subtraction of 50 gives the negative values in the range of −50 to −1.
A floating-point binary number is similarly represented with two registers, one to store the 
coefficient and the other, the exponent. For example, the number + 1001.110 can be represented 
as follows:
signsign
coefficient0 1 0 0 1 1 1 0 0 0   0 0 1 0 0
exponentInitial binary point
The coefficient register has ten flip-flops: one for sign and nine for magnitude. Assuming that the coefficient is a fixed-point fraction, the actual binary point is four positions to the right, so the exponent has the binary value +4. The number is represented in binary as .100111000 × 10
100 
(remember that 10100 in binary is equivalent to decimal 24).
Floating-point is always interpreted to represent a number in the following form:
c ⋅ re
where c represents the contents of the coefficient register and e, the contents of the exponent 
register. The radix (base) r and the radix-point position in the coefficient are always assumed. 
Consider, for example, a computer that assumes integer representation for the coefficient and base 8 for the exponent. The octal number + 17.32 = + 1732 × 8
−2 will look like this:
Initial octal pointsign sign
coefficient0 1 7 3 2 1 0 0
exponent
When the octal representation is converted to binary, the binary value of the registers becomes:
coefficient0 0 0 1 1 1 1 0 1 1 0 1 0 1 0 0 0 0 1 0
exponent
A floating-point number is said to be normalized if the most significant position of the co-
efficient contains a nonzero digit. In this way, the coefficient has no leading zeros and contains the maximum possible number of significant digits. Consider, for example, a coefficient register that can accomodate five decimal digits and a sign. The number +.00357 × 10
3 = 3.57 is not 
normalized because it has two leading zeros and the unnormalized coefficient is accurate to three significant digits. The number can be normalized by shifting the coefficient two positions to the left and decreasing the exponent by 2 to obtain: +.35700 × 10
1 = 3.5700, which is accurate to five 
significant digits.
Arithmetic operations with floating-point number representation are more complicated than 
arithmetic operations with fixed-point numbers and their execution takes longer and requires 
Register-Transfer Logic  297 
more complex hardware. However, floating-point representation is more convenient because of 
the scaling problems involved with fixed-point operations. Many computers have a built-in capa-bility to perform floating-point arithmetic operations. Those that do not have this hardware are usually programmed to operate in this mode.
Adding or subtracting two numbers in floating-point representation requires first an align-
ment of the radix point, since the exponent part must be made equal before the coefficients are added or subtracted. This alignment is done by shifting one coefficient while its exponent is ad-justed until it is equal to the other exponent. Floating-point multiplication or division requires no alignment of the radix point. The product can be formed by multiplying the two coefficients and adding the two exponents. Division is accomplished from the division with the coefficients and the subtraction of the divisior exponent from the exponent of the dividend.
8.10 Nonnumeric Data
The types of data considered thus far represent numbers that a computer uses as operands for arithmetic operations. However, a computer is not a machine that only stores numbers and does high-speed arithmetic. Very often, a computer manipulates symbols rather than numbers. Most programs written by computer users are in the form of characters, i.e., a set of symbols com-prised of letters, digits, and various special characters. A computer is capable of accepting char -
acters (in a binary code), storing them in memory, and performing operations on and transfer -
ring characters to an output device. A computer can function as a character-string-manipulating machine. By a character string is meant a finite sequence of characters written one after another.
Characters are represented in computer registers by a binary code. In Table 1-5, we listed 
three different character codes in common use. Each member of the code represents one character and consists of either six, seven, or eight bits, depending on the code. The number of characters that can be stored in one register depends on the length of the register and the number of bits used in the code. For example, a computer with a word length of 36 bits that uses a character code of 6 bits can store six characters per word. Character strings are stored in memory in consecutive loca-tions. The first character in the string can be specified from the address of the first word. The last character of the string may be found from the address of the last word, or by specifying a character count, or by a special mark designating end of character string. The manipulation of characters is done in the registers of the processor unit, with each character representing a unit of information.
Various other symbols can be stored in computer registers in binary-coded form. A binary 
code can be adopted to represent musical notes for the production of music by computer. Special binary codes are needed to represent speech patterns for an automatic speech-recognition sys-tem. The display of characters through a dot matrix in a CRT (cathode-ray tube) screen requires a binary-coded representation for each symbol that is displayed. Status information to supervise the operation of a controlled process or a power-distribution system uses predetermined binary-coded information. The chess board and pieces to run a chess game by computer require some form of binary-coded information representation.
The operations mostly done on nonnumerical data are transfers, logic, shifts, and control 
decisions. The transfer operations can prepare the binary-coded information in some required or -
der in memory and transfer the information to and from external units. Logic and shift operations provide a capability to perform data manipulation tasks that help in the decision-making process.
Logic microoperations are very useful for manipulating individual bits stored in a register 
or a group of bits that comprise a given binary-coded symbol. Logic operations can change bit 
298 Chapter 8 
values, delete a group of bits, or insert new bit values into a register. The following examples 
show how the bits of one register are manipulated by logic and shift microoperations as a func-tion of logic operands that are prestored in memory.
The OR microoperation can be used to set a bit or a selected group of bits in a register. The 
Boolean relations x + 1 = 1 and x + 0 = x dictate that the binary variable x, when ORed with a 1, 
produces a 1 regardless of the binary value of x; but, when ORed with a 0, it does not change the 
value of x. By ORing a given bit A
1 in a register with a 1, it is possible to set bit A1 to 1 regardless 
of its previous value. Consider the following specific example:
0101  0101 A
1111  0000 B
1111  0101 A ← A ∨ B
The logic operand in B has 1’ s in the four high-order bit positions. By ORing this value with 
the present value of A, it is possible to set the four high-order bits of A to 1’ s but leave the four 
low-order bits unchanged. Thus, the OR microoperation can be used to selectively set bits of a register.
The AND microoperation can be used to clear a bit or a selected group of bits in a register. 
The Boolean relationships x ⋅ 0 = 0 and x ⋅ 1 = x dictate that binary variable x, when ANDed 
with a 0, produces a 0 regardless of the binary value of x; but, when ANDed with a 1, it does not 
change the value of x. A given bit A
i in register A can be cleared to 0 if it is ANDed with a 0. Con-
sider a logic operand B = 0000 1111. When this operand is ANDed with the contents of a register, 
it will clear the four high-order bits of the register but leave the four low-order bits unchanged:
0101  0101 A
0000  1111 B
0000  0101 A ← A ∧ B
The AND microoperation can be used to selectively clear bits of a register. The AND operation is sometimes called a mask operation because it masks or removes all l’ s from a selected portion 
of a register.
The AND operation followed by an OR operation can be used to change a bit or a group 
of bits from a given value to a new desired value. This is done by first masking the bits in ques-tion and then ORing the new value. For example, suppose an A register contains eight bits, 0110 
0101. To replace the four high-order bits by the value 1100, we first mask the four unwanted bits:
0110   0101 A
0000   1111 B1
0000   0101 A ← A L B1
and then insert the new value:
0000   0101 A
1100   0000 B2
1100   0101 A ← A L B1
The mask operation is an AND microoperation and the insert operation is an OR microoperation.
Register-Transfer Logic  299 
The XOR (exclusive-OR) microoperation can be used to complement a bit or a selected 
group of bits in a register. The Boolean relationships x ⊕ 1 = x’ and x ⊕ 0 = x dictate that the 
binary variable x be complemented when XORed with a 1 and remain unchanged otherwise. By 
XORing a given bit in a register with a 1, it is possible to complement the selected bit. Consider 
the numerical example:
1101   0101 A
1111   0000 B
0010   0101 A ← A ⊕ B
The four high-order bits of A are complemented after the exclusive-OR operation with operand 
B. The XOR microoperation can be used to selectively complement bits of a register. If the op-
erand B has all 1’ s, the XOR operation will complement all the bits of A. If the contents of A are 
XORed with their own value, the register will be cleared, since x ⊕ x = 0:
0101   0101 A
0101   0101 B
0000   0000 A ← A ⊕ A
The value of individual bits in a register can be determined by first masking all bits, except 
the one in question, and then checking if the register is equal to 0 Suppose we want to determine if bit 4 in register A is 0 or 1:
101 x 010 A
0001000 B
000 x 000 A ← B L A
The bit marked x can be 0 or 1. When all other bits are masked with the operand in B, register A will contain all 0’ s if bit 4 was a 0. If bit 4 was originally a 1, this bit will remain a 1. By checking if the contents of A are 0 or not, we determine whether bit 4 was 0 or 1.
If each bit in a register must be checked for 0 or 1, it is more convenient to shift the register 
to the left and transfer the high-order bit into a special 1-bit register which is usually called the carry flip-flop. After every shift, the carry can be checked for 0 or 1 and a decision made depend-ing on the outcome.
Shift operations are useful for packing and unpacking binary-coded information. Packing 
of binary-coded information such as characters is an operation that groups two or more charac-ters in one word. Unpacking is a reverse operation that separates two or more characters stored in one word into individual characters. Consider the packing of BCD digits that are first entered as ASCII characters. The ASCII character code for digits 5 and 9 are obtained from Table 1-5. Each contains seven bits and a 0 is inserted in the high-order position as shown below. The character 5 is transferred to register A, and 9 to register B. The four high-order bits are of no use for BCD 
representation, so they are masked out. The packing of the two BCD digits into register A con-
sists of shifting register A four times to the left (with 0’ s inserted in the low-order bit positions) 
and then ORing the contents of the registers;
300 Chapter 8 
           A         B
ASCII 5 =  0011 0101 0011 1001 = ASCII 9
AND with 0000 1111 0000 0101 0000 1001
Shift A left four times 0101 0000
A ← A ∨ B  0101 1001 = BCD 59
A shift operation with 0 inserted in the extreme bit is considered a logical shift microoperation.
The binary information available in a register during logical operations is called a logical 
word. A logical word is interpreted to be a bit string as opposed to character strings or numeri-
cal data. Each bit in a logical word functions in exactly the same way as every other bit; in other 
words, the unit of information of a logical word is a bit.
8.11 Instruction Codes
The internal organization of a digital system is defined by the registers it employs and the se-quence of microoperations it performs on data stored in the registers. In a special-purpose digital 
system, the sequence of microoperations is fixed and the system performs the same specific task over and over again. A digital computer is a general-purpose digital system capable of executing 
various operations and, in addition, can be instructed as to what specific sequence of operations it must perform. The user of a computer can control the process by means of a. program, i.e., a set of instructions that specify the operations, operands, and the sequence in which processing has to occur. The data-processing task may be altered simply by specifying a new program with different instructions or by specifying the same instructions with different data. Instruction codes, together with data, are stored in memory. The control reads each instruction from memory and places it in a control register. The control then interprets the instruction and proceeds to execute it by issuing a sequence of control functions. Every general-purpose computer has its own unique instruction repertoire. The ability to store and execute instructions, the stored-program concept, is the most important property of a general-purpose computer.
An instruction code is a group of bits that tell the computer to perform a specific operation. 
It is usually divided into parts, each having its own particular interpretation. The most basic part of an instruction code is its operation part. The operation code of an instruction is a group of 
bits that define an operation such as add, subtract, multiply, shift, and complement. The set of machine operations formulated for a computer depends on the processing it is intended to carry out. The total number of operations thus obtained determines the set of machine operations. The number of bits required for the operation part of the instruction code is a function of the total number of operations used. It must consist of at least n bits for a given 2
n (or less) distinct op-
erations. The designer assigns a bit combination (a code) to each operation. The control unit of the computer is designed to accept this bit configuration at the proper time in a sequence and to supply the proper command signals to the required destinations in order to execute the specified operation. As a specific example, consider a computer using 32 distinct operations, one of them being an ADD operation. The operation code may consist of five bits, with a bit configuration 10010 assigned to the ADD operation.
When the operation code 10010 is detected by the control unit, a command signal is applied 
to an adder circuit to add two numbers.
Register-Transfer Logic  301 
The operation part of an instruction code specifies the operation to be performed. This op-
eration must be executed on some data, usually stored in computer registers. An instruction code, 
therefore, must specify not only the operation but also the registers where the operands are to be found as well as the register where the result is to be stored. These registers may be specified in an instruction code in two ways. A register is said to be specified explicitly if the instruction code 
contains special bits for its identification. For example, an instruction may contain not only an operation part but also a memory address. We say that the memory address specifies explicitly a memory register. On the other hand, a register is said to be specified implicitly if it is included 
as part of the definition of the operation, i.e., if the register is implied by the operation part of the code.
8.11.1 Instruction-Code Formats
The format of an instruction is usually depicted in a rectangular box symbolizing the bits of the instruction as they appear in memory words or in a control register. The bits of the instruction are sometimes divided into groups that subdivide the instruction into parts. Each group is assigned a symbolic name, such as operation-code part or address part. The various parts specify differ -
ent functions for the instruction, and when shown together they constitute the instruction-code format. 
Consider, for example, the three instruction-code formats specified in Fig. 8-12. The in-
struction format in (a) consists of an operation code which implies a register in the processor unit. It can be used to specify operations such as “clear a processor register,” or “complement a register,” or “transfer the contents of one register to a second register.” The instruction format in (b) has an operation code followed by an operand. This is called an immediate operand instruc-
tion because the operand follows immediately after the operation-code part of the instruction. It can be used to specify operations such as “add the operand to the present contents of a register” or “transfer the operand to a processor register,” or it can specify any other operation to be done between the contents of a register and the given operand. The instruction format specified in Fig. 8-12(c) is similar to the one in (b) except that the operand must be extracted from memory at the location specified by the address part of the instruction. In other words, the operation specified by the operation code is done between a processor register and an operand which can be stored in memory anywhere. The address of this operand in memory is included in the instruction.
Let us assume that we have a memory unit with 8 bits per word and that an operation code 
contains 8 bits. The placement of the three instruction codes in memory is depicted in Fig. 8-13. At address 25, we have an implied instruction that specifies an operation: “transfer the contents of processor register R into processor register A.” This operation can be symbolized by the state-
ment:
A ← R
In memory addresses 35 and 36, we have an immediate operand instruction that occupies 
two words. The first word at address 35 is the operation code for the instruction, “transfer the operand to register A,”  symbolized as:
A ← operand
The operand itself is stored immediately after the operation code at address 36.
302 Chapter 8 
In addresses 45 and 46, there is a direct address instruction that specifies the operation:
A ← M[address]
This symbolizes a memory-transfer operation of an operand which is specified by the address 
part of the instruction. The second word of the instruction at address 46 contains the address, and its value is binary 70. Therefore, the operand to be transferred to register A is the one stored in 
address 70, and its value is shown to be binary 28. Note that the instruction is stored in memory at some address. This instruction has an address part which gives the address of the operand. To avoid the confusion of saying the word “address” so many times, it is customary to refer to a memory address as a “location.” Thus the direct address instruction is stored in locations 45 and 46. The address of the operand is in location 46, and the operand is available from location 70.
It must be realized that the placing of instructions in memory as shown in Fig, 8-13 is only 
one of many possible alternatives. Only very small computers have 8-bit words. Large computers may have from 16 to 64 bits per word. In most computers, the entire instruction can be placed in one word, and in some, even two or more instructions can be placed in a single memory word.
The instruction formats shown in Fig. 8-12 are three of many possible formats that can be 
formulated for digital computers. They are presented here just as an example and should not be considered the only possibilities. Subsequent chapters, especially Chapters 11 and 12, present and discuss other instructions and instruction-code formats.
At this point we must recognize the relationship between an operation and a microoperation 
as applied to a digital computer. An operation is specified by an instruction stored in computer memory. It is a binary code that tells the computer to perform a specific operation. The control unit receives the instruction from memory and interprets the operation-code bits. It then issues a sequence of control functions that perform microoperations in internal computer registers.
For every instruction in memory that specifies an operation, the control issues a sequence 
of microoperations which are needed for the hardware implementation of the specified opera-tion code. An operation is specified by a user in the form of an instruction to the computer. A microoperation is an elementary operation which is constrained by the available hardware inside the computer.
8.11.2 Macrooperations versus Microoperations
There are occasions when it is convenient to express a sequence of microoperations with a single 
statement. A statement that requires a sequence of microoperations for its implementation is Operation-code    (a) Implied
Operation-code Operand  (b) Immediate operand
Operation-code Address of operand  (c) Direct address
Figure 8.12 Three possible instruction formats
Register-Transfer Logic  303 
called a macrooperation. A statement in the register-transfer method of notation that defines an 
instruction is a macrooperation statement, although macrooperation statements can be used on 
other occasions as well. The register-transfer method can be used to define the operation speci-
fied by a computer instruction because all instructions specify some register-transfer operation which must be executed by computer hardware.
One cannot tell from looking at an isolated register-transfer statement whether it represents 
a macro- or microoperation, since both types of statements denote some register-transfer state-
ment. The only way to distinguish between them is to recognize from the context and the internal hardware of the system in question whether the statement is executed with one control function or not. If the statement can be executed with a single control function, it represents a microopera-tion. If the hardware execution of the statement requires two or more control functions, the state-ment is taken to be a macrooperation. Only if one knows the hardware constraints of the system can this question be answered.
Consider, for example, the instruction in Fig. 8-13 symbolized by the statement:
A ← operand
This statement is a macrooperation because it specifies a computer instruction. To execute the instruction, the control unit must issue control functions for the following sequence of microop-erations:
1. Read the operation code from address 35.
2. Transfer the operation code to a control register.
3. The control decodes the operation code and recognizes it as an immediate operand in-struction, so it reads the operand from address 36.
4. The operand read from memory is transferred into register A.
Memor y Operation Address
0000000 1 op-code=1 A←R
A←Operand
A←M(A ddress)op-code=2
operand=44
op-code=3
address=70
operand=28000000 10
00101100
00011100000000 11
0100011025
35
36
45
46
70
Figure 8.13 Memory representation of instructions
304 Chapter 8 
The microoperation in step 4 executes the instruction, but steps 1 through 3 are needed prior to 
it for the control to interpret the instruction itself. The statement that symbolizes the instruction:
A ← R
is also a macrooperation because the control has to first read the operation code at address 25 to decode and recognize it. The interregister transfer itself is executed with a second control func-tion.
The register-transfer method is suitable for describing the operations among the registers 
in a digital system. It can be used at different levels of presentation provided one interprets the statements properly. Specifically, it can be used for the following tasks:
1. To define computer instructions concisely by macrooperation statements.
2. To express any desired operation by means of a macrooperation statement without being concerned with specific hardware implementation.
3.  To define the internal organization of digital systems by means of control functions and 
microoperations.
4.  To design a digital system by specifying the hardware components and their interconnec-
tions.
The set of instructions for a given computer can be explained in words, but when defined 
with macrooperation statements, the definition can be stated precisely and with a minimum of ambiguity. The use of other macrooperation statements may facilitate the initial specifications of a system and can be used to simulate the system when it is desired to check its intended operation. The internal organization of a digital system is best described by a set of control functions and microoperations. The list of register-transfer statements that describe the organi-zation of the system can be used to derive the digital functions from which the system can be  
designed.
The next section shows by example how the register-transfer method is used in each of the 
four tasks listed above. This is done by defining and designing a very simple computer.
8.12 Design of a Simple Computer
The block diagram of a simple computer is shown in Fig. 8-14. The system consists of a memory unit, seven registers, and two decoders. The memory unit has 256 words of 8 bits each, which is very small for a real computer, but sufficient for demonstrating the basic operations found in most computers. Instructions and data are stored in the memory unit, but all information process-ing is done in the registers. The registers are listed in Table 8-4, together with a brief description of their function and the number of bits they contain.
The memory address register, MAR, holds the address for the memory. The memory buffer 
register, MBR, holds the contents of the memory word read from or written into memory. Regis-
ters A and R are general-purpose processor registers.
The program counter PC, the instruction register IR, and the timing counter T are part of 
the control unit. The IR receives the operation code of instructions. The decoder associated with 
this register supplies one output for each operation code encountered. Thus q
1 = 1 if the operation 
code is binary 1, q2 = 1 if the operation code is binary 2, and so on. The T counter is also decoded 
Register-Transfer Logic  305 
to supply eight timing variables, t0 through t7 (see Section 7-6). This counter is incremented with 
every clock pulse, but it can be cleared at any time to start a new sequence from t0.
The PC goes through a step-by-step counting sequence and causes the computer to read 
successive instructions previously stored in memory. The PC always holds the address of the 
next instruction in memory. To read an instruction, the contents of PC are transferred into MAR 
and a memory-read cycle is initiated. The PC is then incremented by 1 so it holds the next ad-
dress in the sequence of instructions. An operation code read from memory into MBR is then 
transferred into IR. If the memory-address part of an instruction is read into MBR, this address is  PC
MAR
MBR
Operation
  decoderMemor y unit
  256 × 8
Timing
decoderIR
A
R
Tt0q1q2q3
t7
Figure 8.14 Block diagram of a simple computer
Table 8-4 List of registers for the simple computer
Symbol Number of bits Name of register Function
MAR 8 Memory address register Holds address for memory
MBR 8 Memory buffer register Holds contents of memory word
A 8 A register Processor register
R 8 R register Processor register
PC 8 Program counter Holds address of instruction
IR 8 Instruction register Holds current operation code
T 3 Timing counter Sequence generator
306 Chapter 8 
transferred into MAR to read the operand. Thus, MAR can receive addresses either from PC or from  
MBR.
The three instructions defined in the previous section are specified again in Table 8-5. Since 
there are eight bits in the operation code, it is possible to specify up to 256 different operations. 
To simplify the presentation, we consider here only the three listed instructions. The mnemonic associated with each instruction can be used by programmers to specify the instructions with symbolic names. The mnemonic MOV stands for the corresponding binary operation code and symbolizes a “move” instruction. The R symbol following the MOV indicates that the contents of R are moved to register A. The mnemonic LDI symbolizes a “load immediate” instruction. The OPRD following LDI stands for an actual operand that the programmer must specify with this instruction. LDA is an abbreviation for “load into A,” and the ADRS following it stands for an address number that the programmer must specify with this instruction. The actual OPRD and ADRS values, together with their corresponding operation codes, will be stored in memory as in Fig. 8-13.
Table 8-5 gives a word description for each instruction. This word description is not precise. 
The statements listed under the function column give a concise and precise definition of each instruction.
A computer with only three instructions is not very useful. We must assume that this com-
puter has many more instructions, even though only three of them are considered here. A pro-gram written for the computer is stored in memory. This program consists of many instructions, but once in a while the instruction used will be one of the three listed. We now consider the internal operations needed to execute the instructions that arc stored in memory.
8.12.1 Instruction Fetch Cycle
Program counter PC must be initialized to contain the first address or the program stored in 
memory. When, a “start” switch is activated, the computer sequence follows a basic pattern. An operation code whose address is in PC is read from memory into MBR. The PC is incremented 
by 1 to prepare it for the next address in sequence. The operation code is transferred from MBR to 
IR, where it is decoded by the control. This sequence is called the instruction fetch cycle, since it 
fetches the operation code from memory and places it in a control register. The timing variables, t
0, t1, and t2, out of the timing decoder are used as control functions to sequence the microopera-
tions for reading an operation code (op-code) and placing it into IR:
t0: MAR ← PC transfer op-code address
t1: MBR ← M, PC ← PC + 1 read op-code, increment PC
t2: IR ← MBR transfer op-code to IRTable 8-5 Three instructions for a simple computer
Operation code Mnemonic Description Function
00000001 MOV  R Move R to A A ← R
00000010 LDI   OPRD Load OPRD into A A ← OPRD
00000011 LDA  ADRS Load operand specified by ADRS into A A ← M[ADRS]
Register-Transfer Logic  307 
It is assumed that the timing counter, T, starts from a value 000 which produces a t0 timing 
variable out of the decoder. The T register is incremented with every clock pulse and automati-
cally produces the next timing variable in sequence. The first three timing variables execute the 
microoperation sequence which may be symbolized with the macrooperation statement:
IR ← M[PC], PC ← PC + 1
This states that the memory word specified by the address in PC is transferred into IR and then 
the PC is incremented. The hardware constraint in the simple computer is that only MAR and 
MBR can communicate with the memory. Since PC and IR cannot communicate directly with the 
memory, the above macrooperation must be executed with a sequence of three microoperations. Another hardware constraint is that the PC cannot be incremented while its value is being used 
to supply the address for a memory read. Only after the read operation is completed can the PC 
be incremented. By transferring the contents of PC into MAR, the PC can be incremented while 
the memory reads the word addressed by MAR.
The fetch cycle is common to all instructions. The microoperations and control functions 
that follow the fetch cycle are determined in the control section from the decoded operation code. This is available from outputs q
i, i = 1, 2, 3,…. in the operation decoder.
8.12.2 Execution of Instructions
During timing variable t3, the operation code is in IR and one output of the operation decoder is 
equal to 1. The control uses the qi variables to determine the next microoperations in sequence. 
The MOV R instruction has an operation code that makes q1 = 1. The execution of this instruc-
tion requires the microoperation:
q1t3: A ← R, T ← 0
Thus, when qi = 1 at time t3, the-contents of R are transferred into register A and the tim-
ing register T is cleared. By clearing T, control goes back to produce timing variable t0, and 
thus starts the fetch cycle again to read the operation code of the next instruction in sequence. Remember that PC was incremented during time t
1, so now it holds the address of the next in-
struction in sequence.
The LDI OPRD instruction has an operation code that makes q2 = 1. The microoperations 
that execute this instruction are:
q2t3:    MAR ← PC      transfer operand address
q2t4:    MBR ← M, PC ← PC +1 read operand, increment PC
q2t5:    A ← MBR, T ← 0  transfer operand, go to fetch cycle.
The three timing variables that follow the fetch cycle while q2 = 1 read the operand from memory 
and transfer it into register A. Since the operand is in a memory location following the operation 
code, it is read from memory from the address specified in PC, The operand read into MBR is 
then transferred to A. Note that PC is incremented once again to prepare it for the address of the 
next operation code before going back to the fetch cycle.
308 Chapter 8 
The LDA ADRS instruction has an operation code that makes q3 = 1. The microoperations 
needed to execute this instruction are listed below:
q3t3: MAR ← PC transfer next instruction address
q3t4: MBR ← M, PC ← PC + 1 read ADRS, increment PC
q3t5: MAR ← MBR transfer operand address
q3t6: MBR ← M read operand
q3t7: A ← MBR, T ← 0 transfer operand to A, go to fetch cycle
The address of the operand, symbolized by ADRS, is placed in memory right after the 
operation code. Since PC was incremented at t1 during the fetch cycle, it now holds the address 
where ADRS is stored. The value of ADRS is read from memory at time t4. PC is incremented at 
this time to prepare it for the fetch cycle of the next instruction. At time t5, the value of ADRS is 
transferred from MBR to MAR. Since ADRS specifies the address of the operand, a memory read 
during time t6 causes the operand to be placed in MBR. The operand from MBR is transferred to 
register A and control goes back to the fetch cycle.
The control functions and microoperations for the simple computer are summarized in 
Table 8-6. The first three timing variables constitute the fetch cycle which reads the operation 
code into IR. The microoperations that are executed during time t3 depend on the operation-code 
value in IR. There are three control functions that are a function of t3, but either q1 or q2 or q3 
can be equal to 1 at this time. The particular microoperation executed at time t3 is the one whose 
corresponding control function has a q variable that is equal to 1. The same can be said for the 
other timing variables.
A practical computer has many instructions, and each instruction requires a fetch cycle 
for reading its operation code. The microoperations needed for the execution of the particular instructions are specified by the timing variables and by the particular q
i, i = 0, 1, 2. 3,…, 255, 
Table 8-6 Register-transfer statements for a simple computer
FETCH t0: MAR ← PC
t1: MBR ← M, PC ← PC + 1
t2: IR ← MBR
MOV q1t3: A ← R, T ← 0
LDI q2t3: MAR ← PC
q2t4: MBR ← M, PC ← PC + 1
q2t5: A ← MBR, T ← 0
LDA q3t3: MAR ← PC
q3t4: MBR ← M, PC ← PC + 1
q3t5: MAR ← MBR
q3t6: MBR ← M
q3t7: A ← MBR, T ← 0
Register-Transfer Logic  309 
which happens to be in the 1-state at that time. The list of control functions and microoperations 
for a practical computer would be much longer than the one shown in Table 8-6. Obviously, the simple computer is not a practical device, but by using only three instructions, the basic functions of a digital computer can be clearly demonstrated. The extension of this principle to a computer with more instructions and more processor registers should be apparent from this example. In Chapter 11, we use the principles presented here to design a more realistic computer.
8.12.3 Design of Computer
It was shown previously that the register-transfer logic is suitable for defining the operations specified by computer instructions. We have just shown that the register-transfer logic is a con-venient method for specifying the sequence of internal control functions in a digital computer, together with the microoperations they execute. It will be shown now that the list of control functions and microoperations for a digital system is a convenient starting point for the design of the system. The list of microoperations specifies the types of registers and associated digital functions that must be incorporated in the system. The list of control functions specifies the logic gates required for the control unit. To demonstrate this procedure, we will go through the design of the simple computer from the list of register-transfer statements given in Table 8-6.
The first step in the design is to scan the register-transfer statements listed in Table 8-6 
and retrieve all those statements that perform the same microoperation on the same register. For example, the microoperation MAR ← PC is listed in the first line with control function t
0, in the 
fifth line with control function q2t3, and in the eighth line with control function q3t3. The three 
lines are combined into one statement:
t0 + q2t3 + q3t3: MAR ← PC
Remember that a control function is a Boolean function. The + between the control functions denotes a Boolean OR operation, and the absence of an operator between q
2 and t3 denotes a 
Boolean AND operation. The above statement combines all the control conditions for the trans-fer from PC into MAR. The hardware implementation of the above statement is depicted in Fig. 
8-15. The control function can be manipulated as a Boolean function to give:
x
1 = t0 + q2t3+ q3t3 = t0 + (q2 + q3)t3
The binary variable x1 is applied to the load input of MAR and the outputs from PC are applied 
to the inputs of MAR. When x1 = 1, the next clock pulse transfers the contents of PC into MAR. 
The binary variables that cause x1 to be a 1 come from the operation and timing decoders in the 
control unit.
MARLoadPC
x1t0
t3
q2
q3
Figure 8.15 Implementation of x1 : MAR ← PC
310 Chapter 8 
There are eight different microoperations listed in Table 8-6. For each distinct microop-
eration, we accumulate the associated control functions and OR them together. The result is 
as shown in Table 8-7. The combined control functions obtained for each microoperation are equated to a binary variable x
1, i = 1, 2,..., 8. The eight x variables can be easily generated with 
AND and OR gates, and will not be done here.
The design of the simple computer can be now obtained from the register-transfer infor -
mation given in Table 8-7. The block diagram design is shown in Fig. 8-16. Here we again have the seven registers, the memory unit, and two decoders. In addition, there is a box labeled “combinational circuit.” The combinational-circuit block generates the eight control functions, x
1 
through x8, according to the list of control functions in the table. The control functions enable the 
load and increment inputs of the various registers. A register that receives information from two sources needs a multiplexer to select between the two. For example, MAR receives information 
from MBR or from PC. The multiplexer associated with MAR transfers the contents of PC when 
its select line is a 1 (x
1 = 1) but transfers the contents of MBR when the select line is 0. This is 
because x1 = 0 when x2 = 1, but x2 initiates the load input of MAR so that the contents of MBR 
go through the multiplexer into MAR. Timing counter T is incremented with every clock pulse; 
however, when x7 = 1, it is cleared to zero.
The registers and other digital functions specified in Fig. 8-16 can be designed individually 
by means of combinational and sequential logic procedures. If the system is constructed with integrated circuits, one can readily find commercial MSI circuits for all registers and digital functions. The combinational circuit for the control can be constructed with SSI gates. In a large computer, this part would be more efficiently implemented with a programmable logic array.
REFERENCES
1. Mano, M. M., Computer System Architecture. Englewood Cliffs, N.J.: Prentice-Hall. Inc.,1976.
2. Chu, Y ., Computer Organization and Microprogramming. Englewood Cliffs, N.J.; Prentice-Hall, Inc., 
1972.
3. Dietmeyer, D. Logical Design of Digital Systems. Boston, Mass.: Allyn and Bacon, 1971.
4. Bell, C. G., and A. Newell. Computer Structures: Readings and Examples. New Y ork: McGraw-Hill 
Book Co., 1971.Table 8-7 Hardware specification for a simple computer
x1 = t0 + q2t3+q3t3: MAR ← PC
x2 = q3t5: MAR ← MBR
x3 = t1 + q2t4+q3t4: PC ← PC + 1
x4 = x3+q3t6: MBR ← M
x5 = q2t5+q3t7: A ← MBR
x6 = q1t3: A ← R
x7 = x5+x6: T ← 0
x8 = t2: IR ← MBR
Register-Transfer Logic  311 
Increment
Increment
ClearTAddressPC
Load
Load
LoadLoad
Decoder
DecoderIRRead
MAR
MBR
R
1
s
A0MUX
MUX1
0sMemor y
q2q1 q3x8
x1
x2Combinational
      cir cuit
x3x5
x6
x7
x4t0 t6t7
Figure 8.16 Design of a simple computer
312 Chapter 8 
5. Hill, F ., and G. Peterson, Digital Systems: Hardware Organization and Design. New Y ork: John Wiley 
& Sons, 1973.
6. Bartee, T. C, I. L. Lebow, and I. S. Reed, Theory and Design of Digital Machines. New Y ork: McGraw-Hill Book Co., 1962.
7. Computer, Special Issue on Computer Hardware Description Languages, V ol. 7, No. 12 (December, 
1974).
8. Computer, Special Issue on Hardware Description Language Applications, V ol. 10, No, 16 (June, 
1977).
PROBLEMS
8-1.  Show the block diagram that executes the statement:
 xT3: A ← B, B ← A
8-2.  A constant value can be transferred to a register by applying to each input a binary signal equivalent to logic-1 or logic-0. Show the implementation of the transfer:
 T: A ← 11010110
8-3. An 8-bit register A has one input x. The register operation is described symbolically as:
 P: A
8 ← x,    Ai ← Ai + 1    i = 1.2, 3,….,7
 What is the function of the register? The cells are numbered from right to left.
8-4.  Show the hardware implementation for the following statements. The registers are 4-bits in length:
  T0: A ← R0
  T1: A ← R1
  T2: A ← R2
  T3: A ← R3
8-5.  Let s1 , s0 be the selection variables for the multiplexer of Fig. 8-6, and let d1d0 be the selection 
variables for the destination decoder. Variable e is used to enable the decoder.
(a) State the transfers that occur when the selection variables s1s0d1d0e are equal to: (1) 00010; (2) 
O1000; (3) 11100; (4) 01101.
(b) Give the values of the selection variables for the following transfers: (1) A ← B; (.2) B ← C; (3) 
D ← A.
8-6.  A memory unit has two control inputs labeled enable and read/write (as explained in conjunction 
with Pig. 7-30). The memory data inputs and outputs are connected to an MBR register as in Fig. 8-7. 
The MBR can receive information either from an external register EXR or from the memory unit after 
a read operation. The MBR provides the data for the memory-write operation. Draw a block diagram 
using multiplexers and gates that shows the connection of MBR to memory. The system must have a 
capability of implementing the following three transfers:
  W: M ← MBR  write into memory
  R: MBR ← M  read from memory
  E: MBR ← EXR  load MBR from EXR
Register-Transfer Logic  313 
8-7.  The following memory transfers are specified for the system of Fig. 8-8.
(a) M [A2] ← B3
(b) B2 ← M [A3]
 Specify the memory operation and determine the binary selection variables for the two multiplexers 
and the destination decoder.
8-8.  Using the quadruple 2-to-1 line multiplexers of Fig. 5-17 and four inverters, draw a block diagram for implementing the statements:
  T
1: R2 ← R1
  T2: R2 ← R2
  T3: R2 ← 0
8-9.  Consider a 4-bit register A with bit A4 being in the most significant position. What is the operation 
specified by the following statement:
     A′4C:  A ← A + 1
     A4:  A ← 0
 Show the implementation of the system using a counter with parallel load.
8-10.  Show the hardware required to implement the following logic microoperations:
(a) T1:   F ← A ∧ B
(b) T2:   G ← C ∨ D
(c) T3:   E ← E
8-11.  What is the difference between these two statements?
 A + B:     F ← C ∨ D
 and
 C + D:     F ← A + B
8-12.  Specify the serial transfer depicted in Fig. 7-8 in symbolic form. Let S be the shift control function. 
Assume that S is enabled for a period of four pulses.
8-13.  Show the hardware that implements the following statement. Include the logic gates for the control 
function.
 xy′T0 + T1 + x′yT2:       A ← A + B
8-14.  A digital system has three registers: AR, BR, and PR. Three flip-flops provide the control functions 
for the system: S is a flip-flop which is enabled by an external signal to start the system’ s operation; F 
and R are used for sequencing the microoperations. A fourth flip-flop, D, is set by the digital system 
when the operation is completed. The function of the system is described by the following register-
transfer operations:
S:  PR ← 0,     S ← 0,     D ← 0,     F ← 1
F:  F ← 0,     if (AR = 0) then (D ← l) else (R ← l)
R:  PR ← PR + BR,     AR ← AR − 1,     R ← 0,     F ← 1
 What is the function that the system performs?
314 Chapter 8 
8-15.  The binary numbers listed below have a sign bit in the leftmost position and, if negative, are in 2’ s-
complement form. Perform the arithmetic operations indicated using the algorithms for addition and subtraction stated in the text. Check your results by doing the arithmetic with equivalent decimal numbers.
(a) 001110 + 110010  (e) 010101 − 000111
(b) 010101 +000011   (d) 001010 − 111001
(c) 111001 + 001010  (g) 111001 − 001010
(d) 101011 + 111000  (h) 101011 − 100110
8-16.  (a)     Show the contents of an 8-but register that stores the numbers +36 and −36 in binary and in 
three different representations, i.e., sign-magnitude, sign-1’ s com plement, and sign-2’ s com-
plement, (b) Show the contents of the register after the numbers arc shifted arithmetically one 
position to the right (in all three repre sentations). (c) Repeat (b) for arithmetic shift-left.
8-17.  Two numbers in sign-2’ s-compkment representation are added as shown in Fig. 8-10, and the sum is 
transferred to register A. Show that the arithmetic right-shift symbolized by
A ← shr A,      A
n ← An ⊕ V
 will always produce the correct sum divided by 2 whether or not there was an overflow in the original sum.
8-18.  The algorithms for adding and subtracting decimal numbers in sign-10’ s-complement representation is similar to the algorithms for binary numbers in sign-2’ s-complement representation.
(a) State the algorithms for decimal addition and subtraction in sign- 10’ s-comple-ment represen-
tation. A positive sign is represented by a 0 and a negative sign is represented by a 9 in the most 
significant position.
(b) Apply the algorithms for the decimal computations (− 638) + (785) and (− 638) − (185).
8-19.  A 36-bit floating-point binary number has 8 bits plus sign for the-exponent. The coefficient is assu-med to be a normalized fraction. The numbers in the coefficient and exponent are in sign-magnitude form. What are the largest and smallest positive quantities that can be accommodated, excluding 
zero?
8-20.  A 30-bit register holds a decimal floating-point number represented in BCD, The coefficient occu-
pies 21 bits of the register and is assumed to be a normalized integer. The numbers in the coefficient 
and exponent are assumed to be in sign-magnitude representation. What are the largest and smallest 
positive quantities that can be accommodated, excluding zero?
8-21.  Represent the number (+ 31.5)
10 with a normalized integer coefficient of 13 bite and an exponent of 
7 bits as:
(a) A binary number (assumed base of 2).
(b) A binary-coded octal number (assumed base of 8).
(c) A binary-coded hexadecimal number (assumed base of 16).
8-22.  A digital computer has a memory unit with 24 bits per word. The instruction set consists of 190 
different operations. Each instruction is stored in one word of memory and consists of an operation-
code pan and an address part.
(a) How many bits are needed for the operation code?
(b) How many bits are left for the address part of the instruction?
(c) How many words can be accommodated in the memory unit?
(d) What is the largest signed fixed-point binary number that can be stored in one word of memory?
Register-Transfer Logic  315 
8-23.  Specify an instruction format for a computer that performs the following operation:
 A ← M[address] + R
 where R can be any one of eight possible registers in the processor.
8-24.  Assume that the memory unit of Fig. 8-14 has 65,536 words of 8 bite each.
(a) What should be the number of bits in the first five registers listed in Table 8-4?
(b) How many words of memory are required to store the instruction:
LDA       APRS
 as specified in Table 8-5?
(c)  List the sequence of microoperations needed to execute the instruction. Register R can be used 
to temporarily hold part of an address.
8-25.  An immediate instruction for the simple computer defined in Fig. 8-14 has an operation code 
00000100. The instruction is specified as follows:
LRI OPRD (Load OPRD into R) R ← OPRD
 List the sequence of microoperations for executing this instruction.
8-26.  Repeat the design of the simple computer presented in Section 8-12. Replace the instructions in Table 8-5 by the following instructions:
Operation code Mnemonic Description Function
00000001 ADD R Add R to A A ← A + R
00000010 ADI OPRD Add operand to A A ← A + OPRD
00000011 ADA ADRS Add direct to A A ← A + M[ADRS]
8-27.  Draw a block diagram showing the hardware implementation of the system specified in problem 8-14. Include a start input to set flip-flop S and a done output from flip-flop D.
8-28.  Write short notes on
(a) Interregister transfer.
(b) Bus transfer.
(c) Memory transfer.
8-29.  Differentiate between 
(a) Decimal data and Floating point data.
(b) Logic Microoperation and Shift microoperations.
(c) Implied and  Immediate operand instruction code
8-30.  What is meant by overflow? Briefly discuss with proper example. Explain the circuit of addition of 
sign-2’ s complement numbers related to overflow.
8-31.  Perform arithmetic operations (+33) + (−12) and (+33) − (−12) using(a) Sign-1’ s competent representation.
(b) Sign-2’ s competent representation.
(c) Sign-9’ s competent representation
(d) Sign-10’ s competent representation
316 Chapter 8 
8-32.  What is the range of numbers that can be accommodated in a 24-bit register when the binary num-
bers are represented in :
(a) Sign-magnitude.
(b) Sign-2’ s complement.
 Give the answers in equivalent decimal representation.
8-33.  Represent +169 and −156 in BCD using sign-10’ s complement representation. Use one bit for the 
sign. Add the two BCD numbers, including the sign bit, and interpret the answer obtained
8-34.  Register A holds the binary information 10101110. Determine the B operand and the logic microo-perations to be performed between A and B to change the value in A to:
(a) 01101101
(b) 11011011
8-35.  Determine  the logic operation that will selectively set bits in register A in those positions where 
there are 0’ s in the bits of register B.
8-36.  For memory configured as in figure, if immediate addressing is allowed what is the maximum value 
of number (in decimal) can be loaded through instruction fetch?
 7                      5     4                                   0
   Opcode Address
8-37.  What is the minimum size required for MAR if memory addressed has size 1K × 16?
8-38.  For a more complex computer design, 75 different instructions are required. What size of IR would 
you likely to choose?
9Chapter
processor Logic Design9.1 Introduction
A processor unit is that part of a digital system or a digital computer that implements the opera-
tions in the system. It is comprised of a number of registers and the digital functions that imple-ment arithmetic, logic, shift, and transfer microoperations. The processor unit, when combined with a control unit that supervises the sequence of microoperations, is called a central processor unit or CPU. This chapter is concerned with the organization and design of the processor unit. 
The next chapter deals with the logic design of the control unit. In Chapter 11, we demonstrate the organization and design of a computer CPU.
The number of registers in a processor unit may vary from just one processor register to as 
many as 64 registers or more. Some older computers came with only one processor register. In some cases a special-purpose digital system may employ a single processor register. However, since registers and other digital functions are inexpensive when constructed with integrated cir -
cuits, all recent computers employ a large number of processor registers and route the informa-tion among them through common buses.
An operation may be implemented in a processor unit either with a single microoperation 
or with a sequence of microoperations. For example, the multiplication of two binary numbers stored in two registers may be implemented with a combinational circuit that performs the op-eration by means of gates. As soon as the signals propagate through the gates, the product is available and can be transferred to a destination register with a single clock pulse. Alternatively, the multiplication operation may be performed with a sequence of add and shift microopera-tions. The method chosen for the implementation dictates the amount and type of hardware in the processor unit.
All computers, except the very large and fast ones, implement the involved operations by 
means of a sequence of microoperations. In this way, the processor unit need only have circuits that implement simple, basic microoperations such as add and shift. Other operations, such as multiplication, division, and floating-point arithmetic, are generated in conjunction with the con-trol unit. The processor unit by itself is designed to implement basic microoperations of the type discussed in Chapter 8. The control unit is designed to sequence the microoperations to achieve other operations which are not included in the basic set.
The digital function that implements the microoperations on the information stored in pro-
cessor registers is commonly called an arithmetic logic unit or ALU. To perform a microopera-tion, the control routes the source information from registers into the inputs of the ALU. The 
318 Chapter 9
ALU receives the information from the registers and performs a given operation as specified by 
the control. The result of the operation is then transferred to a destination register. By definition, the ALU is a combinational circuit; thus the entire register-transfer operation can be performed during one clock pulse interval. All register-transfer operations, including interregister transfers, in a typical processor unit are performed in one common ALU; otherwise, it would be necessary to duplicate the digital functions for each register. The shift microoperations are often performed in a separate unit. The shift unit is usually shown separately, but sometimes this unit is implied to be part of the overall arithmetic and logic unit.
A computer CPU must manipulate not only data but also instruction codes and addresses 
coming from memory. The register that holds and manipulates the operation code of instructions is considered to be part of the control unit. The registers that hold addresses are sometimes in-cluded as part of the processor unit, and the address information is manipulated by the common ALU. In some computers, the registers that hold addresses are connected to a separate bus and the address information is manipulated with separate digital functions.
This chapter presents a few alternatives for the organization and design of a processor unit. 
The design of a particular arithmetic logic unit is undertaken to show the design process involved in formulating and implementing a common digital function capable of performing a large num-ber of microoperations. Other digital functions considered and designed in this chapter are a shifter unit and a general-purpose processor register, commonly called an accumulator.
9.2 Processor Organization
The processor part of a computer CPU is sometimes referred to as the data path of the CPU because the processor forms the paths for the data transfers between the registers in the unit. The various paths are said to be controlled by means of gates that open the required path and close 
all others. A processor unit can be designed to fulfill the requirements of a set of data paths for a specific application. The design of a special-purpose processor was demonstrated in Section 8-12. Figure 8-16 showed the various data paths for a particular, very limited processor. The gat-ing of the data paths is achieved through the decoders and combinational circuit which comprise the control section of the unit.
In a well-organized processor unit, the data paths are formed by means of buses and other 
common lines. The control gates that formulate the given path are essentially multiplexers and decoders whose selection lines specify the required path. The processing of information is done by one common digital function whose data path can be specified with a set of common selection variables. A processor unit that has a well-structured organization can be used in a wide variety of applications. If constructed within an integrated circuit, it becomes available to many users, each of which may have a different application.
In this section, we investigate a few alternatives for organizing a general-purpose processor 
unit. All organizations employ a common ALU and shifter. The differences in organizations are mostly manifested in the organization of the registers and their common path to the ALU.
9.2.1 Bus Organization
When a large number of registers are included in a processor unit, it is most efficient to connect them through common buses or arrange them as a small memory having very fast access time. The registers communicate with each other not only for direct data transfers, but also while 
Processor Logic Design 319 
performing various microoperations. A bus organization for four processor registers is shown in 
Fig. 9-1. Each register is connected to two multiplexers (MUX) to form input buses A and B. The 
selection lines of each multiplexer select one register for the particular bus. The A and B buses 
are applied to a common arithmetic logic unit. The function selected in the ALU determines the particular operation that is to be performed. The shift microoperations are implemented in Load
DecoderMUX MUXEnab le
Destination  select
Arithmatic-logic
  unit (ALU) 
ShifterB 
select
Function
  select
Shift
selectInputdata
A select
A bus B bu s
S busR 0
R 1
R 2
R 3
Output dat a
Figure 9-1 Processor registers and ALU connected through common busts
320 Chapter 9
the shifter. The result of the microoperation goes through the output bus S into the inputs of all  
registers. The destination register that receives the information from the output bus is selected 
by a decoder. When enabled, this decoder activates one of the register load inputs to provide a transfer path between the data on the S bus and the inputs of the selected destination register.
The output bus S provides the terminals for transferring data to an external destination. One 
input of multiplexer A or B can receive data from the outside environment when it is necessary 
to transfer external data into the processor unit.
The operation of the multiplexers, the buses, and the destination decoder is explained in 
Section 8-2 in conjunction with Fig. 8-6. The ALU and shifter are discussed later in this chapter.
A processor unit may have more than four registers. The construction of a bus-organized 
processor with more registers requires larger multiplexers and decoder; otherwise, it is similar to the organization depicted in Fig. 9-1.
The control unit that supervises the processor bus system directs the information flow 
through the ALU by selecting the various components in the unit. For example, to perform the microoperation:
R1 ← R2 + R3
the control must provide binary selection variables to the following selector inputs:
1. MUX A selector: to place the contents of R 2 onto bus A.
2. MUX B selector: to place the contents of R 3 onto bus B.
3. ALU function selector: to provide the arithmetic operation A + B.
4. Shift selector: for direct transfer from the output of the ALU onto output bus S (no shift).
5. Decoder destination selector: to transfer the contents of bus S into R 1.
The five control selection variables must be generated simultaneously and must be available 
during one common clock pulse interval. The binary information from the two source registers propagates through the combinational gates in the multiplexers, the ALU, and the shifter, to the output bus, and into the inputs of the destination register, all during one clock pulse interval. Then, when the next clock pulse arrives, the binary information on the output bus is transferred into R1. To achieve a fast response time, the ALU is constructed with carry look-ahead circuits 
and the shifter is implemented with combinational gates.
When enclosed in an IC package, a processor unit is sometimes called a register and arith-
metic logic unit or RALU. It is also called by some vendors a bit-slice microprocessor. The prefix micro refers to the small physical size of the integrated circuit in which (he processor is enclosed. 
Bit-slice refers to the fact that the processor can be expanded to a processor unit with a larger 
number of bits by using a number of ICs. For example, a 4-bit-stice microprocessor contains reg-isters and ALU for manipulating 4-bit data. Two such ICs can be combined lo construct an 8-bit processor unit. For a 16-bit processor, it is necessary to use four ICs and connect them in cascade. The output carry from one ALU is connected to the input carry of the next higher-order ALU, and the serial output and input lines of the shifters are also connected in cascade. A bit-slice micro-processor should be distinguished from another type of IC called a microprocessor. The former 
is a processor unit, whereas a microprocessor refers to an entire computer CPU enclosed in one IC package. Microprocessors and associated equipment are discussed in Chapter 12.
Processor Logic Design 321 
9.2.2 Scratchpad Memory
The registers in a processor unit can be enclosed within a small memory unit. When included in 
a processor unit, a small memory is sometimes called a scratchpad memory. The use of a small 
memory is a cheaper alternative to connecting processor registers through a bus system. The dif-ference between the two systems is the manner in which information is selected for transfer into the ALU. In a bus system, the information transfer is selected by the multiplexers that form the buses. On the other hand, a single register in a group of registers organized as a small memory must be selected by means of an address to the memory unit. A memory register can function just as any other processor register as long as its only function is to hold binary information to be processed in the ALU.
A scratchpad memory should be distinguished from the main memory of the computer. 
Contrary to the main memory which stores instructions and data, a small memory in a processor unit is merely an alternative to connecting a number of processor registers through a common transfer path. The information stored in the scratchpad memory would normally come from the main memory by means of instructions in the program.
Consider, for example, a processor unit that employs eight registers of 16 bits each. The 
registers can be enclosed within a small memory of eight words of 16 bits each, or an 8 × 16 RAM. The eight memory words can be designated R0 through R7, corresponding to addresses 0 
through 7, and constitute the registers for the processor.
A processor unit that uses a scratchpad memory is shown in Fig. 9-2. A source register 
is selected from memory and loaded into register A. A second source register is selected from 
memory and loaded into register B. The selection is done by specifying the corresponding word 
address and activating the memory-read input. The information in A and B is manipulated in the 
ALU and shifter. The result of the operation is transferred to a memory register by specifying its word address and activating the memory-write input control. The multiplexer in the input of the memory can select input data from an external source.
Assume that the memory has eight words, so that an address must be specified with three 
bits. To perform the operation:
R1 ← R2 + R3
the control must provide binary selection variables to perform the following sequence of three microoperations:
T
1: A ← M [010]  read R2 into register A
T2: B ← M [011]  read R3 into register B
T3: M [001] ← A + B  perform operation in ALU
    and transfer result to R 1
Control function T1, must supply an address of 010 to the memory and activate the read and load 
A inputs. Control function T2 must supply an address 011 to the memory and activate the read 
and load B inputs. Control function T3 must supply the function code to the ALU and shifter to 
perform an add operation (with no shift), apply an address 001 to the memory, select the output 
of the shifter for the MUX, and activate the memory write input. The symbol M[xxx] designates 
a memory word (or register) specified by the address given in the binary number xxx.
322 Chapter 9
The reason for a sequence of three microoperations, instead of just one as in a bus-orga-
nized processor, is due to the limitation of the memory unit. Since the memory unit has only one 
set of address terminals but two source registers are to be accessed, two accesses to memory are needed to read the source information. The third microoperation is needed to address the desti-nation register. If the destination register is the same as the second source register, the control could activate the read input to extract the second-source information, followed by a write signal to activate the destination transfer, without having to change the address value.
Some processors employ a 2-port memory in order to overcome the delay caused when 
reading two source registers. A 2-port memory has two separate address lines to select two words of memory simultaneously. In this way, the two source registers can be read at the same time. If the destination register is the same as one of the source registers, then the entire microoperation can be done within one clock pulse period.
The organization of a processor unit with a 2-port scratchpad memory is shown in  
Fig. 9-3.
* The memory has two sets of addresses, one for port A and the other for port B. Data 
from any word in memory are read into the A register by specifying an A address. Likewise, 
data from any word in memory are read into the B register by specifying a B address. The same  
*This organization is similar to the 4-bit slice microprocessor, type 2901.LoadMUX
Scratchpad
 memor y
ALU
ShifterSelect
Function
  select
Shift
selectInput dat a
Address
Output
 data
LoadRead
Write
AB
Figure 9-2 Processor unit employing a scratchpad memory
Processor Logic Design 323 
address can be applied to the A address and the B address, in which case the identical word will 
appear in both A and B registers. When enabled by the memory enable (ME) input, new data 
can be written into the word specified by the B address. Thus the A and B addresses specify two 
source registers simultaneously, and the B address always specifies the destination register. Fig-
ure 9-3 does not show a path for external input and output data, but they can be included as in 
previous organizations.
The A and B registers are, in effect, latches that accept new information as long as the clock 
pulse, CP, is in the 1-state. When CP goes to 0, the latches are disabled, and they hold the infor -
mation that was stored when CP was a 1. This eliminates any possible race conditions that could 
occur while new information is being written into memory. The clock input controls the memory read and write operations through the write enable (WE) input. It also controls the transfers into 
the A and B latches. The waveform of one clock pulse interval is shown in the diagram.
When the clock input is 1, the A and B latches are open and accept the information com-
ing from memory. The WE input is also in the 1-state. This disables the write operation and 
enables the read operation in the memory. Thus, when CP = 1, the words selected by the A and 
B addresses are read from memory and placed in registers A and S, respectively. The operation 
in the ALU is performed with the data stored in A and B. When the clock input goes to 0, the 
latches are closed and they retain the last data entered. If the ME input is enabled while WE = 0, 
the result of the microoperation is written into the memory word defined by the B address. Thus, 
a microoperation:
R1← R 1 + R2
can be done within one clock pulse period. Memory register R1 must be specified with the B ad-
dress, and R2 with the A address.Scratchpad memor y
ALU and shif terA addr ess B addr ess
Memor y
enab le
ABWE ME
CP
Figure 9-3 Processor unit with a 2-port memory
324 Chapter 9
9.2.3 Accumulator Register
Some processor units separate one register from all others and call it an accumulator register, 
abbreviated AC or A register. The name of this register is derived from the arithmetic addition 
process encountered in digital computers. The process of adding many numbers is carried out by 
initially storing these numbers in other processor registers or in the memory unit of the computer and clearing the accumulator to 0. The numbers are then added to the accumulator one at a time, in consecutive order. The first number is added to 0, and the sum transferred to the accumula-tor. The second number is added to the contents of the accumulator, and the newly formed sum replaces its previous value. This process is continued until all numbers are added and the total sum is formed. Thus, the register “accumulates” the sum in a step-by-step manner by performing sequential additions between a new number and the previously accumulated sum.
The accumulator register in a processor unit is a multipurpose register capable of perform-
ing not only the add microoperation, but many other microoperations as well. In fact, the gates associated with an accumulator register provide all the digital functions found in an ALU.
Figure 9-4 shows the block diagram of a processor unit that employs an accumulator reg-
ister. The A register is distinguished from all other processor registers. In some cases the entire 
processor unit is just the accumulator register and its associated ALU. The register itself can function as a shift register to provide the shift microoperations. Input B supplies one external 
source information. This information may come from other processor registers or directly from the main memory of the computer. The A register supplies the other source information to the 
ALUProcessor r egist ers
          or
   memor y unit
Accumulat or
regist er (A)Select
B sour ce
A B
Output dat aInput dat a
Figure 9-4 Processor with an accumulator register
Processor Logic Design 325 
ALU at input A. The result of an operation is transferred back to the A register and replaces its 
previous content. The output from the A register may go to an external destination or into the 
input terminals of other processor registers or memory unit.
To form the sum of two numbers stored in processor registers, it is necessary to add them in 
the A register using the following sequence of microoperations:
T1: A ← 0 clear A
T2: A ← A + R1 transfer R1 to A
T3: A ← A + R2 add R2 to A
Register A is first cleared. The first number in R1 is transferred into the A register by adding it 
to the present zero content of A. The second number in R2 is then added to the present value of 
A. The sum formed in A may be used for other computations or may be transferred to a required 
destination.
9.3 Arithmetic Logic Unit
An arithmetic logic unit (ALU) is a multioperation, combinational-logic digital function. It can 
perform a set of basic arithmetic operations and a set of logic operations. The ALU has a num-ber of selection lines to select a particular operation in the unit. The selection lines are decoded within the ALU so that k selection variables can specify up to 2
k distinct operations.
Figure 9-5 shows the block diagram of a 4-bit ALU. The four data inputs from A are com-
bined with the four inputs from B to generate an operation at the F outputs. The mode-select 
input s2 distinguishes between arithmetic and logic operations. The two function-select inputs s1 
and s0 specify the particular arithmetic or logic operation to be generated. With three selection 
variables, it is possible to specify four arithmetic operations (with s2 in one state) and four logic 
operations (with s2 in the other state). The input and output carries have meaning only during an 
arithmetic operation.
The input carry in the least significant position of an ALU is quite often used as a fourth 
selection variable that can double the number of arithmetic operations. In this way, it is possible to generate four more operations, for a total of eight arithmetic operations.
Arithmetic logic unit
           (ALU)AB
AA4A3 B4 A1 A2 B3 B1 B2
F4F3 F1 F2Cout
Cins2
s0s1(Mode-select)
(Output car ry)(Function-select)
(Input carr y)
Figure 9-5 Block diagram of a 4-bit ALU
326 Chapter 9
The design of a typical ALU will be carried out in three stages. First, the design of the 
arithmetic section will be undertaken. Second, the design of the logic section will be considered. 
Finally, the arithmetic section will be modified so that it can perform both arithmetic and logic operations.
9.4 Design of Arithmetic Circuit
The basic component of the arithmetic section of an ALU is a parallel adder. A parallel adder is constructed with a number of full-adder circuits connected in cascade (see Section 5-2). By con-trolling the data inputs to the parallel adder, it is possible to obtain different types of arithmetic operations. Figure 9-6 demonstrates the arithmetic operations obtained when one set of inputs to 
Cout Cin = 0 A B
F = A + BParallel adder
               Cout Cin = 1 A B
Parallel adder
F = A + B + 1
  (a) Addition       (b) Addition with carry
Cout Cin = 0 A
Parallel adderB
F = A + B                Cout Cin = 1 A
Parallel adderB
F = A + B + 1
   (c) A plus 1’s complement of B (d) Subtraction
Cout Cin = 0 A
Parallel adder0
F = A                Cout Cin = 1 A
Parallel adder0
F = A + 1
  (e) Transfer A           (f) Increment A
Cout Cin = 0 A
Parallel adderAll 1’s
F = A – 1                Cout Cin = 1 A
Parallel adderAll 1’s
F = A
           (g) Decrement A         (h) Transfer A
Figure 9-6 Operations obtained by controlling one set of inputs to a parallel adder
Processor Logic Design 327 
a parallel adder is controlled externally. The number of bits in the parallel adder may be of any 
value. The input carry Cin goes to the full-adder circuit in the least significant bit position. The 
output carry Cout comes from the full-adder circuit in the most significant bit position.
The arithmetic addition is achieved when one set of inputs receives a binary number A, the 
other set of inputs receives a binary number B, and the input carry is maintained at 0. This is 
shown in Fig. 9-6(a). By making Cin = 1 as in Fig. 9-6(b), it is possible to add 1 to the sum in F.  
Now consider the effect of complementing all the bits of input B. With Cin = 0, the output pro-
duces F = A + B, which is the sum of A plus the 1’ s complement of B. Adding 1 to this sum by 
making Cin = 1, we obtain F = A + B + 1, which produces the sum of A plus the 2’ s complement 
of B. This operation is similar to a subtraction operation if the output carry is discarded. If we 
force all 0’ s into the B terminals, we obtain F = A + 0 = A, which transfers input A into output 
F.  Adding 1 through Cin as in Fig. 9-6(f), we obtain F = A + 1, which is the increment operation.
The condition illustrated in Fig. 9-6(g) inserts all 1’ s into the B terminals. This produces 
the decrement operation F = A - 1. To show that this condition is indeed a decrement operation, 
consider a parallel adder with n full-adder circuits. When the output carry is 1, it represents the 
number 2n because 2n in binary consists of a 1 followed by n 0’ s. Subtracting 1 from 2n, we obtain 
2n - 1, which in binary is a number of n 1’ s. Adding 2n - 1 to A, we obtain F = A + 2n - 1 = 2n + 
A - 1. If the output carry 2n is removed, we obtain F = A - 1.
To demonstrate with a numerical example, let n = 8 and A = 9. Then:
              A = 0000 1001 = (9)10
             2n =1 0000 0000 = (256)10
      2n - 1 = 1111 1111 = (255)10
A + 2n - 1 = 1 0000 1000 = (256 + 8)10
Removing the output carry 2n = 256, we obtain 8 = 9 - 1. Thus, we have decremented A by 1 by 
adding to it a binary number with all 1’ s.
The circuit that controls input B to provide the functions illustrated in Fig. 9-6 is called a 
true/complement, one/zero element. This circuit is illustrated in Fig. 9-7. The two selection lines s
1 and s0 control the input of each B terminal. The diagram shows one typical input designated 
by B, and an output designated by Yi. In a typical application, there are n such circuits for i = 1, 
2, …, n. As shown in the table of Fig. 9-7, when both s1 and s0 are equal to 0, the output Yi = 0, 
regardless of the value of Bi. When s1s0 = 01, the top AND gate generates the value of B, while the 
bottom gate output is 0; so Yi = Bi. With s1s0 = 10, the bottom AND gate generates the comple-
ment of Bi to give Yi = B′i. When s1s0 = 11, both gates are active and Yi = Bi + B′i = 1.
s0
s1Bi
Yi
      s1s0Yi
0 0 0
0 1 Bi
1 0 B′i
1 1 1
Figure 9-7 True/complement, one/zero circuit
328 Chapter 9
A 4-bit arithmetic circuit that performs eight arithmetic operations is shown in Fig. 9-8, 
The four full-adder (FA) circuits constitute the parallel adder. The carry into the first stage is the 
input carry. The carry out of the fourth stage is the output carry. All other carries are connected internally from one stage to the next. The selection variables are s
1 s0, and Cin. Variables s1 and s0 
control all of the B inputs to the full-adder circuits as in Fig. 9-7. The A inputs go directly to the 
other inputs of the full adders.
The arithmetic operations implemented in the arithmetic circuit are listed in Table 9-1. The 
values of the Y inputs to the full-adder circuits are a function of selection variables s1 and s0. Add-
ing the value of Y in each case to the value of A plus the Cin value gives the arithmetic operation 
in each entry. The eight operations listed in the table follow directly from the function diagrams illustrated in Fig. 9-6.
This example demonstrates the feasibility of constructing an arithmetic circuit by means of 
a parallel adder. The combinational circuit that must be inserted in each stage between the exter -
nal inputs A
i and Bi and the inputs of the parallel adder Xi and Yi is a function of the arithmetic 
operations that are to be implemented. The arithmetic circuit of Fig. 9-8 needs a combinational circuit in each stage specified by the Boolean functions:
X
i = Ai
Yi = Bis0 + B′isi       i = 1, 2, .... n
where n is the number of bits in the arithmetic circuit. In each stage i, we use the same common 
selection variables s1 and s0. The combinational circuit will be different if the circuit generates 
different arithmetic operations.
9.4.1 Effect of Output Carry
The output carry of an arithmetic circuit or ALU has special significance, especially after a sub-traction operation. To investigate the effect of the output carry, we expand the arithmetic circuit of Fig. 9-8 to n bits so that C
out = 1 when the output of the circuit is equal to or greater than 2n. 
Table 9-2 lists the conditions for having an output carry in the circuit. The function F = A will Table 9-1 Function table for the arithmetic circuit of Fig. 9-8
Function select Y equals Output equals Function
s1s0Cin
0 0 0 0 F = A Transfer A
0 0 1 0 F = A + 1 Increment A
0 1 0 B F = A + B Add B to A
0 1 1 B F = A + B + 1 Add B to A plus 1
1 0 0 B F = A + B Add 1’ s complement of B to A
1 0 1 B F = A + B + 1 Add 2’ s complement of B to A
1 1 0 All 1’ s F = A - 1 Decrement A
1 1 1 All 1’ s F = A Transfer A
Processor Logic Design 329 
always have the output carry equal to 0. The same applies to the increment operation F = A + 1, 
except when it goes from an all-1’ s condition to an all-0’ s condition, at which time it produces 
an output carry of 1. An output carry of 1 after an addition operation denotes an overflow condi-tion. It indicates that the sum is greater than or equal to 2
n and that the sum consists of n + 1 bits.
The operation F = A + B adds the l’ s complement of B to A. Remember from Section 1-5 
that the complement of B can be expressed arithmetically as 2n - 1 - B. The arithmetic result in 
the output will be:
F = A + 2n - 1 - B = 2n + A - B - 1
If A > B, then (A - B) > 0 and F > (2n - 1), so that Cout = 1. Removing the output carry 2n from 
this result gives:
F = A - B - 1s0s1Cin
B1A1
B2A2
B3A3
B4A4C2FA
FA
FA
FAC2
CoutF1
Y1X1
X2
X3
X4Y2
Y3
Y4F2
F3
F4C3
C4
C5
Figure 9-8 Logic diagram of arithmetic circuit
330 Chapter 9
which is a subtraction with borrow. Note that if A  B, then (A - B)  0 and F  (2n - 1), so that 
Cout = 0. For this condition it is more convenient to express the arithmetic result as:
F = (2n - 1) - (B - A)
which is the l’ s complement of B - A.
The condition for output carry when F = A + B + 1 can be derived in a similar manner. B 
+ 1 is the symbol for the 2’ s complement of B. Arithmetically, this is an operation that produces 
a number equal to 2n - B. The result of the operation can be expressed as:
F = A + 2n - B = 2n + A - B
If A  B, then (A – B)  0 and F  2n, so that Cout = 1. Removing the output carry 2n, we obtain:
F = A - B
which is a subtraction operation. If, however, A < B, then (A - B) < 0 and F < 2n, so that Cout = 0. 
The arithmetic result for this condition can be expressed as:
F = 2n - (B - A)
which is the 2’ s complement of B - A. Thus, the output of the arithmetic subtraction is correct as 
long as A  B. The output should be B - A if B >A, but the circuit generates the 2’ s complement 
of this number.
The decrement operation is obtained from F = A + (2n - l) = 2n + A - 1. The output carry is 
always 1 except when A = 0. Subtracting 1 from 0 gives - 1, and - 1 in 2’ s complement is 2n - 1, 
which is a number with all l’ s. The last entry in Table 9-2 generates F = (2n - 1) + A + 1 = 2n + 
A. This operation transfers A into F and gives an output carry of 1.Table 9-2 Effect of output carry in the arithmetic circuit of Fig. 9-8
Function  
selectArithmetic 
functionCout = 1 Comments
if
s1s0Cin
0 0 0 F = A Cout is always 0
0 0 1 F = A + 1 A = 2n - 1 Cout = 1 and F = 0 if A = 2n - 1
0 1 0 F = A + B (A + B)  2n Overflow occurs if Cout = 1
0 1 1 F = A + B + 1 (A + B)  (2n - 1) Overflow occurs if Cout = 1
1 0 0 F = A - B - 1 A > B If Cout = 0, then A < B and 
F = 1’ s complement of (B - A)
1 0 1 F = A - B A  B If Cout = 0, then A < B and 
F = 2’ s complement of (B - A)
1 1 0 F = A - 1 A ≠ 0 Cout = l, except when A = 0
1 1 1 F = A Cout is always 1
Processor Logic Design 331 
9.4.2 Design of Other Arithmetic Circuits
The design of any arithmetic circuit that generates a set of basic operations can be undertaken 
by following the procedure outlined in the previous example. Assuming that all operations in the set can be generated through a parallel adder, we start by obtaining a function diagram as in Fig. 9-6. From the function diagram, we obtain a function table that relates the inputs of the full-adder circuit to the external inputs. From the function table, we obtain the combinational gates that must be added to each full-adder stage. This procedure is demonstrated in the following example.
EXAMPLE 9-1: Design an adder/subtractor circuit with one selection variable s and two 
inputs A and B. When s = 0 the circuit performs A + B. When s = 1 the circuit performs A - B 
by taking the 2’ s complement of B.
The derivation of the arithmetic circuit is illustrated in Fig. 9-9. The function diagram is 
shown in Fig. 9-9(a). For the addition part, we need C
in = 0. For the subtraction part, we need 
the complement of B and Cin = 1. The function table is listed in Fig. 9-9(b). When s = 0, Xi and 
Yi of each full adder must be equal to the external inputs Ai and Bi, respectively. When s = 1, 
we must have Xi = A, and Yi = B’i. The input carry must be equal to the value of s. The diagram 
in (b) shows the position of the combinational circuit in one typical stage of the arithmetic circuit. The truth table in (c) is obtained by listing the eight values of the binary input vari-ables. Output X
i is made to be equal to input Ai in all eight entries. Output Yi is equal to Bi for 
the four entries when s = 0. It is equal to the complement of Bi for the last four entries where  
s = 1. The simplified output functions for the combinational circuit are:
Xi = Ai
Yi = Bi ⊕ s
The diagram of the 4-bit adder/sub tractor circuit is shown in Fig. 9-10. Each input Bi requires 
an exclusive-OR gate. The selection variable s goes to one input of each gate and also to the 
input carry of the parallel adder. The 4-bit adder/subtractor can be constructed with two ICs. One IC is the 4-bit parallel adder and the other is a quadruple exclusive-OR gates.
9.5 Design of Logic Circuit
The logic microoperations manipulate the bits of the operands separately and treat each bit as a binary variable. Table 2-6 listed 16 logic operations that can be performed with two binary variables. The 16 logic operations can be generated in one circuit and selected by means of four selection lines. Since all logic operations can be obtained by means of AND, OR, and NOT (complement) operations, it may be more convenient to employ a logic circuit with just these operations. For three operations, we need two selection variables. But two selection Lines can select among four logic operations, so we choose also the exclusive-OR (XOR) function for the logic circuit to be designed in this and the next section.
The simplest and most straightforward way to design a logic circuit is shown in Fig. 9-11. 
The diagram shows one typical stage designated by subscript i. The circuit must be repeated n times for an n-bit logic circuit. The Four gates generate the four logic operations OR. XOR, 
332 Chapter 9
AND, and NOT. The two selection variables in the multiplexer select one of the gates for the out-
put. The function table lists the output logic generated as a function of the two selection variables.
The logic circuit can be combined with the arithmetic circuit to produce one arithmetic 
logic unit. Selection variables s1 and s0 can be made common to both sections provided we use 
a third selection variable, s2, to differentiate between the two. This configuration is illustrated in 
Fig. 9-12. The outputs of the logic and arithmetic circuits in each stage go through a multiplexer with selection variable s
2. When s2 = 0, the arithmetic output is selected, but when s2 = 1, the logic 
output is selected. Although the two circuits can be combined in this manner, this is not the best way to design an ALU.Cin = 0 A
Parallel adderB
F = A + BCin = 1A
Parallel adderB
F = A + B + 1 =  A – B 
(a) Function specification
CiB
Xi
YiFi
Ci + 1s
Ai
BiFACombinational
       circuitAiAiBi
B’is XiYiCin
0
1 10
(b) Specifying combinational circuit
sAiBiXiYi
00 0 0 0
00 1 0 1 Xi = Ai
01 0 1 0 Yi = Bi ⊕ s
01 1 1 1 Cin = s
10 0 0 1
10 1 0 0
11 0 1 1
11 1 1 0
(c) Truth table and simplified equations
Figure 9.9 Derivation of an adder/subtractor circuit
Processor Logic Design 333 
X1
Y1F1 FA
X2
Y2F2 FA
X3
Y3F3 FA
X4
Y4F4 FAC1
CoutA1
B1s
A2
B2
A3
B3
A4
B4
Figure 9-10 4-bit adder/subtractor circuit
Ai
Fi
s1
s0Bi
10
2
SelectMUX
3
(a) Logic diagrams1s0Output Operation
00 Fi = Ai + BiOR
01 Fi = Ai ⊕ BiXOR
10 Fi = AiBiAND
11 Fi = A′iNOT
(b) Function table
Figure 9-11 One stage of logic circuit
334 Chapter 9
A more efficient ALU can be obtained if we investigate the possibility of generating logic 
operations in an already available arithmetic circuit. This can be done by inhibiting all input  
carries into the full-adder circuits of the parallel adder. Consider the Boolean function that gener -
ates the output sum in a full-adder circuit:
Fi = Xi ⊕ Yi ⊕ Ci
The input carry Ci in each stage can be made to be equal to 0 when a selection variable s2 is equal 
to 1. The result would be:
Fi = Xi ⊕ Yi
This expression is valid because of the property of the exclusive-OR operation x ⊕ 0 = x. Thus, 
with the input carry to each stage equal to 0, the full-adder circuits generate the exclusive-OR 
operation.
Now consider the arithmetic circuit of Fig. 9-8. The value of Y, can be selected by means of 
the two selection variables to be equal to either 0, Bi, B′i or 1.
The value of Xi is always equal to input Ai. Table 9-3 shows the four logic operations ob-
tained when a third selection variable s2 = 1. This selection variable forces Ci to be equal to Ai
Bi
0Ci
s2s0s1Ci + 1
Fi
1  One stage of
arithmetic cir cuit
One stage of
logic cir cuitMUX
Select
Figure 9-12 Combining logic and arithmetic circuits
Table 9-3 Logic operations in one stage of arithmetic circuit
s2 s1 s0Xi Yi  CiFi = Xi ⊕ YiOperationRequired
operation
1 0 0 Ai 0 0 Fi = AiTransfer A OR
1 0 1 Ai Bi 0 Fi = Ai ⊕ BiXOR XOR
1 1 0 Ai B′i 0 Fi = Ai BiEquivalence AND
1 1 1 Ai 1 0 Fi = A′iNOT NOT
Processor Logic Design 335 
0 while s1 and s0 choose a particular value for Yi. The four logic operations obtained by this 
configuration are transfer, exclusive-OR, equivalence, and complement. The third entry is the 
equivalence operation because:
Ai ⊕ B′i = Ai Bi + A′i B′i = Ai  Bi
The last entry in the table is the NOT or complement operation because:
Ai ⊕ 1 = A′i
The table has one more column which lists the four logic operations we want to include 
in the ALU. Two of these operations, XOR and NOT, are already available. The question that must be answered is whether it is possible to modify the arithmetic circuit further so that it will generate the logic functions OR and AND instead of the transfer and equivalence functions. This problem is investigated in the next section.
9.6 Design of Arithmetic Logic Unit
En this section, we design an ALU with eight arithmetic operations and four logic operations. Three selection variables s
2, s1 and s0 select eight different operations, and the input carry Cin is 
used to select four additional arithmetic operations. With s2 = 0, selection variables s1 and s0 to-
gether with Cin will select the eight arithmetic operations listed in Table 9-1. With s2 = 1, variables 
s1 and s0 will select the four logic operations OR, XOR, AND, and NOT.
The design of an ALU is a combinational-logic problem. Because the unit has a regular 
pattern, it can be broken into identical stages connected in cascade through the carries. We can design one stage of the ALU and then duplicate it for the number of stages required. There are six inputs to each stage: A
i, Bi, Ci, s2, s1, and s0. There are two outputs in each stage: output Fi and 
the carry out Ci + 1. One can formulate a truth table with 64 entries and simplify the two output 
functions.
Here we choose to employ an alternate procedure that uses the availability of a parallel 
adder.
The steps involved in the design of an ALU are as follows:
1. Design the arithmetic section independent of the logic section.
2. Determine the logic operations obtained from the arithmetic circuit in step 1, assuming that the input carries to all stages are 0.
3. Modify the arithmetic circuit to obtain the required logic operations.
The third step in the design is not a straight forward procedure and requires a certain amount of ingenuity on the part of the designer. There is no guarantee that a solution can be found or that the solution uses the minimum number of gates. The example presented here demonstrates the type of logical thinking sometimes required in the design of digital systems.
It must be realized that various ALUs are available in EC packages. In a practical situation, 
all that one must do is search for a suitable ALU or processor unit among the ICs that are avail-able commercially. Y et, the internal logic of the IC selected must have been designed by a person familiar with logic design techniques.
The solution to the first design step is shown in Fig. 9-8. The solution to the second design 
step is presented in Table 9-3. The solution of the third step is carried out below.
336 Chapter 9
From Table 9-3, we see that when s2 = 1, the input carry Ci in each stage must be 0. With 
s1 s0 = 00, each stage as it stands generates the function Fi = Ai. To change the output to an OR 
operation, we must change the input to each full-adder circuit from Ai, to Ai + Bi. This can be ac-
complished by ORing Bi and Ai when s2 s1 s0 = 100.
The other selection variables that give an undesirable output occur when s2 s1 s0 = 110. The 
unit as it stands generates an output Fi = Ai  Bi but we want to generate the AND operation Fi 
= AiBi. Let us investigate the possibility of ORing each input Ai with some Boolean function Ki. 
The function so obtained is then used for Xi when s2 s1 s0 = 110:
Fi = Xi ⊕ Yi = (Ai ⊕ Ki) ⊕ B′i = Ai Bi + KiBi + A′iK′iB′i
Careful inspection of the result reveals that if the variable Ki = B′i, we obtain an output:
Fi = Ai Bi + B′i Bi + Ai Bi B′i = Ai Bi 
Two terms are equal to 0 because Bi B′i = 0. The result obtained is the AND operation as required. 
The conclusion is that, if Ai is ORed with B′i when s2s1s0 = 110, the output will generate the AND 
operation.
The final ALU is shown in Fig. 9-13. Only the first two stages are drawn, but the diagram 
can be easily extended to more stages. The inputs to each full-adder circuit are specified by the 
Boolean functions:
Xi = Ai + s2s′1s′0Bi + s2s1s′0B′i
Yi = s0Bi + s1B′i
Zi = s2C′i
When s2 = 0, the three functions reduce to;
Xi = Ai
Yi = s0Bi + s1B′i
Zi = C′i
which are the functions for the arithmetic circuit of Fig. 9-8. The logic operations are generated when s
2 = 1. For s2s1s0 = 101 or 111, the functions reduce to:
Xi = Ai
Yi = s0Bi + s1B′i
Ci = 0
Output Fi is then equal to Xi ⊕ Yi and produces the exclusive-OR and complement operations as 
specified in Table 9-3. When s2s1s0 = 100, each Ai is ORed with Bi to provide the OR operation 
as discussed above. When s2s1s0 = 110, each Ai is ORed with B′i to provide the AND operation as 
explained previously.
The 12 operations generated in the ALU are summarized in Table 9-4. The particular func-
tion is selected through s2, s1, s0, and Cin. The arithmetic operations are identical to the ones listed 
for the arithmetic circuit. The value of Cin for the four logic functions has no effect on the opera-
tion of the unit and those entries are marked with don’t-care X’s .
Processor Logic Design 337 
s0s1Cin
B1A1
B2A2F1
F2s2
Y2X2Z2
C3FAY1X1Z1
C2FAC1
Cout
Figure 9-13 Logic diagram of arithmetic logic unit (ALU)
338 Chapter 9
9.7 Status Register
The relative magnitudes of two numbers may be determined by subtracting one number from 
the other and then checking certain bit conditions in the resultant difference. If the two numbers are unsigned, the bit conditions of interest are the output carry and a possible zero result. If the two numbers include a sign bit in the highest-order position, the bit conditions of interest are the sign of the result, a zero indication, and an overflow condition. It is sometimes convenient to supplement the ALU with a status register where these status-bit conditions are stored for further analysis. Status-bit conditions are sometimes called condition-code bits or flag bits.
Figure 9-14 shows the block diagram of an 8-bit ALU with a 4-bit status register. The four 
status bits are symbolized by C, S, Z, and V.  The bits are set or cleared as a result of an operation 
performed in the ALU.
1. Bit C is set if the output carry of the ALU is 1. It is cleared if the output carry is 0.
2. Bit S is set if the highest-order bit of the result in the output of the ALU (the sign bit) is 
1. It is cleared if the highest-order bit is 0.
3. Bit Z is set if the output of the ALU contains all 0’ s, and cleared otherwise. Z = 1 if the 
result is zero, and Z  = 0 if the result is nonzero.
4. Bit V is set if the exclusive-OR of carries C
8 and C9 is 1, and cleared otherwise. This is 
the condition for overflow when the numbers are in sign-2’ s-complement representation (see Section 8-6). For the 8-bit ALU, V is set if the result is greater than 127 or less than 
- 128.
The status bits can be checked after an ALU operation to determine certain relationships 
that exist between the values of A and B. If bit V is set after the addition of two signed numbers, 
it indicates an overflow condition. If Z is set after an exclusive-OR operation, it indicates that  Table 9-4 Function table for the ALU of Fig. 9-13
Selection
Outputs2s1s0CinFunction
0 0 0 0 F = A Transfer A
0 0 0 1 F = A + 1 Increment A
0 0 1 0 F = A + B Addition
0 0 1 1 F = A + B + 1 Add with carry
0 1 0 0 F = A - B - 1 Subtract with borrow
0 1 0 1 F = A - B Subtraction
0 1 1 0 F = A - 1 Decrement A
0 1 1 1 F = A Transfer A
1 0 0 X F = A ∨ B OR
1 0 1 X F = A ⊕  B XOR
1 1 0 X F = A ∧ B AND
1 1 1 X F = A Complement A
Processor Logic Design 339 
A = B. This is so because x ⊕ x = 0, and the exclusive-OR of two equal operands gives an all-0’ s 
result which sets the Z bit. A single bit in A can be checked to determine if it is 0 or 1 by masking 
all bits except the bit in question and then checking the Z status bit. For example, let A = 101 x 
1100, where x is the bit to be checked. The AND operation of A with B = 00010000 produces a 
result 000 x 0000. If x = 0, the Z status bit is set, but if x = 1, the Z bit is cleared since the result 
is not zero.
The compare operation is a subtraction of B from A, except that the result of the operation is 
not transferred into a destination register, but the status bits are affected. The status register then 
provides the information about the relative magnitudes of A and B. The status bits to consider 
depend on whether we take the two numbers to be unsigned or signed and in 2’ s-complement representation.
Consider the operation A - B done with two unsigned binary numbers. The relative magni-
tudes of A and B can be determined from the values transferred to the C and Z status bits. If  
Z = 1, then we know that A = B, since A - B = 0. If Z = 0, then we know that A ≠ B. From Table 
9-2, we have that C = 1 if A > B and C = 0 if A < B. These conditions are listed in Table 9-5. The 
table lists two other conditions. For A to be greater than but not equal to B (A > B), we must have 
C = 1 and Z = 0. Since C is set when the result is 0, we must check Z to ensure that the result is not 0. For A to be less than or equal to B(A ≤ B), the C bit must be 0 (for A < B) or the Z bit must 
be 1 (for A = B). Table 9-5 also lists the Boolean functions that must be satisfied for each of the 
six relationships.
Some computers consider the C bit to be a borrow bit after a subtraction operation A - B. 
An end borrow does not occur if A ≥ B, but an extra bit must be borrowed when A < B. The con-C8A B
Select8-bit
ALU
FC S Z VC9 = Cout
Status
register
C –  Carry
Z –  Zer o
V –  Ov erflowS –  Sign
Figure 9-14 Setting bits in a status register
340 Chapter 9
dition for a borrow is the complement of the output carry obtained when the subtraction is done 
by taking the 2’ s complement of B. For this reason, a processor that considers the C bit to be a 
borrow after a subtraction will complement the C bit after a subtraction or compare operation 
and denote this bit as a borrow.
Now consider the operation A - B done with two signed binary numbers when negative 
numbers are in 2’ s-complement form. The relative magnitudes of A and B can be determined 
from the values transferred to the Z, S, and V status bits. If Z = 1, then we know that A = B; when 
Z = 0, we have that A′ ≠ B. If S = 0, the sign of the result is positive, so A must be greater than 
B. This is true if there was no overflow and V = 0. If the result overflows, we obtain an errone-
ous result. It was shown in Section 8-5 that an overflow condition changes the sign of the result. Therefore, if S = 1 and V = 1, it indicates that the result should have been positive and therefore 
A must be greater than B.
Table 9-6 lists the six possible relationships that can exist between A and B and the cor -
responding values of Z, S, and V in each case. For A - B to be greater than but not equal to zero  
(A > B), the result must be positive and nonzero. Since a zero result gives a positive sign, we must ensure that the Z bit is 0 to exclude the possibility of A = B. For A ≥ B. it is sufficient to check 
for a positive sign when no overflow occurs or a negative sign when an overflow occurs. For  
A < B, the result must be negative. If the result is negative or zero, we have that A ≤ B. The Bool-ean functions listed in the table express the status-bit conditions in algebraic form.Table 9-5 Status bits after the subtraction of unsigned numbers (A - B)
Relation Condition of status bits Boolean function
A > B C = 1 and Z = 0 CZ’
A ≥ B C = 1 C
A <B C = 0 C’
A ≤ B C = 0 and Z = 1 C’ + Z
A = B Z = 1 Z
A ≠ B Z = 0 Z’
Table 9-6 Status bits after the subtraction of sign-2’s complement numbers (A - B)
Relation Condition of status bits Boolean function
A > B Z = 0 and (S = 0, V = 0 or S = 1, V = 1) Z′(S  V) 
A  B S = 0, V = 0 or S = 1, V = 1 S  V 
A < B S = 1, V = 0 or S = 0, V = 1 S ⊕ V 
A  B S = 1, V = 0 or S = 0, V = 1 o r  Z = 1 (S ⊕ V) + Z
A = B Z = 1 Z
A ≠ B Z = 0 Z′
Processor Logic Design 341 
9.8 Design of Shifter
The shift unit attached to a processor transfers the output of the ALU onto the output bus. The 
shifter may transfer the information directly without a shift, or it may shift the information to the right or left. Provision is sometimes made for no transfer from the ALU to the output bus. The shifter provides the shift microoperations commonly not available in an ALU.
An obvious circuit for a shifter is a bidirectional shift-register with parallel load. The infor -
mation from the ALU can be transferred to the register in parallel and then shifted to the right or left. In this configuration, a clock pulse is needed for the transfer to the shift register, and another pulse is needed for the shift. These two pulses are in addition to the pulse required to transfer the information from the shift register to a destination register.
The transfer from a source register to a destination register can be done with one clock 
pulse if the shifter is implemented with a combinational circuit. In a combinational-logic shifter, the signals from the ALU to the output bus propagate through gates without the need for a clock pulse. Hence, the only clock pulse needed in the processor system is for loading the data from the output bus into the destination register.
A combinational-logic shifter can be constructed with multiplexers as shown in Fig. 9-15. 
The two selection variables, H
1 and H0, applied to all four multiplexers select the type of opera-
tion in the shifter. With H1H0 = 00, no shift is executed and the signals from F go directly to the 
S lines. The next two selection variables cause a shift-right operation and a shift-left operation. 
When H1H0 = 11, the multiplexers select the inputs attached to 0 and as a consequence the S 
outputs are also equal to 0, blocking the transfer of information from the ALU to the output bus. Table 9-7 summarizes the operation of the shifter.
The diagram of Fig. 9-15 shows only four stages of the shifter. The shifter, of course, must 
consist of n stages in a system with n parallel lines. Inputs I
R and IL serve as serial inputs for the 
IRSerial
output
MUX MUX MUX MUXH0H1
S1 S2 S3 S4F1 F4 F3 F2
Serial
output
IL
0 321 0 3210 321 0 3210
Figure 9-15 4-bit combinational-logic shifter
342 Chapter 9
last and first stages during a shift-right or shift-left, respectively. Another selection variable may 
be employed to specify what goes into IR or IL during the shift. For example, a third selection vari-
able, H2, when in one state can select a 0 for the serial input during the shift. When H2 is in the 
other state, the information can be circulated around together with the value of the carry status bit. In this way, a carry produced during an addition operation can be shifted to the right and into the most significant bit position of a register.
9.9 Processor Unit
The selection variables in a processor unit control the microoperations executed within the pro-cessor during any given clock pulse. The selection variables control the buses, the ALU, the shifter, and the destination register. We will now demonstrate by means of an example how the control variables select the microoperations in a processor unit. The example defines a processor unit together with all selection variables. Then we will discuss the choice of control variables for some typical microoperations.
A block diagram of a processor unit is shown in Fig 9-16(a). It consists of seven registers 
R1 through R7 and a status register. The outputs of the seven registers go through two multiplex-
ers to select the inputs to the ALU. Input data from an external source are also selected by the same multiplexers. The output of the ALU goes through a shifter and then to a set of external output terminals. The output from the shifter can be transferred to any one of the registers or to an external destination.
There are 16 selection variables in the unit, and their function is specified by a control word 
in Fig. 9-16(b). The 16-bit control word, when applied to the selection variables in the processor, specifies a given microoperation. The control word is partitioned into six fields, with each field designated by a letter name. All fields, except C
in, have a code of three bits. The three bits of A 
select a source register for the input to left side of the ALU. The B field is the same, but it selects 
the source information for the right input of the ALU. The D field selects a destination register. 
The F field, together with the bit in Cin, selects a function for the ALU. The H field selects the 
type of shift in the shifter unit.
The functions of all selection variables are specified in Table 9-8. The 3-bit binary code 
listed in the table specifies the code for each of the five fields A, B, D, F, and H. The register se-
lected by A, B, and D is the one whose decimal number is equivalent to the binary number in the 
code. When the A or B field is 000, the corresponding multiplexer selects the input data. When 
D = 000, no destination register is selected. The three bits in the F field, together with the input 
carry Cin, provide the 12 operations of the ALU as specified in Table 9-4. Note that there are two 
possibilities for F = A. In one case the carry bit C is cleared, and in the other case it is set to 1 
(see Table 9-2).Table 9-7 Function table for shifter
H1H0Operation Function
0 0 S ← F Transfer F to S (no shift)
0 1 S ← shr F Shift-right F into S
I 0 S ← shl F Shift-left F into S
1 I S ← 0 Transfer 0’ s into S
Processor Logic Design 343 
The first four entries for the code in the H field specify the shift operations of Table 9-7. A 
third selection variable is used to specify either a 0 for the serial inputs IR and IL or a circular shift 
with the carry bit C. For convenience, we designate a circular right-shift with carry by crc and a 
circular left-shift with carry, by clc. Thus, the statement:
R ← crc R
is an abbreviation for the statement:
R ← shr R,         Rn ← C,       C ← R1V C S Z1
105
67
8
94
32
1514131211
16A B
F
HCinALU
ShifterDDestination
   select
Status register
Output dataInput data
Register
   fileR1 to R7
Bus AselectBus Bselect
(a) Block diagram
A Cin H F D B11 0 5678 9 4321 516 14131211
(b) Control word
Figure 9-16 Processor unit with control variables
344 Chapter 9
R is shifted to the right, its least significant bit R1, goes to C, and the value of C goes into the most 
significant bit position Rn.
A control word of 16 bits is needed to specify a microoperation for the processor unit. The 
most efficient way to generate control words with so many bits is to store them in a memory 
unit which functions as a control memory where all control words are stored. The sequence of control words is then read from the control memory, one word at a time, to initiate the desired sequence of microoperations. This type of control organization is called microprogramming and 
is discussed in more detail in Chapter 10.
The control word for a given microoperation can be derived directly from the selection 
variables defined in Table 9-8. The subtract microoperation:
R1 ← R1 - R2
specifies R1 for the left input of the ALU, R2 for the right input of the ALU, A - B for the ALU 
operation, no shift for the shifter, and R1 for the destination register. From Table 9-8, we derive the control word for this operation to be 0010100010101000:
A B D F C
in H
001 010 001 010 1 000
The control words for this microoperation and a few others are listed in Table 9-9.
The compare operation is similar to the subtract microoperation, except that the difference 
is not transferred to a destination register; only the status bits are affected. The destination field D for this case must be 000. The transfer of R4 into R5 requires an ALU operation F = A. The 
source A is 100 and the destination D is 101. The B selection code could be anything because the 
ALU does not use it. This field is marked with 000 in the table for convenience, but any other 3-bit code could be used.
To transfer the input data into R6, we must have A = 000 to select the external input and D = 
110 to select the destination register. Again the value of B does not matter and the ALU function Table 9-8 Functions of control variables for the processor of Fig. 9-16
Binary codeFunction of selection variables
A B DF with  
Cin = 0F with  
Cin = 1 H
0 0 0 Input data Input data None A, C ← 0 A + 1 No shift
0 0 1 R1 R1 R1 A + B A + B + 1 Shift-right, IR = 0
0 1 0 R2 R2 R2 A - B - 1 A - B Shift-left, IL = 0
0 1 1 R3 R3 R3 A - 1 A, C ← 1 0’ s to output bus
1 0 0 R4 R4 R4 A ∨ B — —
1 0 1 R5 R5 R5 A ⊕ B — Circulate-right with C
1 1 0 R6 R6 R6 A ∧ B — Circulate-left with C
1 1 1 R7 R7 R7 A — —
Processor Logic Design 345 
is F = A. To output data from R7, we make A = 111 and D = 000 (or 111). The ALU operation F 
= A places the information from R7 into the output bus.
It is sometimes necessary to clear or set the carry bit before a circular-shift operation. 
This can be done with an ALU select code 0000 or 0111. With the first select code the C bit is 
cleared, and with the second code the C bit is set. The transfer R1 ← R1, C ← 0 does not change 
the contents of the register, but it clears C and V.  The Z and S status bits are affected in the usual manner. If R 1 = 0, then Z is set to 1; otherwise, it is cleared. The S bit is set lo the value of the 
sign bit in R1.
The clock pulse that triggers the destination register also transfers the status bits from the 
ALU into the status register. The status bits are affected after the arithmetic operations. The C and 
V status bits are left unchanged during a logic operation, since these bits have no meaning for the 
logic operations. In some processors, it is customary not to change the value of carry bit C after an increment or decrement operation as well.
If we want to place the contents of a register into the shifter without changing the carry bit, 
we can use the OR logic operation with the same register selected for both ALU inputs A and B. 
The operation:
R ← R ∨ R
does not change the value of register R. However, it does place the contents of R into the inputs 
of the shifter, and it does not change the values of status bits C and V.
The examples in Table 9-9 discussed thus far use the shift-select code 000 for the H field 
to indicate a no-shift operation. To shift the contents of a register, the value of the register must be placed into the shifter without any change through the ALU. The shift-left microoperation statement:
R3 ← shl R3
specifies the code for the shift select but not the code for the ALU. The contents of R3 can be placed into the shifter by specifying an OR operation between R3 and itself. The shifted  
Table 9-9 Examples of microoperations for processor
Control word
Microoperation A B D F CinH Function
R1 ← R1 - R2 001 010 001 010 1 000 Subtract R2 from R1
R3 - R4 011 100 000 010 1 000 Compare R3 and R4
R5 ← R4 100 000 101 000 0 000 Transfer R4 to R5
R3 ← Input 000 000 110 000 0 000 Input data to R6
Output ← R7 111 000 000 000 0 000 Output data from R7
R1 ← R1, C ← 0 001 000 001 000 0 000 Clear carry bit C
R3 ← shl R3 011 011 011 100 0 010 Shift-left R3 with IL = 0
R1 ← crc R1 001 001 001 100 0 101 Circulate-right R1 with carry
R2 ← 0 000 000 010 000 0 011 Clear R2
346 Chapter 9
information returns to R3 if R3 is specified as the destination register. This requires that select 
fields A, B, and D have the code 011 for R3, that the ALU function code be 1000 for the OR 
operation, and that the shift-select H be 010 for the shift-left.
The circular shift-right with carry of register R1 is symbolized by the statement:
R1 ← crc R1
This statement specifies the code for the shifter, but not the code for the ALU. To place the con-tents of R3 into the output terminals of the ALU without affecting the C bit, we use the OR op-eration as before. In this way, the C bit is not affected by the ALU operation but may be changed 
because of the circular shift.
The last example in Table 9-9 shows the control word for clearing a register to 0. To clear 
register R2, the output bus is made to contain al 0’ s, with H = 011. The destination field D is made 
equal to the code for register R2.
It is obvious from these examples that many more microoperations can be generated in the 
processor unit. A processor unit with a complete set of microoperations is a general-purpose device that can be adapted for many applicants. The register-transfer method is a convenient tool for specifying the operations in symbolic form in a digital system that employs a general-purpose processor unit. The system is first defined with a sequence of microoperation statements in the register-transfer method of notation or in any other suitable equivalent notation. A control function here is represented not by a Boolean function, but rather by a string of binary variables called a control word. The control word for each microoperation is derived from the function table of the processor
The sequence of control words for the system is stored in a control memory. The output of 
the control memory is applied to the selection variables of the processor. By reading consecutive control words from memory, it is possible to sequence the micro-operations in the processor. Thus, the entire design can be done by means of the register-transfer method which, in this particular case, is referred to as the microprogramming method. This method of controlling the processor unit is demonstrated in Section 10-5.
9.10 Design of Accumulator
Some processor units distinguish one register from all others and call it an accumulator register. The organization of a processor unit with an accumulator register is shown in Fig. 9-4. The ALU associated with the register may be constructed as a combinational circuit of the type discussed in Section 9-5. In this configuration, the accumulator register is essentially a bidirectional shift register with parallel load which is connected to an ALU. Because of the feedback connection from the output of the register to one of the inputs in the ALU, the accumulator register and its associated logic, when taken as one unit, constitute a sequential circuit. Because of this prop-erty, an accumulator register can be designed by sequential-circuit techniques instead of using a combinational-circuit ALU.
The block diagram of an accumulator that forms a sequential circuit is shown in Fig. 9-17, 
The A register and the associated combinational circuit constitute a sequential circuit. The com-
binational circuit replaces the ALU but cannot be separated from the register, since it is only the combinational-circuit part of a sequential circuit. The A register is referred to as the accumulator 
register and is sometimes denoted by the symbol AC. Here, accumulator refers to both the A reg-
Processor Logic Design 347 
ister and its associated combinational circuit. The external inputs to the accumulator are the data 
inputs from B and the control variables that determine the microoperations for the register. The 
next state of register A is a function of its present state and of the external inputs.
In Chapter 7, we considered various registers that perform specific functions such as paral-
lel load, shift operations, and counting. The accumulator is similar to these registers but is more general, since it can perform not only the above functions, but also other data-processing opera-tions. An accumulator is a multifunction register that, by itself, can be made to perform all of the microoperations in a processor unit. The microoperations included in an accumulator depend on the operations that must be included in the particular processor. To demonstrate the logic design of a multipurpose operational register such as an accumulator, we will design the circuit with nine microoperations. The procedure outlined in this section can be used to extend the register to other microoperations.
The set of microoperations for the accumulator is given in Table 9-10. Control variables p
1 
through p9 are generated by control logic circuits and should be considered as control functions Regist er A
Control va riablesCombinational
      cir cuit
Data inputsB
Figure 9-17 Block diagram of accumulator
Table 9-10 List of microoperations for an accumulator
Control variable Microoperation Name
p1 A ← A + B Add
p2 A ← 0 Clear
p3 A ← AComplement
p4 A ← A L B AND
p5 A ← A \/ B OR
p6 A ← A ⊕  B Exclusive-OR
p7 A ← shr A Shift-right
p8 A ← shl A Shift-left
p9 A ← A + 1 Increment
If (A = 0) then (Z = 1) Check for zero
348 Chapter 9
that initiate the corresponding register-transfer operations. Register A is a source register in all 
the listed microoperations. In essence, this represents the present state of the sequential circuit. 
The B register is used as a second source register for microoperations that need two operands. 
The B register is assumed to be connected to the accumulator and supplies the inputs to the 
sequential circuit. The destination register for all microoperations is always register A. The new 
information transferred to A constitutes the next state of the sequential circuit. The nine control 
variables are also considered as inputs to the sequential circuit. These variables are mutually ex-clusive and only one variable must be enabled when a clock pulse occurs. The last entry in Table 9-10 is a conditional control statement. It produces a binary 1 in an output variable Z when the content of register A is 0, i.e., when all flip-flops in the register are cleared.
9.10.1 Design Procedure
The accumulator consists of n stages and n flip-flops, A1, A2, …., An, numbered consecutively 
starting from the rightmost position. It is convenient to partition the accumulator into n similar 
stages, with each stage consisting of one flip-flop denoted by Ai, one data input denoted by Bi, 
and the combinational logic associated with the flip-flop. In the design procedure that follows, we consider only one typical stage i with the understanding that an n-bit accumulator consists of 
n stages for i = 1, 2, ..., n. Each stage A
i is interconnected with the neighboring stage Ai - 1 on its 
right and stage Ai + 1 on its left. The first stage, A1, and the last stage, An, have no neighbors on one 
side and require special attention. The register will be designed using JK-type flip-flops.
Each control variable pj, j = 1, 2,..., 9, initiates a particular microoperation. For the opera-
tion to be meaningful, we must ensure that only one control variable is enabled at any given time. Since the control variables are mutually exclusive, it is possible to separate the combinational circuit of a stage into smaller circuits, one for each microoperation. Thus, the accumulator is to be partitioned into n stages, and each stage is to be partitioned into those circuits that are needed 
for each microoperation. In this way, we can simplify the design process considerably. Once the various pieces are designed separately, it will be possible to combine them to obtain one typical stage of the accumulator and then to combine the stages into a complete accumulator.
Add B to A (p
1): The add microoperation is initiated when control variable p1 is 1. This part 
of the accumulator can use a parallel adder composed of full-adder circuits as was done with the ALU. The full-adder in each stage i will accept as inputs the present state of A
i, the data input Bi, 
and a previous carry bit Ci. The sum bit generated in the full-adder must be transferred to flip-flop 
A1, and the output carry Ci + 1, must be applied to the input carry of the next stage.
The internal construction of a full-adder circuit can be simplified if we consider that it oper -
ates as part of a sequential circuit. The state table of a full-adder, when considered as a sequential circuit, is shown in Fig. 9-18. The value of flip-flop A
i before a clock pulse specifies the present 
state in the sequential circuit. The value of Ai after the application of a clock pulse specifies the 
next state. The next state of Ai is a function of its present state and inputs Bi and Ci. The pres-
ent state and inputs in the state table correspond to the inputs of a full-adder. The next state and output C
i + 1 correspond to the outputs of a full-adder. But because it is a sequential circuit, Ai ap-
pears in both the present and next-state columns. The next state of Ai gives the sum bit that must 
be transferred to the flip-flop.
The excitation inputs for the JK flip-flop are listed in columns JAi and KAi. These values are 
obtained by the method outlined in Section 6-7. The flip-flop input functions and the Boolean 
Processor Logic Design 349 
function for the output are simplified in the maps of Fig. 9-18. The J input of flip-flop Ai, desig-
nated by JAi, and the K input of flip-flop Ai, designated by KAi, do not include the control variable 
p1. These two equations should affect the flip-flop only when p1 is enabled; therefore, they should 
be ANDed with control variable p1. The part of the combinational circuit associated with the add 
microoperation can be expressed with three Boolean functions:
JAi = BiC′i p1 + Bi′Ci p1
KAi = BiC′i p1 + Bi′Ci p1
Ci + 1 = Ai Bi + AiCi + BiCi
The first two equations are identical, and they specify a condition for complementing A,. The 
third equation generates the carry for the next stage.
Clear (p2): Control variable p2 clears all flip-flops in register A. To cause this transition in 
a JK flip-flop, we need only apply control variable p2 to the K input of the flip-flop. The J input Present  
stateInputs Next 
stateFlip-flop 
inputsOutput
AiBiCiAiJAiKAiCi + 1
0 0 0 0 0 X 0
0 0 1 1 1 X 0
0 1 0 1 1 X 0
0 1 1 0 0 X 1
1 0 0 1 X 0 0
1 0 1 0 X 1 1
1 1 0 0 X 1 1
1 1 1 1 X 0 1
1s2
Bi
1
1 1 1 11
1X
X X X XXX X
Ai
Ci
JAi  = BiC’i + B’iCi KAi  = BiC’i + B’iCiCi + 1  = AiBi + AiCi + BiCi
Figure 9-18 Excitation table for add microoperation
350 Chapter 9
will be assumed to be 0 if nothing is applied to it. The input functions for the clear microopera-
tion are:
JAi = 0
KAi = p2
Complement (p3): Control variable p3 complements the state of register A. To cause this 
transition in a JK flip-flop, we need to apply p3 to both the J and K inputs:
JAi = p3
KAi = p3
AND (p4): The AND microoperation is initiated with control variable p4. This operation 
forms the logic AND operation between Ai and Bi and transfers the result to Ai. The excitation 
table for this operation is given in Fig. 9-19(a). The next state of Ai is 1 only when both Bi and 
the present state of Ai are equal to 1. The flip-flop input functions which are simplified in the two 
maps dictate that the K input of the flip-flop be enabled with the complement value of Bi. This 
result can be verified from the conditions listed in the state table. If Bi = 1, the present state and 
next state of Ai are the same, so the flip-flop does not have to undergo a change of state. If Bi = 0, 
the next state of Ai must go to 0, and this is accomplished by enabling the K input of the flip-flop. 
The input functions for the AND microoperation must include the control variable that initiates this microoperation:
JA
i = 0
KAi = B′i p4
OR (p5): Control variable p5 initiates the logic OR operation between Ai and Bi, with the 
result transferred to Ai. Figure 9-19(b) shows the derivation of the flip-flop input functions for 
this operation. The simplified equations in the maps dictate that the J input be enabled when  
Bi = 1. This result can be verified from the state table. When Bi = 0, the present state and next 
state of Ai are the same. When Bi = 1, they input is enabled and the next state of Ai becomes 1. 
The input functions for the OR microoperation are:
JAi = Bi p5
KAi = 0
Exclusive-OR (p6): This operation forms the logic exclusive-OR between Ai and Bi and 
transfers the result to Ai. The pertinent information for this operation is shown in Fig. 9-19(c). 
The flip-flop input functions are:
JAi = Bi p6
KAi = Bi p6
Shift-right (p7): This operation shifts the contents of the A register one position to the right. 
This means that the value of flip-flop Ai + 1, which is one position to the left of stage i, must be 
Processor Logic Design 351 
transferred into flip-flop Ai. This transfer is expressed by the input functions:
JAi = Ai + 1 p7
KAi = A′i + 1 p7
Shift-left (p8): This operation shifts the A register one position to the left. For this case, the 
value of Ai - 1, which is one position to the right of stage i, must be transferred to Ai. This transfer 
is expressed by the input functions:
JAi = Ai - 1 p8
KAi = A′i - 1 p81Bi
X X
X X Ai
KAi  = B’iBi
Ai
JAi  = 0Present 
state InputNext 
stateFlip-flop 
inputs
AiBiAiJAiKAi
0 0 0 0 X
0 1 0 0 X
1 0 0 X 1
1 1 1 X 0
(a) AND
1Bi
X X
X X Ai
KAi  = 0Bi
Ai
JAi  = BiPresent 
state InputNext 
stateFlip-flop 
inputs
AiBiAiJAiKAi
0 0 0 0 X
0 1 1 1 X
1 0 1 X 0
1 1 1 X 0
(b) OR
1Bi
X X
X X Ai
KAi  = BiBi
Ai
JAi  = Bi1Present 
state InputNext 
stateFlip-flop 
inputs
AiBiAiJAiKAi
0 0 0 0 X
0 1 1 1 X
1 0 1 X 0
1 1 0 X 1
(c) Exclusive-OR
Figure 9-19 Excitation tables for logic microoperations
352 Chapter 9
Increment (p9): This operation increments the contents of the A register by one; in other 
words, the register behaves like a synchronous binary counter with p9 enabling the count. A 3-bit 
synchronous counter is shown in Fig. 9-20. It is similar to the counter in Fig. 7-17 of Section 7-5, 
where the operation of synchronous binary counters are discussed in detail. From the diagram, we see that each stage is complemented when an input carry E
i= 1. Each stage also generates an 
output carry, Ei + l, for the next stage on its left. The first stage is an exception, since it is comple-
mented with the count-enable p9. The Boolean functions for a typical stage can be expressed as 
follows:
  JAi = Ei
 KAi = Ei
Ei + 1 = EAi i = 1, 2,…, n
   Ei = p9
The input carry, Ei, into the stage is used to complement flip-flop Ai. Each stage generates a carry 
for the next stage by ANDing the input carry with Ai. The input carry into the first stage is E1, and 
must be equal to control variable p9 which enables the count.
Check for Zero (Z): Variable Z is an output from the accumulator used to indicate a zero 
content in the A register. This output is equal to binary 1 when all the flip-flops are cleared. When 
a flip-flop is cleared, its complement output, Q′, is equal to 1. Figure 9-21 shows the first three 
stages of the accumulator that checks for a zero content. Each stage generates a variable zi + 1 by 
ANDing the complement output of Ai to an input variable zi. In this way, a chain of AND gates 
through all stages will indicate if all flip-flops are cleared. The Boolean functions for a typical Stage 3A1
J
CPKQ
E1 = p9A2
J KQ
E2A3
J KQ
E3E4
Figure 9-20 3-bit synchronous binary counter
Processor Logic Design 353 
stage can be expressed as follows:
zi + 1 = z1A′i  i = 1, 2,…, n
    zi = 1
zn + 1 = Z
Variable Z becomes 1 if the output signal from the last stage, zn + 1, is 1.
9.10.2 One Stage of Accumulator
A typical accumulator stage consists of all the circuits that were derived for the individual micro-
operations. Control variables p1 through p9 are mutually exclusive; therefore, the corresponding 
logic circuits can be combined with an OR operation. Combining all the input functions for the J and the K inputs of flip-flop A
i produces a composite set of input Boolean functions for a typical 
stage:
JAi = BiC′i p1 + B′iCi p1 + p3 + Bi p5 + Bi p6 + Ai + 1 p7 + Ai - 1 p8 + Ei
KAi = BiC′i p1 + B′iCi p1 + p2 + p3 + B′i p4 + Bi p6 + A′i + 1 p7 + A′i - 1 p8 + Ei
Each stage in the accumulator must also generate the carries for the next stage:
Ci + 1 = AiBi + AiCi + BiCi
Ei + 1 = Ei Ai
zi + 1 = zi A′i
The logic diagram of one typical stage of the accumulator is shown in Fig. 9-22. It is a 
direct implementation of the Boolean functions listed above. The diagram is a composite circuit that includes the individual circuits associated with each microoperation. The various circuits are combined with two OR gates in the J and K inputs of flip-flop A
i.QA3
z4Q’
Stage 3QA2
z3Q’ QA1
z2Q’
z1 = 1
Figure 9-21 Chain of AND gates for checking the zero content of a register
354 Chapter 9
Each accumulator stage has eight control inputs, p1 through p8, that initiate one of eight 
possible microoperations. Control variable p9 is applied only to the first stage to enable the incre-
ment operation through input Ei. There are six other inputs in the circuit. Bi is the data bit from 
the B terminals that provide the inputs to the accumulator. Ci is the input carry from the previous 
stage on the right. Ai - 1 comes from the output of the flip-flop one position to the right, and Ai + 1 zi
CPp1BiCi
p2
p3
p4
p5
p6
p7
p8Ai – 1
EiAi + 1Add
Complement
ANDClear
OR
Exclusiv e-OR
Shift-right
Shift-left
Incrementzi + 1
Q’Ei + 1Ci + 1
Ai
Q
J K
Figure 9-22 One typical stage of the accumulator
Processor Logic Design 355 
comes from the flip-flop one position to the left, Ei is the carry input for the increment operation, 
and zi is used to form the chain for zero detection. The circuit has four outputs: Ai is the output of 
the flip-flop, Ci + 1 is a carry for the next stage, Ei + 1 is the increment carry for the next stage, and  
zi + 1 is for the next stage on the left to form the chain for zero detection.
9.10.3 Complete Accumulator
An accumulator with n bits requires n stages connected in cascade, with each stage having the 
circuit shown in Fig. 9-22. All control variables, except p9, must be applied to each stage. The 
other inputs and outputs in each stage must be connected in cascade to form a complete accu-
mulator.
The interconnection among stages to form a complete accumulator is illustrated in the 
4-bit accumulator shown in Fig. 9-23. Each block in the diagram represents the circuit of Fig. 9-22. The number on top of each block represents the bit position in the accumulator. All blocks receive eight control variables, p
1 through p8, and the clock pulses from CP . The other six inputs 
and four outputs in each block are identical to those of a typical stage, except that subscript i is now replaced by the particular number in each block.
The circuit has four B inputs. The zero-detect chain is obtained by connecting the z vari-
ables in cascade, with the first block receiving a binary constant 1. The last stage in this chain produces the zero-detect variable Z. The carries for the arithmetic addition are connected in 
cascade as in full-adder circuits. The serial input for the shift-left operation goes to input A
0, 
which corresponds to input Ai - 1 in the first stage. The serial input for the shift-right operation 
goes to input A5, which corresponds to Ai + 1 in the fourth and last stage. The increment operation 
B44
C5
A4
E5
A5E4A3C4z4 z5B33
C4
A3
E4
A4E3A2C3z3 z4B22
C3
A2
E3
A3E2A1C2z2 z3B11
C2
A1
E2
A2E1A0C1z1 z2B4 B3 B2 B1
I Z
Input carry
Serial input
p9Output carry
Serial inputIncrement  carry
p
1 to p8
CP
Figure 9-23 4-bit accumulator constructed with four stages
356 Chapter 9
is enabled with control variable p9 in the first stage. The other blocks receive the increment carry 
from the previous stage.
The total number of terminals in the 4-bit accumulator is 25, including terminals for the A 
outputs. Incorporating two more terminals for power supply, the circuit can be enclosed within 
one IC package having 27 or 28 pins. The number of terminals for the control variables can be reduced from nine to four if a decoder is inserted in the IC. In such a case, the IC pin count can be reduced to 22 and the accumulator can be extended to 16 microoperations without adding external pins.
REFERENCES
1. Mano, M. M., Computer System Architecture. Englewood Cliffs, NJ.: Prentice-Hall, Inc., 1976.
2. The TTL Data Book for Design Engineers. Dallas, Texas: Texas Instruments, Inc., 1976.
3. The Am2900 Bipolar Microprocessor Family Data Book. Sunnyvale, Calif.: Advanced Micro De-
vices, Inc., 1976.
4. Sobel, H. S., Introduction to Digital Computer Design. Reading. Mass.: Addison-Wesley Publishing 
Co., 1970.
5. Kline, R. M., Digital Computer Design. Englewood Cliffs, N.J.: Prentice-Hall, Inc., 1977.
6. Chirlian, P . M., Analysis and Design of Digital Circuits and Computer Systems. Champaign. Ill.: Matrix Publishing, Inc., 1976.
PROBLEMS
9-1. Modify the processor unit of Fig. 9-1 so that the selected destination register is always the same register that is selected for the A bus. How does this effect the number of multiplexers and the num-
ber of selection lines used?
9-2. A bus-organized processor as in Fig. 9-1 consists of 15 registers. How many selection lines are there in each multiplexer and in the destination decoder?
9-3. Assume that each register in Fig. 9-1 is 8 bits long. Draw a detailed block diagram for the box labeled MUX that selects the register for the A bus. Show that the selection can be done with eight 4-to-1 line 
multiplexers.
9-4. A processor unit employs a scratchpad memory as in Fig. 9-2. The processor consists of 64 registers of eight bits each.
(a) What is the size of the scratchpad memory?
(b) How many lines are needed for the address?
(c) How many lines are there for the input data?
(d)  What is the size of the MUX that selects between the input data and the output of the shifter?
9-5. Show a detailed block diagram for the processor unit of Fig. 9-4 when the B inputs come from:
(a) Eight processor registers forming a bus system.
(b) A memory unit with address and buffer registers.
9-6. The 4-bit ALU of Fig. 9-5 is enclosed within one IC package. Show the connections among three 
such ICs to form a 12-bit ALU. Designate the input and output carries in the 12-bit ALU.
9-7. TTL IC type 7487 is a 4-bit true /complement, zero/one element. One stage of this IC is shown in 
Fig. P9-7.
Processor Logic Design 357 
s0s1BiYi
Figure P9-7 True/complement, one/zero circuit
(a) Derive the Boolean function for output Yi as a function of inputs Bi, s1, and s0.
(b) Draw the truth table for the circuit.
(c) Draw a function table (similar to the one shown in Fig. 9-7) and verify the circuit operation.
9-8. Modify the arithmetic circuit of Fig. 9-8 by including a third selection variable, s2. When s2 = 1, the 
modified circuit is identical to the original circuit. When s2 = 0, all the A inputs to the full-adders are 
inhibited and 0’ s are inserted instead.
(a) Draw the logic diagram of one stage of the modified circuit
(b) Go over an analysis similar to that in Fig 9-6 to determine die eight operations obtained when  
s2 = 0.
(c) List the new output functions in tabular form.
9-9. Determine the arithmetic operations obtained in the eight blocks of Fig. 9-6 if, in each case, input A 
is changed to A (complement of A).
9 10. Design an arithmetic circuit with one selection variable s and two data inputs A and B. When s = 0, 
the circuit performs the addition operation F = A + B. When s = 1, the circuit performs the increment 
operation F = A + 1.
9- 11. The straight binary subtraction F = A - B produces a correct difference if A ≥ B. What would be the 
result if A < B? Determine the relationship between the result obtained in F and a borrow in the most 
significant position.
9-12. Design an arithmetic circuit with two selection variables, s1, and s0, that generates the following 
arithmetic operations. Draw the logic diagram of one typical stage.
s1s0Cin = 0 Cin = 1
0 0 F = A + B F = A + B + 1
0 1 F = A F = A + 1
1 0 F = B–  F = B–   + 1
1 1 F = A + B–  F = A + B–   + 1
9-13. Design an arithmetic circuit with two selection variables, s1 and s0 that generates the following arith-
metic operations. Draw the logic diagram of one typical stage.
s1s0Cin = 0 Cin = 1
0 0 F = A F = A+ 1
0 1 F = A - B - 1 F = A - B
1 0 F = B - A - 1 F = B - A
1 1 F = A + B F = A + B + 1
358 Chapter 9
9-14. The following relationships of the exclusive-OR operation were used in deriving the logic operations 
of Table 9-3.
(a) x ⊕ 0 = x
(b) x ⊕ 1 - x′
(c) x ⊕ y′ = x  y
 Prove that these relationships are valid.
9-15. Derive a minimal combinational circuit that generates all 16 logic functions listed in Table 2-5. Use 
four selection variables. Hint: Try a 4 × 1 multiplexer in reverse, i.e., use the normal inputs of the 
multiplexer as the selection lines for the logic unit.
9-16. Modify the arithmetic circuit of Fig. 9-8 into an ALU with mode-select variable s2. When s2 = 0, 
the ALU is identical to the arithmetic circuit. When s2 = 1, the ALU generates the logic functions 
according to the following table:
s2s1s0Output Function
1 0 0 F = A ∧ B AND
1 0 1 F = A ⊕ B XOR
1 1 0 F = A ∨ B OR
1 1 1 F = A NOT
9-17. An arithmetic logic unit is similar to the one shown in Fig. 9-13 except that the inputs to each full-adder circuit are according to the following Boolean functions:
 X
i = Ai Bi + (s2 s′1 s′0) Ai + s2 s1 s′0 Bi
 Yi = s0 Bi + s1 B′i(s2 s1 s′0)′
 Z1= s′2 Ci
 Determine the 12 functions of the ALU.
9-18. The operation performed in an ALU is F = A + B–   (A plus 1’ s complement of B).
(a) Determine the output value of F when A = B. Let this condition sec a status bit E.
(b) Determine the condition for Cout = 1. Let this condition set a status bit C.
(c) Derive a table for the six relationships listed in Table 9-5 in terms of the status bit conditions  
E and C defined above.
9-19. A processor unit has a status register of ten bits, one for each of the conditions listed in Tables 9-5 and 9-6. (The equal and unequal conditions are common to both tables.) Draw a logic diagram showing the gates from the outputs of the ALU to the ten bits of the status register.
9-20. Two signed numbers are added in an ALU, and their sum transferred to register R. The status bits 5 
(sign) and V (overflow) are affected during the transfer. Prove that the sum can now be divided by 2 
according to the statement:
R ← shr R,       R
n ← S ⊕ V
 where Rn is the sign bit (leftmost position) of register R.
Processor Logic Design 359 
9-21. Add another multiplexer to the shifter of Fig. 9-15 with two separate selection lines G1 and G0. This 
multiplexer is used to specify the serial input IR during a shift-right operation in the following man-
ner:
G1G0Function
0 0 Insert 0 into IR
0 1 Perform a circular shift
1 0 Perform a circular shift with carry
1 1 Insert the value o f  S ⊕ V for arithmetic shift (see problem 9-20)
 Show the connection of the multiplexer between the status register and the shifter.
9-22. The shift-select H defined for the processor of Fig. 9-16 has three variables, H2, H1, and H0. The last 
two selection variables are used for the shifter specified in Table 9-7. Design the circuit associated 
with selection variable H2.
9-23. Specify the control word that must be applied to the processor of Fig. 9-16 to implement the fol-lowing microoperations:
(a) R2 ← R1 + 1  (e) R1 ← shr R1
(b) R3 ← R4 + R5  (f) R2 ← clc R2
(c) R6 ← 
R6  (g) R3 ← R4 ⊕ R5
(d) R7 ← R7 - 1  (h) R7 ← R7
9-24. It is necessary to compute the average value of four unsigned binary numbers stored in registers R1, 
R2, R3, and R4 of the processor defined in Fig. 9-16. The average value is to be stored in register RS. 
The other two registers in the processor can be used for intermediate results. Care must be taken not to cause an overflow.
(a) List the sequence of microoperations in symbolic form.
(b) List the corresponding binary control words.
9-25. The following sequence of microoperations is performed in the accumulator defined in Section 9-10:
 p
3: A ← A
 p9: A ← A + 1
 p1: A ← A + B
 p3: A ← A
 p9: A ← A + 1
(a) Determine the content of A after each microoperation if initially A = 1101 and the B input is 
0110.
(b) Repeat with initial A = 0110 and B = 1101.
(c) Repeat with initial A = 0110 and B = 0110.
(d) Prove that the above sequence of microoperations performs (A - B) if A > B, or the 2’ s comple-
ment of (B - A) if A < B.
9-26. Using JK flip-flops, design one typical stage of an A register that performs the subtract microopera-
tion:
 p10: A ← A - B
 Use full-subtracter circuits (Section 4-4) with input, and output borrows Ki and Ki + 1.
360 Chapter 9
9-27. Using JK flip-flops, design one typical stage of a register that performs the following logic microo-
perations:
 p11: AA B←∨    NOR
 p12: AA B←∧    NAND
 p13: AA B←   Equivalence
9-28. Derive the Boolean functions for a typical stage of a decrement microoperation:
 p14: A ← A - 1
9-29. Using T -type flip-flops, design a 4-bit register that performs the 2’ s-complement microoperation:
 p: A ← A + 1
 From the result obtained, show that a typical stage can be expressed by the following Boolean func-
tions:
   TAi = PEi         i = 1, 2, 3,…,n
 Ei + 1 = Ai + Ei
     Ei = 0
9-30 A 4-bit accumulator performs 15 microoperations with control variables p1 through p15. The circuit 
is enclosed in one IC package with only four terminals available for selecting a microoperation. Design the circuit (within the IC) that must be inserted between the four terminals and the 15 control 
variables. Include a no-operation condition.
9-31 Write short notes on
(a) Processor organization.
(b) Bus organization.
(c) Scratchpad Memory.
9-32 Differentiate between (a) Arithmetic unit and Logic unit.
(b) One stage accumulator and Complete accumulator.
9-33 Give the final content of ACC when following statements are executed T1 : ACC ACC 
⊕ MDR
 T2 : ACC ← ACC ′
9-34 State what the following statement performs for the computer described below
 T1 : ACC ← ACC  + MDR
 CY & T2 : P ← ACC
 CY′ & T2 : Q ← ACC
9-35 What does LOADMAR = T0 + T2 mean?
9-36 Explain if there will be any problem if by mistake the control unit is developed on logic equation LOAD
MAR = T0 + T2 + T4.
9-37 How many clock cycles are required to execute program given for questions 9.33 and 9.34?
ExtRA SOL vED PROBLEMS
1. Write a program for this computer that adds two positive integers, available in memory locations 
addr1 and addr2, multiplies the sum by 5 and stores final result in location addr3. Consider, the 
Processor Logic Design 361 
numbers are small enough not to cause any overflow i.e. data at every stage require less than 8-bits 
for its representation.
 Soln: Addition of two numbers is straightforward and can be done using LDA and ADD instructions. 
For multiplication with 5 we have to use an indirect technique. Two left shift give multiplication by 
4 and one addition will make it multiplication by 5. Alternatively, 5 ADD operations will also give multiplication by 5. The program can be written as follows.
LDA addr1
ADD addr2
STA addr3
SHL
SHL
ADD addr3
STA addr3
HLT
2. Write a program for this computer that performs bit-wise Ex-OR operation on two numbers available 
in memory locations addr1 and addr2. The result is to be stored in location addr3.
 Soln: Our designed computer can perform only two kind of logic operations AND and NOT. There-
fore, we break Ex-OR logic of two numbers say A and B in such a way that there is only AND and 
NOT operator.
 Y = A ⊕ B = AB′ + A′B = ((AB′)′.(A′B)′)′ [From DeMorgan’s Theorem]
 Thus the program can be written as shown next. The logic operation performed by each instruction 
is shown as comment after semicolon.
             LDA addr1              ; A
     NOT               ; A
′
     AND addr2           ; A ′B
                NOT             ; (A ′B)′
        STA addr3
         LDA addr2           ; B
       NOT             ; B ′
     AND addr1           ; AB ′
                NOT             ; (AB ′)′
    AND addr3             ; (AB ′)′.(A′B)′
     NOT             ; ((AB ′)′.(A′B)′)′
      STA addr3
          HLT
10Chapter
Control Logic Design10.1 Introduction
The process of logic design is a complex undertaking. Many installations develop various com-
puter-automated design techniques to facilitate the design process. However, the specifications for the system and the development of algorithmic procedures for achieving the required data-processing tasks cannot be automated and require the mental reasoning of a human designer.
The most challenging and creative part of the design is the establishment of design objec-
tives and the formulation of algorithms and procedures for achieving the stated objectives. This task requires a considerable amount of experience and ingenuity on the part of the designer. An algorithm is a procedure for obtaining a solution to a problem. A design algorithm is a procedure 
for implementing the problem with a given piece of equipment. The development of a design algorithm cannot start until the designer is certain of two things. First, the problem at hand must be thoroughly understood. Second, an initial configuration of equipment must be assumed for implementing the procedure. Starting from the problem statement and equipment availability, a solution is then found and an algorithm formed. The algorithm is stated by a finite number of well-defined procedural steps.
The binary information found in a digital system is stored in processor or memory registers, 
and it can be either data or control information. Data are discrete elements of information that are manipulated by microoperations. Control information provides command signals for specifying the sequence of microoperations. The logic design of a digital system is a process for deriv-ing the digital circuits that perform data processing and the digital circuits that provide control  
signals.
The timing for all registers in a synchronous digital system is controlled by a master-clock 
generator. The clock pulses are applied to all flip-flops and registers in the system, including the flip-flops and registers in the control unit. The continuous clock pulses do not change the state of a register unless the register is enabled by a control signal. The binary variables that control the selection variables and enable inputs of registers are generated in the control unit. The outputs of the control unit select and enable the data-processor part of the system and also determine the next state of the control unit itself.
The relationship between the control and the data processor in a digital system is shown in 
Fig. 10-1. The data processor part may be a general-purpose processor unit, or it may consist of individual registers and associated digital functions. The control initiates all microoperations in 
Control Logic Design  363 
the data processor. The control logic that generates the signals for sequencing the microopera-
tions is a sequential circuit whose internal states dictate the control functions for the system. At any given time, the state of the sequential control initiates a prescribed set of microoperations. Depending on status conditions or other inputs, the sequential control goes to the next state to ini-tiate other microoperations. Thus, the digital circuit that acts as the control logic provides a time sequence of signals for initiating the microoperations in the data-processor part of the system.
The design of a digital system that requires a control sequence starts with the assumption of 
the availability of timing variables. We designate each timing variable in the sequence by a state and then form a state diagram or an equivalent representation for the transition between states. Concurrent with the development of the control sequence, we develop a list of microoperations to be initiated for each control state. If the system is too complicated for a state diagram, it may be convenient to specify the system entirely in the register-transfer method by means of control functions and microoperation statements.
The control sequence and register-transfer relationships may be derived directly from the 
word specification of the problem. However, it is sometimes convenient to use an intermediate representation to describe the needed sequence of operations for the system. Two representations which are helpful in the design of systems that need a control are timing diagrams and flowcharts.
A timing diagram clarifies the timing sequence and other relationships among the various 
control signals in the system. In a clocked sequential circuit, the clock pulses synchronize all operations, including signal transitions in control variables. In an asynchronous system, a sig-nal transition in one control variable may cause a change of another control variable. A timing diagram is very useful in asynchronous control because it provides a pictorial representation of required changes and transitions of all control variables.
A flowchart is a convenient way to specify the sequence of procedural steps and decision 
paths for an algorithm. A flowchart for a design algorithm would normally use the variable names of registers defined in the initial equipment configuration. It translates an algorithm from its word statement to an information-flow diagram that enumerates the sequence of register-transfer op-erations together with the conditions necessary for their execution.Control
  logicExternal
 inputs
Initiat e
Micro-operations
Status condition sInput dat a
  Data
processor
Output data
Figure 10-1 Control and data-processor interaction
364 Chapter 10
A flowchart is a diagram that consists of blocks connected by directed lines. Within the 
blocks, we specify the procedural steps for implementing the algorithm. The directed lines be-
tween blocks designate the path to be taken from one procedural step to the next. Two major types of blocks are used: A rectangular block designates a function block within which the microopera-
tions are listed. A diamond-shaped block is a decision block within which is listed a given status 
condition. A decision block has two or more alternate paths, and the path that is taken depends on the value of the status condition specified within the block.
A flowchart is very similar to a state diagram. Each function block in the flowchart is 
equivalent to a state in the state diagram. The decision block in the flowchart is equivalent to the binary information written along the directed lines that connect two states in a state diagram. As a consequence, it is sometimes convenient to express an algorithm by means of a flowchart from which the control state diagram may be readily derived.
In this chapter, we first present four possible configurations for a control unit. The various 
configurations are presented in block diagram form to emphasize the differences in organization. We then demonstrate the various procedures available for control logic design by going through specific examples.
The design of control logic cannot be separated from the algorithmic development neces-
sary for solving a design problem. Moreover, the control logic is directly related to the data processor part of the system that it controls. As a consequence, the examples presented in this chapter start with the development of an algorithm for implementing the given problem. The data-processing part of the system is then derived from the stated algorithm. Only after this is done can we proceed to show the design of the control that sequences the data processor accord-ing to the steps specified by the algorithm.
10.2 Control Organization
Once a control sequence has been established, the sequential system that implements the control operations must be designed. Since the control is a sequential circuit, it can be designed by a sequential logic procedure as outlined in Chapter 6.
However, in most cases this method is impractical because of the large number of states 
that the control circuit may have. Design methods that use state and excitation tables can be used in theory, but in practice they are cumbersome and difficult to manage. Moreover, the control circuit obtained by this method usually requires an excessive number of flip-flops and gates, which implies the use of SSI circuits. This type of implementation is inefficient with respect to the number of IC packages used and the number of wires that must be interconnected. One major goal of control logic design should be the development of a circuit that implements the desired control sequence in a logical and straightforward manner. The attempt to minimize the number of circuits would tend to produce an irregular network which would make it difficult for anyone but the designer to recognize the sequence of events that the control undergoes. As a consequence, it may be difficult to service and maintain the equipment when it is in operation.
Because of the reasons cited above, experienced logic designers use specialized methods 
for control logic design which may be considered an extension of the classical sequential-logic method combined with the register-transfer method. In this section, we consider four methods of control organization:
1. One flip-flop per state method.
2. Sequence register and decoder method.
Control Logic Design  365 
3. PLA control.
4. Microprogram control.
The first two methods result in a circuit that must use SSI and MSI circuits for the im-
plementation. The various circuits are interconnected by wires to form the control network. A 
control unit implemented with SSI and MSI devices is said to be a hard-wired control. If any alterations or modifications are needed, the circuits must be rewired to fulfill the new require-ments. This is in contrast to the PLA or microprogram control which uses an LSI device such as a programmable logic array or a read-only memory. Any alterations or modifications in a micro-program control can be easily achieved without wiring changes by removing the ROM from its socket and inserting another ROM programmed to fulfill the new specifications.
We shall now explain each method in general terms. The subsequent sections of this chapter 
deal with specific examples that demonstrate the detailed design of control units by each of the four methods.
10.2.1 One Flip-Flop per State Method
This method uses one flip-flop per state in the control sequential circuit. Only one flip-flop is set at any particular time: all others are cleared. A single bit is made to propagate from one flip-flop to the other under the control of decision logic. In such an array, each flip-flop represents a state and is activated only when the control bit is transferred to it.
It is obvious that this method does not use a minimum number of flip-flops for the sequen-
tial circuit. In fact, it uses a maximum number of flip-flops. For example, a sequential circuit with 12 states requires a minimum of four flip-flops because 2
3 < 12 < 24. Y et by this method, the 
control circuit uses 12 flip-flops, one for each state.
The advantage of the one flip-flop per state method is the simplicity with which it can be 
designed. This type of controller can be designed by inspection from the state diagram that de-scribes the control sequence. At first glance, it may seem that this method would increase system cost since more flip-flops are used. But the method offers other advantages which may not be apparent at first. For example, it offers a savings in design effort, an increase in operational sim-plicity, and a potential decrease in the combinational circuits required to implement the complete sequential circuit.
Figure 10-2 shows the configuration of a four-state sequential control logic that uses four 
D-type flip-flops: one flip-flop per state T
i, i = 0, 1,2, 3. At any given time interval between two 
clock pulses, only one flip-flop is equal to 1; all others are equal to 0. The transition from the present state to the next is a function of the present T
i that is a 1 and certain input conditions. 
The next state is manifested when the previous flip-flop is cleared and a new one is set. Each of the flip-flop outputs is connected to the data-processing section of the digital system to initiate certain microoperations. The other control outputs shown in the diagram are a function of the T’s  and external inputs. These outputs may also initiate microoperations.
If the control circuit does not need external inputs for its sequencing, the circuit reduces 
to a straight shift register with a single bit shifted from one position to the next. If the control sequence must be repeated over and over again, the control reduces to a ring counter. A ring counter is a shift register with the output of the last flip-flop connected to the input of the first 
flip-flop. In a ring counter, the single bit continuously shifts from one position to the next in a circular manner. For this reason, the one flip-flop per state method is sometimes called a ring-counter controller.
366 Chapter 10
10.2.2 Sequence Register and Decoder Method
This method uses a register to sequence the control states. The register is decoded to provide 
one output for each state. For n flip-flops in the sequence register, the circuit will have 2n states 
and the decoder will have 2n outputs. For example, a 4-bit register can be in any one of 16 states.  
A 4 × 16 decoder will have 16 outputs, one for each state of the register. Both the sequence reg-ister and decoder are MSI devices.
Figure 10-3 shows the configuration of a four-state sequential control logic. The sequence 
register has two flip-flops and the decoder establishes separate outputs for each state in the reg-ister. The transition to the next state in the sequence register is a function of the present state and the external input conditions. Since the outputs of the decoder are available anyway, it is convenient to use them as present state variables rather than use the direct flip-flop outputs. Other outputs which are a function of the present-state and external inputs may initiate microoperations in addition to the decoder outputs.
If the control circuit of Fig. 10-3 does not need external inputs, the sequence register reduc-
es to a counter that continuously sequences through the four states. For this reason, this method is DQDQDQDQOther contr ol outputs
External
  input
conditions
Decision
  logic
CPT1
T2T0
T3
Figure 10-2 Control logic with one flip-flop per state
Control Logic Design  367 
sometimes called a counter-decoder method. The counter-decoder method and the ring-counter 
method were explained in Chapter 7 in conjunction with Fig. 7-22.
10.2.3 PLA Control
The programmable logic array was introduced in Section 5-8. It was shown there that the PLA 
is an LSI device that can implement any complex combinational circuit. The PLA control is essentially similar to the sequence register and decoder method except that all combinational circuits are implemented with a PLA, including the decoder and the decision logic. By using a PLA for the combinational circuit, it is possible to reduce the number of ICs and the number of  
interconnection wires.
Figure 10-4 shows the configuration of a PLA controller. An external sequence register 
establishes the present state of the control circuit. The PLA outputs determine which microop-Other contr ol outputs
External
  input
conditionsT1T0
Decision
  logic
Present stat eSequence regist er Decoder
T3T2
Figure 10-3 Control logic with sequence register and decoder
External
  input
conditions
Sequence
 regist erPLAInitiat e
  micr o-
operations
Figure 10-4 PLA control logic
368 Chapter 10
erations should be initiated, depending on external input conditions and the present state of the 
sequence register. At the same time, other PLA outputs determine the next state of the sequence register.
The sequence register is external to the PLA if the unit implements only combinational cir -
cuits. However, some PLAs are available which include not only gates, but also flip-flops within the unit. This type of PLA can implement a sequential circuit by specifying the links that must be connected to the flip-flops in the same manner that the gate links are specified.
10.2.4 Microprogram Control
The purpose of the control unit is to initiate a series of sequential steps of microoperations. During any given time, certain operations are to be initiated while all others remain idle. Thus, the control variables at any given time can be represented by a string of 1’ s and 0’ s called a  
control word. As such, control words can be programmed to initiate the various components in the system in an organized manner. A control unit whose control variables are stored in a mem-ory is called a microprogrammed control unit. Each control word of memory is called a microin-struction, and a sequence of microinstructions is called a microprogram. Since alteration of the 
microprogram is seldom needed, the control memory can be a ROM. The use of a microprogram involves placing all control variables in words of the ROM for use by the control unit through successive read operations. The content of the word in the ROM at a given address specifies the microoperations for the system.
A more advanced development known as dynamic microprogramming permits a micro-
program to be loaded initially from the computer console or from an auxiliary memory such as a magnetic disk. Control units that use dynamic micro programming employ a writable control 
memory (WCM). This type of memory can be used for writing (to change the microprogram) 
but is used mostly for reading. A ROM, PLA, or WCM, when used in a control unit, is referred to as a control memory.
Figure 10-5 illustrates the general configuration of the microprogram control unit. The con-
trol memory is assumed to be a ROM, within which all control information is permanently stored. The control memory address register specifies the control word read from control memo-ry. It must be realized that a ROM operates as a combinational circuit, with the address value as the input and the corresponding word as the output. The content of the specified word remains on the output wires as long as the address value remains in the address register. No read signal is needed as in a random-access memory. The word out of the ROM should be transferred to a 
External
  input
conditionsInitiat e
  micr o-
operations    Ne xt
 addr ess
generat orControl
address
regist er Control
 memor y
  (ROM)
Next addr ess info rmation
Figure 10-5 Microprogram control logic
Control Logic Design  369 
buffer register if the address register changes while the ROM word is still in use. If the change in 
address and ROM word can occur simultaneously, no buffer register is needed.
The word read from control memory represents a microinstruction. The microinstruction 
specifies one or more microoperations for the components of the system. Once these operations are executed, the control unit must determine its next address. The location of the next micro-instruction may be the next one in sequence, or it may be located somewhere else in the control memory. For this reason, it is necessary to use some bits of the microinstruction to control the generation of the address for the next microinstruction. The next address may also be a function of external input conditions. While the microoperations are being executed, the next address is computed in the next-address generator circuit and then transferred (with the next clock pulse) into the control address register to read the next microinstruction. The detailed construction of the next address generator depends on the particular application.
The remainder of this chapter deals with specific examples of control logic design. The 
first example in Section 10-3 demonstrates the one flip-flop per state method, and Section 10-4 presents the same example with a microprogram control. Section 10-6 uses a second example to demonstrate the sequence register and decoder method, and Section 10-7 implements the second example with a PLA. Sections 10-5 and 10-8 consider the microprogram control method in more detail.
10.3 Hard-wired Control — Example 1
This example demonstrates the development of a design algorithm. We start from the statement of the problem and proceed through the design to obtain the control logic for the system. The design is carried out in five consecutive steps.
1. The problem is stated.
2. An initial equipment configuration is assumed.
3. An algorithm is formulated.
4. The data-processor part is specified.
5. The control logic is designed.
An initial equipment configuration is necessary in order to formulate the design algorithm 
in terms of the register-transfer method. The algorithm is formulated by means of a flowchart that specifies the sequence of microoperations for the system. Once we have a list of microoperations, we can choose the digital functions necessary for their implementation. In essence, this supplies the data-processor part of the system. The control is then designed to sequence the required mi-crooperations in the data processor.
The control logic derived in this section is a hard-wired control of the one flip-flop per state 
method. The digital system presented here is used again in the next section to demonstrate an example of microprogram control.
10.3.1 Statement of the Problem
In Section 8-5, an algorithm was stated for the addition and subtraction of binary fixed-point numbers when negative numbers are in sign-2’ s-complement form. The problem here is to imple-ment with hardware the addition and subtraction of two fixed-point binary numbers represented 
370 Chapter 10
in sign-magnitude form. Complement arithmetic may be used, provided the final result is in 
sign-magnitude form.
The addition of two numbers stored in registers of finite length may result in a sum that 
exceeds the storage capacity of the register by one bit. The extra bit is said to cause an overflow. The circuit must provide a flip-flop for storing a possible overflow bit.
10.3.2 Equipment Configuration
The two signed binary numbers to be added or subtracted contain n bits. The magnitudes of the 
numbers contain k = n - 1 bits and are stored in registers A and B. The sign bits are stored in flip-
flops As and Bs. Figure 10-6 shows the registers and associated equipment. The ALU performs the 
arithmetic operations and the 1-bit register E serves as the overflow flip-flop. The output carry 
from the ALU is transferred to E.
It is assumed that the two numbers and their signs have been transferred to their respective 
registers and that the result of the operation is to be available in registers A and As. Two input 
signals in the control specify the add (qa) and subtract (qs) operations. Output variable x indicates 
the end of the operation. The control logic communicates with the outside environment through the input and output variables. Control recognizes input signal q
a or qs and provides the required 
operation. Upon completion of the operation, control informs the external environment with out-put x that the sum or difference is in registers A and A
s and that the overflow bit is in E.
10.3.3 Derivation of the Algorithm
The representation of numbers by sign-magnitude is familiar because it is used for paper and pencil arithmetic calculations. The procedure for adding or subtracting two signed binary num-bers with paper and pencil is simple and straightforward. A review of this procedure will be helpful for deriving the design algorithm.
We designate the magnitude of the two numbers by A and B. When the numbers are added 
or subtracted algebraically, we find that there are eight different conditions to consider, depend-ing on the sign of the numbers and the operation performed. The eight conditions may be ex-pressed in a compact form as follows:
(± A) ± (± B)(Operation
terminated)qsqaBs
AsE
A regist erB regist er
ALUControl
  logic(Add)
(Subtract)Magnitude Sign
Overflow
x
Figure 10-6 Register configuration for the adder-subtractor
Control Logic Design  371 
If the arithmetic operation specified is subtraction, we change the sign of B and add. This is evi-
dent from the relations:
(± A) - (+B) = (± A) + (- B)
(± A) - (-B) = (± A) + (+ B)
This reduces the number of possible conditions to four, namely:
(±A) + (±B)
When the signs of A and B are the same, we add the two magnitudes and the sign of the result 
is the same as the common sign. When the signs of A and B are not the same, we subtract the 
smaller number from the larger and the sign of the result is the sign of the larger number. This is 
evident from the following relationships:
If A  B If A < B
(+A) + (+B) = + (A + B)
(+A) + (-B) = +(A - B) = -(B - A)
(-A) + (+B) = -(A - B) = +(B - A)
(-A) + (-B) = - (A + B)
The flowchart of Fig. 10-7 shows how we can implement sign-magnitude addition and sub-
traction with the equipment of Fig. 10-6. An operation is initiated by either input qs or input qa. 
Input qs initiates a subtraction operation, so the sign of B is complemented. Input qa initiates an 
add operation, and the sign of B is left unchanged. The next step is to compare the two signs. The 
decision block marked with As : Bs symbolizes this decision. If the signs are equal, we take the 
path marked by the symbol = ; otherwise, we take the path marked by the symbol ≠. For equal 
signs, the content of A is added to the content of B and the sum is transferred to A. The value of 
the end carry in this case is an overflow; so the E Flip-flop is made equal to the output carry Cout. 
The circuit then goes to its initial state and output x becomes 1. The sign of the result in this case 
is the same as the original sign of As; so the sign bit is left unchanged.
The two magnitudes are subtracted if the signs are not the same. The subtraction of the mag-
nitudes is done by adding A to the 2’ s complement of B. No overflow can occur if the numbers are 
subtracted; so E is cleared to 0. A 1 in E indicates that A ≥ B and the number in A is the correct 
result. The sign of the result again is equal to the original value of As . A 0 in E indicates that  
A < B. For this case, it is necessary to form the 2’ s complement of the value in A and comple-
ment the sign in As. The 2’ s complement of A can be done with one microoperation, A ← A  + 1. 
However, we want to use the ALU of Chapter 9 and this ALU does not have the 2’ s complement 
operation. For this reason, the 2’ s complement is obtained from the complement and increment operations which are available in the ALU.
10.3.4 Data Processor Specification
The flowchart algorithm lists all the microoperations for the data-processor part of the system. The operations between A and B can be done with the ALU. The operations with A
s, Bs, and E 
must be initiated with separate control variables. Figure 10-8(a) shows the data-processor with 
372 Chapter 10
the required control variables. As mentioned before, the ALU is from Chapter 9 and its function 
is specified in Table 9-4. This ALU has four selection variables, as shown in the diagram. The variable L loads the output of the ALU into register A and also the output carry into E. Variables 
y, z, and w complement B
s and As and clear E, respectively.
The block diagram of the control logic is shown in Fig. 10-8(b). The control receives five 
inputs: two from the external environment and three from the data-processor. To simplify the design, we define a new variable S:
S = A
s ⊕ Bs
This variable gives the result of the comparison between the two sign bits. The exclusive-OR operation is equal to 1 if the two signs are not the same, and it is equal to 0 if the signs are both positive or both negative.qa = 1 Initial stat e
  x = 1
qs = 1 
Bs ← Bs
As : Bs
E ← Cout E ← CoutA ← A + B + 1 A ← A + B
A ← A
A ← A  + 1
As ← AsE ← 0  = 0 = 1 E
A < B A ≥ B= ≠
Figure 10-7 Flowchart for sign-magnitude addition and subtraction
Control Logic Design  373 
The control provides an output x for the external circuit. It also selects the operations in the 
ALU through the four selection variables s2, s1, s0, and Cin. The other four outputs go to registers 
in the data-processor as specified in the diagram. Although not shown in the diagram, the outputs 
of the control logic should be connected to the corresponding inputs in the data-processor. Now that the data-processor is specified, we can design the control logic for the system.
10.3.5 Control State Diagram
The design of a hard-wired control is a sequential-logic problem. As such, it may be convenient to formulate the state diagram of the sequential control. The function boxes in a flowchart may be considered as states of the sequential circuit, and the decision boxes as next-state conditions. The microoperations that must be executed at a given state are specified within the function box. AsCout
E Bsy
z
wL (Load)Cins0s1s2B regist er
B regist er     ALU
(Table 9-4)
(a) Data processor registers and ALU
As
E Bs
y (Complement Bs)
z (Complement As)
w (Clear E)L (Load A and E fr om ALU )Cin (Input carr y)s0s1s2
Control
  logic(Function select)(Mode select)(Initial stat e) x
Sqa
qs
(b) Control block diagram
Figure 10-8 System block diagram
374 Chapter 10
The conditions for the next state transition are specified inside the decision box or in the directed 
lines between two function boxes. Although one can formulate this relationship between a flow-chart and a state diagram, the conversion from one form to the other is not unique. Consequently, different designers may produce different state diagrams for the same flowchart, and each may be a correct representation of the system.
We start by assigning an initial state, T
0, to the sequential controller. We then determine the 
transition to other states T1, T2, T3, and so on. For each state, we determine the microoperations 
that must be initiated by the control circuit. This procedure produces the state diagram for the controller, together with a list of register-transfer operations which are to be initiated while the control circuit is in each and every state.
The control state diagram and the corresponding register-transfer operations are derived 
in Fig. 10-9. The information for this design is taken directly from the flowchart of Fig. 10-7 and the variables defined in the block diagram of Fig. 10-8. The initial control state is T
0. While 
T1T0
T6T7
T5T2
T4T3qa = 0
qs = 0
qa
qsAdd
Subtract
Signs alik e
Signs unlike
Output carr yS = 0
S = 0
S = 1
EE = 1qs = 1
E = 0S = 1qa = 1
(a) State diagram
Control outputs
x s2s1s0CinL yzw
T0: Initial state x = 1 1 0 0 0 0 0 00 0
T1: Bs ← B–  s0 0 0 0 0 0 10 0
T2: nothing 0 0 0 0 0 0 00 0
T3: A← A+B, E ← Cout0 0 0 1 0 1 00 0
T4: A← A+B–   + 1, E ← Cout0 0 1 0 1 1 00 0
T5: E ← 0 0 0 0 0 0 0 00 1
T6: A← A 0 1 1 1 0 1 00 0
T7: A← A+1, As ← As 0 0 0 0 1 1 01 0
(b) Sequence of register transfers
Figure 10-9 Control state diagram and sequence of microoperations
Control Logic Design  375 
the control is in this state, variable x is made equal to 1. This variable is 0 in all other states. As 
long as qa and qs are 0, the control stays in its initial state. If qs becomes 1, the control performs 
a subtraction operation by going to state T1. In this state, sign bit Bs is complemented. Control 
then goes to state T2 to add the two numbers. If qa becomes 1, control goes directly to state T2.
The next state after T2 depends on the relative values of the sign bits which are determined 
from input variable S. If the signs are alike, S is 0 and control goes to state T3. In this state, the two 
magnitudes are added and the overflow bit set. Once this is done, control goes back to the initial 
state. If the signs are unlike, S is 1 and control goes from state T2 to state T4. In this state, the two 
magnitudes are subtracted by taking the 2’ s complement of B. The end carry is transferred to E during the subtraction, and control then goes to state T
5.
It must be realized that the end carry from the ALU is transferred to E with a clock pulse. 
This happens with the same clock pulse that causes the control to go from state T4 to T5. Although 
we show the microoperation:
E ← Cout
with timing variable T4 this operation is not executed until a clock pulse occurs. Once this clock 
pulse executes the operation, control finds itself in state T5. Therefore, the value of E for an end 
carry should not be checked until control reaches state T5. The value of E is checked to deter -
mine the relative magnitudes of A and B. If E = 1, it indicates that A  B. For this case, E must 
be cleared and the operation is completed. If E = 0, it indicates that A < B. Control then goes to states T
6 and T7 to complement A and As. Note that E is cleared while the control is in state T5. 
This is done whether E is 1 or 0, since trying to clear a flip-flop that is already 0 leaves the flip-flop in the 0 state anyway. Note also that E is cleared with the clock pulse that causes control to go out of state T
5. It must be realized that clearing E and transferring control to state T0 or T6 is 
done with one common clock pulse without a conflict. The original value of E at time T5 deter -
mines the next state even though this flip-flop is cleared while the clock pulse goes through an edge transition.
It should be apparent from this example that the interpretation of a flowchart may result in 
a different state diagram for the same control logic. This is acceptable as long as the hardware constraints are taken into consideration and the system functions according to the specifications. For example, instead of checking E at time T
5, we could have chosen to check Cout at time T4. If 
Cout is 1, control goes to state T5 to clear E. If it is 0, control can go directly to state T6, bypassing 
state T5; in this case.
10.3.6 Design of Hard-wired Control
The control outputs are a function of the control states and are listed in Fig. 10-9(b). These out-puts are defined in the block diagram of Fig. 10-8(b). The values for the ALU selection variables are determined from Table 9-4. The L (load A) variable must be made equal to 1 every time the 
output of the ALU is transferred to register A. Otherwise, L is 0 and the ALU outputs have no 
effect on the register. To design the control for this system, we need to design the state diagram of Fig. 10-9(a) and provide the control outputs as specified in Fig. 10-9(b).
The control can be designed using the classical sequential-logic procedure. This procedure 
requires a state table with eight states, four inputs, and nine outputs. The sequential circuit to be derived from such a state table will not be easy to obtain because of the large number of vari-
376 Chapter 10
ables. The circuit obtained by using this method may have a minimum number of gates, but it will 
have an irregular pattern and will be difficult to analyze if a malfunction occurs. These difficulties are removed if the control is designed by the one flip-flop per state method.
A control organization that uses one flip-flop per state has the convenient characteristic that 
the circuit can be derived directly from the state diagram by inspection. No state or excitation tables are needed if D flip-flops are employed. Remember that the next state of a D flip-flop is 
a function of the D input and is independent of the present state. Since the method requires one 
flip-flop for each state, we choose eight D flip-flops and label their outputs T
0, T1, T2,..., T7. The 
condition for setting a given flip-flop is specified in the state diagram. For example, flip-flop T2 is 
set with the next clock pulse if T1 = 1 or if T0 = 1 and qa = 1. This condition can be defined with 
the Boolean function:
DT2 = qaT0 + T1
where DT2 designates the D input of flip-flop T2. In fact, the condition for setting a flip-flop to 
1 is obtained from the condition specified in the directed lines going into a given flip-flop state ANDed with the previous flip-flop state. If there is more than one directed line going into a state, all conditions must be ORed. Using this procedure for the other flip-flops, we obtain the input functions given in Table 10-1.
Initially, flip-flop T
0 is set and all others are cleared. At any given time, only one D input is 
in the 1 state while all others are maintained at 0. The next clock pulse sets the flip-flop whose D input is 1 and clears all others. For example, if presently T
0 = 1, then if qa = 0 and qs = 0, the D 
input of T0 will be 1 and the next pulse will leave flip-flop T0 in the 1 state. If during the interval 
between two pulses qs becomes a 1, the D input of T0 will change to 0; but the D input of T1 will 
be 1, so the next pulse will set T1 and clear T0. The flip-flop input functions are mutually exclusive 
and only one flip-flop can be set at any given time; all others are cleared because their D inputs 
are 0’ s.
We now need to specify the control outputs as a function of flip-flop states. This is done 
with the Boolean functions given in Table 10-1. These Boolean functions are obtained by inspec-tion from Fig. 10-9(b). For example, the L output must be 1 during state T
3, T4, T6, or T7. These 
variables are available from outputs of flip-flops. What is needed here is a 4-input OR gate to generate output control L.
The circuit for the control logic is not drawn but can be easily obtained from the Boolean 
functions in Table 10-1. The circuit can be constructed with eight D flip-flops, seven AND gates, 
six OR gates, and four inverters. Note that five control outputs are taken directly from the flip-flop outputs.
10.4 Microprogram Control
In a microprogram control, the control variables that initiate microoperations are stored in mem-ory. The control memory is usually a ROM, since the control sequence is permanent and needs no alteration. The control variables stored in memory are read one at a time to initiate the se-quence of microoperations for the system.
The words stored in a control memory are microinstructions, and each microinstruction 
specifies one or more microoperations for the components in the system. Once these microopera-tions are executed, the control unit must determine its next address. Therefore, a few bits of the 
Control Logic Design  377 
microinstruction are used to control the generation of the address for the next microinstruction. 
Thus, a microinstruction contains bits for initiating microoperations and bits that determine the next address for the control memory itself.
In addition to the control memory, a microprogram control unit must include special cir -
cuits for selecting the next address as specified by the microinstruction. These circuits and the configuration of the microinstruction bits stored in memory vary from one unit to another. In-stead of dwelling on all the possibilities encountered in different situations, we choose here to introduce the microprogram concept by means of a simple example.
The control logic to be designed is for the sign-magnitude adder-subtractor developed in 
the previous section. The hard-wired control designed in Section 10-3 will be replaced by a microprogram control to be designed subsequently. Realize, however, that the digital system considered here is too small for a microprogram controller and, in practice, a hard-wired control would be more efficient. The microprogram control organization is more efficient in large, com-plicated systems.
A state in control memory is represented by the address of a microinstruction. An address 
for control memory specifies a control word within a microinstruction just as a state in a sequen-tial circuit specifies a microoperation. The control we wish to design is specified in Fig. 10-9. Since there are eight states in the control, we choose a control memory with eight words having addresses 0 through 7. The address of the control memory corresponds to the subscript number under the T’ s in the state diagram.
Inspection of the state diagram reveals that the address sequencing in the microprogram 
control must have the following capabilities.
1. Provision for loading an external address as a result of the occurrence of external signals q
a and qs.
2. Provision for sequencing consecutive addresses.
3. Provision for choosing between two addresses as a function of present values of the sta-tus variables S  and E.
Each microinstruction must contain a number of bits to specify the way that the next address is to be selected.Table 10-1 Boolean functions for control
Flip-flop input functions Boolean functions for output control
DT0 = q′a q′sT0 + T3 + ET5 + T7x = T0
DT1 = qsT0s2 = T6
DT2 = qaT0 + T1s1 = T4 + T6
DT3 = S′T2s0 = T3 + T6
DT4 = ST2Cin = T4 + T7
DT5 = T4L = T3 + T4 + T6 + T7
DT6 = E’T5y = T1
DT7 = T6z = T7
w = T5
378 Chapter 10
10.4.1 Hardware Configuration
The organization of the microprogram control unit is shown in Fig. 10-10. The control memory 
is an 8-word by 14-bit ROM. The first nine bits of a microinstruction word contain the control variables that initiate the microoperations. The last five bits provide information for selecting the next address. The control address register (CAR) holds the address for the control memory. This 
register receives an input value when its load control is enabled; otherwise, it is incremented by 1. CAR is essentially a counter with parallel-load capability.
Bits 10, 11, and 12 of a microinstruction contain an address for CAR. Bits 13 and 14 select 
an input for a multiplexer. Bit 1 provides the initial state condition denoted by variable x and also 
enables an external address when q
s or qa is equal to 1. We stipulate that when x = 1, the address 
field of the microinstruction must be 000. Then if qs = 1, address 001 is available at the inputs 
of CAR, but if qa = 1, address 010 is applied to CAR. If both qs and qa are 0’ s, the zero address 
from bits 10, 11, and 12 are applied to the inputs of CAR. In this way, the control memory stays 
at address zero until an external variable is enabled.
The multiplexer (MUX) has four inputs that are selected with bits 13 and 14 of the micro-
instruction. The functions of the multiplexer select bits are tabulated in Fig. 10-10. If bits 13 and 14 are 00, a multiplexer input that is equal to 0 is selected. The output of the multiplexer is 0, and the increment input to CAR is enabled. This configuration increments CAR to choose 
the next address in sequence. An input of 1 is selected by the multiplexer when bits 13 and 14 are equal to 01. The output of the multiplexer is 1 and the external input is loaded into CAR. Status variable S is selected when bits 13 and 14 are equal to 10. If S = 1, the output of the mul-tiplexer is 1 and the address bits of the microinstruction are loaded into CAR (provided x = 0). If  
S = 0, the output of the multiplexer is 0 and CAR is incremented. With bits 13 and 14 equal to 11,  
status variable E is selected and the address field is loaded into CAR if E = 1, but CAR is in-
cremented if E = 0. Thus, the multiplexer allows the control to choose between two addresses, 
depending on the value of the status bit selected.
10.4.2 The Microprogram
Once the configuration of a microprogram control unit is established, the designer’ s task is to generate the microcode for the control memory. This code generation is called microprogram-ming and is a process that determines the bit configuration for each and all words in control memory. To appreciate this process, we will derive the microprogram for the adder-subtractor example. The control memory has eight words and each word contains 14 bits. To microprogram the control memory, we must determine the bit values of each of the eight words.
The register-transfer method can be adopted for developing a microprogram. The microop-
eration sequence can be specified with register-transfer statements. There is no need for listing control functions with Boolean variables since, in this case, the control variables are the control words stored in control memory. Instead of a control function, we specify an address with each register-transfer statement. The address associated with each symbolic statement corresponds to the address where the microinstruction is to be stored in memory. The sequencing from one address to the next can be indicated by means of conditional control statements. This type of statement can specify the address to which control goes, depending on status conditions. Thus, instead of thinking in terms of the l’ s and 0’ s that must be inserted for each microinstruction, it is more convenient to think in terms of symbols in the register-transfer method. Once the symbolic 
Control Logic Design  379 
s0s1
Cins2
L
y
z
wx
4
106
92
7
8531
11
141312ROM
8 × 14
Address
Select 1 0 01 0 0
1
00
1 ES23s0
s1MUXqaqs
Increment
Load inputControl addr ess
register (CA R)
ROM bits MUX select function
13 14
 0  0 Increment CAR
 0  1 Load input to CAR
 1  0 Load input to CAR if S = 1, increment CAR if S = 0
 1  1 Load inputs to CAR if E = 1. increment CAR if E = 0
Figure 10-10 Microprogram control block diagram
380 Chapter 10
microprogram is established, it is possible to translate the register-transfer statements to their 
equivalent binary form.
The microprogram in symbolic form is given in Table 10-2. The eight addresses of the ROM 
are listed in the first column. In the second column, the microinstruction that must be stored at each address is given in symbolic form.
The comments are used to clarify the register-transfer statements. Address 0 is equivalent to 
the initial state and produces an output x = 1. The next address depends on the values of external 
variables q
s and qa. The three conditional control statements in this microinstruction use a go to 
statement after the word then. This is interpreted to mean that if the condition is satisfied, control 
goes to the address written after the words go to. Thus, if both qs and qa are 0, control stays in ad-
dress 0 to repeat the microinstruction. If qs or qa is 1, control goes to address 1 or 2, respectively.
The conditional control statements in the other microinstructions use the status variables 
S and E. The go to statement without a condition attached specifies an unconditional branch to 
the indicated address. For example, go to 0 means that control goes to address 0 after the present microinstruction is executed. If there is no go to statement in the microinstruction, it implies that the next microinstruction is taken from the next address in sequence. Also, if the condition after an if statement is not satisfied, control goes to the next address in sequence.
The microinstructions associated with the eight addresses are derived directly from the 
control specifications of Fig. 10-9. The microoperations listed are identical to the ones listed in Fig. 10-9(b). The conditional control statement specifies the address sequence as given by the state diagram of Fig. 10-9(a). Note that each address number is the same as the subscript number under the T’ s in the state diagram. It should be obvious that the conditional control statements provide a different way to specify a state diagram. This shows that the register-transfer method can be used to specify a sequential circuit.
The microprogram in Table 10-2 could have been derived directly from the flowchart of  
Fig. 10-7. This flowchart was used to specify the algorithm for the system that we are attempting to design. Although the microprogram developed here seems to require many intermediate steps, it must be realized that this was done for explanatory purposes. Once the microprogram con-cept is understood, there is no reason we could not specify the algorithm directly as a symbolic  
Table 10-2 Symbolic microprogram for control memory
ROM  
address Microinstruction Comments
0 x = 1, if (qs = 1) then (go to 1), if (qa = 1)
then (go to 2), if (qs ∧ qa = 0) then (go to 0)Load 0 or external address
1 Bs ← B–  sqs = 1, start subtraction
2 If (S = 1) then (go to 4) qs = 1, start addition
3 A ← A + B, E ← Cout, go to 0 Add magnitudes and return
4 A ← A + B–   + 1, E ← Cout, Subtract magnitudes
5 If (E = 1) then (go to 0), E ← 0 Operation terminated if E = 1
6 A ← A E = 0, complement A
7 A ← A + 1, As ← As, go to 0 Done, return to address 0
Control Logic Design  381 
microprogram without the need for a state diagram. Once the equipment configuration for the 
data processor and the microprogram control is established, the algorithm can be developed by means of a microprogram.
The symbolic designation is a convenient method for developing the microprogram in a 
way that people can read and understand. But this is not the way that the microprogram is stored in control memory. The symbolic microprogram must be translated to binary because this is the form that goes into memory. The translation is done by dividing the bits of each microinstruc-tion into their functional parts called fields. Here we have three functional parts. Bits 1 through 
9 specify the control word for initiating the microoperations. Bits 10 through 12 specify an address field, and bits 13 and 14 select a multiplexer input. For each microinstruction listed in symbolic form, we must choose the appropriate bits in the corresponding microinstruction  
fields.
The equivalent binary form of the microprogram is given in Table 10-3. The addresses for 
the ROM control memory are listed in binary. The content of each word of ROM is also given in binary. This table constitutes the truth table needed for programming the ROM.
The first nine bits in each ROM word give the control word that initiates the specified 
microoperations. These bit values are taken directly from Fig. 10-9(b). The last five bits in each ROM word are derived from the conditional control statements in the symbolic program.
At address 000, we have 01 for the select field. This allows an external address to be loaded 
into CAR if q
s or qa is equal to 1. Otherwise, address 000 is transferred to CAR. In address 001, 
the microinstruction select field is 01 and the address field is 010. From the table in Fig. 10-10, we find that the clock pulse that initiates the microoperation B
s ← B–
s (because y = 1) also trans-
fers the address field into CAR. The next microinstruction out of ROM will be the one stored in 
address 010. The select field at address 001 could have been chosen to be 00. This would have caused CAR to increment and go to address 010.
Inspection of the select field in bits 13 and 14 shows that when these two bits are equal to 
01, the address field is the next address. When these two bits are 10, status variable S is selected, 
and when they are 11, status variable E is selected. In the last two cases, the next address is the Table 10-3 Binary microprogram for control memory
ROM  
addressROM outputs
x s2s1s0CinL y z w Address Select
1 2 3 4 5 6 7 8 9 10 11 12 13 14
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1
0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0
0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1
1 0 0 0 0 1 0 1 1 0 0 0 1 0 1 0 1
1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1
1 1 0 0 1 1 1 0 1 0 0 0 1 1 1 0 1
1 1 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1
382 Chapter 10
one specified in the address field if the selected status bit is equal to 1. If the selected status bit is 
equal to 0, the next address is the one next in sequence because CAR is incremented.
10.5 Control of Processor Unit
The hardware configuration of the microprogram control unit used in the preceding section is suitable for the particular example considered. In a practical situation, the hardware organization of a microprogram control unit must have a general-purpose configuration to suit a wide variety of situations. A general-purpose microprogram control unit must have a control memory large enough to store many microinstructions. Provisions must be made to include all possible control variables in the system—not only for controlling an ALU. The multiplexer and select bits must include all other possible status bits that one may want to check in the system. A provision must be available to accept an external address to initiate many operations rather than just two opera-tions such as add and subtract.
The main advantage of the microprogram control is the fact that, once the hardware config-
uration is established, there should be no need for further hardware or wiring changes. If we want to establish a different control sequence for the system, all we need to do is specify a different set of microinstructions for the control memory. The hardware configuration should not change for different operations; the only change should be in the microprogram residing in control memory.
To show the general property of the microprogram organization, we will expand the hard-
ware configuration to include the control of an entire processor unit. A general-purpose proces-sor unit was introduced in Section 9-9. Referring to Fig. 9-16, we note that the processor unit has seven registers, an ALU, a shifter, and a status register. A microoperation is selected with a control word of 16 bits. The bits for a given control word can be formulated from the binary code listed in Table 9-8.
A microprogram organization for controlling the processor unit is shown in Fig. 10-11. It 
has a control memory of 64 words, with 26 bits per word. To select 64 words, we need an address of 6 bits. To select 8 status bits, we need 3 selection lines for the multiplexer. One bit of the mi-croinstruction selects between an external address and the address field of the microinstruction. Adding the 16 bits for selecting the microoperation in the processor requires a total of 26 bits for each microinstruction.
The processor unit is included in the diagram to show its connection to the microprogram 
control unit. The first 16 bits of the microinstruction select the microoperation for the processor. The other 10 bits select the next address for the control address register. The status bits from the processor are applied to the inputs of a multiplexer. Both the normal and complement values are used, except for the overflow bit V.  Input 0 of MUX 2 is connected to a binary constant which is 
always 1. The load input to CAR is enabled when this input is selected by bits 18, 19, and 20 in 
the microinstruction. This causes a transfer of information from the output of MUX 1 into CAR. The input into CAR is a function of bit 17 in the microinstruction. If bit 17 is 1, CAR receives the 
address field of the microinstruction. If bit 17 is 0, an external address is loaded into CAR. The 
external address is for the purpose of initiating a new sequence of microinstructions which can be specified by the external environment. The status bit (or its complement) selected by bits 18, 19, and 20 of the microinstruction may be equal to 1 or 0. The input address is loaded into CAR 
if the selected bit is 1, but CAR is incremented if the selected bit is 0.
To construct correct microprograms, it is necessary to specify exactly how the status bits 
are affected by each microoperation in the processor. The S (sign) and Z (zero) bits are affected 
Control Logic Design  383 
by all operations. The C (carry) and V (overflow) bits do not change after the following ALU 
operations:
1. The four logic operations OR, AND, XOR, and complement.
2. The increment and decrement operations.
For all other operations, the output carry from the ALU goes into the C bit of the status register. 
The C bit is also affected after a circular shift with carry operation.
10.5.1 Microprogram Example
We now demonstrate by means of an example how a microprogram is written to implement a given macrooperation. A macrooperation initiates a sequence of microinstructions in control 4262017
18
5 32116
Control
memor y
64 × 26Address
  field
Select1
0
SMUX 2Increment
Load inputControl addr ess
regist er (CA R)
1
012 67MUX 1
Select
SelectInputs
OutputsStatus bitsExternal
address
1 VS’ CC’ZZ’
Processor unit
    (Fig. 9-16 
        and     Table 9-8)
Figure 10-11 Microprogram control for processor unit
384 Chapter 10
memory. This sequence constitutes a microprogram routine for executing the specified macro-
operation. A macrooperation is initiated by an external address that supplies the first address in 
control memory for the microinstruction routine. The routine is terminated with a microinstruc-tion that loads a new external address to start executing the next macrooperation.
The macrooperation we wish to implement counts the number of 1’ s presently stored 
in processor register R1 and sets processor register R2 to that number. For example, if R1 = 00110101, the microprogram routine counts the four 1’ s stored in the register and sets register R2 to the binary number 100.
Although the microprogram can be derived directly from the statement of the problem, 
it may be convenient to first construct a flowchart that shows the sequence of microoperations and decision paths. The flowchart for the microprogram is shown in Fig. 10-12. We assume that the microprogram routine starts at address 8. Register R2 and the C (carry) bit are first set to 0. 
The content of R1 is then examined. If it is 0, it signifies that there are no 1’ s stored in it; so the microprogram routine terminates with R2 equal to 0. If the content of R1 is not 0, it indicates 
that there are some 1’ s stored in it. Register R1, together with the carry, is shifted in a circular manner as many times as necessary until a 1 is transferred into C. For every 1 detected in C, we 
increment register R2 and then go back to check if R1 is equal to 0. This loop is repeated until 
C ← 0
R2 ← R2 + 1C= 0≠ 0
Circulat e R1 with carryR2 ← 0
= 0
= 1Start (addr ess 8)
Done R1
Figure 10-12 Flowchart for counting the number of 1’s in register R1
Control Logic Design  385 
all the 1’ s in R1 are counted. Note that the value of C is always 0 when it is circulated with the 
content of R1.
The microprogram routine in symbolic form is presented in Table 10-4. The routine starts 
at address 8 by clearing register R2, The microinstruction in address 9 clears the C bit and sets 
the Z bit if R1 contains all 0’ s. This is done by transferring the content of R1 into itself through 
the ALU. The microinstruction in address 10 checks the value of the Z bit. If it is 1, it indicates that R1 contains all 0’ s, and the routine is terminated by accepting a new external address to start 
executing another macrooperation. If Z is not equal to 1, control continues with address 11. The circular night-shift with carry (crc) places the least significant bit of R1 into C. Next we check 
the value of C. If it is 0, control goes back to address 11 to circulate again until E becomes a 1. 
When C = 1, control goes to address 13 to increment R2 and then returns to address 9 to check 
the content of R1 for an all 0’ s state.
The binary microprogram is given in Table 10-5. The 16 bits for the control word that se-
lects the processor microoperations are derived from Table 9-8. In fact, most of the control words listed were explained in Section 9-9 in conjunction with Table 9-9. The multiplexer select bits select the inputs to the two multiplexers. Bit 17 is 0 in address 10 for selecting an external ad-dress. In all other cases, it is 1 to select the address field of the microinstruction. When bits 18, 19, and 20 are 000, the next address is determined directly from the address field. When these bits Table 10-4 Symbolic microprogram to count the number of 1’s in R1
ROM address Microinstruction Comments
8 R2 ← 0 Clear R2 counter
9 R1← R1, C ← 0 Clear C, set status bits
10 If (Z = 1) then (go to external address) Done if R1 = 0
11 R1 ← crc R1 Circulate R1 right with carry
12 If (C = 0) then (go to 11) Circulate again if C = 0
13 R2 ← R2 + 1, go to 9 Carry = 1, increment R2
Table 10-5 Binary microprogram to count the number of 1’s in R1
ROM content
ROM  
addressMicrooperation select MUX 
selectAddress  
fieldA B D F H
1 16 17 20 21 26
001000 000 000 010 0000 011 1 0 0 0 0 0 1 0 0 1
001001 001 000 001 0000 000 1 0 0 0 0 0 1 0 1 0
001010 001 001 000 1000 000 0 0 1 1 0 0 0 0 0 0
001011 001 001 001 1000 101 1 0 0 0 0 0 1 1 0 0
001100 001 001 000 1000 000 1 0 1 0 0 0 1 0 1 1
001101 010 000 010 0001 000 1 0 0 0 0 0 1 0 0 1
386 Chapter 10
are 011, they select the Z bit for MUX 2. If Z = 1, an external address is transferred to CAR. If  
Z = 0, CAR is incremented and the next address is the next one in sequence. The microinstruction 
at address 12 selects the complement of the carry bit or C. If C = 0, then C ′ = 1 and the address 
field (binary 1011) is transferred into CAR. If C = 1, then C¢ = 0 and CAR is incremented to give 
13 for the next address.
The reader familiar with machine- or assembly-language programming for a computer will 
realize that writing microprograms is very similar to writing machine-language programs for a 
computer. Thus, the microprogram concept is a systematic procedure for designing the control unit of a digital system. Once the microinstruction format is established, the design is done by writing a microprogram, which is similar to writing a program for a computer. For this reason, the microprogram method is sometimes referred to as firmware to distinguish it from the hard-ware method (which we called a hard-wired control) and the software concept which constitutes a programming method.
10.6 Hard-wired Control—Example 2
The example presented in this section demonstrates the development of a second arithmetic algorithm and a different method for designing the control logic. As in the previous example, we first develop the design algorithm together with the hardware configuration for the processor part of the system. After this is done, we formulate the control logic specification for the system.
The control organization chosen for this example is the sequence register and decoder 
method. In the next section, we design the control logic by means of a PLA. This example dem-onstrates the direct relationship that exists between the sequence register and decoder method and its corresponding PLA control implementation.
10.6.1 Statement of the Problem
We wish to design an arithmetic circuit that multiplies two fixed-point binary numbers in sign-magnitude representation. The product obtained from the multiplication of two binary numbers whose magnitudes consist of k bits each can be up to 2k bits long. The sign of each number oc-
cupies one additional bit.
Multiplication of two fixed-point binary numbers in sign-magnitude representation is done 
with paper and pencil by successive additions and shifting. This process is best illustrated with a numerical example. Let us multiply the two binary numbers 10111 and 10011:
23     10111 multiplicand
×
19     10011 multiplier
    10111
   10111
  00000 +
 00000
10111
437 110110101 product
Control Logic Design  387 
The process consists of looking at successive bits of the multiplier, least significant bit first. 
If the multiplier bit is a 1, the multiplicand is copied down; otherwise, zeros are copied down. 
The numbers copied down in successive lines are shifted one position to the left from the previ-ous number. Finally, the numbers are added; their sum forms the product.
The sign of the product is determined from the signs of the multiplicand and multiplier. If 
they are alike, the sign of the product is plus. If they are unlike, the sign of the product is minus.
When the above process is implemented in a digital machine, it is convenient to change 
the process slightly. First, instead of providing digital circuits to store and add simultaneously as many binary numbers as there are 1’ s in the multiplier, it is convenient to provide circuits for the summation of only two binary numbers and successively accumulate the partial products in a register. Second, instead of shifting the multiplicand to the left, the partial product is shifted to the right, which results in leaving the partial product and the multiplicand in the required relative positions. Third, when the corresponding bit of the multiplier is a 0, there is no need to add all zeros to the partial product since it will not alter its value. The previous numerical example is repeated here to clarify the proposed multiplication process:
multiplicand: multiplier: 10111 
 10011
1st multiplier bit = 1, copy multiplicand   shift right to obtain 1st partial product2nd multiplier bit = 1, copy multiplicand 10111
 010111
 10111
add multiplicand to previous partial product  shift right to obtain 2nd partial product3rd multiplier bit = 0, shift right to obtain 3rd partial product4th multiplier bit = 0, shift right to obtain 4th partial product5th multiplier bit = 1, copy multiplicand1000101
 1000101 01000101
 001000101
 10111
   add multiplicand to previous partial product  shift right to obtain 5th partial product = final product 110110101
 0110110101
10.6.2 Equipment Configuration
The register configuration for the binary multiplier is shown in Fig. 10-13. The multiplicand is stored in register B, the multiplier is stored in register Q, and the partial product is formed in 
qm (Multipl y)Qs
AsBs B regist er
A register Q regist erP count er
Control
  logicMultiplicand
MultiplierQ1 E
k
Product
Figure 10-13 Registers for binary multiplier
388 Chapter 10
register A. The sign of the multiplicand is in Bs, the sign of the multiplier is in Qs, and the sign 
of the product is formed in As. The E flip-flop stores the output carry after the addition of B to A. 
The two numbers to be multiplied consist of n bits. One of these bits holds the sign and the other 
k = n - 1 bits hold the magnitude of the number. The P counter is initially set to hold a binary 
number equal to the number of bits in the multiplier magnitude. This counter is decremented 
after the formation of each new partial product. When the contents of the counter reaches zero, the product is formed in registers A and Q and the process stops.
The control logic stays in an initial state until variable q
m becomes 1. The control then per -
forms the multiplication. The sum of A and B forms a partial product which is transferred to A. 
If there is a carry out of the addition, it is transferred to E. Both the partial product in A and the 
multiplier in Q are shifted to the right. After the right-shift of A and Q, one bit of the partial prod-
uct is transferred into Q while the multiplier bits in Q are shifted one position to the right. In this 
manner, the rightmost bit in register Q, designated by Q1, always holds the bit of the multiplier 
which must be inspected next.
10.6.3 Derivation of Algorithm
The flowchart for the binary multiplier is shown in Fig. 10-14. Initially, the multiplicand is in B and the multiplier in Q. Their corresponding signs are in B
s and Qs. The multiplication process 
is initiated when qm = 1. The two signs are compared by means of an exclusive-OR gate. If the 
two signs are alike, the exclusive-OR operation produces a 0 which is transferred to A, to give a 
plus for the product. If the signs are unlike, a 1 is transferred to As to give a negative sign for the 
product. Registers A and E are cleared and the sequence counter P is set to a binary number k, 
which is equal to the number of bits in the multiplier.
Next we enter a loop that keeps forming the partial products. The multiplier bit in Q1 is 
checked, and if it is equal to 1, the multiplicand in B is added to the present partial product in A. 
Any carry from the addition is transferred to E. The partial product in A is left unchanged if Q1 
= 0. The P counter is decremented by 1 regardless of the value of Q1. Registers A, Q, and E are 
then shifted once to the right to obtain a new partial product. This shift operation is symbolized in the flowchart in compact form with the statement:
AQ ← shr EAQ , E ← 0
EAQ is a composite register made up of registers E, A, and Q. If we use the individual register 
symbols, the shift operation can be described by the following microoperations:
A ← shr A, Q ← shr Q, A
k ← E, Qk ← A1, E ← 0
Both registers A and Q are shifted right. The leftmost position of A, designated by Ak, receives 
the carry from E. The leftmost bit of Q, or Qk, receives the bit from the rightmost position of A in 
A1; and E is cleared. In essence, this is a long shift of the composite register EAQ with 0 inserted 
into the leftmost position, which is in E.
The value in the P counter is checked after the formation of each partial product. If P is 
not 0, the process is repeated and a new partial product is formed. The process stops after the kth partial product when P = 0. Note that the partial product formed in A is shifted into Q one bit at 
a time and eventually replaces the multiplier. The final product is available in A and Q, with A 
holding the most significant bits and Q holding the least significant bits. The sign of the product 
is in A
s.
Control Logic Design  389 
10.6.4 Control Specifications
The design algorithm given in the flowchart can be specified more precisely by a state diagram 
and a list of register-transfer operations. It was mentioned previously that the conversion from a flowchart to a state diagram is not unique. The flowchart may be considered a preliminary formu-lation of the algorithm. The control state diagram, together with a list of microoperations, is more precise since it takes into consideration the hardware constraints of the system.
The control sequence of operations is defined in Fig. 10-15. The control has four states, 
and the register-transfer operations for each state are listed below the state diagram. Control stays in an initial state T
0 until qm becomes 1. It then goes to state T1 to initialize registers A, E, 
and P and to form the sign of the product. Control then goes to state T2. In this state, register P is 
decremented and the contents of B are added to A if Q1 = 1; otherwise, A is left unchanged. The 
two control functions at time T2 are:
Q1T2:       A ← A + B, E ← Cout
     T2:      P ← P - 1P ← P – 1
≠ 0 = 0    
PAQ ← shr EA Q, E ← 0= 0 = 1
P ← P – 1A ← A + B, E ← CoutQ1Initial stat e
P ← kA ← 0, E ← 0As ← Bs ⊕ Qsqm = 1
Figure 10-14 Flowchart for binary multiplier
390 Chapter 10
The second statement is always executed when T2 = 1. The first statement is executed at 
time T2 only if Q1 = 1. Thus, a status variable (here Q1) can be included with a timing variable to 
form a control function. Note that it is convenient to decrement P at state T2 so that its new value 
can be checked at state T3.
Control goes to T3 after T2. At state T3, the composite register EAQ is shifted to the right and 
the contents of P are checked for zeros. The binary variable Pz is 1 if the P register contains all 
0’ s; otherwise Pz is 0. If Pz = 1, the operation is terminated and control goes to the initial state. If 
Pz = 0, control goes to state T2 to form a new partial product. Note that P refers to the contents of 
the register, whereas Pz is a binary variable.
10.6.5 Data-Processor Specification
The data-processor part of the system can be derived from the microoperations list of Fig. 10-
15(b). A block diagram of the data processor is shown in Fig. 10-16. A parallel adder is inserted between registers A and B to form the sum, which is transferred to A. The sign of the product 
is formed by an exclusive-OR gate, and binary variable P
z is generated with a NOR gate. The 
outputs of the control logic initiate the microoperations for the data processor. Variable T1 loads 
the sign of the product into As and the number k into P, and it clears registers A and E. Variable T2 
decrements register P, and if Q1 = 1, it generates variable L which loads the sum from the parallel 
adder into A and E. Variable T3 shifts A and Q to the right and clears E. Variable T0 has no effect 
on the data processor since it only indicates that the system is in an initial state.
The inputs to the control logic are the external signal, qm, and the two status conditions, Pz 
and Q1. The outputs are T1, T2, L, and T3. Although not shown in the diagram, these outputs should 
be connected to the corresponding inputs in the data processor. The AND gate that generates variable L is shown separately, although it is part of the control logic.T1T0 T2 T3pz = 1
qm = 0
pz = 0qm = 1pz = 0 if P ≠ 0pz = 1 if P = 0qm  Multipl y
(a) State diagram
T0: Initial state
T1: As ← Bs ⊕ Qs, A ← 0, E ← 0, P ← k
Q1T2: A ← A + B, E ← Cout
T2: P ← P - 1
T3: AQ ← shr EAQ, E ← 0
(b) Sequence of register transfers
Figure 10-15 Control state diagram and sequence of microoperations for multiplier
Control Logic Design  391 
10.6.6 Design of Hard-wired Control
The control logic for the binary multiplier is specified in the state diagram of Fig. 10-15. 
The state diagram has four states and two inputs. To implement it by the sequence register and 
decoder method, two flip-flops and a 2 × 4 decoder are needed. Although this is a simple ex-ample, the procedure outlined below applies to more complicated situations as well.
We start with the excitation table of the sequential circuit given in Fig. 10-17(a). The state 
table part is obtained directly from the state diagram. The flip-flop input conditions are for two JK flip-flops labeled G
1 and G2. Note that the excitation table has don’t-care entries in most of 
the inputs. Note also that a present state is listed more than once if it has two or more next-state conditions. The variables T
0 through T3 are listed along with the binary states for identification. 
The flip-flop input excitations are obtained directly from the excitation table of the JK flip-flop 
as shown in Table 6-8(b).
The sequential circuit can be designed from the excitation table by means of the classical 
procedure. This example has a small number of states and inputs; in most other control logic  Q1T2  (Decr ement)
L  (Load sum)
Control
  logicE
T0kQsBs
AsT1  (Load)B regist er
A register Q regist erParallel adde r
Sum
Load ClearT1
Cout
T1  (Clear)
T3  (Shif t-right)
qm
PzT2
T3T1
Q1Q1T2 = LP registerPz
Figure 10-16 Data processor tor binary multiplier
392 Chapter 10
applications, the number of states and inputs is much larger. The application of the classical 
method requires an excessive amount of work to obtain the simplified input functions for the flip-flops. The design can be simplified if we take into consideration the fact that the decoder outputs are available for use in the design. Instead of using the flip-flop outputs as the present-state conditions, we might as well use the outputs of the decoder to supply this information. If the outputs of the decoder are designated by variables T
0, T1, T2, and T3, these variables can be used 
to supply the present-state conditions for the circuit.Present 
State Inputs Next state Flip-flop inputs
G2 G1qm PzG2 G1JG2KG2JG1KG1
T00 0 0 X 0 0 0 X 0 X
T00 0 1 X 0 1 0 X 1 X
T10 1 X X 1 0 1 X X 1
T21 0 X X 1 1 X 0 1 X
T31 1 X 0 1 0 X 0 X 1
T31 1 X 1 0 0 X 1 X 1
(a) Excitation table
    JG2 = T1                KG2 = T3Pz
JG1 = T0qm + T2  KG1 = 1
 (b) Flip-flop input functions
T1T0
T2
LT3
KQJJQ
KG2
G1
1
CPQ1Pz
qm  2 × 4
decoder
(c) Logic diagram
Figure 10-17 Design of control for binary multiplier
Control Logic Design  393 
Instead of using maps for simplifying the flip-flop input functions, one can simply decide to 
obtain these functions directly from the excitation table. Although this may not result in a mini-
mal circuit, the possible waste of a few gates may be worth the time saved. For example, from the excitation table we note that the J input of G
2 (designated by JG2 in the table) must receive a bi-
nary 1 only when the present output of the decoder is T1. The K input of G2 must receive a 1 when 
the decoder output is T3, provided Pz = 1. These observations can be written in algebraic form as:
JG2 = T1
KG2 = T3Pz
In all other cases, both the J and K inputs of G2 will receive a 0 and the state of the flip-flop will 
not change. This is acceptable because all other entries under JG2 and KG2 have either 0’ s or 
don’t-care X’s .
In a similar fashion, it is possible to derive the flip-flop input functions for G1, by inspection, 
from the excitation table. The input functions so obtained are:
JG1 = T0qm + T2
KG1 = 1
The reason for KG1 being always 1 is that all entries in the table for this input variable are 
either 1’ s or X’s .
When deriving input functions by inspection from the excitation table, we cannot be sure 
that the functions have been simplified in the best way possible. For this reason, one should al-ways analyze the circuit to ensure that the derived equations do indeed produce the required state transitions as specified in the state table.
The logic diagram of the control logic is drawn in Fig. 10-17(c). It consists of two flip-flops, 
G
1 and G2, and a decoder. The outputs of the decoder are used to obtain the next state of the 
circuit according to the Boolean functions listed in Fig. 10-17(b). The outputs of the controller should be connected to the data-processor part of the system as shown in Fig. 10-16.
10.7 PLA Control
We have seen from the two examples presented in this chapter that the design of a control circuit is essentially a sequential-logic design problem. In Section 7-2 we showed that a sequential cir -
cuit can be constructed by means of a register connected to a combinational circuit. In Section 5-8 we investigated the programmable logic array and showed that it can be used to implement any combinational circuit. By replacing the combinational circuit with a PLA, it is then possible to design a control circuit with a register connected to a PLA. The register operates as a sequence register that determines the state of the control. The PLA is programmed to provide the control outputs and the next state for the sequence register.
The design of a control unit with a PLA is very similar to the design using the sequence 
register and decoder methods. In fact, the sequence register in both methods is the same. The dif-ference in the methods is in the way the combinational-logic part of the control is implemented. The PLA essentially replaces the decoder and all other decision logic circuits required in the hard-wired implementation.
The internal organization of the PLA was presented in Section 5-8. It was also shown there 
how to obtain the PLA program table. The reader is advised to review this section to make sure 
394 Chapter 10
that the meaning of a PLA program table is understood. The internal paths inside the PLA are 
“programmed” according to the specifications given in the program table.
The design of a PLA control requires that we obtain the state table for the circuit. The PLA 
method should be used if the state table contains many don’t-care entries; otherwise, it may be advantageous to use a ROM instead of a PLA. The state table gives essentially all the information required for obtaining the PLA program table (or the ROM truth table).
To demonstrate the procedure with an example, consider the control circuit for the binary 
multiplier presented in the previous section. The control specifications for the binary multiplier are given in Fig. 10-15. From this information, we obtain the state table of Table 10-6. The pres-ent state is determined from flip-flops G
1 and G2. The input variables for the control circuit are 
qm, Pz, and Q1. The next state of G1 and G2 may be a function of one of the inputs or it may be 
independent of any inputs. If an input variable does not influence the next state, we mark it with a don’t-care X. If the next state is a function of a particular input, the present state is repeated in 
the table but the next states are assigned different binary values. The table also lists all control outputs as a function of the present state and input conditions. Note that input Q
1 does not affect 
the next state but only determines the value of output L when output T1 is equal to 1.
The block diagram of the PLA control is shown in Fig. 10-18(a). The PLA is connected to 
a sequence register with two flip-flops G1 and G2. The inputs to the PLA are the values of the 
present state of the sequence register and the three external inputs. The outputs of the PLA pro-vide the next state for the sequence register and the control output variables. At any given time, the present state of the sequence register, together with input conditions, determines the output values and the next state for the sequence register. The next clock pulse initiates the microopera-tions specified by the outputs and transfers the next state into the sequence register. This provides a new control state and possible different input values. Thus, the PLA acts as the combinational-logic part of a sequential circuit to provide the control outputs and the next state values for the sequence register.
A PLA is specified by the number of inputs, the number of product terms, and the number 
of outputs. For this case, we have five inputs and seven outputs. The number of product terms is a function of the circuit we wish to implement.Table 10-6 State table for control circuit
Present 
state Input Next state Outputs
G2 G1qmPzQ1G2G1T0T1T2L T3
0 0 0 X X 0 0 1 0 0 0 0
0 0 1 X X 0 1 1 0 0 0 0
0 1 X X X 1 0 0 1 0 0 0
1 0 X X 0 1 1 0 0 1 0 0
1 0 X X 1 1 1 0 0 1 1 0
1 1 X 0 X 1 0 0 0 0 0 1
1 1 X 1 X 0 0 0 0 0 0 1
Control Logic Design  395 
The PLA program table can be obtained directly from the state table without the need 
for simplification procedures. The PLA program table in Fig. 10-18(b) specifies seven product 
terms, one for each row in the state table. The input and output terminals are marked with num-bers, and the variables applied to these numbered terminals are indicated in the block diagram. The comments are not part of the table but are included for clarification.
According to the rules established in Section 5-8, a no connection for a PLA path is indi-
cated by a dash (-) in the table. The X’s  in the state table designate don’t-care conditions and 
imply no connection for the PLA. The CTs in the output columns also indicate no connections to the OR gates within the PLA. The translation from the state table to a PLA program table is very simple: The X’ s in the input columns and the 0’ s in the output columns are changed to dashes, 
and all other entries remain the same. Note that the inputs to the PLA are the same as the pres-ent state and inputs in the state table. The outputs of the PLA are the same as the next state and outputs in the state table.
The procedure for designing control logic with a PLA should be evident from this example. 
From the specifications of the system, we first obtain a state table for the controller. The number 
of states determines the number of flip-flops for the sequence register. The PLA is then connected PLA T1
T0
116
5
4
3
23457
T2LT3
2 G1
G2Q1
Pz
qm
(a) Block diagram
Product 
termInputs
1    2    3    4    5Outputs
1    2    3    4    5    6    7Comments
1 0    0    0    -    - -    -    1    -    -    -    - T0 = 1,  qm = 0
2 0    0    1    -    - -    1    1    -    -    -    - T0 = 1,  qm = 1
3 0    1    -    -    - 1    -    -    1    -    -    - T2 = 1
4 1    0    -    -    0 1    1    -    -    1    -    - T2 = 1,  Q1 = 0
5 1    0    -    -    1 1    1    -    -    1    1    - T2 = 1,  L = 1, Q1 = 1
6 1    1    -    0    - 1    -    -    -    -    -    1 T3 = 1,  Pz = 0
7 1    1    -    1    - -    -    -    -    -    -    1 T3 = 1,  Pz = 1
(b) PLA program table
Figure 10-18 PLA control for binary multiplier
396 Chapter 10
to the sequence register and to the input and output variables. The PLA program table is obtained 
directly from the state table.
The PLA unit in a PLA control may be visualized as a control memory that stores control 
information for the system. The outputs of the sequence register, together with external inputs, may be considered to be an address for such a control memory. The outputs provide a control word for the data processor, and the next-state information specifies a partial value for the next address in the control memory. From this point of view, a PLA control may be classified as a microprogram control unit with the PLA replacing the ROM for the control memory. However, the organization of the two methods is different, although there is a certain amount of similarity between the PLA and the microprogram control methods.
The control examples introduced in this chapter demonstrate four methods of control logic 
design. These should not be considered the only possible methods. A resourceful designer may be able to formulate a control configuration to suit a particular application. This configuration may consist of a combination of methods or may constitute a control organization other than the ones presented here.
The design of the control logic for a digital computer follows the same procedure as out-
lined in this chapter. The role of the microprogram control in the organization of a general-purpose computer is presented in the next section. Chapter 11 presents the detailed design of a digital computer and shows how to implement its control unit by means of a hard-wired method, a PLA method, and a microprogram method.
10.8 Microprogram Sequencer
A microprogram control unit should be viewed as consisting of two parts: the control memory that stores the microinstructions and the associated circuits that control the generation of the next address. The address-generation part is sometimes called a microprogram sequencer, since it se-
quences the microinstructions in control memory. A microprogram sequencer can be constructed with MSI circuits to suit a particular application. However, just as general-purpose processor units are available in IC packages, so are general-purpose sequencers suited for the construction of microprogram control units. To guarantee a wide range of acceptability, an IC sequencer must provide an internal organization that can be adapted to a wide range of applications.
*
A microprogram sequencer attached to a control memory inspects certain bits of the micro-
instruction, from which it determines the next address for control memory. A typical sequencer provides the following address-sequencing capabilities:
1. Increments the present address for control memory.
2. Branches to an address as specified by the address field of the microinstruction.
3. Branches to a given address if a specified status bit is equal to 1.
4. Transfers control to a new address as specified by an external source.
5. Has a facility for subroutine calls and returns.
In most cases the microinstructions are read from control memory in succession. This type 
of sequencing can be easily accomplished by incrementing the address register of the control 
* Some commercial microprogram sequencers are IC type 8X02 (Signetics), 9408 (Fairchild), and 2910 
(Advanced Micro Devices).
Control Logic Design  397 
memory. In some microinstruction formats, each microinstruction contains an address field even 
for sequential addresses. This eliminates the need to increment the control memory address reg-ister, because the address field available in each microinstruction specifies the address of the next microinstruction. In any case, provision must be available for branching to an address out of normal sequence.
Once in a while, control must be transferred to a nonsequential microinstruction; thus, the 
sequencer must provide the capability for branching to any one of two addresses, depending on whether a status bit is 0 or 1. The simplest way to accomplish this is to branch to the address specified by the address field of the microinstruction if the status bit specified is equal to 1, but go to the next address in sequence if the status bit is equal to 0. This configuration requires the capability of incrementing the address register.
The sequencer transfers a new address for control memory to start executing a new macro-
operation. The external address transfers control to the first microinstruction in a microprogram routine that executes the specified macrooperation.
Subroutines are programs used by other routines to accomplish a particular task. Subrou-
tines can be called from any point within the main body of the microprogram. Frequently, many microprograms contain identical sections of code. Microinstructions can be saved by employing subroutines which use common sections of microcode. Microprograms that use subroutines must have a provision for storing the return address during a subroutine call and restoring the address during a subroutine return. This may be accomplished by placing the return address into a spe-cial register and then branching to the beginning of the subroutine. This special register can then become the address source for setting the address register for the return to the main routine. The best way to organize a register file that stores addresses for subroutine calls and returns is to use a last-in, first-out (LIFO) stack. The stack organization and its use in subroutine calls and returns are explained in more detail in Section 12-5.
The block diagram of a microprogram sequencer is shown in Fig. 10-19. It consists of a 
multiplexer that selects an address from four sources and routes it into a control address register. The output from CAR provides the address for the control memory. The contents of CAR are 
incremented and applied to the multiplexer and to the stack register file. The register selected in the stack is determined by the stack pointer. Inputs I
0, I1, and I2 specify the operation for the 
sequencer, and input T is a test point for a status bit. The address register can be cleared to zero 
to initialize the system and the clock pulses synchronize the loading into the registers.
The function table listed in the diagram specifies the operation of the sequencer. Inputs I1 
and I0 determine the selection variables for the multiplexer. An external address (EXA) is trans-
ferred into CAR when I1I0 = 00. The transfer from the stack register (SR) occurs when I1I0 = 01, 
and CAR is incremented when I1I0 = 10. The T and I2 inputs have no effect during these three op-
erations and they are marked with don’t-care X entries. When I1I0 = 11, the sequencer executes a 
conditional branch operation dependent on the value of the test bit in T. If I2 is also equal to 1, the 
operation is a conditional call to subroutine. In either case, CAR is incremented if the test bit T 
is 0. The branch address (BRA) is transferred to CAR if T = 1. Thus, with I1I0 = 11, the sequencer 
branches to the BRA if the status bit in T is equal to 1. but increments CAR if the status bit is 0. 
The branch address normally comes from the address field of the microinstruction.
The conditional subroutine call (I2 = 1) is similar to the conditional branch (I2 = 0), except 
that the former uses the stack and the latter does not. The address stored in the stack during a subroutine call is taken from the incrementer. This is the address next in sequence, and it is called 
398 Chapter 10
the return address. The return address is transferred back into CAR with a subroutine return 
operation (I1I0 = 01).
The operation of the stack register and stack pointer will be better understood after reading 
Section 12-5. A register (or memory) stack is similar to a memory unit, except that the address 
for the stack is determined from the value in the stack-pointer register. The access to the stack is in a last-in, first-out sequence and is controlled by incrementing or decrementing the stack pointer. Initially, the stack pointer is cleared and is said to point at address 0 in the stack. The I1
PushI2I0
PopInc DecStack point er
regist er (SP)
Output addr essStack 
regist er
(SR)
Control addr ess 
regist er (CA R)Increment erReadWrite
Clear
CPT(test)    Branch
address(BRA)   Ext ernal
address(EX A)
MUXs1
s001 32
Function table
I2I1I0T s1s0Operation Comments
X 0 0 X 0 0CAR ← EX A Transfer external address
X 0 1 X 0 1CAR ← SR Transfer from register stack
X 1 0 X 1 0CAR ← CAR + 1 Increment address
0 1 1 0 1 0CAR ← CAR + 1 Increment address
0 1 1 1 1 1CAR ← BRA Transfer branch address
1 1 1 0 1 0CAR ← CAR + 1 Increment address
1 1 1 1 1 1CAR ← BRA, SR ← CAR + 1 Branch to subroutine
Figure 10-19 Typical microprogram sequencer organization
Control Logic Design  399 
write or the transfer of information into the stack is called push. It consists of writing the input 
information into the stack at the address specified by the stack pointer and then incrementing the 
stack-pointer register. In this way, information is transferred into the stack, and the stack pointer points at the next empty location in the stack. The read or the transfer of information out of the 
stack is called pop. It consists of first decrementing the stack-pointer register and then reading 
out the contents of the register (or word) specified by the new value in the stack pointer.
A call to subroutine is executed when I
2I1I0 = 111 and T = 1. This causes a push-stack op-
eration and a branch to the address specified by BRA. This is implemented by first storing the 
incremented value from CAR into the stack. When clock pulse CP goes through a positive-edge 
transition, the BRA address is transferred to CAR and the write input to the stack is inhibited. The 
stack-pointer register is incremented later when CP goes through its negative-edge transition. 
This is illustrated in Fig. 10-20(a).
The return from subroutine is executed when I1I0 = 01. This causes a pop-stack operation 
and a branch to the address stored on top of the stack. This is implemented by first decrementing the stack-pointer register on the negative-edge transition of CP . The value in the stack, given by 
the address presently available in the stack pointer, is then read and transferred to CAR on the 
positive-edge transition of CP . This is illustrated in Fig. 10-20(b). Note that CAR is triggered 
during the positive edge and SP during the negative edge of a clock pulse. The stack pointer is 
incremented after the transfer into CAR and decremented prior to the transfer into CAR.
10.8.1 Microprogrammed CPU Organization
A digital computer consists of a central processor unit (CPU), a memory unit, and input-output devices. The CPU can be classified into two distinct but interactive functional sections. One section is the processing section and the other is the control section. A processor unit is a useful device for constructing the processor section of a CPU. The microprogram sequencer is a conve-nient element for constructing a microprogram control for a CPU. We now develop a computer CPU to show the usefulness of the microprogram sequencer defined in Fig. 10-19.CP
Write CAR + 1
  into stac k
CAR ← BRA SP ← SP + 1
(a) Call subroutine (push stack) I2I1I0T = 1111
CP
Read fr om
   stac k
CAR ← SR SP ← SP – 1
(b) Return from subroutine (pop stack) I1I0 = 01
Figure 10-20 Stack operations in microprogram sequencer
400 Chapter 10
A block diagram of a microprogrammed computer is shown in Fig. 10-21. It consists of a 
memory unit, two processor units, a microprogram sequencer, a control memory, and few other 
digital functions. This configuration may be compared with the simple computer that was de-signed in Section 8-9 and whose block diagram is given in Fig. 8-16.
The memory unit stores the instructions and data supplied by the user through an input 
device. The data processor manipulates the data, and the address processor manipulates the ad-Control memor y
         (RO M)Memor y addr ess
       r egist er
Instruction re gister
       Program count erAddress pr ocessor
Code transf ormation
          (PL A)
Microprogram
Sequencer(Fig. 10-19)   Da ta 
ProcessorMemor y
   unitAddress 
Read/wr ite
MUX       
EXA
BRA
Pipeline R egist er
BRAI0 – I2T
II
MUX
SL MC PS DFStatus bits
I         – Sequence select or
SL      – MUX select or
BRA   – Branch addr ess
MC     – Memor y contr ol
PS      – Pr ocessor select or
DF      – Da ta fiel d
Figure 10-21 Microprogrammed computer organization
Control Logic Design  401 
dress information received from memory. The two processors can be combined into one unit, but 
sometimes it is convenient to separate them in order to provide a distinct bus for the memory address. An instruction extracted from memory during the fetch cycle goes into the instruction register. The instruction-code bits in the instruction register specify a macrooperation for control memory. A code transformation is sometimes needed to convert the operation-code bits of an instruction into a starting address for the control memory. This code transformation constitutes a mapping function and can be implemented with a ROM or a PLA. The mapping concept provides a flexibility for adding instructions or macrooperations for control memory as the need arises. The address generated in the code transformation mapping function is applied to the external address (EXA) input of the sequencer.
The microprogram control unit consists of the sequencer of Fig. 10-19, a control memory 
for storing the microinstructions, a multiplexer, and a pipeline register. The multiplexer selects one of many status bits and applies it to the T (test) input of the sequencer. One of the inputs to 
the multiplexer is always 1 to provide an unconditional branch operation. The pipeline register is not always necessary, because the outputs from control memory can go directly to the control inputs of the various units in the CPU. However, a pipeline register speeds up the control opera-tion. It allows the next address to be generated and the output of control memory to change while the current control word in the pipeline register initiates the microoperations given by the present microinstruction.
A possible microinstruction format for the control memory is illustrated within the pipeline 
register. The 1 field consists of three bits and supplies the input information for the sequencer. The SL field selects a status bit for the multiplexer. The BRA field is the address field of the 
microinstruction and supplies a branch address (BRA) to the sequencer. These three fields of a 
microinstruction provide information to the sequencer to determine the next address for con-trol memory. The sequencer generates the next address and the control memory reads the next microinstruction while the present microoperations are being executed in the other units of the  
CPU.
The other three fields in the microinstruction are for controlling the microop erations in the 
processor and memory units. The memory control (MC) field controls the address processor and 
the read and write operations in the memory unit. The processor select (PS) field controls the operations in the data processor unit. The last field is a data field (DF) used to introduce constants into the processor. The procedure of introducing data into the system from the control memory is a frequently used technique in many microprogrammed systems. Outputs from the data field may be used to set up control registers and introduce data in processor registers. For example, a con-stant in the data field may be added to a processor register to increment its contents by a speci-fied value. Another use of the data field is in setting a sequence counter to a constant value. The sequence counter is then used to count the number of times a microprogram loop is traversed, as is usually required in a multiply or divide routine.
Once the hardware configuration of a microprogrammed CPU is established, the designer 
can use it to construct any one of many possible computer configurations. First, the instruction set for the computer is formulated and then a microprogram is written for control memory. One can change the microprogram in control memory if a different computer with a different set of in-structions is desired. No hardware changes are required if the computer’ s specifications change; the change is only in the control memory ROM. This involves removing the present ROM from its socket and replacing it with another unit with a different microprogram.
402 Chapter 10
The construction of a CPU from LSI components as shown in Fig. 10-21 provides the 
freedom to define the instruction set for a computer system. It must be realized, however, that 
integrated circuits are available that contain a complete CPU within a single package. This type of CPU is called a microprocessor. If a microprocessor is used instead of a custom-made CPU, 
one must be satisfied with the fixed instruction set of the microprocessor chosen. In other words, a microprocessor is a ready-made CPU with a fixed set of computer instructions. A custom-made microprogrammed CPU is a flexible unit that allows the’ formulation of instructions suited to a particular application. Microprocessors are discussed in Chapter 12.
REFERENCES
1. Mano, M. M., Computer System Architecture. Englewood Cliffs, N. J.: Prentice-Hall, Inc., 1976.
2. Rhyne, V . T., Fundamentals of Digital Systems Design. Englewood Cliffs, N. J.: Prentice-Hall, Inc., 
1973.
3. Chu, Y ., Computer Organization and Microprogramming. Englewood Cliffs, N. J.: Prentice-Hall, Inc., 
1972.
4. Mick, J. R., and J. Brick, Microprogramming Handbook. Sunnyvale, Calif.: Advance Micro Devices, 
Inc., 1977.
5. Bipolar Microcomputer Components Data Book. Dallas, Texas: Texas Instruments, Inc., 1977.
6. Agrawala, A.K., and T. G. Rauscher, Foundations of Microprogramming. New Y ork: Academic Press, 
1976.
7. Signetics Field Programmable Logic Array: An Application Manual. Sunnyvale, Calif.: Signetics 
Corp., 1977.
8. Clare, C. R., Designing Logic Systems Using State Machines. New Y ork: McGraw-Hill Book Co., 1973.
9. Alexandridis, N. A., “Bit-sliced Microprocessor Architecture”, Computer, V ol. 11, no. 6, (June 1978), 
pp. 56-80.
PROBLEMS
10-1. (a) Show that the ring-counter control of Fig. 7-22(a) is a special case of the one flip-flop per state control depicted in Fig. 10-2. Indicate how the latter can be reduced to the former. (b) Show that the counter and decoder control of Fig. 7-22(b) is a special case of the sequence register and decoder 
control depicted in Fig. 10-3. Indicate how the latter can be reduced to the former.
10-2. The adder-sub tractor system designed in Section 10-3 employs an ALU. Redraw the system block 
diagram of Fig. 10-8 without using an ALU. Instead, use the adder-subtractor circuit of Fig. 9-10 
and a register with complement, increment, and load capabilities. Revise the control outputs of Fig. 
10-9(b).
10-3. Go over the flowchart of Fig. 10-7 to find out if a negative zero may result at the end of the compu-
tation. A negative zero occurs if A = 0 and A
s= 1.
10-4. Design a digital system that adds and subtracts two binary fixed-point numbers represented in sign-
2’ s-complement form. Include an overflow indication.
10-5. Revise the control state diagram of Fig. 10-9 if the value of Cout is checked at time T4, instead of 
checking the value of E at time T5.
Control Logic Design  403 
10-6. The number of states for the control of Fig. 10-9 can be reduced if the S variable is used together 
with qa and qs to determine the next state after the initial state. Also, register A can be complemented 
during the same state that E is cleared if E’ is included in the control function for the complement 
operation. Show that the adder-subtractor system can be implemented with six control states.
10-7. Design the control specified by the state diagram of Fig. 10-15(a) by the one flip-flop per state 
method. Draw the logic diagram using gates and four D flip-flops.
10-8. Obtain a second listing for the binary microprogram of Table 10-3 by using 00 for ROM  bits 13 and 
14 every time that CAR is incremented unconditionally.
10-9. Redesign the input circuit of Fig. 10-10 by replacing the AND gates associated with qa and qs with a 
dual 2-to-1 line multiplexer with enable input.
10-10. The microprogram control unit of Fig. 10-10, together with the associated data processor of  
Fig. 10-8(a), is to be used for adding and subtracting two binary numbers in sign-2’ s-complement representation. The sign bits reside in the leftmost bit position of registers A and B. Since the signs 
are included with A and B, there is no need for A
s and Bs and variable S. Instead, let S now be a flip-
flop that stores the carry Cn that goes into the sign-bit position, just as E stores the carry Cn + 1 = Cout 
coming out of the sign-bit position. Let variables y and z be two control signals that set and clear an 
overflow flip-flop V. If an overflow occurs, V is set with control variable y. If no overflow occurs, V 
is cleared with control variable z.
(a) Write the microprogram in symbolic form.
(b) List the ROM truth table in binary.
10-11. Give a microinstruction in binary form for the control memory of Fig. 10-11 that will keep the 
system in a no-operation loop as long as the external address is the same as the address where the 
microinstruction is located in memory. The values that go into the status register are not important.
10-12. Write a microprogram in symbolic form for the system of Fig. 10-11 that checks the sign of the 
number stored in register R1. The number is in sign-2’ s complement representation. If the number 
is positive, it is divided by 2. If negative, it is multiplied by 2. If an overflow occurs, R1 is cleared to zero.
10-13. Write a microprogram that compares two unsigned binary numbers stored in R1 and R2. The register containing the smaller number is then cleared. If the two numbers are equal, both registers are clea-red. Use the microprogram system of Fig. 10-11.
10-14. The processor of Fig. 9-16 is used for multiplying two unsigned binary numbers. The multiplicand is in R1, the multiplier is in R3, and the product is formed in R2 and R3. Register R4 holds a binary 
number equal to the number of bits in the multiplier. Derive the algorithm in flowchart form.
10-15. List the contents of registers E, A, Q, and P (Fig. 10-16) after each clock pulse during the process of 
multiplication of the two magnitudes 10111 (multiplicand) and 10011 (multiplier).
10-16. The control state diagram of Fig. 10-15(a) does not use variable Q
1 as a condition for state transition. 
Instead, Q1 is used as part of a control function in the list of register transfers. Redesign the control 
so that Q1 appears as a condition in the state diagram and removed from the list of control functions. 
Show that for this case the state diagram must have at least five states.
10-17. Determine the time it takes to process the multiplication operation in the digital system described in Fig. 10-15. Assume that the Q register has k bits and the interval between two clock pulses is t 
seconds.
10-18. Design the control logic of Fig. 10-16 using two T flip-flops and a decoder.
10-19. Change the P register of Fig. 10-16 to an up-counter with parallel load. Input T
2 will now increment 
the P register. What is the initial value that must be loaded into P at time T1?
404 Chapter 10
10-20. Prove that the multiplication of two n-digit numbers in any base r gives a product of no more than 
2n digits in length. Show that this statement implies that no overflow can occur in the multiplier 
designed in Section 10-6.
10-21. Design the control specified in Fig. 10-9 by the sequence register and decoder method. Use three JK flip-flops G
3, G2, and G1.
10-22. Design the control specified in Fig. 10-9 using a sequence register and a PLA. List the PLA program table.
10-23. The register configuration and flowchart of a digital system that multiplies two unsigned binary 
numbers, by the repeated addition method is shown in Fig. P10-25.
(a) Convince yourself that the system multiplies the contents of A and B and places the product in 
register P.
 qm = 1x = 1
P ← 0
P ← P + B
A ← A – 1APA B
= 0
≠ 0Initial stat eMultiplicand Multiplier
Product
Control
  logicqm
x
 Figure P10-25 Multiplication by successive additions
(b) Let A = 0100 and B = 0011. Going through the steps in the flowchart, show that the system 
returns to the initial state, with register P having the product 1100.
(c) Draw a state diagram for the control and List the register transfers to be executed in each control 
state.
(d) Draw the block diagram of the data-processor part.
(e) Design the control by the one flip-flop per state method.
10-24. The state diagram of a control unit is shown in Fig. P10-28. It has four states and two inputs x and y. 
Design the control by the sequence register and decoder method with two JK flip-flops G2 and G1.
(a) Use the decoder outputs as conditions for the present states.
(b) Use the flip-flop outputs as conditions for the present states. Compare the two results and com-ment on the advantages and disadvantages in each case.
Control Logic Design  405 
T0
T2T3x = 1x = 1
y = 0 y = 1y = 1T1
x = 1, y = 0                    
x = 1, y = 1                    y = 0x = 1
x = 0 x = 0x = 0
Figure P16-26 Control state diagram for problem 10-28
10-25. The pipeline register in Fig. 10-21 has one additional output labeled P for controlling the polarity of 
the T input in the sequencer. When P = 0, the value of the status bit selected by SL is applied to the 
T input. When P = 1, the complement of the selected status bit is  applied to T.
(a) What does the polarity control P accomplish?
(b) Design the circuit that must be placed between the multiplexer selected by SL and the test  
input T.
10-26. The microprogrammed computer of Fig. 10-21 has a control address register (CAR) inside the 
sequencer and a pipeline register (PLR) in the output of control memory. The speed of operation can 
be improved if only one register is used. Compare the speed of operation by comparing the propaga-tion delays encountered when the system uses:
(a) A CAR without a PLR.
(b) A PLR without a CAR.
10-27. Write short notes on(a) Hard-wired control.
(b) Control of processor unit.
(c) Microprogram sequencer.
10-28. Differentiate between 
(a) PLA Control & Microprogram Control.
(b) One flip-flop per state method & sequence register and decoder method.
10-29. Derive expression of the input function for flip-flops B
s, As, and E of Fig. 10-8(a). Use SR flip-flops.
10-30. Design the control specified by the state diagram of Fig. 10.15(a) by sequence register and decoder 
method.
10-31. The following register-transfer operations specify a three-state control of the sequence register and 
decoder type, G is a 3-bit sequence register and T0, T1 and T2 are the outputs of the decoder
x To:  G ← 101
y To:  G ← 111
T1 + T2: G ← G + 1
406 Chapter 10
10-32. A control unit has two input x and y and five states. The control state diagram is shown in the Fig. 
given below
(a) Design the control using five T flip-flops.
(b) Design the control a register, a decoder, and a PLA
     T0 T4
T3T1T2
x = 0
y = 1y = 0
x = 1
11Chapter
 Computer Design11.1 Introduction
This chapter presents a small general-purpose digital computer starting from its functional speci-
fications and culminating in its design. Although the computer is small, it is far from useless. Its 
scope is quite limited when compared with commercial electronic data-processing systems, yet it encompasses enough functional capabilities to demonstrate the design process. It is suitable for construction in the laboratory with ICs, and the finished product can be a useful system capable of processing digital data.
*
The computer consists of a central processor unit, a memory unit, and a teletypewriter 
input-output unit. The logic design of the central processor unit will be derived here. The other two units are assumed to be available as finished products with known external characteristics.
The hardware design of a digital computer may be divided into three interrelated phases: 
system design, logic design, and circuit design. System design is concerned with the specifica-tions and general properties of the system. This task includes the establishment of design objec-tive and design philosophy, the formulation of computer instructions, and the investigation of its economic feasibility. The specifications of the computer structure are translated by the logic designer to provide the hardware implementation of the system. The circuit design specifies the components for the various logic circuits, memory circuits, electromechanical equipment, and power supplies. The computer hardware design is greatly influenced by the software system, 
which is normally developed concurrently and which constitutes an integral part of the total computer system.
The design of a digital computer is a complicated task. One cannot expect to cover all as-
pects of the design in one chapter. Here we are concerned with the system and logic design of a small digital computer whose specifications are formulated somewhat arbitrarily in order to es-tablish a minimum configuration for a very small, yet practical machine. The procedure outlined in this chapter can be useful in the logic design of more complicated systems.
The design process is divided into six phases:
1. The decomposition of the digital computer into registers which specify the general con-figuration of the system.
*The instructions for the computer are a subset of the instructions in the PDP -8 computer.
408 Chapter 11
2. The specification of computer instructions.
3. The formulation of a timing and control network.
4. The listing of the register-transfer operations needed to execute all computer instruc-
tions.
5. The design of the processor section.
6. The design of the control section.
The design process is carried out by means of tabular listings that summarize the specifications and register-transfer operations in compact form. The processor section is defined by means of a block diagram consisting of registers and multiplexers. It is assumed that the reader has suf-ficient information to replace the blocks in the diagram with MSI circuits. The control section is designed by each of the three methods outlined in Chapter 10.
11.2 System Configuration
The configuration of the computer is shown in Fig. 11-1. Each block represents a register, ex-cept for the memory unit, the master-clock generator, and the control logic. This configuration is assumed to satisfy the final system structure. In a practical situation, the designer starts with a tentative system configuration and constantly modifies it during the design process. The name of each register is written inside the block, together with a symbolic designation in parentheses.
The master-clock generator is a common clock-pulse source, usually an oscillator, which 
generates a periodic train of pulses. These pulses are fanned out by means of amplifiers and 
Program C ounter
         (PC)
Memor y addr ess
Regist er  (MAR)
Instruction
Regist er (I)Memor y Buf fer Regist er
                (B)
Accumulat or Registe r
              (A)E
SF
Control
  LogicMemor y unit
 4096 wo rds
16 bits/wor d
SequenceRegist er (G)
Input R egist er
        (N)Output R egist
er
         (U)Mast er cloc k
  generat or
Figure 11.1 Block diagram of digital computer
Computer Design  409 
distributed over the entire system. Each pulse must reach every flip-flop and register at the same 
time. Phasing delays may be needed intermittently so that the difference in transmission delays is uniform throughout. The frequency of the pulses is a function of the speed with which the system operates. We shall assume a frequency of 1 megahertz, which gives one pulse every microsecond. This pulse frequency is chosen for the sake of having a round number and to avoid problems of circuit propagation delays.
The memory unit has a capacity of 4096 words of 16 bits each. This capacity is large enough 
for meaningful processing. A smaller size may be used if the computer is to be constructed in the laboratory under economic restrictions. Twelve bits of an instruction are needed to specify the address of an operand,
 which leaves four bits for the operation part of the instruction. The access 
time of the memory is assumed to be less than 1 microsecond so that a word can be read or writ-ten during the interval between two clock pulses.
The part of the digital computer to be designed is decomposed into register subunits. The 
following paragraphs explain why each register is needed and what function it performs. A list of the registers and a brief description of their functions is presented in Table 11-1. Registers that hold memory words are 16 bits long. Those that hold an address are 12 bits long. Other registers have different numbers of bits, depending on their function.
11.2.1 Memory Address and Memory Buffer Registers
The memory address register, MAR, is used to address specific memory locations. MAR is loaded 
from PC when an instruction is to be read from memory, and from the 12 least significant bits of 
the B register when an operand is to be read from memory. Memory buffer register B holds the 
word read from or written into memory. The operation part of an instruction word placed in B is transferred into the I register, and the address part is left in the B register for transfer to MAR. 
An operand word placed in the B register is accessible for operation with the A register. A word 
to be stored in memory must be loaded into the B register before a write operation is initiated.Table 11-1 List of registers tor computer
Symbolic  
designation NameNumber 
of bits Function
A Accumulator register 16 Processor register
B Memory buffer register 16 Holds contents of memory word
PC Program counter 12 Holds address of next instruction
MAR Memory address register 12 Holds address of memory word
I Instruction register 4 Holds current operation-code
E Extension flip-flop 1 Accumulator extension
F Fetch flip-flop 1 Controls fetch and execute cycles
S Start-stop flip-flop 1 Starts and stops computer
G Sequence register 2 Provides timing signals
N Input register 9 Holds information from input device
U Output register 9 Holds information for output device
410 Chapter 11
11.2.2 Program Counter
Program counter PC holds the address of the next instruction to be read from memory. This reg-
ister goes through a step-by-step counting sequence and causes the computer to read successive 
instructions previously stored in memory. When the program calls for a transfer to another loca-tion or for skipping the next instruction in sequence, the PC is modified accordingly, causing the 
program to continue from a memory location out of the counting sequence. To read an instruc-tion, the contents of PC are transferred to MAR and a read operation is initiated. The program 
counter is always incremented by 1 while a memory write operation reads the present instruction. Therefore, the address of the next instruction, one higher than the one presently being executed in the processor, is always available in PC.
11.2.3 Accumulator Register
Accumulator register A is a processor register that operates on data previously stored in memory. 
This register is used to execute most instructions and for accepting data from the input device or transferring data to the output device. The A register, together with the B register, makes up the 
bulk of the processor unit for the computer. Although most data processing systems include more registers for the processor unit, we have chosen to include only one accumulator here in order not to complicate the design. With a single accumulator as the arithmetic element, it is possible to implement only the add operation. Other arithmetic operations such as subtraction, multiplica-tion, and division must be implemented with a sequence of instructions that form a subroutine.
11.2.4 Instruction Register
Instruction register I holds the operation-code bits of the current instruction. This register has only four bits since the operation-code of instructions is four bits long. The operation-code bits are transferred to the I register from the B register, while the address part of the instruction is left 
in B. The operation-code part must be taken out of the B register because an operand read from 
memory into the B register will destroy the previously held instruction. The operation part of 
the instruction is needed by the control to determine what is to be done to the operand just read.
11.2.5 Sequence Register
Sequence register G is a counter that produces the timing signals for the computer. The G register 
is decoded to supply four timing variables for the control unit. The timing variables, together with other control variables, produce the control functions that initiate all the microoperations for the computer.
11.2.6 E, F, and S Flip-flops
Each of these flip-flops is considered a one-bit register. The E flip-flop is an extension of the A 
register. It is used during shifting operations, receives the end carry during addition, and other -
wise is a useful flip-flop that can simplify the data processing capabilities of the computer. The F flip-flop distinguishes between the fetch and execute cycles. When F is 0, the word read from 
memory is treated as an instruction. When F is 1, the word is treated as an operand. S is a start-
stop flip-flop that can be cleared by program control and manipulated manually. When S is 1, the 
Computer Design  411 
computer runs according to a sequence determined by the program stored in memory. When S is 
0, the computer stops its operation.
11.2.7 Input and Output Registers
The input-output (I/0) device is not shown in the block diagram of Fig. 11-1. It is assumed to be 
a teletypewriter unit with a keyboard and a printer. The teletypewriter sends and receives serial information. Each quantity of information has 8 bits of an alphanumeric code. The serial infor -
mation from the keyboard is shifted into the input register. The serial information for the printer is stored in the output register. These two registers communicate with the teletypewriter serially and with the accumulator register in parallel.
Input register N consists of nine bits. Bits 1 through 8 hold alphanumeric input informa-
tion; bit 9 is a control bit called an input flag. The flag bit is set when a new character is available 
from the input device and cleared when the character is accepted by the computer. The flag bit is needed to synchronize the slow rate by which the input device operates compared to the high-speed circuits in the computer. The process of information transfer is as follows. Initially, the flag bit in N
9 is cleared. When a key is struck on the keyboard, an 8-bit code is shifted into the 
input register (N1 - N8). As soon as the shift operation is completed, the flag bit in N9 is set to 1. 
The computer checks the flag bit; if it is 1, the character code from the N register is transferred 
in parallel into the A register and the flag bit is cleared. Once the flag is cleared, a new character 
can be shifted into the N register by striking another key.
Output register U works in a similar fashion, but the direction of information flow is re-
versed. Initially, the output flag in U9 is set to 1. The computer checks the flag bit; if it is I, a 
character code from the A register is transferred in parallel to the output register (U1 - U8) and 
the flag bit U9 is cleared to 0. The output device accepts the coded information and prints the 
corresponding character; when the operation is completed, it sets the flag bit to 1. The computer does not load a new character into the output register when the flag is 0, because this condition indicates that the output device is in the process of printing the previous character.
11.3 Computer Instructions
The number of instructions available in a computer and their efficiency in solving the problem at hand are a good indication of how well the system designer foresaw the intended application of the machine. Medium- to large-scale computing systems may have hundreds of instructions, while most small computers limit the list to less than 100. The instructions must be chosen carefully to supply sufficient capabilities to the system for solving a wide range of data process-ing problems. The minimum requirements of such a list should include a capability for stor -
ing and loading words from memory, a sufficient set of arithmetic and logic operations, some address-modification capabilities, unconditional branching and branching under test conditions, register manipulation capabilities, and I/O instructions. The instruction list chosen for our com-puter is believed to be close to the absolute minimum required for a restricted but practical data  
processor.
The formulation of a set of instructions for the computer goes hand in hand with the formu-
lation of the formats for data and instruction words. A memory word consists of 16 bits. A word may represent either a unit of data or an instruction. The formats of data words are shown in Fig. 11-2. Data for arithmetic operations are represented by a 15-bit binary number, with the sign in 
412 Chapter 11
the 16th bit position. Negative numbers are assumed to be in their 2’ s-complement equivalent. 
Logical operations are performed on individual bits of the word, with bit 16 treated as any other bit. When the computer communicates with the I/O device, the information transferred is con-sidered to be 8-bit alphanumeric characters. Two such characters can be accommodated in one computer word.
The formats of instruction words are shown in Fig. 11-3. The operation part of the instruc-
tion contains four bits; the meaning of the remaining 12 bits depends on the operation-code encountered. A memory-reference instruction uses the remaining 12 bits to specify an address. A 
register-reference instruction implies an operation on, or a test of, the A or E register. An operand Sign Magnitude (neg ative number s in 2’ s complement)
10 98 76 5 4 3 2 1 11 12 13 14 15 16
(a) Arithmetic operand
Logical word
10 98 76 5 4 3 2 1 11 12 13 14 15 16
(b) Logical operand
Charact er
10 98 76 5 4 3 2 1 11 12 13 14 15 16Charact er
(c) Input/output data
Figure 11.2 Data formats
Operation
10 98 76 5 4 3 2 1 11 12 13 14 15 16Address
(a) Memory-reference instruction
Code 01 10
10 98 76 5 4 3 2 1 11 12 13 14 15 16Type of r egist er operation or test
(b) Register- reference instruction
Code 0 111
10 98 76 5 4 3 2 1 11 12 13 14 15 16Type of input-output operation or t est
(c) Input/output instruction
Figure 11.3 Instruction formats
Computer Design  413 
from memory is not needed; therefore, the 12 least significant bits are used to specify the opera-
tion or test to be executed. A register-reference instruction is recognized by the code 0110 in the operation part. Similarly, an input-output instruction does not need a reference to memory and is 
recognized by the operation code 0111. The remaining 12 bits are used to specify the particular device and the type of operation or test performed.
Only four bits of the instruction are available for the operation code. It would seem, then, 
that the computer is restricted to a maximum of 16 distinct operations. However, since register-reference and input-output instructions use the remaining 12 bits as part of the operation-code, the total number of instructions can exceed 16. In fact, the total number of instructions chosen for the computer is 22.
Of the 16 distinct operations that can be formulated with four bits, only eight have been 
utilized by the computer because the leftmost bit of all instructions (bit 16) is always a 0. This leaves open the possibility of adding new instructions and extending the computer capabilities if desired.
The six memory-reference instructions for the computer are listed in Table 11-2. The sym-
bolic designation is a three-letter word and represents an abbreviation intended for use by pro-grammers and users when writing symbolic programs for the computer. The hexadecimal code listed is an equivalent hexadecimal number of the binary code adopted for the operation-code. A memory-reference instruction uses one hexadecimal digit (4 bits) for the operation-code; the remaining three hexadecimal digits (12 bits) of the instruction represent an address designated by die letter m. Each instruction has a brief word description and is specified more precisely in 
the function column with a-macrooperation statement. A further clarification of each instruction is given below, together with an explanation of its use.
11.3.1 AND to A
This is a logic operation that performs the AND operation on corresponding pairs of bits in A, with the memory word M specified by the address part of the instruction. The result of the opera-
tion is left in register A, replacing its previous contents. Any computer must have a basic set of 
logic operations for manipulating nonnumerical data. The most common logic operations found Table 11-2 Memory-reference instructions
SymbolHexa-decimal 
code Description Function
AND 0 m* AND to A A ← A ∧ M* 
ADD 1 m Add to A A ← A + M, E ← Carry  
STO 2 m Store in A M ← A
ISZ 3 m Increment and skip if zero M ← M + l, if (M + 1 = 0) then
(PC ← PC + 1)
BSB 4 m Branch to subroutine M ← PC + 5000, PC ← m+ 1
BUN 5 m Branch unconditionally PC ← m
* m is the address part of the instruction. M is the memory word addressed by m.
414 Chapter 11
in computer instructions are AND, OR, exclusive-OR, and complement. Here we use only the 
AND and complement. The latter is included as a register-reference instruction. These two logic operations constitute a minimal set from which all other logic operations can be derived, because together the AND and the complement perform a NAND operation. In Section 4-7 we saw that this is a universal operation from which any other logic operation can be obtained.
11.3.2 ADD to A
This instruction adds the contents of the memory word M, specified by the address part of the 
instruction, to the present contents of register A. The addition is done assuming that negative 
numbers are in their 2’ s-complement form. This requires that the sign bit be added in the same way as all other bits are added. The end-carry out of the sign-bit position is transferred to the E 
flip-flop. This instruction, together with the register-reference instructions, is sufficient for writ-ing programs to implement all other arithmetic operations. Subtraction is achieved by comple-menting and incrementing the subtrahend. Multiplication is achieved by adding and shifting. The increment and shift are register-reference instructions.
The ADD instruction must be used for loading a word from memory into the A register. This 
is done by first clearing the A register with the register-reference instruction CLA (defined in 
Table 11-3). The required word is then loaded from memory by adding it to the cleared A register.
11.3.3 STORE in A
This instruction stores the contents of the A register into the memory word specified by the 
instruction address. The first three memory-reference instructions are used to manipulate data between memory words and the A register. The next three instructions are control instructions 
that cause a change in normal program sequence.
11.3.4 Increment and Skip if Zero (ISZ)
The increment-and-skip instruction is useful for address modification and for counting the num-ber of times a program loop is executed. A negative number previously stored in memory at address m is read by the ISZ instruction. This number is incremented by 1 and stored back into 
memory. If, after it is incremented, the number reaches 0, the next instruction is skipped. Thus, at the end of a program loop, one inserts an ISZ instruction followed by a branch uncondition-ally (BUN) instruction to the beginning of the program loop. If the stored number does not reach 0, the program returns to execute the loop again. If it reaches 0, the next instruction (BUN) is skipped and the program continues to execute instructions after the program loop.
11.3.5 Branch Unconditionally (BUN)
This instruction transfers control unconditionally to the instruction at the location specified by the address part m. Remember that the program counter holds the address of the next instruction 
to be read and executed. Normally, the PC is incremented to give the address of the next instruc-
tion in sequence. The programmer has the prerogative of specifying any other instruction out of sequence by using the BUN instruction. This instruction tells the computer to take the address part m and transfer it into PC. The address of the next instruction to be executed is now in PC 
and is the one which was previously the address part of the BUN instruction.
Computer Design  415 
The BUN instruction is listed with the memory-reference instructions because it needs an 
address part m. However, it does not need a reference to memory to access a memory word (des-
ignated by the symbol M), as is required by the other memory-reference instructions.
11.3.6 Branch to Subroutine (BSB)
This instruction is useful for branching to a subroutine portion of a program. When executed, the 
instruction stores the address of the next instruction in sequence which is presently held in PC 
(called the return address) into the memory word specified by the address part of the instruction. It also stores the operation code of BUN (hexadecimal 5) in the same memory location. The contents of the address part m plus 1 are transferred into PC to start executing the subroutine 
program at this location. After the subroutine is executed, control is transferred back to the call-ing program by means of a BUN instruction placed at the end of the subroutine.
The process of branching to a subroutine and the return to the calling program is demon-
strated in Fig. 11-4 by means of a specific numerical example. The calling program is now in location 32. The subroutine program starts at location 65. The BSB instruction causes a transfer to the subroutine, and the last instruction in the subroutine causes a branch back to location 33 in the calling program. The numerical example in Fig. 11-4 shows a BSB instruction in location 32 with an address part m equal to binary 64. While this instruction is being executed, PC holds 
the address of the next instruction in sequence, which is 33. The BSB instruction performs the macrooperation (see Table 11-2):
M ← PC + 5000, PC ← m + 1
The contents of PC plus hexadecimal 5000 (code for BUN) are transferred into location 64. This 
transfer produces an instruction BUN 33. The address part of the instruction is incremented and 
0100 00000 1000000
0101 000000 10000 1
0101 00000 1000000Memor yAddress
  (dec)
m = 64 BUN 33
Subr outin eBSB 64
BUN 64m + 1 = 6532
33
Figure 11.4 Demonstration of branch-to-subroutine instruction
416 Chapter 11
placed in PC. PC now holds the binary equivalent of 65, so the computer starts executing the 
subroutine at this location. The last instruction in the subroutine is BUN 64. When this instruc-tion is executed, control is transferred to the instruction in location 64. But in address 64, there is now an instruction that branches back to address 33. The address stored in location 64 by the BSB instruction will always have the proper return address no matter where the BSB instruction is located. In this way, the subroutine return is always to a location one higher than the location of the BSB instruction. Note that the address number of the BUN instruction placed at the end of the subroutine must always be equal to the address number where the return address is temporar -
ily stored, which is 64 in this case.
11.3.7 Register-reference Instructions
The 12 register-reference instructions for the computer are listed in Table 11-3. Each register-reference instruction has an operation code 0110 (hexadecimal 6) and contains a single 1 in one of the remaining 12 bits of the instruction. These instructions are specified with four hexadecimal digits which represent all 16 bits of an instruction word. The first seven instructions perform an operation on the A or E register and are self-explanatory. The next four are skip instructions 
used for program control, conditioned on certain status bits. To skip the next instruction, the PC 
is incremented by 1 once again. The first increment occurs when the present instruction is read. In this way, the next instruction read from memory is two locations up from the location of the present (skip) instruction.
The status bits for the skip instructions are the sign bit in A, which is in flip-flop A
16, and 
a zero condition for A or E. If the designated status condition is present, the next instruction in 
sequence is skipped; otherwise, the computer continues from the next instruction in sequence because PC is not incremented.
Table 11-3 Register-reference instructions
SymbolHexa-decimal 
code Description Function
CLA 6800 Clear A A ← 0
CLE 6400 Clear E E ← 0
CMA 6200 Complement A A ← A
CME 6100 Complement E E ← E
SHR 6080 Shift-rights A and E A ← shr A, A16 ← E, E ← A1
SHL 6040 Shift-left A and E A ← shl A, A1 ← E, E ← A16
INC 6020 Increment A A ← A+ 1
SPA 6010 Skip on positive A If (A16 = 0) then (PC ← PC + 1)
SNA 6008 Skip on negative A If (A16 = 1) then (PC ← PC + 1)
SZA 6004 Skip on zero A If (A = 0) then (PC ← PC + 1)
SZE 6002 Skip on zero E If (E = 0) then (PC ← PC + 1)
HLT 6001 Halt computer S ← 0
Computer Design  417 
The halt instruction is usually placed at the end of a program if one wishes to stop the com-
puter. Its execution clears the start-stop flip-flop, which prevents further operations.
11.3.8 Input-Output Instructions
The computer has four input-output instructions and they are listed In Table 11-4. These instruc-
tions have an operation code 0111 (hexadecimal 7), and each contains a 1 in only one of the remaining 12 bits of the instruction word. The input-output instructions are specified with four hexadecimal digits starting with 7.
The INP instruction transfers the input character from N to A and also clears the input 
flag in N
9. The OUT instruction transfers an 8-bit character code from A into the output register 
and also clears the output flag in U9. The two skip instructions check the corresponding status 
flags and cause a skip of the next  instruction if the flag bit is 1. The instruction that is skipped is 
normally a BUN instruction. The BUN instruction is not skipped if the flag bit is 0; this causes a branch back to the skip instruction to check the flag again. If the flag bit is 1, the BUN instruc-tion is skipped and an input or output operation is executed. Thus, the computer stays in a two-instruction loop (skip on flag and branch back to previous instruction) until the flag bit is set by the external device. The next instruction in sequence must be an input or output instruction.
11.4 Timing and Control
All operations in the computer are synchronized by the master-clock generator whose clock pulses are applied to all flip-flops in the system. In addition, a certain number of timing variables are available in the control unit to sequence the operation in the proper order. These timing vari-ables are designated t
0, t1, t2, and t3 and are shown in Fig. 11-5. The clock pulses occur once every 
microsecond (ms). Each timing variable is 1 ms long and occurs once every 4 ms. We assume that 
the triggering of flip-flops occurs during the negative edge of the clock pulses. By applying one of the timing variables to the enable input of a given register, we can control the specific clock pulse that triggers the register. The timing variables repeat continuously in such a way that t
0 
always appears after t3. Four timing variables are sufficient for the execution of any instruction in 
the computer we are considering here. In other situations, it may be necessary to employ a differ -
ent number of timing variables.
We assume that the memory access time is less than 1 ms. A memory read or write operation 
can be initiated with one of the timing variables when it goes high. The memory operation will be completed by the time the next clock pulse arrives.Table 11-4 Input-output instructions
SymbolHexadecimal 
code Description Function
SKI 7800 Skip on input flag If (N9 = 1) then (PC ← PC + 1)
INP 7400 Input to A A1 - 8 ← N1 - 8, N9 ← 0
SKO 7200 Skip on output flag If (U9 = 1) then (PC ← PC + 1)
OUT 7100 Output from A U1 - 8 ← A1 - 8, U9 ← 0
418 Chapter 11
The digital computer operates in discrete steps controlled by the timing signals. An instruc-
tion is read from memory and executed in registers by a sequence of microoperations. When the 
control receives an instruction, it generates the appropriate control functions for the required microoperations. A block diagram of the control logic is shown in Fig. 11-6. An instruction read from memory is placed in the memory buffer register B. The instruction has an operation code 
of 4 bits, designated by the symbol OP . If it is a memory-reference instruction, it has an address 
part designated by the symbol AD. The operation code is always transferred to the instruction 
register I. The operation code in I is decoded into eight outputs q
0-q7, the subscript number being 
equal to the hexadecimal code for the operation. The G register is a 2-bit counter that continu-
ously counts the clock pulses as long as start-stop flip-flop S is set. The outputs of the G register 
are decoded into the four timing variables t0-t3. The F flip-flop distinguishes between the fetch 
and execute cycles. Other status conditions are sometimes needed to determine the sequence of control. The outputs of the control logic network initiate all microoperations for the computer. The block diagram of the control logic is helpful in visualizing the control unit of the computer when the register-transfer operations are derived during the logic design process.
The control logic network is a combinational circuit consisting of a random connection of 
gates. Its implementation constitutes a hard-wired control. We shall see in Section 11-7 that the control part of the computer can also be implemented with programmable logic arrays. The PLA configuration will replace the control logic network as well as the operation and timing decoders. It will also be shown in Section 11-7 that the control can be partially implemented with a micro-program unit. The microprogram control configuration will replace the control logic network, the two decoders, and the I and G registers.t0Clock
pulses (CP)1 µsec
t2t1
t3
Figure 11 5 Computer timing signals
Computer Design  419 
11.5 Execution of Instructions
Up to this point, we have considered the system design of the computer. We have specified the 
register configuration, the set of computer instructions, a timing sequence, and the configuration of the control unit. In this section, we start with the logic design phase of the computer. The first step is to specify the microoperations, together with the control functions, needed to execute each machine instruction.
The register-transfer operations describe in concise form the process of information trans-
fer within the registers of the computer. Each statement in the description consists of a control function, followed by a colon, followed by one or more microoperations in symbolic notation. The control function is a Boolean function whose variables are the timing signals t
0-t3, the de-
coded operation q0-q7, and certain status-bit conditions. The microoperations are specified in 
accordance with the symbolic notation defined in the register-transfer method.
Once a “start” switch is activated, the computer sequence follows a basic pattern. An in-
struction whose address is in PC is read from memory. Us operation part is transferred to reg-
ister I, and PC is incremented by 1 to prepare it for the address of the next instruction. If the 
instruction is a memory-reference type, it may be necessary to access the memory again to read an operand. Thus, words read from memory into the B register can be either instructions or data. 
The F flip-flop is used to distinguish between the two. When F = 0, the word read from memory 
is interpreted to be an instruction and the computer is said to be in an instruction fetch cycle, 
When F = 1, the word read from memory is taken as an operand and the computer is said to be 
in a data execute cycle.16
t0 – t313 12 1
B(OP) B(AD) I Regist er
G Regist er Timing
decoder Control
   logicnetwork
Other status
  conditions CountSF
CPControl functions
       to  initiat e
microoperationsOperation
decoder
q0 – q7
Figure 11.6 Block diagram of control logic
420 Chapter 11
11.5.1 Fetch Cycle
An instruction is read from memory during the fetch cycle. The register-transfer relations that 
specify this process are:
F’t0:  MAR ← PC
F’t1:  B ← M, PC ← PC +1
F’t2:  I ← B (OP)
When F = 0, liming signals t0, t1, and t2 initiate a sequence of operations that transfer the contents 
of PC into MAR, initiate a memory read, increment PC, and transfer the operation code of the 
instruction to the I register. All microoperations are executed when the control function is logic 1 and when a clock pulse occurs. The microoperations in registers and the transfer of the memory word into B are executed during the negative edge of a clock pulse. This occurs just prior to the 
time that the specified timing variable goes to 0.
The operation code in the I register is decoded at time t
3. The next step depends on the 
value of qi, i = 0, 1,...,7, that produces a 1 in the output of the decoder. If the decoded output is a 
memory-reference instruction, an operand may be needed. If not, the instruction can be executed during time t
3.
The BUN instruction and the register-reference and input-output instructions do not need a 
second access to memory. When an operation code 0, 1, 2, 3, or 4 is encountered, the computer has to go to an execute cycle to access the memory again. This condition is detected from the operation decoder which causes a transfer to the execute cycle by selling F to 1:
F’(q
0 + q1 + q2 + q3 + q4) t3: F ← 1
The register-transfer operations common to all instructions during the fetch cycle are listed in Table 11-5.
The BUN instruction has an operation code 5, and its corresponding output from the op-
eration decoder is q
5. This instruction does not need an operand from memory, even though 
it is listed as a memory-reference instruction. It merely specifies that the next instruction be taken from a location given by the address part m. The address part of the instruction is in 
B(AD) at time t
3 of the fetch cycle. The instruction can be executed during the fetch cycle at this  
time:
q5t3: PC ← B(AD)
There is no need to include F in the control function because the only time that q5 can be 1 is 
during the fetch cycle. The microoperation that executes the instruction specifies a transfer of bits 1 through 12 of register B into the PC. The next timing variable after t
3 is always t0. Since F 
remains 0 for this instruction, the computer returns to the beginning of the fetch cycle to read the instruction given by PC.
The register-reference instructions are recognized from the decoder output q
6, and the in-
put-output instructions from q7. Since these instructions require only one more microoperation 
for their execution, they can be terminated at time t3 during the fetch cycle. This fact is indicated 
in Table 11-5. The specific microoperations are listed in later tables.
Computer Design  421 
11.5.2 Execute Cycle
Flip-flop F is equal to 1 during the execute cycle. The four timing variables that occur during this 
cycle perform the microoperations for executing one of the memory-reference instructions. The 
instruction to be executed is specified by variable qi, i = 0, 1,2, 3, 4, available from the operation 
decoder. At the end of the fetch cycle, the address part of the instruction is in bits 1 through 12 of register B, symbolized by B(AD). This address is transferred to MAR at the beginning of the 
execute cycle to serve as the memory address for the subsequent memory word:
Ft
0: MAR ← B(AD)
The instructions that need an operand from memory are the AND (q0) ADD (q1), and ISZ (q3). 
The other two instructions, STO (q2) and BSB (q4), store a value into memory and are excluded 
during the next memory read operation:
F(q0 + q1 + q3)t1: B ← M
The particular decoded instruction is executed with timing variables t2 and t3. At time t3, the F 
flip-flop is cleared for the computer to return to the fetch cycle:
Ft3: F ← 0
The next timing variable after t3 is t0. But now F is equal to 0, so the next control function is F¢t0. 
This is the first control function in the fetch cycle. Thus, after executing the current instruction, control always returns to the fetch cycle to read the next instruction whose address is in PC. The 
common operations performed during the execute cycle are listed in Table 11-6.Table 11-5 Register-transfer operations during fetch cycle
F¢t0: MAR ← PC Transfer instruction address
F¢t1: B ← M, PC ← PC + 1 Read instruction, increment PC
F’t2: I ← B(OP) Transfer operation code
F¢(q0 + q1 + q2 + q3 + q4) t3: F ← 1 Go to execute cycle
q5t3: PC ← B(AD) Branch unconditionally (BUN)
Q6t3: See Table 11-8 Register-reference instruction
Q7t3: See Table 11-9 Input-output instruction
Table 11-6 Common operations for execute cycle
Ft0: MAR ← B(AD) Transfer address part
F(q0 + q1 + q3)t1: B ← M Read operand
F(t2 + t3): See Table 11-7 Execute memory-reference instruction
Ft3: F ← 0 Return to fetch cycle
422 Chapter 11
The five memory-reference instructions and their corresponding register-transfer opera-
tions are listed in Table 11-7. These instructions are executed when F = 1 and with timing vari-
ables t2 and t3 The decoded operation qi determines the particular instruction that is executed.
The AND and ADD instructions are executed with timing variable t3, although they 
could use timing variable t2 instead. The operand from memory has been transferred to B with 
timing variable t1. The corresponding operation can be performed now between the B and A  
registers.
The STO instruction specifies a transfer of the contents of A into the memory word whose 
address was transferred to MAR with timing variable t0. The contents of A are first transferred 
into B, and a write operation transfers the contents of B into the memory word specified by MAR:
Fq2t2: B ← A
Fq2t3: M ← B
The ISZ instruction is executed with the following microoperations:
Fq3t2: B ← B + 1
Fq3t3: M ← B
Fq3Bzt3: PC ← PC + 1  Bz = 1 if B = 0
The word from location M was placed in B during time t1 (see Table 11-6). The B register is 
incremented at time t2 and the new value is stored back in memory. All this time MAR does not 
change, so it always specifies the address of M. Remember that a memory word cannot be incre-
mented while residing in memory. It must be transferred to a processor register where the count-
ing can be implemented. While the incremented number is being stored in memory, its value in B is checked; if it is 0, PC is incremented to cause a skip of one instruction. Variable B
z used in 
the last statement above is a zero-detect variable and is equal to binary 1 if register B contains 
an all-0’ s number.Table 11-7 Execution of memory-reference instructions
AND Fq0t3: A ← A L B AND microoperation
ADD Fq1t3: A ← A L B, E ← carry Add microoperation
STO Fq2t2: B ← A Transfer A to B
Fq2t3: M ← B Store in memory
ISZ Fq3t2: B ← B + 1 Increment memory word
Fq3t3: M ← B Store back in memory
Fq3Bzt3: PC ← PC + 1 Skip if Bz = 1 (B = 0)
BSB Fq4t2: B(AD) ← PC, B(OP) ← 0101, 
PC ← MARTransfer return address, trans-fer address to PC
Fq
4t3: M ← B, PC ← PC + 1 Store return address, increment address in PC
Computer Design  423 
The BSB instruction is the most complicated instruction available in the computer. A pos-
sible way to execute this instruction is as follows:
Fq4t2: B(AD) ← PC, B(OP) ← 0101, PC ← MAR
Fq4t3: M ← B, PC ← PC + 1
The return address available in PC is transferred to the address part of register B and the code 
0101 (BUN) is transferred to the operation-code part of the same register. Remember that the 
address register MAR contains the address part of the instruction designated by m. The transfer 
from MAR to PC results in transferring m into PC. All this is done during timing variable t2. The 
return address is stored in memory at time t3. PC is also incremented at this time, so the instruc-
tion to be read during the next fetch cycle will be from location m + 1.
11.5.3 Register-reference Instructions
The register microoperations that execute the register-reference instructions are listed in Table 11-8. These instructions are recognized from operation decoder output q
6 and are executed dur -
ing time t3 of the fetch cycle. For convenience, we define a new variable r = q6t3 and use it in all 
register-reference control functions. The rest of the control function is determined from one of the bits in the B register, where the rest of the instruction resides at this time. For example, the 
instruction CLA has the hexadecimal code 6800, which corresponds to a binary code 0110 1000 0000 0000. The operation code is decoded from the I register and is equal to q
6. Bit 12 in the B 
register is 1; so the control function that executes this instruction is q6t3B12 = rB12.
The first seven register-reference instructions perform the clear, complement, shift, and 
increment operations on the A or E register. The next four instructions are skip instructions 
executed only if the stated condition is satisfied. The skipping of the instruction is achieved by incrementing PC again, in addition to the incrementing at time t
1 (see Table 11-5). The status-bit 
condition for skipping becomes part of the control function. Thus the accumulator is positive if 
Table 11-8 Execution of register-reference instructions
r = q6t3
CLA rB12: A ← 0 Clear A
CLE rB11: E ← 0 Clear E
CMA rB10: A ← A Complement A
CME rB9: E ← E Complement E
SHR rB8: A ← shr A, A16 ← E, E ← A1Shift-right A and E
SHL rB7: A ← shl A, A1 ← E, E ← A16Shift-left A and E
INC rB6: A ← A+ 1 Increment A
SPA rB5A¢16: PC ← PC + 1 Increment PC if A is positive
SNA rB4A16: PC ← PC + 1 Increment PC if A is negative
SZA rB3Az: PC ← PC + 1 Increment PC if A is zero
SZE rB2E¢: PC ← PC + 1 Increment PC if E is zero
HLT rB1: S ← 0 Gear start-stop flip-flop
424 Chapter 11
A16 = 0 and negative if A16 = 1. The symbol A: is a binary variable equal to I when the A register 
contains all 0’ s. E’ is equal to 1 when the E flip-flop contains 0.
The halt instruction clears the start-stop flip-flop S and stops the timing sequence. The 
sequence register G stops counting while its value is 0. This causes the computer to idle, with t0 
always being at the output of the timing decoder. Since F is also 0, the control function F¢t0 is the 
only one produced while the computer is halted. This control function transfers the contents of 
PC to MAR continuously (see Table 11-5). We could tolerate this continuous transfer when the 
computer halts. If this is undesirable, we can remove the clock pulses from MAR as well to pre-
vent this transfer from occurring when S = 0. The computer can resume when the “start” switch is activated, which sets flip-flop S. This causes die clock pulses to reach the sequence register G 
and start producing the other timing variables.
11.5.4 Input-Output Instructions
The register-transfer microoperations that execute the four input-output instructions are listed in Table 11-9. These instructions are recognized from operation-decoder output q
7 and are executed 
during time t3. We define a new variable p = q7t3 and use it in all input-output control functions. 
The control functions for these instructions contain a single bit from the B register which is part 
of the instruction-code definition. The two skip instructions depend on the status condition of flag bits N
9 and U9.
11.6 Design of Computer Registers
The design of a synchronous digital system follows a prescribed procedure. From a knowledge of the system requirements, one formulates a control network and obtains a list of register-transfer operations for the system. Once this list is derived, the rest of the design is straightforward. Some installations utilize computer design automation techniques for translating the register-transfer statements to a circuit diagram composed of integrated circuits.
Section 11-5 specified the register-transfer statements for the computer in five separate 
tables. The entries in the tables consist of control functions and microoperations. The list of control functions provides the Boolean functions for the gates in the control logic network. The list of microoperations gives an indication of the types of registers that must be chosen for the computer. Although these tables are sufficient to complete the logic design of the system, it may be convenient to rearrange the information in the tables in a more convenient way during the actual implementation .process.Table 11-9 Execution of input-output instructions
p = q7t3
SKI pB12N9: PC ← PC + 1 Increment PC if input flag N9 = 1
INP pB11: A1 - 8 ← N1 - 8, N9 ← 0 Input to A, clear flag
SKO pB10U9: PC ← PC + 1 Increment PC if output flag U9 = 1
OUT pB9: U1 - 8 ← A1 - 8, U9 ← 0 Output from A, clear flag
Computer Design  425 
11.6.1 Register Operations
To determine the type of control input that must be provided in each register, we must obtain 
the list of microoperations that affect each register separately. This can be done by scanning the tables in Section 11-5 and retrieving all those statements that change the contents of a particular register. This also applies to the read and write operations in the memory unit. For example, a memory-read operation is symbolized with the microoperation:
B ← M
The statement also indicates that the contents of register B will change in value. This statement 
is found twice in the list of microoperations. In Table 11-5, we find it with control function F¢t
1, 
and in Table 11-6, with control function F(q0 + q1 + q3)t1. Since both control functions produce 
the same operation, they can be combined with an OR into one statement:
R = F¢t1 + F(q0 + q1 + q3)t1 : B ← M
The symbol R is used for convenience to designate the read operation with a single Boolean 
control variable. The equal sign after R designates its equality with the control function listed.
This procedure is repeated for the memory-write operation and for all the registers in the 
computer. The result is as shown in Table 11-10. Each control function listed in the table is as-signed a control-variable name. The single-letter variable names are not necessary, but they help shorten the algebraic expressions of input control for the registers. In most cases, the control variable is assigned a lowercase letter identical to the capital letter reserved to symbolize the corresponding register. The control variables common to the same register are distinguished by different numerical subscripts.
Table 11-10 is derived directly from Tables 11-5 through 11-9. The register to which a mi-
crooperation belongs is recognized by the presence of its symbol on the left side of the arrow. To recognize the microoperations belonging to register A, we scan the operations listed in Tables 11-5 through 11-9 and retrieve all those that have an A as a destination register. The microopera-
tions for the other registers are obtained in a similar manner. If the microoperation occurs more than once, the corresponding control functions are ORed to form a composite control function.
The operations for the E flip-flop must be separated from the operations for the A register, 
even though they were listed together in the previous tables. The circular shift-right operation, for example, is stated in Table 11-8 as:
rB
8: A ← shr A, A16 ← E, E ← A1
Note that r is a variable equal to q6t3, and rB8 is assigned a control variable a5. In Table 11-10 
under the A register, we have;
a5 = rB8: A ← shr A, A16 ← E
which is the part of the shift operation that changes the contents of A, Under the E flip-flop, we 
have:
a5 = rB8: E ← A1
426 Chapter 11
Table 11-10 Microoperations for registers
Memory Control
R = F’t1 + F(q0 + q1 + q3)t1 : B ← M Memory read
W = F(q2 + q3 + q4)t3 : M ← B Memory write
A Register
a1 = Fq0t3 : A ← A L B AND
a2 = Fq1t3 : A ← A + B Add
a3 = rB12 : A ← 0 Clear
a4 = rB10 : A ← A Complement
a5 = rB8 : A ← shr A, A16 ← E Shift-right
a6 = rB7 : A ← shl A, A1 ← E Shift-left
a7 = rB6 : A ← A + 1 increment
a8 = pB11 : A1 - 8 ← N1 - 8Transfer
B Registerb
1 = Fq2t2 : B ← A Transfer
b2 = Fq3t2 : B ← B + 1 Increment
b3 = Fq4t2 : B(AD) ← PC, B(OP) ← 0101 Transfer
PC Register
c1 = F’t1 :
+ (q4Bz + q4)Ft3
+ (B5A’16 + B4A16
+ B3Az + B2E’)r
+ (B12N9 + B10U9)p: PC ← PC + 1 Increment
c2 = q5t3 : PC ← B(AD) Transfer
b3 = Fq4t2 : PC ← MAR Transfer
MAR Registerd
1 = F’t0 : MAR ← PC Transfer
d1 =F’t0 : MAR ← B(AD) Transfer
I Registeri
1 = F’t2 : I ← B(OP) Transfer
E Flip-Flope
1 = rB11 : E ← 0 Clear
e2 = rB9 :E ← EComplement
a2 = Fq1t3 : E ← carry Transfer
a5 = rB8 : E ← A1Shift-right
Computer Design  427 
which shows the part of the shift operation that changes the E flip-flop. Thus, the shift-right con-
trol variable a5 shifts the contents of A to the right and inserts the value of E into the leftmost bit 
of A. It also transfers the rightmost bit of A into E. 
The sequence register G does not have any listed microoperations in the previous tables. 
This register is shown in Fig. 11-6 to be a counter whose clock pulses are enabled by the start-
stop flip-flop S. This is included in Table 11-10 with the statement:
S: G ← G + 1
11.6.2 Design of Computer
The list of microoperations given in Table 11-10 provides the information needed to design the registers of the computer. The operations to be performed on each register are clearly demon-strated by the listed statements. For example, program counter PC has three microoperations:
c
1: PC ← PC + 1
c2: PC ← B(AD)
b3: PC ← MAR
This register must have increment and transfer capabilities. It can be implemented by means of a counter with parallel load of the type shown in Fig. 7-19. Since PC receives input information 
from two sources, it requires a multiplexer to select between the two inputs, as explained in con-junction with Fig. 8-3. The other registers are designed in a similar manner.
A block diagram showing the types of registers needed for the computer is given in Fig. 
11-7. The memory unit is also included to show its connection to the processor. The control logic a6 = rB7 : E ← A16Shift-left
F Flip-Flop
f1 ← F ¢(q0 + q1 + q2
+ q3 + q4)t3 : F ← 1 Set
f2 ← Ft3: F ← 0 Clear
S Flip-flop
s1 = rB1 : S ← 0 Clear
G Register
S: G ← G  + 1 Count
U Register
u1 = pB9 : U1 - 8 ← A1 - 8, U9 ← 0 Transfer
N Registera
8 = pB11 : N9 ← 0 Clear
428 Chapter 11
provides all the control variables for the registers. The design of the control logic is discussed 
in the next section. The control variables that are generated in the control unit are applied to the registers as indicated in the diagram. In addition to the registers, the processor uses four multi-plexers to select from two or more sources. All the registers and multiplexers are MSI functions available in standard integrated circuits. The three flip-flops, E, F, and S, and their corresponding combinational logic must be designed with SSI gates and flip-flops.
All of the registers in the computer, except register A, require a load, increment, or both 
load and increment control inputs. One can choose to employ an MSI counter with parallel load for all registers. In this manner, it would be possible to have an inventory of just one standard type of IC component for the registers. A possible commercial component is IC type 74161. i1
f1
f2
s1
u1e1 – a6
a1 – a8a8b2b1
b3s1
s0s
c1
d1d2c2
b30 1
MUX
MARs0 1
MUX01
MUX
s0 1
MUX2
F
E
SPC
G Regist er U Regist er N Regist erA Re gisterI Regist erB Regist erAddress
Load
IncLoad
Inc
Load
Load
Load
CountW
RB1–12
B1–12
B13 –16B1–16
Memor y
    unit
Control logic
      and
  decoder sControl outputs
Figure 11.7 Detailed block diagram for computer
Computer Design  429 
This MSI circuit contains a 4-bit counter with parallel load and an asynchronous clear input. The 
clear inputs of the registers can be connected to a master reset switch in the computer to clear all registers asynchronously prior to the clocked operations. The 12-bit registers, PC and MAR, will 
need three such ICs, and the 16-bit register, B, will require four ICs. The I and G registers can be 
implemented with one IC each. The 4-bit counter, IC, can be converted to a 2-bit counter for G by the method outlined in Section 7-5, in conjunction with Fig. 7-20.
The A register is the most complicated register because it performs all the processing tasks 
for the computer. This register is an accumulator register of the type designed in Section 9-10 and can use the configuration shown in Fig. 9-22. It can also be implemented with a bidirectional shift register with parallel load, as shown in Fig, 7-9, together with an ALU of the type discussed in Section 9-6. A better choice would be to use an accumulator MSI circuit such as type 74S281 IC. When implemented with an ALU or accumulator IC, the control unit must generate the cor -
responding control variables to select the required microoperations in the ALU. These will be different from the single control functions defined for the control unit in this design.
Input register N and output register U can be part of a standard teletypewriter interface. 
Integrated circuits that interface with a teletypewriter unit are available commercially and are usually called universal asynchronous receiver- transmitters (abbreviated UART). Such an IC includes an input register and an output register within the unit, together with the two flags requi-red for synchronizing the transfer.
Three of the multiplexers in Fig. 11-7 select between two input sources. When the select 
input marked with an s is 1, MUX input number 1 is selected. When s = 0, MUX input num-
ber 0 is selected. The multiplexer associated with register B has three input sources. Selection 
variables s
1 and s0 determine the selected input. When both selection lines are 0, the selected 
input comes from PC. The memory-read signal R makes s0 = 1 while s1 remains 0 (because b1 
= 0 when R = 1). With s1s0 = 01, MUX input number 1 is selected and this input comes from 
the memory unit. Similarly, control variable b1 produces a selection s1s0 = 10, which causes the 
contents of register A to be selected.
The entire computer shown in Fig. 11-7 can be enclosed within a single IC package to 
form a microcomputer. A typical microcomputer IC normally has added features in the proces-
sor section, but includes a smaller memory. Most of the memory in a microcomputer is usually of the ROM type. The internal design of a microcomputer chip requires that the logic of the computer be defined with a set of Boolean functions that specify all gates and flip-flops in the system. The Boolean functions that implement each register in the system can be derived by the method presented in Section 9-10 for the design of registers in terms of Boolean functions.
11.7 Design of Control
The control unit of the computer generates the control variables for the registers and memory unit. There are 24 distinct control variables and all of them are listed in Table 11-10 as control functions. In Chapter 10, we presented three methods for control logic design: hard-wired con-trol, PLA control, and microprogram control. The control unit of the computer can be designed using any one of these three methods.
11.7.1 Hard-wired Control
The control organization presented in Fig. 11-6 is essentially a hard-wired organization of the se-quence register and decoder method. Sequence register G in this case is a counter, and the timing 
430 Chapter 11
decoder provides four control states for the system. A second decoder is used for the operation 
code stored in the I register. The control-logic-network block generates all the control functions for the computer.
The implementation of the control logic network in Fig. 11-6 completes the design of the 
hard-wired control. This implementation consists of combinational gates that generate the 24 control functions listed in Table 11-10. The Boolean functions listed as control functions specify the Boolean equations from which the combinational circuit can be derived. This circuit will not be drawn here but can be easily obtained from the 24 Boolean functions that define the control variables R, W, a
1, through a8, b1, b2, b3, c1, c2, d1, d2, i1, e1, e2, f1, f2, s1, and u1.
11.7.2 PLA Control
The PLA control is similar to the sequence register and decoder method, except that all combi-
national circuits are implemented within the PLA. The two decoders are included inside the PLA implementation, since they are combinational circuits. The total number of control outputs is 24. The total number of PLA inputs is also 24. A 24-input, 24-output PLA may not be available in one commercial IC package. For this reason, the control unit should be partitioned in such a way so it can be implemented with a minimum number of PLA ICs.
One way to partition the control is according to the function tables presented in Section 11-
5. The register-transfer statements in this section are listed in Tables 11-5 through 11-9. The PLA control partitioned according to these tables is shown in Fig. 11-8. This implementation replaces the hard-wired control of Fig. 11-6.
Figure 11-8 shows three PLAs and two registers for the control unit. The two decoders are 
not needed here, since they are implemented inside the PLA. Note that there are no connections from the outputs of any PLA to the inputs of sequence register G. A feedback connection is not 
necessary because the G register is a counter and the next state is predetermined from the con-
tinuous count sequence. PLA 1 implements the control variables listed in Table 11-5 (fetch cycle) and Table 11-6 (common operations for execute cycle). These control variables depend on the timing variables from G, the operation code from I, and the cycle control in F.  PLA 2 implements 
the control functions listed in Table 11-7 (execution of memory-reference instructions). These control functions have the same input variables as PLA 1, with the addition of binary variable B
z. 
Remember that Bz is a binary variable equal to I when the B register contains all 0’ s.
The third PLA generates the register-reference and input-output control functions listed in 
Tables 11-8 and 11-9. These control functions have two common variables:
r = q6t3  for the register-reference operations
p = q7t3  for the input-output operations
These two common variables are generated in PLA 1 and applied as inputs to PLA 3. The other inputs to the third PLA come from register B (bits 1-12) and other status-bit conditions.
Control variable c
1 increments the program counter. This control variable is generated in all 
three PLAs. The three outputs must be combined with an external OR gate to provide a single output. This output is applied to the increment input of PC
The derivation of the program tables for the three PLAs completes the control design. The 
PLA 1 program table can be obtained from the control functions listed in Tables 11-5 and 11-6. These functions are repeated again in Table 11-11 for convenience. Some of the functions have 
Computer Design  431 
been simplified for entry in the program table. For example, the read control variable R was 
originally listed as:
R = F′t1 + F(q0+ q1 + q3)t3
The decoded output variables q0, q1, and q3 are a function of the variables in the I register and can 
be simplified as follows;
q0+ q1 + q3 = I′3I′2I′1 + I′3I′2I1 + I′3I2I1 = I′3I1 + I′3I′2
Since the PLA accepts the I variables rather than the q variables, it is more convenient to use 
the two-term function rather than the three-term function. Control variable f1 is simplified in a f1
f2 s1
u1
a8
b2b1
b3
c1d1
d2c2
PLA 2B1Not
used
F Fc1
c1a4e1a3
a5e2
a6
a7B12
A16to
Az
E
U9
N9i3R
r
pG1G2I1I2I3
ti
G1G2
Bz BzF
G1G2I1I2I3 a1
a2
wPLA 1PLA 3I1 I2I3 I4
qi
Tables
  11-5
  11-6Tables
  11-8
  11-9
Table
  11-7
c1
Figure 11.8 PLA control for computer
432 Chapter 11
similar manner. The other Boolean variables need a translation from the t designation to a state 
in the sequence register G and from the q designation to the corresponding operation code in the 
I register.
The program table for PLA 1 is given in Table 11-12. The PLA has 6 inputs, 12 product 
terms, and 10 outputs. The entries for G2 and G1 are 00, 01, 10, and 11 and correspond to timing 
variables t0, i1, t2, and t3, respectively. The entry for I3, I2, and I1, is a binary number equal to the 
value of subscript i in qi, unless the function is simplified. Note that register I has four bits, but 
I4 is not used since it is always 0. The procedure for obtaining a PLA program table from a set of 
Boolean functions is explained in Section 5-8.Table 11-11 Control functions for PLA 1
d1 = F′t0 : MAR ← PC
c1 = F′t1 : PC ← PC + 1
R = F′t1 + F(I’3I1 + I’3I’2)t1 : B ← M
i1 = F′t2 : I ← B(OP)
f1 = F′(I’3 + I′2I′1)t3 : F ← 1
c2 = q5t3 : PC ← B(AD)
d2 = Ft0 : MAR ← B(AD)
f2 = Ft3 : F ← 0
r = q6t3 : Register reference
p = q7t3 : Input-output
Table 11-12 Program table for PLA 1
Product 
termInputs Outputs
I3I2I1F G2G1d1c1R i1f1c2d2f2rp
1 - - - 0 0 0 1 - - - - - - -- -F′t0
2 - - - 0 0 1 - 1 1 - - - - ---F′t1
3 0 - 1 1 0 1 - - 1 - - - - ---FI′3I1t1
4 0 0 - 1 1 0 - - 1 - - - - ---FI′3I′2t1
5 - - - 0 1 0 - - - 1 - - - ---F′t2
6 0 - - 0 1 1 - - - - 1-----FI′3t3
7 - 0 0 0 1 1 - - - - 1-----FI′2I′1t3
8 1 0 1- 0 1 - - - - - 1 - ---q5t3
9 - - - 1 1 0 - - - - - - 1 ---Ft0
10 - - - 1 1 1 - - - - - - - 1--Ft3
11 1 1 0- 1 1 - - - - - - - -1-q6t3
12 1 1 1- 1 1 - - - - - - - --1q7t3
Computer Design  433 
The program table for PLA 2 can be derived in a similar manner, although it is not listed 
here. The third PLA requires 12 AND terms and a 6-input OR gate (to generate control variable 
c1). This part of the control may be implemented more economically with SSI gates or with a 
field-programmable gate array (FPGA). The FPGA’ s similar to the FPLA in concept, except that it contains only programmable AND gates. A typical FPGA has 9 AND (or NAND) gates shar -
ing 16 common inputs.
† Two such FPGA integrated circuits are required to replace PLA 3 in  
Fig. 11-8. The external OR gate can be combined with the other lines that generate variable c1.
11.7.3 Microprogram Control
The organization of the control unit for the computer is more suitable for a PLA control than for a microprogram control, mostly because of the way the register-reference instructions were originally formulated. The microprogram control configuration to be developed here implements the control functions for the fetch cycle and the memory-reference instructions. The register-reference and input-output operations can be implemented more efficiently with a hard-wired or PLA control.
The microprogram control does not need the I, G, and F registers. The operation code is 
in B(OP) at the end of the fetch cycle, and this code can be used to specify a macrooperation 
address for control memory without the need for an I register. The timing variables generated in the sequence register G can be replaced by a sequence of clock pulses that read consecutive mi-
croinstructions from control memory. The transfer from the fetch cycle to the execute cycle can be done in control memory by a branch microinstruction that transfers control to the next cycle without the use of the F flip-flop. The microprogram control configuration to be developed here 
replaces the entire hard-wired control of Fig. 11-6 (except the B register).
Going over Tables 11-5, 11-6, and 11-7, we note that all microinstructions can be sequenced 
by incrementing the control memory address, except for going to execute a particular memory-reference instruction or for returning to the fetch cycle. A particular memory-reference instruc-tion routine can be accessed with an external macrooperation address. If we start the fetch cycle from address 0, it would be possible to branch to the fetch cycle by clearing the control memory address register CAR. Therefore, the address-sequencing part of the microprogram control needs 
only three operations:
1. Increment CAR to read the next microinstruction in sequence.
2. Clear CAR to start the fetch cycle.
3. Provide a bit transformation from B (OP) to an external address for CAR.
A possible microprogram control for the computer is shown in Fig. 11-9. The control memory 
ROM has 32 words of 7 bits each. The first four bits are encoded to provide 16 bit combina-tions, one for each control function. Although the computer has 24 control functions, 16 are sufficient to generate those control functions associated with the fetch cycle and the execution of the memory-reference instructions. Instead of using 16 bits of ROM to specify 16 outputs, we chose to employ only 4 bits and decode them through a 4-to-16 line decoder to provide up to 16 distinguishable output variables. This scheme saves ROM bits but requires an external decoder. 
†IC type 82S103 from Signetics.
434 Chapter 11
It also limits the capability of the microinstructions because only one control function can be 
specified in any given microinstruction.
The address-sequencing part of the microprogram unit does not require a multiplexer to se-
lect status-bit conditions. There is only one status bit to be considered and we will show later how this can be included with an external circuit. There is no need for an address field in the microin-struction because no branching capabilities are provided except to return to the beginning of the fetch cycle or to transfer an external address. The last three bits of a microinstruction determine the next address. Bit 7 increments the control address register. Bit 6 clears CAR, which causes a 
return to the fetch cycle. Bit 5 loads an external address into CAR. The input address must con-
tain 5 bits because the ROM has 32 = 2
5 words. Three of these bits come from the B-register part 
that holds the operation-code. The last two bits are always equal to 11. This is a code transforma-tion from the operation-code bits of the instruction to an external address for control memory. This transformation causes the AND instruction whose operation code is 000 to be changed into an address for CAR equal to 00011. The ADD instruction transforms from 001 to 00111; and so 
on, up to an input-output instruction whose operation code is 111 and whose address transforma-tion is 11111. The most significant bit in B(OP) is not used because it is always 0.
The microprogram control unit shown in Fig. 11-9 is very simple and requires only three 
MSI circuits. Because of its simplicity, it is not very flexible and, as shown subsequently, requires 
additional circuits for a complete control-unit implementation.
The microoperations for the fetch cycle and the execution of memory-reference instruc-
tions are listed in Tables 11-5, 11-6, and 11-7. The microoperations for the I and F registers are 
not needed, since these registers are not used. The remaining microoperations and their encoded control functions are listed in Table 11-13. The first four bits of a ROM word in control memory provide 16 combinations, and each combination specifies a microoperation. The all-0’ s and all-1’ s combinations do not initiate a microoperation. The other 14 combinations are decoded to provide control variables for the listed microoperations. Decoder output 14 initiates the memory-write operation, M ←  B, and also specifies a conditional control for incrementing PC dependent 1
1431
  4 × 16
decoderB(OP) 0
1521
32
32 × 7
 ROM
7654 CAR1
Not
used
Increment
Clear
Load input
Figure 11.9 Microprogram control unit for computer
Computer Design  435 
on variable Bz. The reason for repeating these two microoperations in one microinstruction will 
be clarified later. Note that the memory-write microoperation is also initiated with decoder out-
put 11, and the control variable that increments PC is also available from decoder output 2.
The microprogram for control memory is given in Table 11-14. This is also the truth table 
for programming the ROM. There are 32 words of ROM, and the address and content of each word are specified in the table. The table is subdivided into nine routines showing the micro-instructions that belong to the fetch cycle and the microinstructions for executing each of the computer instructions. The symbolic designation column gives the microprogram in symbolic form and the address sequencing for CAR.
The fetch cycle starts from address 0. The three consecutive microoperations in the fetch 
routine transfer the contents of PC to MAR, read the instruction into the B register, and increment 
PC, At address 2 (0010), bit 5 of the microinstruction is equal to 1. The same clock pulse that 
increments PC also performs the microoperation:
CAR ← 2
2B(OP) + 3
B(OP) contains the three bits of the operation code. These bits are shifted twice to the left (multi-
plied by 22) and binary 3 (11) is added to form an address for CAR. The address received in CAR 
transfers control to one of the routines listed in the table, and control continues to execute the specified instruction. The implementation of this code transformation is depicted in Fig. 11-9.Table 11-13 Encoding of ROM bits for microoperations
ROM bitsDecoder 
outputControl 
function Microoperation 1 2 3 4
0 0 0 0 0 - None
0 0 0 1 1 d1 MAR ← PC
0 0 1 0 2 c1 PC ← PC + 1
0 0 1 1 3 R B ← M
0 1 0 0 4 c2 PC ← B(AD)
0 1 0 1 5 d2 MAR ← B(AD)
0 1 1 0 6 r Register-reference operation
0 1 1 1 7 p Input-output operation
1 0 0 0 8 a1 A ← A L B
1 0 0 1 9 a2 A ← A + B, E ← carry
1 0 1 0 10 b1 B ← A
1 0 1 I 11 W M ← B
1 1 0 0 12 b2 B ← B + 1
1 1 0 1 13 b3 B(AD) ← PC, B(OP) ← 0101, PC ← MAR
1 1 1 0 14 W, c1 M ← B, if (Bz = 1) then (PC ← PC + 1)
1 1 1 1 15 - None
436 Chapter 11
Table 11-14 ROM truth table for microprogram control
Instruction ROM 
addressROM outputs Symbolic designation
1234567 Microoperations Next address
FETCH 00000 0001001 MAR ← PC CAR ← CAR + 1
00001 0011001 B ← M CAR ← CAR + 1
00010 0010100 PC ← PC + 1 CAR ← 22B(OP) + 3
AND 00011 0101001 MAR ← B(AD) CAR ← CAR + 1
00100 0011001 B ← M CAR ← CAR + 1
00101 1000010 A ←A L B CAR ← 0
00110 0000010 None CAR ← 0
ADD 00111 0101001 MAR ← B(AD) CAR ← CAR + 1
01000 0011001 B ← M CAR ← CAR + 1
01001 1001010 A ← A + B, E  ← carry CAR ← 0
01010 0000010 None CAR ← 0
STO 01011 0101001 MAR ← B(AD) CAR ← CAR + 1
01100 1010001 B ← A CAR ← CAR + 1
01101 1011010 M ← B CAR ← 0
01110 0000010 None CAR ← 0
ISZ 01111 0101001 MAR ← B(AD) CAR ← CAR + 1
10000 0011001 B ← M CAR ← CAR + 1
10001 1100001 B ← B + 1 CAR ← CAR + 1
10010 1110010 M ← B. if (Bz = 1) then 
(PC ← PC + 1)CAR ← 0
BSB 10011 0101001 MAR ← B(AD) CAR ← CAR + 1
10100 1101001 B(AD) ← PC, PC ← 
MARCAR ← CAR + 1
10101 1011001 M ← B CAR ← CAR + 1
10110 0010010 PC ← PC + 1 CAR ← 0
BUN 10111 0100010 PC ← B(AD) CAR ← 0
11000 0000010 None CAR ← 0
11001 0000010 None CAR ← 0
11010 0000010 None CAR ← 0
REGISTER 11011 0110010 Register operation CAR ← 0
11100 0000010 None CAR ← 0
11101 0000010 None CAR ← 0
11110 0000010 None CAR ← 0
I/O 11111 0111010 Input-output operation CAR ← 0
Computer Design  437 
This configuration assigns four words of ROM for each instruction, except for the I/O in-
struction. For example, the ISZ instruction has operation code 011. The beginning of the routine 
that executes this instruction is at address 4 × 3 + 3 = 15, which is binary 01111. The four ROM 
words for this routine are at addresses 15, 16, 17, and 18. We cannot use the word at address 19 because this address contains the first microinstruction for the BSB routine. Since there are no branching capabilities in this microprogram unit, we cannot branch to an unused ROM word; therefore, each routine must be completed with no more than four microinstructions.
The AND routine can be implemented with three microinstructions. The address of the 
instruction is transferred into MAR, the operand is read from memory into B, and the AND mi-
crooperation is performed between the A and B registers. The last microinstruction at address 5 
(00101) has bit 6 equal to 1. This causes CAR to be cleared, and control returns to address 0 to 
start the fetch cycle again. The first two microinstructions of the AND routine have bit 7 equal to 1, which causes CAR to be incremented. The last word in this routine at address 6 is not used. 
This word cannot be left empty because we must specify something for the ROM truth table. The best way to fill in this word is to specify no microoperation in bits 1 through 4 and to clear CAR 
with bit 6. In this way, if a malfunction occurs and control memory finds itself in address 6, no operation will be executed and control will return to, the fetch cycle.
The ADD and STO routines need three microinstructions. The BSB instruction uses all four 
words available for the routine. The BUN instruction needs only one microinstruction. A register-reference instruction initiates a control variable r, which must be used in conjunction with a bit in the B register to initiate one of the specified operations. The same applies to an input-output 
(I/O) instruction.
The ISZ routine needs four microoperations and a conditional operation dependent on 
the value of B
z. This imposes a problem, because there are only four ROM words available for 
this routine and the microprogram configuration has no facility for checking status-bit condi-tions. This problem can be solved by including two microoperations in one microinstruction and checking the status bit with an external AND gate. To compensate for this unorthodox configura-tion, we insert an external circuit as shown in Fig. 11-10. The ROM decoder has two outputs for a 
BZRegist er operation
Input-output operation   ROM
decoder
Other inputsHard -wired
   contro l
      or
   PL A 3
of Fig.11-8  Regist er
     and
input-output
  operationIncrement PC
if BZ = 1 WM ← B
M ← B, inc PCc1
pr2
141176
Figure 11.10 Additional circuits for microprogram control
438 Chapter 11
memory-write operation M ← B:. one in output 11 and the other in output 14. These two outputs 
are ORed externally to provide one common output. Output 14 of the decoder is enabled during 
the fourth microinstruction of the ISZ routine. This output is ANDed externally with status bit Bz 
to provide the increment-PC control function. Decoder output 2 also specifies an increment-PC. Some of the operations in the register-reference and input-output instructions specify this opera-tion as well. The three outputs must be ORed together to form a single output for incrementing PC. Variables r and p from the ROM decoder are used in conjunction with other status-bit condi-
tions to generate the remaining control variables for the computer. These control variables can be generated with an external hardwired configuration or with a PLA as indicated in the diagram.
11.8 Computer Console
Any computer has a control panel or console with switches and lamps to allow manual and visual communication between an operator and the computer. This communication is needed for start-ing the operation of the computer (bootstrapping) and for maintenance purposes. For the sake of completeness, we shall enumerate a set of useful console functions for the computer, although the circuits required to implement these functions will not be shown.
Lamps indicate to the operator the status of registers in the computer. The normal output 
of a flip-flop connected to an indicator lamp will cause the lamp to light when the flip-flop is set and to turn off when the flip-flop is cleared. The registers whose outputs are to be observed in the computer console are: A, B, PC, MAR, I, E, F and S. When a count is made of the total number 
of flip-flops involved, we find that 63 indicator lamps are needed.
A set of switches and their functions for the console may include the following:
1. Sixteen “word” switches to set manually the bits of one word.
2. A “start” switch to set the S flip-flop. The signal from this switch also clears flip-flop F , 
N
9, U9 and register G.
3. A “stop” switch to clear the S flip-flop. To ensure the completion of the current instruc-
tion, the signal from the switch is ANDed with the Boolean function (F + q5 + q6 + q7)
t3 before it is applied to clear S.
4. A “load address” switch to transfer an address to the PC register. When this switch is 
activated, the contents of 12 “word” switches are transferred to PC.
5. A “deposit” switch to manually store words into memory. When this switch is activated, the content of PC is transferred to MAR and a memory cycle is initiated. After 1 m s, the 
contents of the 16 “word” switches are transferred into the B register and PC is incre-
mented by 1.
6. A “display” switch to examine the content of a word in memory. When this switch is activated, the content of PC is transferred to MAR,  a memory cycle is initiated, and PC is 
incremented by 1. The contents of the memory word specified by the address in PC are 
in register B and can be seen in the corresponding indicator lamps.
To ensure that the computer is not running when the power is turned on, the S flip-flop must 
have a special circuit that forces it to always turn to the clear position right after the application of power to the machine.
Computer Design  439 
REFERENCES
1. Mano, M. M., Computer System Architecture. Englewood Cliffs, N.J.: Prentice-Hall, Inc., 1976.
2. Small Computer Handbook. Maynard, Mass.: Digital Equipment Corp., 1973.
3. Booth, T. H., Digital Networks and Computer Systems. New Y ork: John Wiley & Sons, Inc., 1971.
4. Hill, F . J., and G. R. Peterson, Digital Systems: Hardware Organization and Design. New Y ork: John 
Wiley & Sons, Inc., 1973.
5. Bell, C. G., J. Grason, and A. Newell, Designing Computers and Digital Systems. Maynard, Mass.: 
Digital Press, 1972.
6. Kline, R. M., Digital Computer Design. Englewood Cliffs, N.J.: Prentice-Hall, Inc., 1977.
7. Soucek, B., Minicomputers in Data Processing and Simulation. New Y ork: John Wiley & Sons, Inc., 
1972.
PROBLEMS
11-1.  Go over the instruction set of the computer designed in this chapter (Tables 11-2, 11-3, and 11-4) and 
list all those instructions that are useful for:
(a) transfers between memory and accumulator;
(b) transfers between input-output and accumulator;
(c) arithmetic manipulations;
(d) logic operations;
(e) shift operations;
(f) control decisions based on status conditions;
(g) subroutine branch and return.
11-2.  (a) List the sequence of instructions for the computer to perform an arithmetic right-shift of a num-
ber stored in the accumulator. The number is in sign-2’ s-complement representation, (b) Repeat for an arithmetic left-shift. Indicate how an overflow can be detected.
11-3.  Show that the list of instructions obtained in problem 11-1(d) constitutes a sufficient set for imple-menting all 16 logic operations listed in Table 2-6.
11-4.  (a) Write a sequence of three instructions to be stored in memory locations 1, 2, and 3. They should check if a character is available in the input device and, if so, transfer it to the accumulator, (b) Write 
a sequence of three instructions to be stored in memory locations 5, 6, and 7. They should check if 
the output device is empty and, if so, transfer a character from the accumulator.
11-5.  The computer described in this chapter does not have an overflow indication after two signed num-bers are added. Assume that the two numbers added with the ADD instruction are in sign-2’ s-com-plement representation. Derive an algorithm in flowchart form for a computer program that will add the two numbers and detect an overflow.
11-6.  The following program is a list of instructions in hexadecimal code. The computer executes the ins-tructions starting from hexadecimal location 100.
(a) Write the program in symbolic form. Note that the last two values are operands.
(b) Determine the contents of register A when the computer halts, and explain what the program 
accomplishes.
440 Chapter 11
Location Instruction
100 6800
101 1106
102 6200
103 6020
104 1107
105 6001
106 0063
107 0074
11-7.  An instruction in address (021)16 in the computer has the operation-code of the AND instruction and 
an address part (983)16. The memory word at address (083)16 contains the number (B8F2)16. Register 
A contains (A937)16. Tabulate the contents of registers PC, MAR, B, A, and I, after the instruction is 
executed. Repeat the problem five more times, each time starting with the operation-code of another 
memory-reference instruction.
11-8. The memory access time for the computer was assumed to be less than 1 ms, so a memory read or write operation can be terminated during a clock pulse interval. Now assume that the memory has an access time of 2 ms. How many microseconds would it take to execute the ISZ instruction, including 
the time to fetch the instruction from memory?
11-9. The ADD instruction assumes that the numbers are either unsigned or in sign-2’ s-complement form, 
since all 16 bits of the numbers are added. It is required to change the hardware execution of this 
instruction (hexadecimal code 1) so that it will add numbers in sign-1’ s complement representation
(a) Modify the register-transfer statements for the ADD instruction in Table 11-7.
(b) Can the modified instruction be used to add two unsigned binary numbers?
(c) What is the circuit that is now needed to detect the zero content of register A for the SZA ins-
truction?
11-10. The computer designed in this chapter does not use the hexadecimal operation codes 8 to F , even 
though the instruction has four bits for the operation pan. We now add the following instructions to the computer. List the register-transfer statements that must be added to Tables 11-5, 11-6, and 11-7 for the execution of these new instructions.
Symbol Hexadecimal code Description Function
ORA 8 m OR to A A ← A ∨ M
XRA 9 m Exclusive-OR to A A ← A ⊕ M
SWP A m Swap A with memory A ← M, M ← A
SUB B m Subtract A from memory A ← M - A
BSA C m Branch and save address in A A ← PC, PC ← m
BPA D m Branch on positive A If (A > 0) then (PC ← m)
BNA E m Branch on negative A If (A < 0) then (PC ← m)
BZA F m Branch on zero A If (A = 0) then (PC ← m)
11-11. The computer designed in this chapter uses an F flip-flop to distinguish between the fetch and exe-
cute cycles. This flip-flop is not needed if the sequence register G is a 3-bit counter and its decoder supplies eight timing signals, t
0 through t7. The G register can be cleared as soon as the execution 
Computer Design  441 
of the instruction is completed. (This is the way the control was designed in the simple computer of 
Section 8-12.)
(a) Revise Tables 11-5, 11-6, and 11-7 to conform with this new control scheme.
(b) Determine the time of execution of each instruction, including the time to fetch the instruction.
11-12. List the register-transfer statements for the execution of the instructions listed below. Assume that 
the computer does not have an F flip-flop, but that the sequence register G has 16 timing variables, 
t0 through t15. The G register must be cleared when the execution of the instruction is completed. The 
fetch cycle for the computer now is:
t0:  PC ← MAR
t1:  B ← M, PC ← PC + 1
t2:  I ← B(OP)
 Each of the following instructions starts the execute cycle from timing variable t3. The last statement 
must include the microoperation G ← 0.
Symbol Hexadecimal code Description Function
SBA 8 m Subtract from A A ← A - M
ADM 9 m Add to memory M ← A + M (A does not change)
BEA A m Branch if A equal If (A = M) then (PC ← m)
(A does not change)
11-13. Compare the register-transfer statements for the A register listed in Table 11-10 with the accumulator 
designed in Section 9-10. Design one typical stage of the A register for the computer using the pro-
cedure outlined in Section 9-10. Include the circuit for the zero-detection variable Az.
11-14. Draw the logic gates that generate control functions a1 through as for register A (Table 11-10).
11-15. One way to simplify a circuit when using the register-transfer method is to use common paths while 
developing the list of statements. To illustrate with a particular example, consider the multiplexer for the input to PC in Fig. 11-7. This multiplexer will not be needed if we can replace the statement:
Fq4t2: PC ← MAR
 by the statement.
Fq4t2: PC ← B(AD)
 in the BSB instruction of Table 11-7. Explain why this can be done and how it results in the removal of the multiplexer from the block diagram of the computer.
11-16. Design the G register of the computer using a 4-bit counter with parallel load of the type shown in 
Fig. 7-19.
11-17. List the program table for PLA 2 of Fig. 11-8.
11-18. Change the AND instruction of the computer to an OR instruction and modify the microprogram of Table 11-14 accordingly. Assign the OR microoperation to decoder output 15 in Table 11-13.
11-19. Change the BSB instruction of the computer to the BSA instruction defined in problem 11-12. Modify the microprogram of Table 11-14 to conform with this change. The encoding of ROM bits in 
Table 11-13 may also need a change.
442 Chapter 11
11-20. Design a microprogram control unit for a computer that implements the fetch cycle and the exe-
cution of the memory-reference instructions listed in Table 11-2 and problem 11-12. Include two outputs for register-reference and input-output operations.
11-21. Write short notes on
(a) Program counter.
(b) Instruction register.
(c) Sequence register.
(d) Computer console.
11-22. Differentiate between 
(a) Fetch Cycle & Execute Cycle.
(b) Register-reference instructions & Input-output instructions.
11-23. Register A contains (A848)
16 and the value of E is 0. Tabulate the contents of register E, A, B, and 
PC after the execution of the CLA instruction. Repeat the problem 13 more times, each time staring 
from another one of the register reference instructions. The initial value of PC is (023)16.
11-24. List the sequence of instructions for the  computer that will 
(a) Reset flip-flip E
(b) Set flip-flip F .
(c) Set flip-flip S.
11-25. Starting from the register-transfer statement given in Table 11-10 for the F flip-flop, derive the input 
Boolean functions for F . Use T flip-flip.
11-26. An 8-bit counter with parallel load is enclosed in one IC package. How many ICs are needed to construct the following computer registers: PC, MAR, B, I and G.? 
12Chapter
Microcomputer System Design12.1 Introduction
A digital system is defined by the registers it contains and the operations performed on the binary 
information stored in the registers. Once a digital system is specified, the role of the designer is to develop the hardware that implements the required sequence of operations. The number of distinct microoperations in a given system is finite. The complexity of the design is in sequenc-ing the operations to achieve the intended data processing task. This involves the formulation of control functions or the development of a microprogram. A third alternative is to use a micro-computer to implement the digital system. With a microcomputer, the sequence of operations can be formulated with a set of instructions that constitutes a program.
A digital system can be constructed by means of MSI circuits such as registers, decoders, 
ALU, memory, and multiplexers. Such a custom-made system has the advantage that it can be tailored to the needs of the particular application. However, a digital system constructed with MSI circuits would require a large number of IC packages. Moreover, any modifications that may be required after the system has been constructed must be accomplished by means of wiring changes among the components.
Some digital systems are suitable for LSI design with components such as processor unit, 
microprogram sequencer, and memory unit. These systems can be microprogrammed to fit the required specifications. The microprogram method operates at the register-transfer level and must specify each microoperation in the system. The microprogram LSI organization uses fewer ICs than the MSI implementation.
The number of IC packages can be further reduced if the digital system is suitable for con-
struction with microcomputer LSI components. These components can be classified by function as follows:
1. A microprocessor, which is a central processor unit (CPU) enclosed in one LSI package.
2. Random-access memory (RAM) and read-only memory (ROM) chips that can be com-bined to form any memory size needed for an application.
3. Programmable interface units whose function is to interface between the CPU or mem-ory and a wide variety of input and output devices.
The user can interconnect these LSI components to form a microcomputer system that fits the design requirements and thus reduce drastically the number of IC packages.
444 Chapter 12
A microprocessor combined with memory and interface modules is called a microcom-
puter. The word micro is used to indicate the small physical size of the components involved. 
The second part of the word in microprocessor and microcomputer is what really sets them apart. 
Processor is used to indicate that section of the system which performs the basic functions to 
execute instructions and to process data as specified by a program. This part is usually called the 
CPU. The term microcomputer is used to indicate a small-size computer system consisting of 
the three basic units: CPU, memory, and input-output interface. The microprocessor is usually enclosed in one IC package called a microprocessor chip. A microcomputer in most cases refers 
to an interconnection of LSI components. On the other hand, some microprocessor chips include within the package not only the CPU, but also a portion of the memory as well. Such an LSI component is sometimes called a one-chip microcomputer.
A microcomputer can be used as a low-cost, general-purpose computer to provide process-
ing capabilities similar to those of any other computer system. Although this is an important application, it is not the one we want to emphasize. In many applications, the microcomputer is used as a special-purpose digital system to provide the register-transfer operations for the system. This has the advantage that a few LSI packages replace the large number of MSI cir -
cuits that would be otherwise needed to generate these operations. Another advantage is that the register-transfer operations for the system can now be specified with a program. The program for a special-purpose application is unalterable, and for this reason it can be stored in a read-only memory. Once a fixed program resides in ROM, there is no behavioral difference between a microcomputer-controlled digital system and a custom hardware design.
The most important feature of the microcomputer is that a special-purpose digital sys-
tem having a dedicated application can be designed by writing a program for a general-purpose digital computer. The execution of the fixed, unalterable program causes the microcomputer to behave in a prescribed manner, just as a corresponding MSI-based digital system would behave. This method of digital design was not economically feasible to implement before the develop-ment of small, inexpensive microcomputer components.
The program stored in the ROM part of a microcomputer system is a computer program that 
needs no alterations. Since RAM is a volatile memory, turning power off and on again destroys the binary information stored in it. The ROM is a nonvolatile memory and the program stored in it is available every time power is turned on. A special-purpose digital system constructed with a microcomputer starts operating as soon as power is supplied since its program resides in ROM. For this reason, the ROM part of a microcomputer system is also called the program memory.
At this point we should distinguish between a microprogram and a microcomputer. Al-
though both use the prefix micro, the former is derived from the concept of microoperations, 
whereas the latter refers to the small size of the components. Both use a ROM to store a program that specifies the operations in the system. A microprogram stored in control memory imple-ments the control unit in the CPU. The instructions stored in a microcomputer may be considered as macrooperations for the CPU rather than microinstructions for processor registers. Further -
more, the word microprogram refers to the way the control unit is implemented. A microcom-puter is a small-size computer whose CPU may or may not have a microprogram control unit.
The low-cost, small-size microcomputer has changed the direction of digital logic design, 
Instead of realizing a set of register-transfer operations by control functions or a microprogram, logic functions are realized by specifying a set of instructions which are stored in ROM and ex-ecuted in the microprocessor CPU. This method of design may be classified as a programmable logic method since the sequential operations are specified with a program stored in memory.
Microcomputer System Design  445 
The microprocessor is a central component in a microcomputer system. The amount and 
type of memory in the system, as well as the nature of the I/O interface units that are used, are a 
function of the particular application. The fixed program that resides in the ROM of a particular microcomputer system is also dependent on the specific application.
The design of a microcomputer system may be divided into two parts: hardware design and 
software design. The hardware design considers the interconnection of the physical components to provide a complete digital system. The software design is concerned with the development of the programs for a particular application. Writing programs for a microcomputer is essentially the same as writing programs for any other computer. The only difference is that a microcomputer programmer must be familiar with the hardware configuration and must take into consideration the problems associated with the particular application. Writing programs for an established general-purpose computer usually involves computational procedures which require very little, if any, knowledge of the hardware construction of the computer itself.
This chapter covers the hardware aspects of microcomputers without considering software 
problems. Writing a program for a microcomputer is similar to writing a microprogram for con-trol memory, except that one must use the set of instructions for the commercial microprocessor selected. The study of software design is a subject that by itself could fill an entire volume.
In this chapter, we first define the various components of a microcomputer system and the 
way they communicate with each other. The organization of a typical microprocessor is then presented, and its internal and external operations are explained. Some important features com-mon to all microprocessors are discussed. We then show the organization of the memory section and explain the various types of interface units commonly used in the design of microcomputer systems.
12.2 Microcomputer Organization
A typical microcomputer system consists of a microprocessor plus memory and I/O interface. The various components that form the system are linked through buses that transfer instructions, data, addresses, and control information among the IC components. Figure 12-1 shows the block diagram of a microcomputer system. Typically, the microcomputer has a single microprocessor. If many processors are included, then we have a multiprocessor system—which is a valid pos-sibility. A number of RAM and ROM chips are combined to form a given memory size. The in-terface units communicate with various external devices through the I/O bus. At any given time, the microprocessor selects one of the units through its address bus. Data are transferred to and from the selected unit and the microprocessor via the data bus. Control information is usually transferred through individual lines, each specifying a particular control function.
The purpose of the microprocessor is to provide a CPU which interprets instruction codes 
received from memory and to perform arithmetic, logic, and control operations on data stored in internal registers, memory words, or interface units. The microprocessor contains a number of registers, an arithmetic logic unit, and timing and control logic. Externally, it provides a bus system for transferring instructions, data, and control information to and from the modules con-nected to it. The internal operations of a typical microprocessor and the functions of the control lines are described in Section 12-3.
The random-access memory is a read-write memory type and consists of a number of IC 
packages connected together. The RAM is used to store data, variable parameters, and inter -
mediate results that need updating and are subject to change. The ROM consists of a number 
446 Chapter 12
of IC packages and is used for storing programs and tables of constants that are not subject to 
change once the production of the microcomputer system is completed. The method of connect-ing memory chips to the microprocessor is described in Section 12-6.
The interface units provide the necessary paths for transferring information between the 
microprocessor and external input and output devices connected to the I/O bus. The micropro-cessor receives status and data information from external devices through the interface. It re-sponds by sending control and data information for the external devices through the interface. This communication is specified by programmed instructions that direct data through the buses in the microcomputer system. The various interface modules available in microcomputers and their operation are presented in Section 12-7.
The communication between the LSI components in a microcomputer takes place via the 
address and data buses. The address bus is unidirectional from the microprocessor to the other units. The binary information that the microprocessor places on the address bus specifies a par -
ticular memory word in RAM or ROM. The address bus is also used to select one of many interface units connected to the system or to a particular register within an interface unit. A memory word and an interface register may be distinguished by assigning a different address to each. Alternatively, a control signal may be used to specify whether the address on the bus is for a memory word or for an interface register. The number of lines available in the address bus determines the maximum memory size that can be accommodated in the system. For n lines, 
the address bus can specify up to 2
n words of memory. The typical length of a microprocessor  Microprocessor
RAM
ROM
Interface
  units
I/O
busData
 busAddress
   busControl
  lines
Figure 12.1 Microcomputer system block diagram
Microcomputer System Design  447 
address bus is 16, providing a maximum memory capacity of 216 = 65,536 words. The amount of 
memory employed in a microcomputer system depends on the particular application and quite 
often is less than the maximum available in the address bus.
The data bus transfers data to and from the microprocessor and the memory or interface 
which is selected by the address bus. The data bus is bidirectional, which means that the binary information can flow in either direction. A bidirectional data bus is used to save pins in the IC package. If a unit did not use a bidirectional data bus, it would be necessary to provide separate input and output terminals in the IC package. The number of lines in the microprocessor data bus ranges from 4 to 16, with 8 lines being the most common.
A set of separate data and address buses is the most common transfer path found in micro-
processors. The advantage of this scheme is that a microprocessor can select a word in memory and transfer the data word at the same time. Some microprocessors use one common bus which is time-multiplexed for transfer of addresses or data. For example, a common 16-line bus can be used to transfer a 16-bit address, followed by a 16-bit data word to be written in memory. The advantage of this scheme is that fewer terminal pins are needed and yet data can be 16 bits wide. The disadvantages are the time lost in the sequential use of the common bus and the need for an external latch to hold the address for memory. Some microprocessors share only part of the system bus between data and address. A 16-line bus can use 8 bidirectional lines for data transfer and all 16 lines for transferring an address. This requires sharing of the data bus, since the ad-dress is split between the 8 data-bus lines and the remaining available 8 lines.
Instead of using a microprocessor chip as shown in Fig. 12-1, some applications replace this 
block with a microcomputer chip. Typically, a microcomputer chip contains a CPU together with 64 words of RAM and about 1024 words of ROM, all within one IC package. It also provides some features of an interface. If the digital system to be designed does not require more memory or additional interface capabilities, then the entire microcomputer system can be constructed with the single-chip microcomputer component. Thus a one-chip microcomputer can be used as a low-cost, small-size component for a stand-alone application. Most microcomputer chips can be expanded with external ROM, RAM, and interface capability to provide a more powerful control application. In subsequent discussions, the memory and interface will be separated from the CPU, but it must be realized that some of the memory and interface may be included within the IC package that contains the CPU.
To facilitate the development of special-purpose digital systems by means of a microcom-
puter, many sources offer a complete microcomputer unit on a single printed-circuit (PC) board. The microprocessor and a number of RAM, ROM, and interface ICs together with any other MSI and SSI chips needed to build a microcomputer unit, are all mounted on a single PC board. The IC terminals are connected through printed wires along the board to form a complete microcom-puter unit. The user is given access to the interface for the I/O devices through the pins of the board connector. The connector also provides enough pins to accommodate all buses and allow for memory and interface expansion external to the board. Memory and interface expansion is also available in ready-made PC boards.
12.2.1 Bus Buffer
The bus system in a microprocessor is commonly implemented by means of bus buffers con-structed with three-state gates. A three-state (or tri-state) gate is a digital circuit that exhibits three output states. Two of the states are signals equivalent to binary 1 and 0 as in conventional 
448 Chapter 12
gates. The third state is called a high-impedance state. The high-impedance state behaves as if 
the output is disabled or “floating,” which means that it cannot affect or be affected by an external signal at the terminal. The electronic circuit of a three-state gate is explained in Section 13-5 in conjunction with Fig. 13-16.
The graphic symbol of a three-state buffer gate is shown in Fig. 12-2. It has a normal input 
and a control input that determines the output state. When the control input is equal to binary 1, the gate behaves as any conventional buffer, with the output equal to the normal input. When the control input is 0, the output is disabled and the gate goes to the high-impedance state, regardless of the value in the normal input. The high-impedance state of a three-state gate provides a feature not available in other gates. Because of this feature, a large number of three-state gate outputs can be connected with wires to form a common bus line without endangering loading effects. However, no more than one gate may be in the active state at any given time. The connected gates must be controlled so that only one three-state gate has access to the bus line while all other gates are in a high-impedance state.
A bidirectional bus can be constructed with bus buffers to control the direction of informa-
tion flow. One line of a bidirectional bus is shown in Fig. 12-3. The bus control has two selection lines, s
i, for input transfer and s0for output transfer. These selection lines control two three-state 
buffers. When si = 1 and s0= 0, the bottom buffer is enabled and the top buffer is disabled by going 
to a high-impedance state. This forms a path for input data coming from the bus to pass through the bottom buffer and into the system. When s
0= 1 and si = 0, the top buffer is enabled and the 
bottom buffer goes to a high-impedance state. This forms a path for output data coming from the system to pass through the upper gate and out to the bus line. The bus line can be disabled by making s
i and s0both 0. This puts both buffers into a high-impedance state, which prevents any 
input or output transfer of information through the bus line. This condition must exist when an Normal input A
Control input CY = A if C =1
Y is disabl ed when C = 0
Figure 12.2 Graphic symbol for a three-state buffer gate
Output contr ol
Input contr olData output
Data inputBidirectional
  bus line
  Bus
contr olsi
s0   Bus disab led
(high impedence)
Figure 12.3 Bidirectional bus buffer
Microcomputer System Design  449 
external source is using the common bus line to communicate with some other component. The 
two selection lines can be used to inform the external modules connected to the bus of the state in which the bidirectional bus is at any given time.
In most cases, the drive capability of a microprocessor bus is limited, i.e., it can drive only 
a small number of external loads, When the bus is connected to a large number of external units, the drive capability of the microprocessor must be enhanced with external bus buffers, which are also available in IC form. Furthermore, any component that has separate input and output termi-nals must be connected to the microcomputer bus system through external bus buffers in order to isolate the component when it is not communicating with the bus. Thus, a microcomputer system quite often needs external bus buffers between the microprocessor and the other LSI components and between certain LSI components and the common-bus system.
12.3 Microprocessor Organization
To guarantee a wide range of acceptability, a microprocessor must provide an internal organiza-tion suited for a wide range of applications. The organizations of commercial microprocessors differ from each other, but they all have the common property of a central processor unit. As such, they are capable of interpreting instruction codes received from memory and of performing data processing tasks specified by a program. They also respond to external control commands and generate control signals for external modules to use.
12.3.1 Typical Set of Control Signals
Proper operation of a microprocessor requires that certain control and timing signals be provided to accomplish specific functions and that other control lines be monitored to determine the state of the microprocessor. A typical set of control lines available in most microprocessors is shown in Fig. 12-4. For completion, the diagram also shows the data bus, address bus, and power supply 
Data bu s
Address bu sWriteReadInterrupt request
Bus grant edReset
Interrupt ac knowledg eClock  input Clock  outputPower suppl y
Bus r equestMicroprocessor
Figure 12.4 Control signals in a microprocessor
450 Chapter 12
input to the unit. The power requirement for a particular microprocessor is specified by the volt-
age level and current consumption that must be supplied to operate the IC.
The clock input is used by the microprocessor to generate multiphase clock pulses that pro-
vide timing and control for internal functions. Some microprocessors require an external clock generator to supply the clock pulses. In this case, the output clock is available from the clock generator rather than from the microprocessor itself. Some units generate the clock within the chip but require an external crystal or circuit to control the frequency of the clock. The clock pulses are used by external modules to synchronize their operations with the operations of the microprocessor.
The reset input is used to reset and start the microprocessor after power is turned on or 
any time the user wants to start the process from the beginning. The effect of a reset signal is to initialize the microprocessor by forcing a given address into the program counter. The program then starts executing with the first instruction at this address. The simplest way to initiate a reset is to clear the program counter and start the program from address zero. Some microprocessors respond to the reset signal by transferring the contents of a specified memory location into the program counter. The designer must then store the beginning address of the program at the ad-opted memory location.
The interrupt request into the microprocessor typically comes from an interface module to 
inform the microprocessor that it is ready to transfer information. When the microprocessor ac-knowledges the interrupt request, it suspends the execution of the current program and branches to a program that services the interface module. At the completion of the service routine, the microprocessor returns to the previous program. The interrupt facility is included to provide a change in program sequence as a result of external conditions. The interrupt concept and the method of responding to an interrupt request are discussed in Section 12-5.
The bus-request control input is a request to the microprocessor to temporarily suspend its 
operation and drive all buses into their high-impedance state. When the request is acknowledged, the microprocessor responds by enabling the bus-granted control output line. Thus, when an 
external device wishes to transfer information directly to memory, it requests that the micropro-cessor relinquish control of the common buses. Once the buses are disabled by the microproces-sor, the device that originated the request takes control of the address and data buses to conduct memory transfers without processor intervention. This feature is called direct memory access and is discussed in Section 12-8.
The read and write are control lines that inform the component selected by the address bus 
of the direction of transfer expected in the data bus. The read line informs the selected unit that the data bus is in an input mode and that the microprocessor will accept data from the data bus. The write line indicates that the microprocessor is in an output mode and that valid data are avail-able on the data bus. When the buses are disabled, these two control lines are in a high-impedance state; thus, the external unit in control of the buses can specify the read and write operations.
Other possibilities exist for bus control. The address bus may be controlled with an addi-
tional line to indicate whether the address is for a memory word or for an interface unit. Another possibility is to combine the read and write control lines into one line labeled R/W . When this line is 1, it indicates a read, and when 0, it indicates a write. A second control line is then needed to indicate when a valid address is on the address bus, so that the external components respond to the R/W line only when requested with a valid address.
The control signals enumerated in Fig. 12-4 constitute a minimum set of control func-
tions for a microprocessor. Most microprocessors have additional control features for special  
Microcomputer System Design  451 
functions. Different units may use different mnemonic names for identical control functions, and 
not necessarily the names used here.
12.3.2 CPU Example
To appreciate the tasks performed by a microprocessor, it will be instructive to investigate the internal organization of a typical unit. Figure 12-5 shows the block diagram of a central proces-sor unit enclosed within a microprocessor chip.
* Externally, it provides a bidirectional data bus, 
an address bus, and a number of control lines. Here we show only the control lines associated with the bus transfer. The data bus is designated by the symbol DBUS and consists of eight lines. The information contained in the eight lines is called a byte, which is the name used to denote 
an 8-bit word. The address bus, designated by the symbol ABUS, consists of 16 lines to specify 
* This is similar to the 8080/85 microprocessor except that the F and G registers are called H and L in the 
8080/85.  (ABUS)
Address bu sBidirectional 
  data bus
   (DBUS)
8-bit int ernal bu s
Instruction
  decoder
Address bu ffersTiming
  andcontr olAccumulat or
Regist er(A)Address R egist er (AR)Stack Pointer (SP)Program C ounter (PC) StatusRegisterTemporar y
Register(T) Instr uction
Register (IR)
Register selectData bu ffers
  Othercontr ol
  lines  WR(write)Multiple xer
  RD(read)ALU1 8
1 16 98B
DEC
FG
H L
Figure 12.5 Block diagram of microprocessor
452 Chapter 12
216 = 64K (K = 1024) possible addresses. Thus the microprocessor is capable of communicating 
with a memory unit of 64K bytes.
Internally, the microprocessor has six processor registers labeled B through G, an accumu-
lator register designated by the letter A, and a temporary register, T. These registers are 8-bits 
wide and can accommodate a byte. The ALU operates on the data stored in A and T, and the result 
of the operation is transferred to A or, through an internal bus, to any one of the other six pro-
cessor registers. The status register holds the status bits of an operation, such as end carry from 
the ALU, the sign-bit value, and a zero-result indication.† The operation code of an instruction 
is transferred to the instruction register (IR), where it is decoded to determine the sequence of microoperations needed to execute the instruction. The timing and control supervise all internal operations in the CPU and the external control lines in the microprocessor.
The address buffers receive information from three sources: the program counter (PC) the 
stack pointer (SP),and the address register (AR). PC maintains the memory address of the current program instruction and is incremented after every instruction fetch. AR is used for temporary 
storage of addresses that are read from memory. The functions of these two registers will be clarified when we describe the sequence of operations in the CPU. SP is used in conjunction with 
a memory stack and its function is explained in Section 12-5. The address bus can also receive address information from a pair of processor registers. Three pairs can be formed to provide a 16-bit address. They are labeled with the combined register symbols BC, DE, and FG. Each pro-
cessor register contains 8 bits and, when combined with the one adjacent to it, forms a register pair of 16 bits. It is sometimes convenient to partition the three 16-bit registers PC, SP, and AR 
into two parts. The symbol H designates the 8 high-order bits, and the symbol L, the 8 low-order 
bits. Thus PC(L)refers to bits 1 through 8 of PC and PC(H) refers to bits 9 through 16.
12.3.3 Memory Cycle
The memory unit consists of both RAM and ROM. It is connected to the microprocessor through the address and data buses and the read and write control. This is shown schematically in Fig. 12-6.  
A memory cycle is defined as the time required to access the memory to read or write a byte.
In the read cycle, the microprocessor places an address in ABUS and enables control line 
RD. The memory responds by reading the byte and placing it in DBUS. The microprocessor 
then accepts the byte and transfers it to an internal register. To express the read cycle sym-bolically, assume that the address is to come from AR and the data byte is to be transferred to  
†The status register was discussed in Sec. 9-7.Address b us (ABUS)
Data bus (DBUS)
Read (RD)Microprocessor
 (For RAM onl y)     Memor y 
(RAM or ROM)
Write (WR)
Figure 12.6 Communication between microprocessor and memory
Microcomputer System Design  453 
register A:
ABUS ← AR, RD ←1  address in bus for reading
DBUS ← M [ABUS]  memory reads byte
A ← DBUS, RD ← 0  byte transferred to A
First, the microprocessor places the memory address into ABUS and informs the memory that 
a valid address is available for reading. The memory responds to RD by reading the byte at the 
address given by ABUS and placing it in DBUS. The microprocessor then transfers the byte from 
DBUS to A. At the same time, control signal RD is disabled, indicating the end of the memory 
transfer.
The three operations listed above can be combined into one statement:
A ← M [AR]
This is a read operation that transfers the memory byte addressed by AR into the A register.
In the write cycle, the microprocessor places an address in ABUS and a data byte in DBUS. 
At the same time, the control line WR is enabled. The memory responds to WR by writing the 
byte from DBUS into a memory location specified by the address in ABUS. This process can be 
expressed symbolically:
ABUS ← AR, DBUS ← A, WR ← 1
M [ABUS] ← DBUS,   WR ← 0
This states that the contents of register A are transferred to a memory byte at the address given by 
AR. Again, it is possible to write this operation with one composite statement:
M [AR] ← A
Memory transfers to and from the microprocessor must conform with certain timing rela-
tionships that must exist between the control signals and the information on the buses. These tim-
ing relationships are specified in timing waveforms that are included with the product specifica-tions of the units involved. The time interval of a memory cycle is a function of the internal clock frequency of the microprocessor and the access time of the memory. Once the microprocessor sends an address, it expects a response within a given interval of time. A memory that is capable of responding within the processor time interval can be directly controlled by the microprocessor memory cycle.
If the microprocessor communicates with a slow memory, it may take longer to access the 
memory than the allowable timing interval. To be able to use slow memories, a microprocessor must be able to delay the transfer until the memory access is completed. One way is to extend the microprocessor clock period by reducing the clock frequency to fit the access time of the memory. Some microprocessors provide a special control input called ready to allow the memory 
to set its own memory cycle time. If, after sending an address out, the microprocessor does not receive a ready input from memory, it enters a wait state for as long as the ready line is in the 
0-state. When the memory access is completed, the ready line goes to the 1-state to indicate that the memory is ready for the specified transfer.
454 Chapter 12
12.3.4 Microprocessor Sequencing
The timing and control in the microprocessor determine the sequence of transfers through the 
internal and external buses, the ALU, and the processor registers. During the fetch cycle, the control reads an operation code from memory and  deposits it into its instruction register. The instruction is decoded and translated into specific processing activities. Further references to memory depend on the operation code decoded. Let us assume that ail operation codes consist of eight bits and are stored in one byte of memory. Operands are also one byte long because the data bus is eight bits wide. An address is specified with two bytes or 16 bits. Now consider three add instructions with different format lengths.
1. Add B to A. This is an instruction to add the contents of register B to the present contents 
of the accumulator. All the information necessary to specify the instruction is contained within the one-byte operation code.
2. Add immediate operand to A. This is an instruction that adds an operand to the pres-ent contents of the accumulator. The operand byte is placed in memory following the operation-code byte. This instruction occupies two bytes of memory.
3. Add operand specified by an address to A. This is an instruction that adds a byte stored anywhere in memory to the present contents of the accumulator. The address of the op-erand is placed in memory following the operation-code byte. This instruction occupies three bytes of memory since the address itself occupies two bytes.
The format and function of the three instructions are summarized in Table 12-1. Each in-
struction has at least one byte for the operation code. The control unit is designed to recognize the number of bytes in a particular instruction from the decoded operation code of the first byte.
The memory representation of the three instructions is depicted in Fig. 12-7. The first in-
struction is assumed to be in location 81, with an operation code of 8 bits assigned arbitrarily. The other two instructions occupy two and three bytes, respectively. The address of the third instruc-tion is 260 and is determined from the 16-bit binary number in locations 85 and 86:
(00000001 00000l00)
2 = (260) 10
The operand for this instruction is shown to reside in memory location 260. In a typical appli-cation, the three instructions with normally reside in ROM, while the operand in location 260 will be in RAM. This operand must reside in RAM because it must be assumed that its value is subject to change during the computation. Otherwise, if the operand value does not change, there is no need to associate it with an address.
Table 12-1 Three typical instructions for microprocessor
Instruction Byte 1 Byte 2 Byte 3 Function
Add B to A Operation code — — A ← A + B
Add immediate oper -
and to AOperation code Operand — A ← A + byte 2
Add operand specified 
by an address to AOperation code High-order half 
of addressLow-order half of 
addressA ← A + M [ad-
dress]
Microcomputer System Design  455 
Referring to Fig. 12-5 for the names of registers and buses, we can now list the sequence 
of operations required to process each instruction. We assume that the program counter initially 
contains 81.
Add B to A;
IR←M [PC], PC ← PC + 1  read operation code
T ←B  transfer B to T
A←A + T  add T to A
The first line represents the fetch cycle for reading the operation code into the instruction regis-ter, The decoded operation specifies a processor register; so the contents of B are transferred to 
T and the add operation is performed in the ALU. Note that PC has been incremented and now 
contains the number 82.
The one-byte instruction is executed with one memory cycle because all operands reside 
in processor registers. If an operand resides in memory, it is necessary to access the memory to read the operand.
Add immediate operand to A:
IR ← M [PC], PC ← PC + 1  read operation code
T ← M [PC], PC ← PC + 1  read operand
A ← A + T  add operand to A
The first line represents the fetch cycle again. PC is incremented to contain address 83. The 
operand at this address is read from memory and placed in T, and the addition is performed in the ALU.Decimal Address 
High-or der half of Address 
Low-order half of Address Op-code to  add B to  A
Operan dOp-code to  add immediat e operand to A
Op-code to  add memory  byte to A
Next op-code 
Operan d 260 00001 11000000001
0101010100000 10011100111111011001100011010000000 81
8786858483821-byte instr uction 
2-byte instr uction 
3-byte instr uction Memor y
  binar y
content 
Figure 12.7 Memory representation of three instructions
456 Chapter 12
If the instruction contains the address of the operand, the microprocessor must go through 
four memory cycles to execute the instruction.
Add operand specified by an address to A:
IR ← M [PC], PC ← PC + 1  read operation code
AR (H) ← M [PC], PC ← PC + 1  read first byte of address
AR (L) ← M [PC], PC ← PC + 1  read second byte of address
T ← M [AR]  read operand
A ← A + T  add operand to A
The address part of the instruction is temporarily stored in the address register (AR). The 16-bit 
address formed in AR is then used to read the operand.
A large number of memory cycles is undesirable in microprocessors because they consume 
a considerable amount of processing time. This is one of the limiting factors on the speed of 8-bit microprocessors with 16-bit addresses. The number of accesses to memory can be reduced if a 16-bit data bus is used. 16-bit microprocessors require fewer references to memory compared to 8-bit microprocessors. Although we have chosen to describe the operation of an 8-bit micro-processor, the operation with a 16-bit data bus would be similar, taking into consideration the differences in word lengths used for processor registers and memory words.
12.4 Instructions and Addressing Modes
The logical structure of microprocessors is described in reference manuals provided by the man-ufacturer. A reference manual for a particular microprocessor describes the internal organization of the CPU, the function of all input and output terminals, and the processor registers available from the user’ s point of view. The manual describes all the instructions available in the computer and explains their functions. It also shows how status bits are affected by each instruction. The internal code for each instruction is listed in binary, octal, or hexadecimal. In most cases, either the octal or hexadecimal equivalent code is adopted because these codes need fewer digits than the binary representation. When a program is written for the computer, each instruction is as-signed a symbolic name to identify it.
Symbolic names and codes assigned to instructions used in one microprocessor are differ -
ent from the names and codes used in a different microprocessor, even for similar instructions. For this reason, the user must study and remember the set of instructions and their symbolic names every time a different microprocessor is employed. Although the instruction sets of dif-ferent microprocessors differ from one another, there are certain instructions that perform basic operations and are included in all microprocessors.
12.4.1 Basic Set of Microprocessor Instructions
Microprocessor instructions may be classified into three distinct types.
1. Transfer instructions that move data among registers, memory words, and interface reg-
isters without changing the binary information content.
2. Operation instructions that perform operations on data stored in registers or memory 
words.
Microcomputer System Design  457 
3. Control instructions used to test status conditions in registers and, depending on results, 
cause a change in program sequence.
The instruction set of a particular microprocessor specifies the register-transfer operations and 
control decisions that are available in the microcomputer system. A specific program for a micro-computer is equivalent to specifying the sequence of operations for the particular digital system that the microcomputer implements.
Transfer-type instructions in microprocessors are indicated by various names. A move in-
struction causes a transfer of data from source to destination. Either the source or the destination may be a processor register or a memory location. The load and store instructions are similar to 
the move instruction, except that they usually refer to transfers from and to memory and accu-mulator. The exchange instruction swaps information between two registers or between a register 
and a memory word. The push and pop instructions transfer data among processor registers and 
a memory stack. The input and output instructions transfer data among processor registers and 
interface registers.
Operation-type instructions perform arithmetic, logic, and shift operations among proces-
sor registers or memory words. They also set, clear, or complement status or flag bits. Typical operation instructions are add, subtract, AND, OR, complement, and set carry. Most of the oper -
ation-type instructions also change the status bits in the status register of the processor.
Control-type instructions provide decision-making capabilities and change the path taken 
by the program when executed in the computer. Instructions are stored in consecutive memory locations and are executed one after the other in sequence. The programmer inserts a control instruction every time that control must be transferred to an instruction out of normal sequence. Control instructions may be conditional or unconditional. A conditional control instruction causes a branch out of normal program sequence only when a specified status condition is de-tected. An unconditional control instruction causes a branch unconditionally. The branch out of normal program sequence is accomplished by changing the program counter so it contains the address of the instruction that is to be executed next.
There are three types of control instructions and each type may be conditional or uncondi-
tional:
1. Jump or branch instructions.
2. Call to and return from subroutine instructions.
3. Skip instructions.
The words jump and branch are used interchangeably to mean the same thing, but sometimes 
they are used to denote different addressing modes. These instructions are associated with an address that specifies where the jump or branch is to be made. The call-to-subroutine and return-from-subroutine instructions are explained in the next section in conjunction with the memory stack. A skip instruction skips the next instruction in sequence. By placing an unconditional branch instruction after the skip instruction, it is possible to branch to one of two possible loca-tions, depending on the value of a specified status-bit condition.
12.4.2 Instructions for Microprocessor
The number of distinct instructions in a particular microprocessor may range from 50 to 250. These instructions must be studied and memorized by the user who writes programs for the 
458 Chapter 12
microcomputer. A partial list of instructions formulated for the microprocessor of Fig. 12-5 is 
presented in Table 12-2. The instructions are divided into three sections to give examples of transfer-, operation-, and control-type instructions.
The hexadecimal code listed in the table is a 2-digit number equivalent to the 8-bit opera-
tion code assigned to the instruction. (The equivalent 4-bit representation for the 16 hexadecimal digits was given in Table 1-l.) The symbolic name for each instruction is a 2- to 4-letter designa-tion followed by one or two symbols for a register, an operand, or a memory address. The descrip-tion column explains the instruction in words, and the function column defines the instruction precisely with a register-transfer statement. Note that computer instructions specify macroopera-tions for the computer and can be symbolized with appropriate statements in the register-transfer method. However, for various practical reasons, computer instructions are written with special-ized symbols as in the second column of the table. These special symbols are assigned by the computer manufacturer and tend to be different in different computers.
The first four instructions in Table 12-2 are move instructions that transfer information from 
a given source to a given destination. The next three are load and store instructions that accom-plish a similar function. A representative number of operation-type instructions are listed in the second part of the table. The last section lists a few control instructions.
The move with register-indirect instruction:
MOV      A, FG
symbolizes the register-transfer operation A ← M [FG]. It transfers the memorybyte whose ad-
dress is in register pair FG into register A. This is called a register-indirect instruction because 
register pair FG specifies the address of the operand rather than the operand itself.
The load-immediate instruction:
LXI      FG, D16
symbolizes the register-transfer operation FG ← D16, where D16 is a 2-byte number that may 
represent an address. This instruction can be used to transfer an address into register pair FG. When used in this manner, register pair FG constitutes a data counter or a pointer that points to 
an address in memory where an operand is stored. FG can be incremented with the increment-
register-pair instruction:
INX      FG
which symbolizes the register-transfer operation FG←FG + 1. In this way, the data counter or 
pointer can be incremented to point at consecutive addresses in memory where the programmer stores a table of consecutive data bytes.
The operation instructions provide the common arithmetic, logic, and shift operations. Note 
that more instructions of the same type can be formulated if we specify one of the other five processor registers C, D, E, F, or G instead of specifying register B. Similarly, an instruction that 
specifies a register pair can be duplicated by using any one of the three possible register pairs BE, DE, or FG.
The last six instructions in the table are control instructions. The jump and call instructions 
need a 16-bit address symbolized by AD 16. The return and halt instructions are one-byte instruc-
tions. Those that include the symbol AD 16 or D 16 are three-byte instructions and those that use 
Microcomputer System Design  459 
Table 12-2 Partial list of instructions for microprocessor
Hexadecimal 
code Instruction symbol Description Function*
78 MOV A, B Move B to A A ← B
3E MVI A, D8 Move immediate operand to A A ← D8
7E MOV A, FG Move to A with register indirect A ← M [FG]
77 MOV FG, A Move A with register indirect M [FG] ← A
3A LDA AD16 Load A direct A ← M [AD 16]
32 STA AD16 Store A direct M [AD 16] ← A
01 LXI FG, D16 Load register pair immediate FG ← D 16
80 ADD B Add B to A A ← A + B
C6 ADI D8 Add immediate operand to A A ← A + D8
86 ADD FG Add to A with register indirect A ← A + M [FG]
90 SUB B Subtract B from A A ← A − B
A0 ANA B AND B to A A ← A ∧ B
B0 ORA B OR B to A A ← A ∨ B
04 INR B Increment B B ← B + 1
05 DCR B Decrement B B ← B − 1
03 INX BC Increment register pair BC BC ← BC + l
0B DCX BC Decrement register pair BC BC ← BC − 1
2F CMA Complement A A ← A
07 RLC Rotate A left with carry A ← clc A
OF RRC Rotate A right with carry A ← crc A
37 STC Set carry bit to 1 C ← 1
C3 JMP AD16 Jump unconditionally PC ← AD 16
DA JC AD16 Jump on carry If (C = 1) then (PC ← AD 16)
C2 JNZ AD16 Jump on nonzero If (Z = 0) then (PC ← AD 16)
CD CALL AD16 Call subroutine Stack ← PC, PC ← AD 16
C9 RET Return from subroutine PC ← stack
76 HLT Halt processor
*A = accumulator register; B =B register; FG = register pair F and G; BC = register pair B and C; D8 = 8-bit data operand 
(1 byte); D16 = 16-bit data operand (2 bytes); AD 16 = 16-bit address (2 bytes).
460 Chapter 12
a D8 symbol are two-byte instructions. All others are one-byte instructions whether they do or 
do not specify a register.
The best way to appreciate the instruction set of a computer is to write programs that per -
form meaningful data-processing tasks. The programs written for a microcomputer system re-
quire the same logical reasoning involved in writing microprograms for a digital system as ex-emplified in Chapter 10.
12.4.3 Addressing Modes
The operation code of the instruction specifies the operation that will be executed after it is read from memory and placed in the control unit of the CPU. The control unit must also know where to find the operand or operands upon which the operation is to be performed. Operands may be located in processor registers, in memory words, or in interface registers. The way the operands are determined during program execution is determined from the addressing mode of the instruc-tion. In large computers, the addressing mode of an instruction is specified with a binary code just as the operation code is specified. In 8-bit microprocessors, the first byte of an instruction is a combined binary code that specifies both the operation and the mode of the instruction. This byte, when placed in the instruction register during the fetch cycle, is interpreted by the control to determine not only the operation that must be executed but also the way to go about locating the operands.
An example of three addressing modes for the same operation can be found in Table 12-1. 
The table defines three types of addressing modes for the add-to-A instruction. By specifying a different mode, the operation can refer to a register, to an immediate operand, or to an operand specified by a memory address. A computer can use a variety of addressing modes for the same operation to provide different ways for locating operands. To the inexperienced user, the variety of addressing modes in some computers may seem excessively complicated. However, the avail-ability of different addressing schemes gives the experienced programmer flexibility for writing programs that are more efficient with respect to the number of instructions and execution time.
We have already discussed several addressing modes in previous examples and they are 
summarized here for reference.
Implied Mode: In this mode the operand is specified implicitly in the definition of the 
instruction. Instructions of this type are 1-byte instructions. For example, the instruction “com-plement accumulator” is an implied-mode instruction because the operand in the accumulator register is implied in the definition of the instruction.
Register Mode: In this mode the operands are in registers which reside within the CPU. 
Register-mode instructions are 1-byte instructions and can be executed within the CPU without the need to reference memory for operands.
Register-indirect Mode: In this mode the instruction specifies a register or a pair of regis-
ters in the processor whose contents give the address of the operand in memory. This mode uses 1-byte instructions even though the operand is in memory. Before using a register-indirect-mode instruction, the programmer must ensure that the address of the operand is placed in the proces-sor register with a previous transfer-type instruction. A reference to the register is then equivalent to specifying a memory address.
Microcomputer System Design  461 
Immediate Mode: In this mode the operand is specified in the instruction itself. In an 8-bit 
microprocessor, the operand is placed in memory immediately after the operation-code byte. An 
immediate-mode instruction having an 8-bit operand is a 2-byte instruction. One with a 16-bit operand is a 3-byte instruction.
Direct-addressing Mode: In this mode the operand resides in memory and its address is 
given directly in the address part of the instruction. In 8-bit microprocessors with 16-bit address-es, a direct instruction consists of 3 bytes. In computers with wider memory words, the address part is combined with the operation and mode code bits to combine the entire instruction in one memory word. Most direct-mode instructions assume that the other operands reside in processor registers. If more than one operand resides in memory, the instruction must include additional addresses to specify their locations.
Some 8-bit microprocessors with 16-bit addresses have special direct-addressing modes 
that require only one byte to specify an address. Such microprocessors divide the 2
16 bytes of 
memory into blocks called pages. Each page is usually assigned 256 bytes of consecutive mem-
ory space. A page in memory is then specified by the 8 high-order bits of an address. The 8 low-order bits give the byte within the page. Thus, a 64K memory can be divided into 256 pages of 256 bytes each. The first page is called page 0 and the last is page 255. By means of the paging scheme, it is possible to develop some variations in the direct mode of addressing.
Zero-page Addressing: This is similar to the direct-addressing mode except that the ad-
dress part of the instruction contains only 1 byte. This is a 2-byte instruction, with the second byte specifying the 8 low-order bits of a memory address. The 8 high-order bits of the address are assumed to be all 0’ s. This restricts the range of addresses to the lowest 256 bytes of memory (0−255) which is defined to be page 0.
Present-page Addressing: This mode assumes that the operand resides in memory within 
the same memory page as the instruction that uses it. Since the program counter always holds the address of the next instruction, its 8 high-order bits also contain the present page number. This mode of addressing uses 2-byte instructions, with an 8-bit address part. The address of the operand is obtained from the page number catenated with the address part of the instruction. The 16-bit address of the operand is computed from:
PC (H) + AD 8
where PC(H) denotes the eight high-order bits of PC, and AD 8 is the 8-bit address of the instruc-
tion. The result is a 16-bit address, with PC(H)giving the first 8 bits and AD 8 the other 8 bits.
Relative Addressing: This is similar to the present-page addressing mode except that it is 
not sensitive to page boundaries. A relative-mode instruction is a 2-byte instruction, with the sec-ond byte specifying a signed number in the range between −128 and +127. This is accomplished by representing the number in sign-2’ s-complement form. The 16-bit address of the operand is computed by adding the 16-bit content presently available in the program counter to the 8-bit signed address in the instruction. If the latter is denoted by AD 8, the address computation can 
be symbolized as:
PC + AD 8
462 Chapter 12
This requires that the operand (or the location where a branch relative instruction transfers con-
trol) be within 127 and - 128 bytes away from the address of the next instruction. Page boundar -
ies are of no consequence in the relative mode because the entire 16 bits of the program counter are used in the calculation.
The address part of an instruction is used by the control unit in the CPU to obtain the 
operand from memory. Sometimes this address is the address of the operand, but sometimes it is just an address from which the address of the operand is calculated. Computers use various other addressing modes to calculate the address of an operand. To differentiate among the vari-ous addresses involved in the computation, we must distinguish between the address given in the instruction and the actual address used by the control when it executes the instruction. The ad-dress of the operand or the address where control branches in response to a jump, branch, or call instruction is called the effective address. In a direct-mode instruction, the effective address is equal to the address part of the instruction. In the relative mode, the effective address is computed from the value in PC plus the address part of the instruction.
The computation of the effective address for the last four addressing modes discussed above 
are listed in Table 12-3. The table also lists five other addressing modes commonly found in microprocessors (and in larger computers as well). The symbol AD 16 denotes a 2-byte address, 
and AD 8 denotes a 1-byte address. PC is the program counter and XR is an index register. XR is 
a CPU register used in many computers for storing an address. The address stored in XR can be 
referenced with an indexed-mode instruction. An address is placed initially into XR by means of 
a transfer-type instruction. The computation of the effective address in each mode is specified in the table with a register computational expression. The computed effective address is then used to access memory to read an operand or becomes the branch address in a control-type instruction. The other addressing modes listed in the table are explained below.
Indexed Addressing: Instructions in this mode contain 3 bytes, with the last two giving a 
16-bit address. The address part of the instruction is added to the value presently stored in the index register to obtain the effective address. The index register is often incremented or decre-mented to facilitate the execution of program loops and to access tables of data stored in memory.Table 12-3 Computation of effective address for various addressing modes
Address mode Effective address Comments
Direct AD 16 16-bit address part of instruction
Zero page ADS 8-bit address part of instruction
Present page PC(H) + AD 8 8 highest-order bits of PC catenated with AD 8
Relative PC + AD 8 Contents of PC plus signed AD8
Indexed XR + AD 16 Contents of XR plus AD 16
Base register XR + AD 8 Contents of XR plus AD 8
Indirect M [AD16] Address stored in location given by AD 16
Indexed-indirect M [XR + AD 8] Address stored in location (XR + AD 8)
Indirect-indexed M [AD 8] + XR Address stored in location AD 8 plus contents of XR
Microcomputer System Design  463 
Base-register Addressing: This is similar to the indexed-addressing mode, except that the 
address pan of the instruction consists of a number of bits that is less than the number of bits 
required for a full address. The effective address is calculated by adding the contents of the in-dex register to the partial address in the instruction. The register used in this mode is sometimes called a base register instead of an index register. The base register holds a base address, and the truncated address in the instruction specifies a displacement with respect to the base address.
Indirect Addressing: In this mode the address part of the instruction specifies the address 
where the effective address is stored. Control reads the address part of the instruction and uses it to address memory again to read the effective address. Memory must be accessed again to read the operand if the instruction is of the operation type. In a control-type instruction, the effective address is the branch address which is transferred to PC.
Indexed-indirect Addressing: This is an indirect-addressing mode, except that the address 
part of the instruction is added to the contents of the index register to determine the address where the effective address is stored in memory.
Indirect-indexed Addressing: In this mode the value stored in the memory location speci-
fied by the address part of the instruction is added to the contents of the index register to obtain the effective address.
Specific microprocessors employ several addressing modes, but very seldom would one 
unit have all the addressing modes enumerated here. To be able to write programs for a micro-computer, it is necessary to know the type of instructions available and also to be thoroughly familiar with the addressing modes used in the microprocessor.
12.5 Stack, Subroutines, and Interrupt
A very useful feature included in many computers is a memory stack, also called a last-in first-out (LIFO) list. A stack is a storage device that stores information in such a manner that the item stored last is the first item retrieved. The operation of a stack is sometimes compared to a stack of trays. The last tray placed in the stack is the first to be taken off.
A stack is useful for a variety of applications and its organization possesses special features 
that facilitate many data processing tasks. For example, a stack is used in some electronic calcu-lators and computers to facilitate the evaluation of arithmetic expressions. Its use in microproces-sors is mostly for handling of subroutines and interrupts. In this section, we explain the operation of a stack and restrict the discussion to those applications found in microprocessors.
12.5.1 Memory Stack
A memory slack is essentially a portion of a memory unit accessed by an address that is always 
incremented or decremented after the memory access. The register that holds the address for a stack is called a slack pointer (SP) because its value always points to the top item in the stack. The two operations of a stack are the insertion and deletion of items. The operation of insertion is called push and it can be thought of as the result of pushing a new item onto the top of the stack. 
The operation of deletion is called pop and it can be thought of as the result of removing one 
item so that the stack pops out. However, nothing is physically pushed or popped in a memory stack. Those operations are simulated by incrementing or decrementing the stack pointer register.
464 Chapter 12
It must be realized that a stack can be placed within the microprocessor without the need 
to refer to memory. In such a case, the stack is constructed with registers and is called a register 
stack. The size of a register stack is limited by the number of registers it contains. A memory 
stack can grow and may occupy the entire memory space if necessary. We will explain the orga-nization of the stack assuming that it resides in memory. The same organization also applies to a register stack, except that the push and pop operations are executed within the microprocessor without reference to memory.
Figure 12-8 shows a portion of a memory unit organized as a stack. The stack pointer reg-
ister SP holds a binary number whose value is equal to the address of the item which is currently 
on top of the stack. Three items are presently storedin the stack: A, B, and C in consecutive ad-
dresses m, m + 1, and m + 2, respectively. Item C at address m + 2 is on top of the stack, so SP 
now contains m + 2. To remove the top item, the stack is popped by reading the item at address m + 2 and decrementing SP . Item B is now on top of the stack since SP contains address m + 1. To 
insert a new item, the stack is pushed by incrementing SP and writing a new item on top of the 
stack. Note that item C has been read out but not physically removed. This does not matter as far 
as the stack operation is concerned, because when the stack is pushed, a new item is written on top of the stack regardless of what was there before.
The position of the stack pointer in a microprocessor can be found in the block diagram 
of Fig. 12-5. The SP can specify an address for memory through the address bus, ABUS. The 
data transferred to and from the memory stack and the microprocessor go through the data bus, DBUS. To write meaningful register-transfer statements for the stack operations, we assume that 
the data are transferred to and from register A.
The push A operation is defined by the statements:
SP ← SP + 1
M [SP] ← A
SP is incremented to point at the next empty location in the stack. The contents of register A are 
placed in DBUS, the contents of SP are placed in ABUS, and a WR (write) operation is initiated. 
This inserts the contents of A into the top of the stack, and SP points at that location.Stack Pointer (SP)
AC
BABUSDBUSMemor y
Address
mm + 4
m + 3
m + 2
m + 1Push:    SP ← SP + 1
             M[SP] ← DBUS
Pop:    DBUS ← M[SP]
           SP  ← SP − 1
Figure 12.8 Memory stack operations
Microcomputer System Design  465 
The pop A operation is defined by the statements:
A ← M [SP]
SP ← SP − 1
The contents of SP are placed in ABUS, and a RD (read) operation is initiated. The memory reads 
the word at the given address and places it in DBUS. The microprocessor accepts the word from 
DBUS and transfers it to register A. SP is then decremented to point at the byte one address down, 
which is now on top of the stack.
The two operations for either push or pop stack are (1) an access to memory through SP, 
and (2) updating SP. Which of the two operations is done first and whether SP is updated by 
incrementing or decrementing depend on the organization of the stack. In Fig. 12-8 the stack grows by increasing the memory address. The stack may be made to grow by decreasing the 
memory address as shown in Fig. 12-9. In such a case SP is decremented for the push operation 
and incremented for a pop operation. A stack may be organized so that SP points at the next 
empty location on top of the stack. In this case, the sequence of operations of updating SP and 
memory access must be interchanged. This last configuration was demonstrated in Fig. 10-20 for the register stack defined in Fig. 10-19.
The stack pointer is loaded with an initial value by means of a transfer-type instruction. 
This initial value must be the bottom address of an assigned stack in memory. Henceforth, SP is 
automatically incremented or decremented with every push or pop operation. The advantage of a memory stack is that the processor can refer to it without having to specify an address, since the address is always available and automatically updated in the stack pointer. Thus, a processor can reference a memory stack without specifying an address. For this reason, instructions involving stack operations are referred to as zero address or implied instructions.
12.5.2 Subroutines
A subroutine is a self-contained sequence of instructions that performs a given task. During normal execution of a program, a subroutine may be called to perform its function many times at various points in the main program. Each time a subroutine is called, a branch is executed to the beginning of the subroutine to start executing its set of instructions. .After the subroutine has been executed, a branch is made back to the main program. Because branching to a subroutine and returning to the main program is a common operation, all processors provide special instruc-tions to facilitate subroutine entry and return.
The instruction that transfers control to a subroutine is known by different names. The most 
common names used are call subroutine, jump to subroutine, and branch to subroutine, A call-
subroutine instruction consists of an operation code together with the address that specifies the 
beginning of the subroutine. The instruction is executed by the performance of two tasks: (1) Control is transferred to the beginning of the subroutine. (2) The address of the next instruction in the calling program is stored in a temporary location so that the subroutine knows where to re-turn. The last instruction of every subroutine, commonly called return from subroutine,transfers control to the instruction in the calling program whose address was originally stored in the tem-porary location.
Microprocessors use the stack for storing the return address when handling subroutines. 
This is accomplished by pushing the return address into the stack every time a subroutine is 
466 Chapter 12
called. The return-from-subroutine instruction is accomplished by popping the stack to read the 
return address and transferring control to the program at this address.
Figure 12-9 demonstrates by example the process of subroutine call and return in an 8-bit 
microprocessor. Three separate portions of memory are shown: the main program, a subroutine program, and a memory stack. The computer is now executing the main program, with PC point-
ing at the instruction in location 3500. The subroutine program starts at location 2673, and the top of the stack is specified by SP at address 7803. This is shown in Fig. 12-9(a) with all ad-
dresses having hexadecimal values. The call-subroutine instruction has associated with it a two-byte address and each byte occupies one memory location. The last instruction of the subroutine in location 2686 has the operation code of the return-from-subroutine instruction. The top of the stack now contains a byte (designated by hexadecimal 46), but this is not important for the pres-ent discussion.
The execution of the call-subroutine instruction in the main program is carried out as fol-
lows: (1) The address associated with the instruction (2673) is transferred to PC. (2) The return 
address to the main program (3503) is pushed into the stack. The result of these two operations is shown in Fig. 12-9(b). PC now points at location 2673, which is the address of the first instruc-
tion in the subroutine. Return address 3503 is pushed into the stack and occupies two bytes of Main pr ogram
PC
SPCALL op-code
Next op-code26
733500 2673
350335023501
26867800
7803 46Stack
First op-code
RETURN op-codeSubr outineSubr outine
(a) Initial values
PC
SPCALL op-code
Next op-code26
733500 2673
350335023501
26867800
7803 46First op-code
RETURN op-codeSubr outine7801
7802 3503
(b) Alter execution of the CALL instruction
PC SPCALL op-code
Next op-code26
73
3503 7803 46First op-code
RETURN op-codeSubr outine
3503
(c) After execution of RETURN instruction
Figure 12.09 Numerical example for the call-subroutine and return-from-subroutine instruc-
tions
Microcomputer System Design  467 
memory. The computer now continues by executing the instructions in the subroutine program, 
since PC points at the first instruction of the subroutine.
When the last instruction of the subroutine is reached at address 2686, the computer exe-
cutes a return-from-subroutine instruction by popping the two top bytes in the stack and placing them into PC. The situation now is as depicted in Fig. 12-9(c). PC now holds address 3503 to 
continue the execution of the main program, and SP returns to its initial position.
The microprocessor shown in Fig. 12-5 executes the call-to-subroutine instruction by 
going through five memory cycles and six internal operations:
IR←M [PC], PC←PC + 1 read operation code
AR (H) ←M [PC], PC←PC + 1 read first byte of address
AR (L) ←M [PC], PC←PC + 1 read second byte of address
SP←SP−1, M [SP] ←PC(H) push first byte of return address
SP←SP−1, M [SP]←PC(L) push second byte of return address
PC←AR branch to subroutine address
The return-from-subroutine instruction is executed with three memory cycles and the updating of PC and SP:
IR ← M [PC], PC ← PC + 1 read operation code
PC (L) ← M [SP], SP ← SP + 1 pop second byte of address
PC(H) ← M [SP], SF ← SP + 1 pop first byte of address
The advantage of using a stack for storing the return address is that, when a subroutine is 
called, the return address is pushed into the stack automatically and the programmer does not have to be concerned with or remember where the return address is stored. If another subroutine is called by the current subroutine, the new return address is pushed into the stack, and so on. The return-from-subroutine instruction automatically pops the stack to obtain the return address from the last program that called it. Thus, the subroutine that exits is always the last subroutine that was called.
12.5.3 Interrupt
The concept of program interrupt is used to handle a variety of problems that arise out of normal program sequence. Program interrupt refers to the transfer of control from a currently running program to another service program as a result of an externally generated control signal. One of the control inputs in the microprocessor of Fig. 12-4 is labeled interrupt. Each interface module is capable of interrupting the microprocessors normal operation by providing a signal at this control input. The interrupt may be either a request for service or an acknowledgment of service performed earlier by the interface.
Consider, for example, the case of a microcomputer that is processing a large volume of 
data, portions of which are to be output to a printer. The microprocessor can output a byte of data within a few clock pulse intervals, but it may take the printer the equivalent of many processor clock pulses to actually print the character specified by the data byte. The processor could then remain idle, waiting until the printer can accept the next data byte. If an interrupt capability is available, the microprocessor can output a data byte and then continue to perform other data pro-cessing tasks. When the printer is ready to accept the next data byte, it can request an interrupt 
468 Chapter 12
via the interrupt control input. When the microprocessor acknowledges the interrupt, it suspends 
the currently running program and automatically branches to a service program that will output 
the next data byte. After the byte is sent to the printer, the processor returns to the program that was interrupted while the character is being printed.
The interrupt procedure is, in principle, quite similar to a subroutine call, except that the 
branch is initiated by an external signal rather than by an instruction in the program. As in a subroutine call, an interrupt stores the return address in the stack. A subroutine-call instruction provides the branch address for the subroutine. With an interrupt procedure, the branch address to the service routine must be provided by the hardware. The way a microprocessor chooses the branch address in response to an interrupt request varies from one unit to another. In principle, there are two methods for accomplishing this. One is called vectored and the other nonvectored 
interrupt. In a nonvectored interrupt, the branch address either is a fixed location in memory or is stored in a fixed location in memory. The interrupt cycle stores the return address from PC into 
the stack and then sets PC to the predetermined branch address. In a vectored interrupt, the inter -
rupting source itself supplies the branch information to the microprocessor. This information, transferred through the data bus, is called an interrupt vector. The interrupt cycle first stores the return address from PC into the stack. If the interrupt vector is an address, the microprocessor 
accepts it from the data bus and transfers it to PC. The interrupt vector in some microprocessors 
is assumed to be a subroutine-call instruction. The microprocessor accepts the instruction from the data bus, places it into its instruction register, and proceeds to execute it.
The return from the service routine back to the original interrupted program is similar to 
a subroutine return. The stack is popped and the return address previously stored there is trans-ferred to PC.
A microprocessor may have single or multiple interrupt input lines. If there are more inter -
rupt sources than there are interrupt inputs in the microprocessor, two or more sources are ORed together to form a common line for the microprocessor. An interrupt signal into a microprocessor may originate at any time during program execution. To ensure that no information is lost, the microprocessor acknowledges the interrupt only after the execution of the current instruction is completed and if the state of the processor warrants it. Figure 12-10 shows a possible vectored interrupt configuration. The diagram shows four sources ORed to a single interrupt-request in-put. The microprocessor has within it an interrupt enable (IEN) flip-flop that can be set or cleared 
with program instructions. When IEN is cleared, the interrupt request is neglected. If IEN is set 
and the microprocessor is at the end of instruction execution, the microprocessor acknowledges the interrupt by enabling 1NTACK. The interrupt source responds to INTACK by placing an inter -
rupt vector into DBUS. The program controlled IEN flip-flop allows the programmer to decide 
whether to use the interrupt facility or not. If an instruction to clear IEN has been inserted in the 
program, it means that the programmer does not want the program to be interrupted. (IEN is also 
cleared with a reset signal.) An instruction to set IEN indicates that the interrupt facility will be 
used while the program is running. Some microprocessors use an interrupt mask bit in the status register instead of a separate IEN flip-flop.
Assume that the interrupt vector supplied to the data bus is an 8-bit address. The micropro-
cessor responds to an interrupt request by performing the following operations:
SP ← SP + 1, M [SP] ← PC (H)  push first byte of return address
SP ← SP + 1, M [SP] ← PC (L)  push second byte of return address
Microcomputer System Design  469 
1NTACK ← 1  enable interrupt acknowledge
PC (H) ← 0, PC (L) ← DBUS  transfer vector address to PC
IEN ← 0  disable further interrupts
In this manner, the interrupt source can specify any vector address from 0 to 255 to serve as the 
branch address to a service routine. IEN is cleared to disable further interrupts. The programmer 
can set IEN in the service program whenever it is appropriate to enable further interrupts.
The return from the interrupt is similar to a return from subroutine. The stack is popped and 
the return address is transferred to PC.
12.5.4 Priority Interrupt
In the preceding discussion, a method for generating the vector address of an interrupt service routine was described. If there is only one source capable of requesting service, the source of the interrupt is known and the service program can immediately begin the service routine. More often, several devices are allowed to originate interrupt requests, and the first task of the interrupt routine is to identify the source of the interrupt. There is also the possibility that several sources will simultaneously request service. In this case, the service program must also decide which source to service first.
The most common method of handling multiple interrupts is to begin the service routine 
by polling the interfaces to identify the one that generated the request. The service routine tests 
each source in sequence to find out if its interrupt signal is on. Once an interrupt is identified, all other interrupts are neglected until the service routine for the particular source is completed.Microprocessor
   End of
instruction
 executionInterrupt sour ce
Interrupt
Interrupt
  vector   Inte rrupt
acknowledge
Interrupt
 Enab le(INTACK)
IEN
INTACK(DBUS)request1 2
4 3
Figure 12.10 Vectored interrupt configuration
470 Chapter 12
A priority interrupt is an interrupt system that establishes a priority over the various sources 
to determine which condition is to be serviced first when two or more requests arrive simultane-
ously. Establishing the priority of simultaneous interrupts can be done by software or hardware. In the software method, there is only one vector address for all interrupts. The service program begins at the vector address and polls the interrupt sources in sequence. The order in which the sources are tested determines the priority of each interrupt request. The highest-priority source is tested first and if its interrupt signal is on, control branches to a service routine for this source. Otherwise, the next lower-priority source is tested, and so on. Thus, the initial service routine for all interrupts consists of a program that tests the interrupt sources in sequence and branches to one of many possible service routines. The particular service routine reached belongs to the highest-priority source among all sources than can interrupt the processor.
Software techniques can, in theory, handle any number of interrupt sources to any sophis-
ticated level of priority. In practice, if there are many sources of interrupt requests, the time required to poll them to find the appropriate interrupt can exceed the time available to service the I/O device. In this situation, an external hardware priority interrupt unit can be used to speed up the operation.
A hardware priority interrupt unit functions as an overall manager in an interrupt system 
environment. It accepts interrupt requests from many sources, determines which of the incoming requests is of the highest priority, and issues an interrupt to the processor based on this deter -
mination. To speed up the operation, each interrupt source has its own vector address to access directly to its own service routine. Thus, no polling is required because all the decisions are established by the hardware priority interrupt unit.
The basic circuit that implements the hardware priority function is a priority encoder. The 
logic of the priority encoder is such that, if two or more input levels arrive at the same time, then the input having the highest priority will take precedence. The output of the priority encoder gen-erates a partial address for the interrupt vector that supplies the branch address. The truth table of a four-input priority encoder is given in Table 12-4. The X’ sin the table designate don’t-care conditions. Input I
0 has the highest priority; so regardless of the values of other inputs, when this 
input is 1 the output generates the partial address xy= 00. I1 has the next priority level. The out-
put is 01 if I1 = 1 provided I0 = 0, regardless of the values of the other two lower-priority inputs. 
The partial address for I2 is generated only if higher-priority inputs are 0, and so on down the 
Table 12-4 Priority encoder truth table
Input
(Interrupt source)Outputs
(Partial address) (Interrupt request)
I0     I1     I2     I3x     y R
1     X     X     X 0     0 1
0     1     X     X 0     1 1
0     0     1     X 1     0 1
0     0     0     1 1     1 1
0     0     0     0 X     X 0
Microcomputer System Design  471 
priority level. The priority levels dictate that a low-level input generates its own partial address 
only if all higher-level inputs are not asking for service. An interrupt request R is generated for 
the microprocessor only when one or more inputs are requesting an interrupt. If all inputs are 0, the R output becomes 0 and the partial address at this time is of no consequence because it will 
not be used by the microprocessor. Usually a microprocessor will have more than four interrupt sources. A priority encoder with eight inputs, for example, will generate a partial address of three bits. The partial address out of the encoder is used to form the vector address for each interrupt source. For example, the vector address supplied to the data bus after an interrupt acknowledge can be of the form:
000 xy 000
where x and y are the output bits from the priority encoder. The particular xy bits transferred 
will belong to the highest-priority interrupt source. By this procedure, the priority encoder can specify one of four possible branch addresses. Each vector address specifies the beginning ad-dress of an 8-byte service routine in the lower 32 bytes of memory.
12.6 Memory Organization
A microprocessor must communicate with memory, both RAM and ROM, to read and write binary information such as instructions, data, and addresses. The size of the memory attached to a microprocessor depends on the number of instructions and data bytes needed for the particular application. A microprocessor may have an address bus with 16 lines to accommodate up to 64K bytes of memory. In many applications, the amount of memory needed may be less than 64K bytes. RAM and ROM chips are available in a variety of sizes and the individual chips must be interconnected to form a required memory size.
12.6.1 RAM and ROM Chips
A RAM chip is better suited for communicating with a microprocessor if it has one or more con-trol inputs for selecting and enabling the unit only upon request. Another convenient feature is a bidirectional data bus to avoid inserting external bus buffers between the RAM and the data bus. The block diagram of a RAM chip suited for microcomputer applications is shown in Fig. 12-11. The capacity of the memory is 128 words of 8 bits each. This requires a 7-bit address and an 8-bit bidirectional data bus. The read and write inputs specify the memory operation, and the two chip select (CS) control inputs are for enabling the chip only when it is selected by the microprocessor. The availability of more than one control input to select the chip facilitates the decoding of the address lines when multiple chips are used in the microcomputer. The read and write inputs are sometimes combined into one line labeled R/W.  When the chip is selected, the two binary states 
in this line specify the two operations of read and write.
The function table listed in Fig. 12-11(b) specifies the operation of the RAM chip. The unit 
is in operation only when CS1= 1 and 
CS2 = 0. The bar on top of the second select variable indi-
cates that this input is enabled when it is 0. If the chip select inputs are not enabled, or if they are enabled but the read and write inputs are not enabled, the memory is inhibited and its data bus is in a high-impedance state. When CS1 = 1 and 
CS2 = 0, the memory can be placed in a write 
or read mode. When the WR input is enabled, the memory stores a byte from the data bus into a 
location specified by the address input lines. When the RD input is enabled, the contents of the 
472 Chapter 12
selected byte are placed on the data bus. The RD and WR signals control the memory operation 
as well as the bus buffers associated with the bidirectional data bus.
A ROM chip is organized externally in a similar manner. However, since a ROM can only 
read, the data bus can only be in an output mode. The block diagram of a ROM chip is shown in 
Fig. 12-12. For the same-size chip, it is possible to have more bits of ROM than of RAM, because the internal binary cells in ROM occupy less space than in RAM. For this reason, the diagram specifies a 512-byte ROM. whereas the RAM has only 128 bytes.
The nine address lines in the ROM chip specify any one of the 512 bytes stored in it. The 
two chip select inputs must be CS1 = 1 and 
CS2 = 0 for the unit to operate. Otherwise, the data 
bus is in a high-impedance state. There is no need for a read or write control because the unit can only read. Thus, when the chip is enabled by the two select inputs, the byte selected by the address lines appears on the data bus.
12.6.2 Memory Address Map
The designer of a microcomputer system must calculate the amount of memory required for the particular application and assign it to either RAM or ROM. The interconnection between memory and microprocessor is then established according to the size of memory needed and the types of RAM and ROM chips available. The addressing of memory can be established by means of a table that specifies the memory address assigned to each chip. The table, called a memory 
address map, is a pictorial representation of assigned address space for each chip in the system.
To demonstrate with an example, assume that a microcomputer system needs 512 bytes of 
RAM and 512 bytes of ROM. The RAM and ROM chips to be used are specified in Figs. 12-11 
128 × 8
  RAM8-bit data busCS1
CS2
RD
WR
AD7Chip select 1
Chip select 2
Read
Write
7-bit addr ess
(a) Block diagram
CS1 ��� RD WR Memory function State of data bus
0 0 X X Inhibit High-impedance
0 1 X X inhibit High-impedance
1 0 0 0 Inhibit High-impedance
1 0 0 1 Write Input data to RAM
1 0 1 X Read Output data from RAM
1 1 X X Inhibit High-impedance
(b) Function table
Figure 12.11 Typical RAM chip
Microcomputer System Design  473 
and 12-12. The memory address map for this configuration is shown in Table 12-5. The compo-
nent column specifies whether a RAM or a ROM chip is used. The hexadecimal address column assigns a range of hexadecimal equivalent addresses for each chip. The address bus lines are listed in the third column. Although there are 16 lines in the address bus, the table shows only 10 lines because the other 6 are not used in this example and are assumed to be zero. The small x’ s under the address bus lines designate those lines that must be connected to the address inputs in each chip. The RAM chips have 128 bytes and need 7 address lines. The ROM chip has 512 bytes and needs 9 address lines. The x’ s are always assigned to the low-order bus lines—lines 1 through 7 for the RAM and lines 1 through 9 for the ROM. It is now necessary to distinguish between four RAM chips by assigning to each a different address. For this particular example, we choose bus lines 8 and 9 to represent four distinct binary combinations. Note that any other pair of unused bus lines can be chosen for this purpose. The table clearly shows that the 9 low-order bus lines constitute a memory space for RAM equal to 2
9= 512 bytes. The distinction between 
a RAM and ROM address is done with another bus line. For this purpose, we choose line 10. When line 10 is 0, the microprocessor selects a RAM, and when this line is 1, it selects the ROM.
The equivalent hexadecimal address for each chip is obtained from the information under 
the address bus assignment. The address bus lines are subdivided into groups of four bits each so that each group can be represented with a hexadecimal digit. The first hexadecimal digit rep-resents lines 13-16 and is always 0. The next hexadecimal digit represents lines 9-12, but lines 11 and 12 are always 0. The range of hexadecimal addresses for each component is determined from thex’ s associated with it. These x’s  represent a binary number that can range from an all-0’ s 
to an all-1’ s value.512 × 8
  ROM8-bit data busCS1
CS2
AD9Chip Select 1
Chip Select 2
9-bit addr ess
Figure 12.12 Typical ROM chip
Table 12-5 Memory address map for microprocomputer
Hexadecimal addressAddress bus
Component 10 9 8 7 6 5 4 3 2 1
RAM 1 0000−007F 0 0 0 x x x x x x x
RAM 2 0080−00FF 0 0 1 x x x x x x x
RAM 3 0100−017F 0 1 0 x x x x x x x
RAM 4 0180−01FF 0 1 1 x x x x x x x
ROM 0200−03FF 1 x x x x x x x x x
474 Chapter 12
12.6.3 Memory Connection to Microprocessor
RAM and ROM chips are connected to a microprocessor through the data and address buses. The 
low-order lines in the address bus select the byte within the chips, and other lines in the address bus select a particular chip through its chip select inputs. The connection of memory chips to the microprocessor is shown in Fig 12-13. This configuration gives a memory capacity of 512 bytes of RAM and 512 bytes of ROM. It implements the memory map of Table 12-5. Each RAM receives the 7 low-order bits of the address bus to select one of 128 bytes possible.The particular RAM chip selected is determined from lines 8 and 9 in the address bus. This is done through a  
2 × 4 decoder whose outputs go to the CS1 inputs in each RAM chip. Thus, when address lines 8 
and 9 are equal to 00, the first RAM chip is selected. When 01, the second RAM chip is selected, and so on. The RD and WR outputs from the microprocessor are applied to the inputs of each 
RAM chip.
The selection between RAM and ROM is achieved through bus line 10. The RAMs are 
selected when the bit on this line is 0, and the ROM, when the bit is 1. The other chip select input in the ROM is connected to the RD control line for the ROM chip to be enabled only during a read operation. Bus lines 1-9 are applied to the input address of ROM without going through the decoder. This assigns addresses 0-511 to RAM and 512−1023 to ROM. The data bus of the ROM has only an output capability, whereas the data bus connected to the RAMs can transfer informa-tion in both directions.
The example just shown gives an indication of the interconnection complexity that can ex-
ist between memory chips and the microprocessor. The more chips connected, the more external decoders are required for selection among the chips. The designer must establish a memory map that assigns addresses to the various chips from which the required connections are determined. Since microprocessors also communicate with interface units, it is necessary to assign addresses to each interface as well. The communication between the microprocessor and interface is dis-cussed in the next section.
12.7 Input-output Interface
An interface chip is an LSI component that provides the communication link between a micro-processor and an I/O device. When in the output mode, the interface receives binary information from the data bus at the microprocessor rate and mode of transfer and transmits it to an external device at the device rate and mode of transfer. The interface behaves in a similar manner in the in-put mode, except that the direction of transfer is in the opposite direction. An interface consists of a number of registers, selection logic, and control circuits that implement the required transfers. Interface logic is sometimes included within a RAM or ROM chip to provide an LSI component that includes both memory and interface capabilities within one IC package.
Most LSI interface components can be programmed to accommodate a variety of combina-
tions of operating modes. The microprocessor, through program instructions, transfers a byte to a control register inside the interface unit. This control information puts the interface in one of the possible modes suitable for the particular device to which it is attached. By changing the control byte, it is possible to change the interface characteristics. For this reason, LSI interface units are often said to be programmable. The instructions that transfer control information into a program-
mable interface are included in the microcomputer program and they initialize the interface for a particular mode of operation.
Microcomputer System Design  475 
Data bus 
AD7RDCS1
WRCS2
128 × 8
RAM 1Data
AD7RDCS1
WRCS2
128 × 8
RAM 2Data
AD7RDCS1
WRCS2
128 × 8
RAM 3Data
AD7RDCS1
WRCS2
128 × 8
RAM 4Data
AD9CS1
CS2
512 × 8
  ROMData1RDWR
981-73028 7-1 16-11 910Address bu sMicroprocessor 
Decoder 
Figure 12-13 Memory connection to the microprocessor
476 Chapter 12
Manufacturers of microprocessors supplement their product with a set of interface chips 
suitable for communication between the microprocessor and a variety of standard input and out-
put devices. Interface components are usually designed to operate with a particular microproces-sor system bus with no additional logic besides address decoding. There are a variety of interface components in commercial use and each can be classified to be in one of four categories:
1. A parallel peripheral interface transfers data in parallel between the microprocessor and 
a peripheral device.
2. A serial communication interface converts parallel data from the microprocessor into 
serial data for transmission and converts incoming serial data into parallel data for recep-tion by the microprocessor.
3. A special dedicated interface is constructed to communicate with one particular input-
output device, or can be programmed to operate with a particular device.
4. A direct memory access (DMA) interface is used for transferring data directly between 
an external device and memory. The bus buffers in the microprocessor are disabled and go into a high-impedance state during DMA transfer.
Commercial interface units may have different names from the ones listed here. Moreover, 
the internal and external characteristics vary considerably from one commercial unit to another. In this section, we discuss the common properties of interface components and explain in gen-eral terms the various modes of transfer that they provide. The direct memory access transfer is discussed in the next section.
12.7.1 Communication with Microprocessor
Large computers quite often use separate buses in the CPU to communicate with memory and I/O interface. An I/O bus in large computers consists of a data bus and an address bus similar to the buses that communicate with memory. The I/O data bus transfers information to and from the external devices, and the I/O address bus is used to select a particular I/O device through its interface. The number of address lines in an I/O bus is smaller than in a memory bus because there are fewer I/O units to select than words in the memory system.
A microprocessor has a limit to the number of terminals that can be accommodated in the 
IC package. There are just not enough pins in a microprocessor chip to provide separate buses for communicating separately with memory and I/O. Invariably, all microprocessors use a common bus system for selecting memory words and interface units. If an interface chip has a number of registers, each register is selected by its own address just as a memory word is selected. The microprocessor bus does not distinguish between an interface register and a memory word. It is the responsibility of the user, through program instructions, to specify the appropriate address that will select one or the other. There are two ways that addresses can be assigned for selecting both memory and interface registers. One method is called memory-mapped I/O and the other is 
called isolated I/O.
In the memory-mapped I/O method, the microprocessor treats an interface register as be-
ing part of the memory system.The assigned addresses for interface registers cannot be used for memory words, thus reducing the memory space available. In a memory-mapped I/O organiza-tion there are no input or output instructions because the microprocessor can manipulate I/O data 
Microcomputer System Design  477 
residing in interface registers with the same instructions that are used to manipulate memory lo-
cations. Each interface is organized as a set of registers that respond to read and write commands in the normal address space of the microprocessor. Typically, a segment of the total address space is reserved for interface registers, but in general, they can be located at any address as long as there is not also a memory word that corresponds to that address.
The memory-mapped I/O organization is convenient for systems that do not need all the 
memory space available from the address bus lines. A microprocessor with a 16-bit address bus that requires a memory of less than 32K bytes can use the other 32K addresses available on the bus to access interface registers. A specific configuration for a memory-mapped I/O can be im-plemented by modifying slightly the address connections shown in Fig. 12-13. Address line 11 in the diagram is not used to access memory. We now let this line distinguish between memory and interface so that when the bit in this line is 1, the address bus selects a memory word, but when the bit is 0, it selects an interface register. To accomplish this new condition, each line going into CS1 in the RAMs and ROM in Fig. 12-13 must be ANDed with the bit from address line 11. The chip select inputs of all interface units must be conditioned on the complement value of line 11, in addition to their assigned address.
With the isolated I/O organization, the microprocessor itself specifies whether the address 
on the address bus is for a memory word or for an interface register. This is done by means of one or two additional control lines provided with the microprocessor. For example, a microprocessor may have an output control line labeled M/IO. When M/IO = 1, it is signifies that the address in 
the address bus is for a memory word. When M/IO = 0, the address is for an interface register. This control line must be connected to the chip select inputs of RAM, ROM, and interface chips in a similar fashion as bus line 11 was connected in the previous example for the memory-mapped I/O case.
In the isolated I/O organization, the microprocessor must provide distinct input and output 
instructions, and each of these instructions must be associated with an address. When the mi-croprocessor fetches and decodes the operation code of an input or output instruction, it reads the address associated with the instruction and places it on the address bus. At the same time it makes control line M/IO equal to 0 to inform the external components that this address is for an 
interface and not for memory. Thus, during a fetch cycle or a memory-reference execute cycle, the microprocessor enables the read or write control and sets the M/IO line to 1. During the 
execution of an input or output instruction, the microprocessor enables the read or write control and sets the M/IO line to 0.
The isolated I/O method isolates memory and I/O addresses so that memory space is not 
affected by the interface address assignment. Because of this isolation, the full address space available by the address bus is unaffected by interface addressing as in the memory-mapped I/O method.
12.7.2 Parallel Peripheral Interface
A parallel peripheral interface is an LSI component that provides a path for transferring binary information in parallel between the microprocessor and a peripheral device. An interface chip normally contains two or more I/O ports that communicate with one or more external devices, and a single interface to communicate with the microprocessor bus system. The block diagram of a typical parallel peripheral interface is shown in Fig. 12-14. It consists of two ports. Each port has two registers, an 8-bit I/O bus, and a pair of lines labeled handshake. The information 
478 Chapter 12
stored in the control register specifies the port’ s mode of operation. The port data register is used 
for transferring data to and from the data bus and the I/O bus.
The interface communicates with the microprocessor through the data bus and the chip 
select and read/write control. A circuit must be inserted externally (usually an AND gate) to detect the address assigned to the interface. This circuit enables the chip select input when the interface is selected through the address bus. Two register select inputs, RS1and RS2 are usually 
connected to the lowest-order lines of the address bus. These two inputs select one of the four registers in the interface, as specified in the table accompanying the diagram. The contents of the selected register are transferred into the microprocessor through the data bus when the RD input 
is enabled. The microprocessor loads a byte into the selected register through the data bus when the WR input is enabled. The interrupt output is used for interrupting the microprocessor, and the 
reset input is for resetting the interface after power is turned on.
The microprocessor initializes each port by transferring a byte to its control register. By 
loading appropriate bits into a control register at system initialization, the program can define the mode of operation of the port. The characteristic of the port depends on the commercial unit used. In most cases, each port can be placed in an input or output mode. This is done by transfer -
ring bits in the control register that specify the direction of transfer in the bus buffers that drive    Bus
 buffers Data bus 
Port A dat a
   regist er Internal b us RS1
RDCS
WRRS2 Chip select
     and
read/wri te
   contr olPort B dat a
   regist erPort A contr ol
    regist er
Port B contr ol
    regist erInterrupt
ResetI/O b us 
I/O b us Handshake  lines
Handshake  lines
CS RS1 RS2 Register selected
0 X X None – data bus in high-impedance
1 0 0 Port A data register
1 0 1 Port A control register
1 1 0 Port B data register
1 1 1 Port B control register
Figure 12-14 Block diagram of parallel peripheral interface
Microcomputer System Design  479 
the bidirectional I/O bus. In addition, the port can be made to function in a variety of operating 
modes. Three operating modes found in most interface chips are:
1. Direct transfer without handshake lines.
2. Transfer with handshaking.
3. Transfer with handshaking using interrupt.
An interface is placed in a direct-transfer mode of operation when the device attached to the 
I/O bus is always ready to transfer information: The handshake lines are not used in this mode, and some interface chips have a programming mode to convert these lines into data transfer lines. The direct transfer can operate in an input or output mode. In the input mode, a read operation transfers the contents of the I/O bus to the microprocessor data bus. In the output mode, a write operation transfers the contents of the data bus to the selected port data register. The received byte is then applied to the I/O bus. Direct input or output transfers are useful only if valid data can reside in the I/O bus for a long time compared with the microprocessor instruction execution time. If I/O data can be valid only for a short time, the interface must operate in the handshake mode.
Handshake lines are used to control the transfer between two devices operating asynchro-
nously with each other, i.e., when they do not share a common clock. Handshaking is a common-ly used procedure and is not restricted to interface chips alone. Two handshake lines, connected between a source device and a destination device, control the transfer by informing each other of the status of the transfer through a common bus. The source device informs the destination through one of the handshake lines when valid information is available on the bus. The destina-tion device responds by enabling the second handshake line when the information on the bus has been accepted. Figure 12-14 shows two handshake lines in each port. One is an output line and the other is an input line. It is customary to refer to these lines with symbols, but the symbols adopted are always different in different commercial units. Because of the variety of symbols used to designate these lines, we prefer not to adopt one symbol over another, but refer to the two lines as the output or input handshake line. The input handshake line would normally set a bit in the control register inside the interface. We will call this bit a flag , realizing that the register that 
holds the flag bit (the control register in this case) can be read by the microprocessor to check the status of the transfer. The flag bit is automatically cleared by the interface after a read or write operation associated with the corresponding data register.
The detailed handshake sequence for a particular commercial interface chip is specified in 
timing diagrams accompanying the product specifications. Because of the variety of procedures encountered in practice, it would be better to explain the handshake method in general terms without a preference for one specific method. The transfer with handshaking depends on whether the port is in an output or input mode.
In the output handshake mode, the microprocessor writes a byte into the interface port data 
register. The interface then enables the output handshake line to inform the external device that a valid byte is available on the I/O bus. When the external device accepts the byte from the I/O bus, it enables the input handshake line. This sets a flag bit in the control register. The microproces-sor reads the register containing the flag bit to determine if the transfer was completed. If so, the microprocessor can write a new byte into the data register of the interface port. Writing data into a given port automatically clears the flag bit associated with the output transfer. The process now can be repeated to output the next byte.
480 Chapter 12
In the input handshake mode, the external device places a byte on the I/O bus and enables 
the interface input handshake line. The interface transfers the byte into its data register and also 
sets a flag bit in the control register. The microprocessor reads the register containing the flag bit to determine if an input transfer is requested. If the flag bit is set, the microprocessor reads the byte from the port data register and clears the flag bit. The interface then informs the device attached to the I/O bus, through the output handshake line, that a new byte can now be accepted. Once the output device has been informed that the interface is ready, it can initiate the transfer of the next byte by enabling the input handshake again.
In the handshake method just described, the microprocessor must periodically read the con-
trol register to check the status of the flag bit. If there are-a number of ports attached to the mi-croprocessor, it would be necessary to poll them in succession to determine the ones that require a transfer. This is a time-consuming operation that can be avoided if the interface is initialized to operate in the interrupt mode. The interrupt output shown in Fig. 12-14 is then used to request an interrupt from the microprocessor. Most commercial units provide a separate interrupt line for each port in the interface. Every time a flag is set in the port, the interrupt request belonging to the port is automatically enabled to inform the microprocessor that a transfer is to be initiated. The microprocessor responds to the interrupt signal from the port that requested the action and transfers the byte of data to or from the interface port data register.
12.7.3 Serial Communication Interface
An I/O device may transfer binary information either in parallel or serially. In parallel transmis-sion, each information bit uses a separate line so that the n bits of an item can be transmitted 
simultaneously. For example, a parallel peripheral device can transmit a word of 16 bits all at once through two 8-bit buses of a parallel peripheral interface. In serial transmission, the bits of a word are transmitted in sequence, one bit at a time, and through a single line. Parallel transmis-sion is faster but requires many lines. It is used for short distances and where speed is important. Serial transmission is slower but less expensive, since it requires only one line. Binary informa-tion transmitted from remote terminals through telephone wires or other communication media is of the serial type, because it would be expensive to subscribe to or lease a large number of lines. Examples of communication terminals are teletypewriters, CRT terminals, and remote computing devices,
The serial binary information transmitted to and from a terminal consists of binary-coded 
characters. The characters may represent alphanumeric information or control characters. The alphanumeric characters are referred to as text and include the letters of the alphabet, the decimal 
digits, and a number of graphic symbols such as period, plus, and comma. The control characters are used for the layout of printing or for specifying the format of the transmitted message. The number of bits assigned to each character code may be between five and eight, depending on the terminal.
The block diagram of a serial communication interface is shown in Fig. 12-15. It functions 
both as a transmitter and as a receiver and can be programmed to operate in a variety of transmis-sion modes. The interface is initialized for a particular serial-transfer mode by means of a control byte which is loaded into its control register. The transmitter register accepts a data byte from the microprocessor through the data bus. This byte is transferred to a shift register for serial trans-mission. The receiver portion receives serial information into another shift register, and when a complete data byte is accumulated, it is transferred to the receiver register. The microprocessor 
Microcomputer System Design  481 
can select the receiver register to read the byte through the data bus. The bits in the status register 
are used to set input and output flags and to detect certain errors that may occur during the trans-mission. The microprocessor can read the status register to check the status of the flag bits and to determine if any errors have occurred.
The chip select and read/write control lines communicate with the microprocessor. The chip 
select (CS) input is used to select the interface. The register select (RS) is associated with the RD and WR controls. Two registers accept information during a write operation and the other two 
supply information during a read operation. The register selected is then a function of the RD and 
WR status, as shown in the table accompanying the diagram.
The transmitter and receiver have a clock input to synchronize the bit rate at which the se-
rial information is transferred. The transmit data line is connected to a remote receiver and the receive data line comes from a remote transmitter. If the clock is also connected to the remote terminal, the transmission is said to be synchronous. If the clock is not shared with the remote 
terminal, the transmission is said to be asynchronous.
In the synchronous serial mode of transmission, the local and remote transmitter and receiv-
er share a common clock. Bits are sent from the transmitter at equal intervals of time determined by the rate of the clock pulses. Since the receiver shares a common clock with the transmitter, it accepts the bits at the same clock rate. In asynchronous transmission, the two sides do not share    Bus
 buffers Data bus 
Transmit ter
   Regist er Internal b us RS
RDCS
WRChip select
     andread/wri te
  contr ol Status
regist er 
Receive r
regist er Control
regist er 
  Shift
regist er Transmit ter
   contr ol
and cloc k
Receiv er
 contr ol
and cloc k  Shift
regist er 
Reset Transmit 
Data clock 
clock data 
Transmit ter 
Receive r
Receive
CS RS Operation Register selected
0 X X None
1 0 WR Transmitter register
1 1 WR Control register
1 0 RD Receiver register
1 1 RD Status register
Figure 12-15 Block diagram of a typical serial communication interface
482 Chapter 12
a common clock. The interface transmitter and receiver clocks are supplied with a local clock 
rate that specifies the transfer rate of the remote communication terminal to which the interface is attached.
A common problem associated with serial transmission is concerned with framing the char -
acters in a string of continuous bits. The transmitter and receiver can be programmed to recog-nize the number of bits in each character in the remote terminal. There remains the problem of detecting the first bit in each character so that a count can start to frame the next character. The way characters are framed in serial transmission depends on whether the mode of transfer is synchronous or asynchronous.
In synchronous serial transmission, one communication control character, called the sync 
character, is chosen to serve as a synchronizing agent between the transmitter and receiver. For example, when the 7-bit ASCII code is used with an odd-parity bit at the most significant posi-tion, the assigned sync character has the 8-bit code 00010110. When the transmitter starts send-ing 8-bit characters, it sends a few sync characters first and then sends the actual message. The initial continuous string of bits accepted by the receiver is checked for a sync character. In other words, with each clock pulse, the receiver checks the last eight bits received. If they do not match the bits of the sync character, the receiver accepts one more bit, rejects the previous high-order bit, and checks again the last 8 bits received for a sync character. This is repeated after each clock pulse and bit received until a sync character is recognized. Once a sync character is detected, the receiver has framed a character. From here on, the receiver counts every eight bits and ac-cepts them as a single character. Usually the receiver checks two consecutive sync characters to remove any doubt that the first sync character did not occur as a result of a noise signal on the line. Moreover, when the transmitter is idle and does not have any message characters to send, it sends a continuous string of sync characters. The receiver recognizes all sync characters as a condition for synchronizing the line and goes into a synchronous idle state. In this state, the two units maintain synchronism while no meaningful message is being communicated.
The standard procedure just described dictates that the transmitter in a synchronous com-
munication interface be designed to send sync characters at the beginning of transmission and also when no characters are available from the microprocessor. The receiver in a synchronous communication interface must frame eight consecutive bits into characters and must be able to identify certain character codes such as the sync character. When the receiver recognizes sync characters, they are used to maintain synchronism with the transmitter; but sync characters are not sent to the microprocessor.
The standard procedure for framing characters during asynchronous transmission is to send 
at least two additional bits with each character. These additional bits are called the stop and start 
bits. For example, a teletype unit uses an 8-bit character code but sends 11 bits for each character transmitted. The first bit is the start bit. This is followed by the 8 bits of the character and then by two stop bits. The convention in this terminal is that it rests in the 1-state when no character is transmitted. The first bit is always 0 and represents the start bit to indicate the beginning of a character. The receiver can detect the start bit when the line goes from 1 to 0. A clock in the receiver knows the transfer rate and the number of character bits to expect. After the 8 bits of the character are received, the receiver checks for two stop bits which are always in the 1-state. The length of time the line stays in the 1 (stop)-state depends on the amount of time required for the terminal to resynchronize. A teletype requires two stop bits. Other terminals use just one stop bit, and some use a one-and-a-half bit time for the stop period. The line remains in the 1-state until another character is transmitted. Figure 12-16 shows the 11 bits of a typical character from 
Microcomputer System Design  483 
a teletype. After the two stop bits have been transmitted, the line may go to 0, indicating a start 
bit for a new character. The line will stay in the 1-state if no other character follows immediately.
The standard procedure just described dictates that the transmitter in an asynchronous com-
munication interface inserts the start and stop bits prior to the serial transmission. The receiver must recognize the start and stop bits to frame the character. The receiver must also isolate the information bits for transfer to the microprocessor.
The standard framing procedures are incorporated with any serial communication interface. 
A serial communication interface may be asynchronous only, synchronous only, or both synchro-nous and asynchronous.
12.7.4 Dedicated Interface Components
In addition to the interface components that transfer information in parallel or serially, one can find in commercial use other interface chips that are dedicated to a particular interface applica-tion. A few of them are listed below.
Floppy disk controller
Keyboard and display interfacePriority interrupt controllerInterval timerUniversal peripheral interface
The floppy disk controller is an interface chip designed to control a small magnetic-disk 
storage device called floppy disk. The keyboard and display interface is suitable for scanning a 
matrix of keys to detect a closure and for driving a display of numeric or alphanumeric informa-tion. The priority interrupt controller facilitates the interrupt handling by establishing priorities and providing an interrupt vector for the microprocessor. An interval timer is a programmable counter that can be set to count for a given interval of time and to interrupt the microprocessor when the counter reaches a prescribed count.
A universal peripheral interface is an LSI component that acts as a slave I/O processor to 
the system CPU. It has its own processor, control logic, RAM, and ROM and in some ways re-sembles a microcomputer chip. Its function is to handle the operations of I/O devices rather than be involved in computational procedures.
The program stored in the ROM part of a universal peripheral interface is a dedicated, fixed 
program that handles the particular devices attached to it. The universal interface component is supervised by the program that is executed in the microprocessor. In essence, this is a two-processor configuration with the system CPU and the slave universal interface device operating in parallel.Start
  bit8 information bits2 stop
  bits1 1 1 1 0 0 0 0
Figure 12.16 Asynchronous serial transmission of a character
484 Chapter 12
12.8 Direct Memory Access
The transfer of data between a mass storage device, such as magnetic disk or magnetic tape, and 
system memory is often limited by the speed of the microprocessor. Removing the processor during such a transfer and letting the peripheral device manage the transfer directly to memory would improve the speed of transfer and make the system more efficient. This transfer technique is called DMA (direct memory access). During DMA transfer, the processor is idle; so it no lon-ger has control of the system bus. A DMA controller takes over the buses to manage the transfer directly between the peripheral device and memory.
The microprocessor may be made to idle in a variety of ways. The most common method 
is to disable the buses through a special control signal. Figure 12-17 shows two control signals useful for DMA transfer. The bus request (BR)input, when in the 1-state, is a request to the 
microprocessor to disable its buses. The microprocessor terminates the execution of its present instruction and then places its buses, including the RD (read) and WR (write) lines, into a high-
impedance state. When this is done, the processor places the bus granted (BG) output in the 1-state. As long as BG = 1, the microprocessor is idle and its buses are disabled. The processor 
returns to its normal operation after the BR line returns to 0 by returning its BG line to 0 and 
enabling its buses. The bus request line is sometimes called a hold command, and the bus granted 
a hold acknowledge.
As soon as BG = 1, the DMA controller can take control of the bus system to communicate 
directly with the memory. The transfer can be made for an entire block of memory words, sus-pending the processor operation until the whole block is transferred. The transfer can be made one word at a time in between microprocessor instruction executions. Such a transfer is called cycle stealing. The processor merely delays its operation for one memory cycle to allow the di-rect memory I/O transfer to steal one memory cycle.
The DMA controller needs the usual circuits of an interface to communicate with the mi-
croprocessor. In addition, it needs an address register, a byte count register, and a set of address lines. The address register and address lines are used for direct communication with the system RAM. The word count register specifies the number of words to be transferred. The data transfer is usually done directly between the peripheral device and memory under control of the DMA.
Figure 12-18 shows the block diagram of a typical DMA controller. The unit communicates 
with the microprocessor via the data bus and control lines. The registers in the DMA are selected by the microprocessor through its address lines by enabling CS (chip select) and RS (register 
select). The RD and WR lines in the DMA are bidirectional. With BG = 0, the microprocessor 
communicates with the DMA register through the data bus to read from or write into the DMA High-impedence
    (disab led)
     if BG = 1BGBR Bus r equestMicroprocessor
Bus grant edRD
WRDBUSABUS
Figure 12.17 Control signals for DMA transfer
Microcomputer System Design  485 
registers. When BG = 1, DMA can communicate directly with the memory by specifying an ad-
dress in the address bus and activating its RD or WR control. The DMA communicates with an 
external peripheral device through the request and acknowledge lines.
The DMA controller includes three registers: an address register, a byte count register, and a 
control register. The address register contains 16 bits that specify the desired location in memory. 
The address bits go through a bus buffer into the address bus. The address register is incremented after each DMA byte transfer. The byte count register holds the number of bytes to be transferred. This register is decremented after each byte transfer and internally tested for zero. The control register specifies the mode of transfer—whether it is into (write) or out of (read) memory. All registers in the DMA appear to the microprocessor as an I/O interface. Thus, the processor can read from or write into the DMA registers under program control via the data bus.
The DMA is first initialized by the microprocessor. After that, the DMA starts and contin-
ues to transfer data between memory and peripheral unit until an entire block is transferred. The initialization process is essentially a program consisting of I/O instructions that include the DMA address for selecting particular registers. The microprocessor initializes the DMA by sending the following information through the data bus:
1. The starting address of the memory block where data are available (for read) or where data are to be stored (for write).
2. The byte count, which is the number of bytes in the memory block.Data bu s
 buffers Data bus 
Address r egist er Address
    bu s
 buffers Address b us 
Byte count
   regist er
Control
regist er Control
  logic
Read/wri teDMA ac knowledgeDMA r equest
InterruptReset
Internal b us 
RS1
BRRDCS
BGRS2
WR
Figure 12.18 Block diagram of DMA controller
486 Chapter 12
3. Control bits to specify a read or write transfer.
4. A control bit to start the DMA.
The starting address is stored in the DMA address register. The byte count is stored in the DMA 
byte count register, and the control bits are stored in the DMA control register. Once the DMA is initialized, the microprocessor stops communicating with the DMA unless it receives an inter -
rupt signal or if it wants to check how many bytes have been transferred.
The position of the DMA controller among other components in a microcomputer system 
is illustrated in Fig. 12-19. The microprocessor communicates with the DMA controller through MicroprocessorRAM
Data bu s
Address bu sInterrupt
Read contr olData 
Write contr olAddress RDWR Address Data RDWRBRBG
Address
 detect
WR
RS
BRRD
CS
BGAddress Data Data 
DMA contr oller Peripheral
  device 
Read/wri teDMA ac know ledge DMA re quest
Figure 12.19 DMA transfer in a microcomputer system
Microcomputer System Design  487 
the address and data buses as with any interface unit. The DMA has its own address which acti-
vates the CS and RS lines. The microprocessor initializes the DMA through the data bus. Once 
the DMA receives the start control bit, it can start the transfer between the peripheral device and system RAM.
When the peripheral device sends a DMA request, the DMA controller activates its BR line, 
informing the processor to relinquish the buses. The microprocessor responds with its BG line, 
informing the DMA that its buses are disabled. The DMA then puts the current value of its ad-dress register onto the address bus, initiates the RD or WR signal and sends a DMA acknowledge 
to the peripheral device.
The peripheral device then puts a byte on the data bus (for write) or receives a byte from 
the data bus (for read). Thus, the DMA controls the read or write operation and supplies the address for the memory. The peripheral unit can then communicate with RAM through the data bus for direct transfer between the two units while the microprocessor is momentarily  
disabled.
For each byte that is transferred, the DMA increments its address register and decrements 
its byte count register. If the byte count register does not reach zero, the DMA checks the request line coming from the peripheral. For a high-speed peripheral, this line will be activated as soon as the previous transfer is completed. A second transfer is then initiated, and the process continues until the entire block is transferred. If the peripheral speed is slower, the DMA request line may come somewhat later. In this case, the DMA removes its bus request line so the microprocessor can continue to execute its program. When the peripheral requests a transfer, the DMA requests the buses again.
If the byte count register reaches zero, the DMA stops any further transfer and removes 
its bus request. It also informs the microprocessor of the termination by means of an interrupt request. When the microprocessor responds to the DMA interrupt, it reads the contents of the byte count register. The zero value of this register indicates that all the bytes were successfully transferred. The microprocessor can read this register at any other time as well to check the num-ber of bytes already transferred.
A DMA controller may have more than one channel. In this case, each channel has a DMA 
request/acknowedge pair of control signals and is connected to a separate peripheral device. Each channel also has its own address register and byte count register within the DMA. A priority among the channels may be established so that channels with high priority are serviced before channels with lower priority.
DMA transfer is very useful in many microcomputer system applications. It is used for 
fast transfer of information between floppy disks or magnetic-tape cassettes and system RAM. It is also useful for communication with interactive terminal systems having CRT screens or with television screens used for video games. Typically, an image of the screen display is kept in a memory which can be updated under processor control. The contents of the memory can be transferred to the screen periodically by means of DMA transfer.
A potential application for DMA is in a multiprocessor system forming a network of two or 
more processors. Communication between processors can be maintained with a shared memory that can be accessed by all processors. DMA is a convenient method for transferring information between the common memory and the various processors in the network.
488 Chapter 12
REFERENCES
1. Peatman, J. B., Microcomputer-Based Design. New Y ork: McGraw-Hill Book Co., 1977.
2. Klingman, E. K., Microprocessor Systems Design. Englewood Cliffs, N.J.: Prentice-Hall, Inc., 1977.
3. Hillburn, J. L. and P . N. Julich, Microcomputers/Microprocessors: Hardware, Software, and Applica-
tions. Englewood Cliffs, N.J.: Prentice-Hall, Inc., 1976.
4. Soucek, B., Microprocessors and Microcomputers. New Y ork: John Wiley & Sons, 1976.
5. Osborn. A., An Introduction to Microcomputers,V olume 1: Basic Concepts. Berkeley, Calif.: Adam 
Osborn and Associates, 1976.
6. Osborn, A., An Introduction to Microcomputers V olume 2: Some Real Products. Berkeley, Calif.: 
Adam Osborn and Associates, 1977.
7. McGlynn, D. R., Microprocessors Technology, Architecture and Applications, New Y ork: Jonn Wiley 
& Sons, Inc., 1976.
8. Intel 8080 Microcomputer Systems User’ s Manual. Santa Clara, Calif.: Intel Corp., 1975.
9. Wakerly, J. F ., “Microprocessor Input/Output Architecture.” Computer, V ol. 10, No. 2 (February, 
1977), pp 26−33.
10. Cosley, J., and S. Vasa,“Block Transfer with DMA Augments Microprocessor Efficiency.” Computer 
Design, V ol. 16, No. 1 (January, 1977), pp 81-85.
PROBLEMS
12-1. Microprocessors are typically categorized as being 4-bit, 8-bit, or 16-bit. What does the number of 
bits imply?
12-2. A microprocessor data bus has 16 lines and its address bus contains 12 lines. What is the maximum memory capacity that can be connected to the microprocessor? How many bytes can be stored in memory?
12-3. What is the difference between a microprocessor and a microcomputer? What is the difference between a single-chip microcomputer and a microprocessor chip?
12-4. Consider an 8-bit LSI component (memory or interface) with separate input and output data termi-nals and no internal bus buffers. Using external three-state buffers, show how the input and output 
terminals of the component should be connected to a bidirectional data bus.
12-5. A 16-bit microprocessor has a single 16-bit bus which is shared for transferring either a 16-bit address or a 16-bit data word. Explain why an external address latch or register would be required 
between the microprocessor and the address inputs of the memory. Formulate a possible set of control signals for communicating between the microprocessor and memory. List the sequence of transfers for a memory read and memory write.
12-6. Go over the list of instructions in Table 12-2 and indicate if the instruction occupies one, two, or three bytes.
12-7. The first instruction listed in Table 12-2 is a move instruction that transfers the contents of B to A. 
How many equivalent instructions are there for transferring the contents of register R1to R2, where 
R1or R2 is one of the registers A, B, C, D, E, F, or G? The source register can be the same as the 
destination register.
Microcomputer System Design  489 
12-8. Table 12-1 lists three add-to A instructions with different addressing modes. Extend the table to 
include the following addressing modes:
(a) Zero-page addressing.
(b) Relative addressing.
(c) Index addressing.
List the sequence of operations required to process each instruction.
12-9. The operation code of an instruction is stored in memory location (7128)16. The next byte in memory 
contains (FB)16. Where should the operand be stored in memory if the instruction has the following 
addressing mode?
(a) Zero-page addressing,
(b) Present-page addressing.
(c) Relative addressing.
12-10. Some microprocessors provide an internal (limited capacity) register stack within the microproces-
sor chip. Others provide a stack pointer register with access to memory for the stack. Discuss the 
advantages and disadvantages of each configuration.
12-11. If you are familiar with an electronic calculator that employs a stack for evaluating arithmetic ex-
pressions, explain how the stack mechanism operates when calculating the expression 3 × 4 + 5 × 6.
12-12. A subroutine return address can be stored in an index register instead of a stack. Discuss the advan-
tages and disadvantages of this configuration.
12-13. The top of the stack contains 5A and the next byte down the stack is 14 (alt numbers are in hexade-
cimal). The stack pointer contains 3A56. A call subroutine to location 67AE instruction (three bytes) 
is located at memory address 013F . What are the contents of PC, SP, and the stack?
(a) Before the call instruction is executed?
(b) After the call instruction is executed?
(c)  After the return from subroutine?
(d) After a second return from subroutine instruction following the one in (c)?
12-14. How would you sequence a program that needs two memory stacks maintained throughout the pro-
gram with a microprocessor that has only one stack pointer?
12-15. What is the fundamental difference between a subroutine call and an interrupt request? Is it possible 
to employ a common memory stack for both?
12-16. A microprocessor responds to an interrupt request by pushing into the stack not only the return 
address, but also the contents of processor registers that may be affected while servicing the inter -
rupt.
(a) List those registers from Fig. 12-5 whose contents should be pushed into the stack.
(b) How many memory cycles would it now take to execute an interrupt request?
12-17. Obtain the circuit of the four-input priority encoder whose truth table is specified in Table 12-4.
12-18. Specify the four vector addresses (in hexadecimal) when x and y of Table 12-4 are bits 4 and 5 of the 
low-order byte. All other bits of the byte are 0. The high-order byte is always FF .
12-19. (a)    How many 128 × 8 RAM chips are needed to provide a memory capacity of 2048 bytes?
(b)  How many lines of the address bus must be used to access 2048 bytes of memory? How many of these lines will be common to all chips?
(c)  How many lines must be decoded for chip select? Specify the size of the decoders.
490 Chapter 12
12-20. A ROM chip of 1024 × 8 bits has four select inputs and operates from a 5-volt power supply. How 
many pins are needed for the IC package? Draw a block diagram and label all input and output ter -
minals in the ROM.
12-21. Extend the memory system of Fig. 12-13 to 4096 bytes of RAM and 4096 bytes of ROM. List the 
memory-address map and indicate what size decoders are needed.
12-22. A microprocessor employs RAM chips of 256 ´ 8 and ROM chips of 1024 × 8. The microcomputer 
system needs 2K bytes of RAM, 4K bytes of ROM, and four interface units, each with four registers. A memory-mapped I/O configuration is used. The two highest-order bits of the address bus are as-
signed 00 for RAM, 01 for ROM, and 10 for interface registers.
(a)  How many RAM and ROM chips are needed?
(b)  Draw a memory-address map for the system.
(c)  Give the address range in hexadecimal for RAM, ROM, and interface.
12-23. An 8-bit microprocessor has a 16-bit address bus. The first 15 lines of the address are used to select 
a bank of 32K bytes of memory. The high-order bit of the address is used to select a register which receives the contents of the data bus. Explain how this configuration can be used to extend the me-
mory capacity of the system to 8 banks of 32K bytes each, for a total of 256K bytes of memory.
12-24. The interface of Fig. 12-14 is connected to the address bus of a microprocessor. The data register of 
port A is selected with a hexadecimal address XXXC, where the X’ s can be any number.
(a)  How should the address lines he connected to the chip select (CS) input?
(b)  What are the hexadecimal addresses that select the other three registers in the interface?
12-25. Consider the possibility of connecting a number of microprocessors to one common set of data and 
address buses. How can an orderly transfer of information be established between the microproces-sors and the common memory?
12-26. Write short notes on
(a) Bus buffer
(b) Memory cycle
(c) Addressing modes
(d) Interrupt(e) Memory stack
12-27. Differentiate between 
(a) Implied Mode and Register mode
(b) Immediate Mode and Direct addressing mode
(c) Zero-page addressing and present-page addressing
(d) RAM and ROM
(e) Direct transfer and transfer with handshaking in a parallel peripheral interface
(f) Synchronous and asynchronous serial transfer
12-28. What will accumulator register A and the status bits C (carry), S (sign), Z (zero), and V (overflow) 
contain after each of the following instructions? The initial value of register A in each case is (83)
16. 
Assume that all status bits are affected after an arithmetic or logic operation.
(a) CMA (2F)
(b) Exclusive-NOR the accumulator to itself 
(c) RLC (07)
(d) RRC (0F)
Microcomputer System Design  491 
12-29. Specify the number of bytes in instructions in each instruction and list the sequence of register trans-
fers that execute the following instructions from Table 12-2
Instruction Symbol Description Function
LXI FG, D16 Load register pair immediate FG ← D16
ORA B OR B to A A ← A∨B
DCX BC Decrement register pair BC BC ← BC-1
JMP AD16 Jump unconditionally PC ← AD16
CALL AD16 Call subroutine Stack ← PC, PC ← AD16
12-30. An electronic calculator that employs a stack for evaluating arithmetic expressions, explain  how the stack mechanism operates when calculating the expression (Division and multiplication have same precision)
6 ÷ 2 – 1 × 2
12-31. Derive the truth table of a 6 –input priority encoder.
12-32. A microprocessor uses RAM chips of 2048 × 1 capacity.
(a) How many chips are needed and how should their address lines be connected to provide a 
memory capacity of 2048 bytes?
(b) How many chips are needed to provide a memory capacity of 32K bytes? Explain in words how the chips are to be connected to the address bus.
13Chapter
Digital Integrated Circuits13.1 Introduction
The integrated circuit (IC) was introduced in Section 1-9, and the various IC digital logic fami-
lies were discussed in Section 2-8. This chapter presents the basic electronic circuits in each IC digital logic family and analyzes their electrical operation. A basic knowledge of electronics is assumed.
The IC digital logic families to be considered here are:
RTL Resistor-transistor logic
DTL Diode-transistor logic
I 
2 L Integrated-injection logic
TTL Transistor-transistor logic
ECL Emitter-coupled logic
MOS Metal-oxide semiconductor
CMOS Complementary metal-oxide semiconductor
The first two, RTL and DTL, have only historical significance since they are seldom used in 
new designs. RTL was the first commercial family to have been used extensively. It is included 
here because it represents a useful starting point for explaining the basic operation of digital gates. DTL circuits have been gradually replaced by TTL. In fact, TTL is a modification of the DTL gate. The operation of the TTL gate will be easier to understand after the DTL gate is discussed. The characteristics of TTL, ECL, and CMOS were presented in Section 2-8. These families have a large number of SSI circuits, as well as MSI and LSI circuits. I
2L and MOS are 
mostly used for constructing LSI functions.
The basic circuit in each IC digital logic family is either a NAND or a NOR gate. This basic 
circuit is the primary building block from which more complex functions are obtained. An RS latch is constructed from two NAND or two NOR gates connected back to back. A master-slave flip-flop is obtained from the interconnection of about ten basic gates. A register is obtained from the interconnection of flip-flops and basic gates. Each IC logic family has available a catalog of integrated-circuit packages that provide various digital logic functions. The differences in the logic functions available from each logic family are not so much in the function that they achieve as in the specific characteristics of the basic gate from which the function has been constructed.
NAND and NOR gates are usually defined by the Boolean functions they implement in 
terms of binary variables. When analyzing them as electronic circuits, it is more convenient to 
Digital Integrated Circuits 493 
investigate their input-output relationships in terms of two voltage levels: a high level (H) and a 
low level (L) (see Fig. 2-10). Binary variables take the values 1 and 0. When positive logic is ad-
opted, the high voltage level is assigned the binary value of 1, and the low voltage level a binary 
0. From the truth table of a positive-logic NAND gate, we deduce its behavior in terms of high and low levels as stated in Fig. 13-1. The corresponding behavior of the NOR gate is also stated in the same figure. These statements must be remembered because they will be used during the analysis of all the gates in this chapter.
The various digital logic families are usually evaluated by comparing the characteristics of 
the basic gate in each family. The most important characteristics were discussed in Section 2-8. They are listed here again for reference.
1. Fan-out specifies the number of standard loads that the output of the gate can drive with-
out impairment of its normal operation. A standard load is defined as the current flowing in the input of a gate in the same IC family.
2. Power dissipation is the power consumed by the gate, which must be available from the power supply.
3. Propagation delay is the average transition delay time for the signal to propagate from input to output when the signals change in value.
4. Noise margin is the limit of a noise voltage which may be present without impairing the proper operation of the circuit.
The bipolar junction transistor (BJT) is the familiar npn or pnp junction transistor. In con-
trast, the field-effect transistor (FET) is said to be unipolar. The operation of a bipolar transistor 
depends on the flow of two types of earners: electrons and holes. A unipolar transistor depends on the flow of only one type of majority carrier which may be eletrons (n-channel) or holes (p-channel). The first five logic families listed previously, RTL, DTL, TTL, ECL, and I
2L, use 
bipolar transistors. The last two logic families, MOS and CMOS, employ a type of unipolar  Inputs Output NAND gate
x y z (a)  If any input is LOW , the output is HIGH.
L L H (b)  If all inputs are HIGH, the output is LOW .
L H H
x
yzH L H
H H L
Inputs Output NOR gate
x y z (a)  If any input is HIGH, the output is LOW .
L L H (b)  If all inputs are LOW , the output is HIGH
L H L
x
yz H L L
H H L
Figure 13.1 Input-output conditions for positive-logic NAND and NOR gates
494 Chapter 13
transistor called metal-oxide semiconductor field-effect, transistor, abbreviated MOSFET, or 
MOS for short. We begin by describing the characteristics of the bipolar transistor and the basic gates used in the bipolar logic families. We then explain the operation of the MOS transistor in conjunction with its two logic families.
13.2 Bipolar Transistor Characteristics
This section is devoted to a review of the bipolar transistor as applied to digital circuits. This information will be used for the analysis of the basic circuit in the five bipolar logic families. Bipolar transistors may be of the npn or pnp type. Moreover, they are constructed either with 
germanium or silicon semiconductor material. IC transistors, however, are made with silicon and are usually of the npn type.
The basic data needed for the analysis of digital circuits may be obtained from inspection of 
the typical characteristic curves of a common-emitter npn silicon transistor, shown in Fig. 13-2. 
The circuit in (a) is a simple inverter with two resistors and a transistor. The current marked I
C 
flows through resistor RC and the collector of the transistor. Current IB flows through resistor RB 
and the base of the transistor. The emitter is connected to ground and its current IE = IC + IB. The 
supply voltage is between VCC and ground. The input is between Vi and ground, and the output is 
between V0 and ground.
VCC
V0
V1IBIC RC
RB
IE
(a) Inverter circuit
VBE (V)IB
(mA)
0.6 0.7 0.8           VCE (V)IC
(mA)
0.6
VCC0.30.40.5
IB = 0.2 mA  VCC
RC
               (b) Transistor base characteristic                (c) Transistor collector characteristic
Figure 13.2 Silicon npn transistor characteristics
Digital Integrated Circuits 495 
We have assumed a positive direction for the currents as indicated. These are the directions 
in which the currents normally flow in an npn transistor. Collector and base currents IC and IB 
are positive when they flow into the transistor. Emitter current IE is positive when it flows out of 
the transistor, as indicated by the arrow in the emitter terminal. The symbol VCE stands for the 
voltage drop from collector to emitter and is always positive. Correspondingly, VBE is the voltage 
drop across the base-to-emitter junction. This junction is forward biased when VBE is positive. It 
is reverse biased when VBE is negative.
The base-emitter graphical characteristic is shown in Fig. 13-2(b). This is a plot of VBE ver-
sus IB. If the base-emitter voltage is less than 0.6 V , the transistor is said to be cutoff and no base 
current flows. When the base-emitter junction is forward biased with a voltage greater than 0.6 
V , the transistor conducts and IB starts rising very fast while VBE changes very little. The voltage 
VBE across a conducting transistor seldom exceeds 0.8 V .
The graphical collector-emitter characteristics, together with the load line, are shown in 
Fig. 13-2(c). When VBE is less than 0.6 V , the transistor is cutoff with IB = 0 and a negligible 
current flows in the collector. The collector-to-emitter circuit then behaves like an open circuit. In the active region, collector voltage V
CE may be anywhere from about 0.8 V up to VCC. Collec-
tor current IC in this region can be calculated to be approximately equal to IBhFE, where hFE is 
a transistor parameter called the dc current gain. The maximum collector current depends not on I
B, but rather on the external circuit connected to the collector. This is because VCE is always 
positive and its lowest possible value is 0 V . For example, in the inverter shown, the maximum IC 
is obtained by making VCE = 0 to obtain IC = VCC/RC.
It was stated that IC = hFEIB in the active region. The parameter hFE varies widely over 
the operating range of the transistor, but still it is useful to employ an average value for the purpose of analysis. In a typical operating range, h
FE is about 50, but under certain conditions 
it could go down to as low as 20. It must be realized that the base current IB may be increased 
to any desirable value, but the collector current IC is limited by external circuit parameters. As 
a consequence, a situation can be reached where hFEIB is greater than IC. If this condition exists, 
then the transistor is said to be in the saturation region. Thus, the condition for saturation is 
determined from the relationship:
II
hBCS
FE≥
where ICS is the maximum collector current flowing during saturation. VCE is not exactly zero in 
the saturation region but is normally about 0.2V .
The basic data needed for analyzing bipolar transistor digital circuits are listed in Table 
13-1. In the cutoff region, VBE is less than 0.6 V , VCE is considered as an open circuit, and both 
Table 13-1 Typical npn silicon transistor parameters
Region VBE(V)* VCE(V) Current relationship
Cutoff < 0.6 Open circuit IB = IC = 0
Active 0.6 − 0.7 > 0.8 IC = hFEIB
Saturation 0.7 − 0.8 0.2 IB ≥ ICS/hFE
* V
be will be assumed to be 0.7 V if the transistor is conducting, whether in the active or saturation region.
496 Chapter 13
currents are negligible. In the active region, VBE is about 0.7 V , VCE may vary over a wide range, 
and IC can be calculated as a function of IB. In the saturation region. VBE hardly changes but VCE 
drops to 0.2 V . The base current must be large enough to satisfy the inequality listed. To simplify 
the analysis, we will assume that VBE = 0.7 V if the transistor is conducting, whether in the active 
or saturation region.
The analysis of digital circuits may be undertaken using a prescribed procedure: For each 
transistor in the circuit determine if its VBE is less than 0.6 V . If so, then the transistor is cutoff  
and the collector-to-emitter circuit is considered an open circuit. If VBE is greater than 0.6 V , the 
transistor may be in the active or saturation region. Calculate the base current, assuming that  
VBE = 0.7 V . Then calculate the maximum possible value of collector current ICS, assuming  
VCE = 0.2 V . These calculations will be in terms of voltages applied and resistor values. Then, if the 
base current is large enough that IB > ICS/hFe, we deduce that the transistor is in the saturation region 
with VCE = 0.2 V . However, if the base current is smaller and the above relationship is not satisfied, 
the transistor is in the active region and we recalculate collector current IC using the equation  
IC = hFEIB. 
To demonstrate with an example, consider the inverter circuit of Fig. 13-2(a) with the fol-
lowing parameters:
RC = 1 kΩ   VCC = 5 V (voltage supply)
RB = 22 kΩ  H = 5 V (high-level voltage)
hFE = 50 L = 0.2 V (low-level voltage)
With input voltage Vi = L = 0.2 V , we have that VBE < 0.6 V and the transistor is cutoff. The 
collector-emitter circuit behaves like an open circuit; so output voltage V0 = 5 V = H.
With input voltage Vi = H = 5 V , we deduce that VBE > 0.6 V . Assuming that VBE = 0.7, we 
calculate the base current:
IVV
RKmABiB E
B=−=−
Ω=50 7
220195.
The maximum collector current, assuming VCE = 0.2 V , is:
IVV
RkmACSCC CE
C=−=−
Ω=50 2
148..
We then check for saturation:
019548
500096 ... =≥ == II
hmABCS
FE
and find that the inequality is satisfied since 0.195 > 0.096. We conclude that the transistor is saturated and output voltage V
0 = VCE = 0.2 V = L. Thus the circuit behaves as an inverter.
The procedure just described will be used extensively during the analysis of the circuits in 
the following sections. This will be done by means of a qualitative analysis, i.e., without writing 
Digital Integrated Circuits 497 
down the specific numerical equations. The quantitative analysis and specific calculations will be 
left as exercises in the Problems section at the end of the chapter.
There are occasions where not only transistors but also diodes are used in digital circuits. 
An IC diode is usually constructed from a transistor with its collector connected to the base, as shown in Fig, 13-3(a). The graphic symbol employed for a diode is shown in Fig. 13-3(b). The diode behaves essentially like the base-emitter junction of a transistor. Its graphical characteris-tic, shown in Fig. 13-3(c), is similar to the base-emitter characteristic of a transistor. We can then conclude that a diode is off and nonconducting when its forward voltage, V
D, is less than 0.6 V . 
When the diode conducts, current ID flows in the direction shown in Fig. 13-3(b), and VD stays 
at about 0.7 V . One must always provide an external resistor to limit the current in a conducting diode, since its voltage remains fairly constant at a fraction of a volt.
13.3 RTL and DTL Circuits
13.3.1 RTL Basic Gate
The basic circuit of the RTL digital logic family is the NOR gate shown in Fig, 13-4. Each in-put is associated with one resistor and one transistor. The collectors of the transistors are tied together at the output. The voltage levels for the circuit are 0.2 V for the low-level and from 1 to 3.6 V for the high-level.
The analysis of the RTL gate is very simple and follows the procedure outlined in the pre-
vious section. If any input of the RTL gate is high, the corresponding transistor is driven into saturation. This causes the output to be low, regardless of the states of the other transistors. If all inputs are low at 0.2 V , all transistors are cutoff because V
BE < 0.6 V . This causes the output of 
the circuit to be high, approaching the value of supply voltage VCC. This confirms the conditions 
stated in Fig. 13-1 for the NOR gate. Note that the noise margin for low signal input is 0.6 − 0.2 = 0.4 V .
The fan-out of the RTL gate is limited by the value of the output voltage when high. As the 
output is loaded with inputs of other gates, more current is consumed by the load. This current must flow through the 640-Ω resistor. A simple calculation (see Problem 13-1) will show that, if 1
2
(a)  Transistor adapted for 
use as a diode
1 2
+ –ID
VD
(b) Diode graphic symbolVD (V)ID
(mA)
0.6 0.7
(c) Diode characteristic
Figure 13.3 Silicon diode symbol and characteristic
498 Chapter 13
hFE drops to 20, the output voltage drops to about 1 V when the fan-out is 5. Any voltage below 
1 V in the output may not drive the next transistor into saturation as required. The power dissipa-
tion of the RTL gate is about 12 mW and the propagation delay averages 25 ns.
13.3.2 DTL Basic Gates
The basic circuit in the DTL digital logic family is the NAND gate shown in Fig. 13-5. Each input is associated with one diode. The diodes and the 5-kΩ resistor form an AND gate. The transistor serves as a current amplifier while inverting the digital signal. The two voltage levels are 0.2 V for the low-level and between 4 and 5 V for the high-level.
The analysis of the DTL gate should conform to the conditions listed in Fig. 13-1 for the 
NAND gate. If any input of the gate is low at 0.2 V , the corresponding input diode conducts cur -
rent through V
CC and the 5-kΩ resistor into the input node. The voltage at point P is equal to the 
input voltage of 0.2 V plus a diode drop of 0.7 V , for a total of 0.9 V . In order for the transistor VCC = 3.6 V
BY = (A + B + C) ′
C A640 Ω
450 Ω 450 Ω 450 Ω
Figure 13.4 RTL basic NOR gate
VCC = 5 V
BY = (ABC) ′
CA2 kΩ
5 kΩ
5 kΩP
Q1D1 D2
Figure 13.5 DTL basic NAND gate
Digital Integrated Circuits 499 
to start conducting, the voltage at point P must overcome a potential of one VBE drop in Q 1 plus 
two diode drops across D1 and D2, or 3 × 0.6 = 1.8 V . Since the voltage at P is maintained at 
0.9 V by the input conducting diode, the transistor is cutoff and the output voltage is high at 5 V .
If all inputs of the gate are high, the transistor is driven into the saturation region. The volt-
age at P now is equal to VBE plus the two diode drops across D1 and D2, or 0.7 × 3 = 2.1 V . Since 
all inputs are high at 5 V and VP = 2.1 V , the input diodes are reverse biased and off. The base 
current is equal to the difference of currents flowing in the two 5-kΩ resistors and is sufficient to 
drive the transistor into saturation (see Problem 13-2). With the transistor saturated, the output drops to V
CE of 0.2 V . which is the low level for the gate.
The power dissipation of a DTL gate is about 12 mW and the propagation delay averages 30 
ns. The noise margin is about 1 V and a fan-out as high as 8 is possible. The fan-out of the DTL gate is limited by the maximum current that can flow in the collector of the saturated transistor (see Problem 13-3).
The fan-out of a DTL gate may be increased by replacing one of the diodes in the base 
circuit with a transistor as shown in Fig. 13-6. Transistor Q1 is maintained in the active region 
when output transistor Q2 is saturated. As a consequence, the modified circuit can supply a larger amount of base current to the output transistor. The output transistor can now draw a larger amount of collector current before it goes out of saturation. Part of the collector current comes from the conducting diodes in the loading gates when Q2 is saturated. Thus, an increase in allow-able collector saturated current allows more loads to be connected to the output, which increases the fan-out capability of the gate.
13.3.3 High-Threshold Logic—HTL
There are occasions where digital circuits must operate in an environment which produces very high noise signals. For operation in such surroundings, there is available a type of DTL gate which possesses a high threshold to noise immunity. This type of gate is called a high-threshold-logic (HTL) gate.VCC = 5 V
Y = (ABC) ′
C2 kΩ
5 kΩQ1D2
BA2 kΩ1.6 k
Q2
Figure 13.6 Modified DTL gate
500 Chapter 13
The HTL gate is shown in Fig. 13-7. Comparing it with the modified DTL gate of Fig. 13-6, 
we note that the supply voltage has been raised to 15 V and a zener diode (Z) is used instead of 
a normal diode. The zener diode has the characteristic of maintaining a constant voltage of 6.9 V when reverse biased.
In order for output transistor Q2 to conduct, the emitter of Q1 must rise to a potential of 
one V
BE drop plus the fixed zener voltage of 6.9 V , for a total of about 7.5 V , The low level for the 
gate remains at 0.2 V , but the high level is about 15 V . With the input of 0.2 V , the base of Q1 is at 0.9 V and Q2 is off. The noise signal must be greater than 7.5 V to change the state of Q2. With 
all the inputs at 15 V , output transistor Q2 is saturated. The noise signal must be greater than 7.5 V (in the negative direction) to turn the transistor off. Thus, the noise margin of the HTL gate is about 7.5 V for both voltage levels.
13.4 Integrated-injection Logic (I2L)
Integrated-injection logic is the most recent digital logic family to be introduced commercially. Its main advantage is the high packing density of gates that can be achieved in a given area of semiconductor chip. This allows more circuits to be placed in the chip to form complex digital functions. As a consequence, this family is used mostly for LSI functions. It is not available in SSI packages containing individual gates.
The I
2L basic gate is similar in operation to the RTL gate, with few major differences: (1) 
The base resistor used in the RTL gate is removed altogether in the I2L gate. (2) The collector 
resistor used in the RTL gate is replaced by a pnp transistor that acts as a load for the I2L gate. 
(3) I2L transistors use multiple collectors instead of the individual transistors employed in RTL.
The schematic diagram of the basic I2L gate is shown in Fig. 13-8. It has an npn transistor, 
Q1, with multiple collectors for the outputs. The base circuit has a pnp transistor, T1, connected to supply voltage V
BB. Unlike other logic families, the I2L basic gate operation cannot be analyzed 
when standing alone. One must show its interconnection to other gates to make any sense.VCC = 15  V
Y
C15 kΩ
5 kΩQ1Z
BA12 kΩ3 kΩ
Q2
6.9 V+–
Figure 13.7 High-threshold-logic (HTL) gate
Digital Integrated Circuits 501 
Figure 13-9 shows the interaction of the basic gate formed by Q1 and T1 with other gates 
in its input and output. Here we see that one collector of Q2 supplies the input to the basic gate. 
Transistor T1 in the basic gate acts as a load that injects current to the collector of Q2. One of the 
collectors of Q1 acts as an output of the basic gate and is connected to the base of Q3. Transistor 
T3, connected to the base of Q3, acts as a load to inject current to the collector of Q1 in the basic 
gate. The basic gate here acts as an inverter and its equivalent circuit is shown in Fig. 13-9(b). Using multiple collectors and a pnp transistor instead of a load resistor turns out to be a more efficient method of construction, since they reduce the chip area required and allow the packing of more circuits. The pnp transistor, although shown to be connected to the base of a given gate, acts as a collector load for all the other gates that are connected to this base.
The basic I
2L gate, when connected to other gates, performs the NOR logic function. This 
is demonstrated in the circuit diagram shown in Fig. 13-10. The logic function that the circuit implements is drawn with graphic gate symbols in Fig. 13-10(a), which shows the interconnec-tion of two NOR gates and an inverter. This is implemented with three I
2L gates, Q1, Q2, and Q3, 
as shown in Fig. 13-10(b). The output transistors are also shown for completeness. The collectors VBB = 1.5 V
Q1InputT1
Outputs
Figure 13.8 I2L basic gate
VBB
Q1
AT1
Q2Q3T3
A′
              VBB
AT3
Q1A′
                              (a) Inverter gate Q1                  (b) Equivalent circuit
Figure 13.9 Connection of other gates to the inputs and outputs of a basic I2L gate
502 Chapter 13
of Q1 and Q2 are tied together to form one NOR function. Input B is complemented by transistor 
Q2. The collectors of Q3 and Q1 are tied together to form the second NOR function. The base 
of each npn transistor receives the injection current from the multiple-collector pnp transistors 
T1 and T2. The emitters of the npn transistors are connected to the base of the pnp transistor to facilitate the construction.
13.5 Transistor-Transistor Logic (TTL)
The original basic TTL gate was a slight improvement over the DTL gate. As the TTL technology progressed, additional improvements were added to the point where this logic family became the most widely used type in the design of digital systems. There are many versions (or “series”) of the TTL basic gate. The names and characteristics of five versions appear in Table 13-2, together with their propagation delay and power dissipation values. The speed-power product is an im-portant parameter for comparing the basic gates. This is a product of the propagation delay and the power dissipation measured in picojoules (pJ). A low value for this parameter is a desirable figure, because it indicates that a given propagation delay can be achieved without excessive power dissipation, or vice versa.BA
(A + B)′ = A′B ′
(A + B′)′ = A′B
(a) Logic diagram
AT2
Q1
B′B Q2T1
Q3(A + B)′
(A + B′)′Injection
 current
(b) Circuit diagram
Figure 13.10 Typical connections among I2L gates
Digital Integrated Circuits 503 
The standard TTL gate was the first version in the TTL family. This basic gate was then 
constructed with different resistor values to produce gates with lower dissipation or higher speed. 
The propagation delay of a saturated logic family depends largely on two factors: storage time and RC time constants. Reducing the storage time decreases the propagation delay. Reducing re-
sistor values in the circuit reduces the RC time constants and decreases the propagation delay. Of 
course, the trade-off is a higher power dissipation because lower resistances draw more current from the power supply. The speed of the gate is inversely proportional to the propagation delay.
In the low-power TTL gate the resistor values are higher than in the standard gate to reduce 
the power dissipation, but the propagation delay is increased. In the high-speed TTL gate, resistor values are lowered to reduce the propagation delay, but the power dissipation is increased. The Schottky TTL is a later improvement in the technology that removes the storage time of transis-tors by preventing them from going into saturation. This version increases the speed of operation without an excessive increase in power dissipation. The low-power Schottky TTL version sacri-fices some speed for reduced power dissipation. It is about equal to standard TTL in propagation delay but has only one-fifth the power dissipation. It has the best speed-power product and, as a consequence, it became the most popular version in new designs.
All TTL versions are available in SSI packages and in more complex forms as MSI and LSI 
functions. The differences in the TTL versions are not in the digital functions that they perform, but rather in the values of resistors and type of transistor that their basic gate uses. In any case, TTL gates in all versions come in three different types of output configurations.
1. Open-collector output.
2. Totem-pole output.
3. Three-state (or tri-state) output.
These three types of outputs will be considered in conjunction with the circuit description of the basic TTL gate.
13.5.1 Open-collector Output Gate
The basic TTL gate shown in Fig. 13-11 is a modified circuit of the DTL gate. The multiple emit-ters in transistor Q1 are connected to the inputs. These emitters behave most of the time like the input diodes in the DTL gate since they form a pn junction with their common base. The base-
collector junction of Q1 acts as another pn junction diode corresponding to D1 in the DTL gate Table 13-2 TTL versions and their characteristics
Name AbbreviationPropagation 
delay (ns)Power
dissipation (mW)Speed-power 
product (pJ)
Standard TTL TTL 10 10 100
Low-power TTL LTTL 33  1  33
High-speed TTL HTTL 6 22 132
Schottky TTL STTL 3 19  57
Low-power Schottky TTL LSTTL  9.5  2  19
504 Chapter 13
(see Fig. 13-5). Transistor Q2 replaces the second diode, D2, in the DTL gate. The output of the 
TTL gate is taken from the open collector of Q3. A resistor connected to VCC must be inserted 
external to the IC package for the output to “pull up” to the high voltage level when Q3 is off; 
otherwise, the output acts as an open circuit. The reason for not providing the resistor internally will be discussed later.
The two voltage levels of the TTL gate are 0.2 V for the low level and from 2.4 to 5 V for the 
high level. The basic circuit is a NAND gate. If any input is low, the corresponding base-emitter junction in Q1 is forward biased. The voltage at the base of Q1 is equal to the input voltage of 0.2 V plus a V
BE drop of 0.7 V or 0.9 V . In order for Q3 to start conducting, the path from Q1 to Q3 
must overcome a potential of one diode drop in the base-collector pn junction of Q1 and two VBE 
drops in Q2 and Q3, or 3 × 0.6 = 1.8 V , Since the base of Q1 is maintained at 0.9 V by the input 
signal, the output transistor cannot conduct and is cutoff. The output level will be high if an exter -
nal resistor is connected between the output and VCC (or an open circuit if a resistor is not used).
If all inputs are high, both Q2 and Q3 conduct and saturate. The base voltage of Q1 is equal 
to the voltage across its base-collector pn junction plus two VBE drops in Q2 and Q3, or about 0.7 
× 3 = 2.1 V . Since all inputs are high and greater than 2.4 V , the base-emitter junctions of Q1 are all reverse biased. When output transistor Q3 saturates (provided it has a current path), the output voltage goes low to 0.2 V . This confirms the conditions of a NAND operation.
In the above analysis, we said that the base-collector junction of Q1 acts like a pn diode 
junction. This is true in the steady-state condition. However, during the turn-off transition, Q1 does exhibit transistor action resulting in a reduction in propagation delay. When all inputs are high and then one of the inputs is brought to a low level, both Q2 and Q3 start turning off. At this time, the collector junction of Q1 is reverse biased and the emitter is forward biased; so transistor Q1 goes momentarily into the active region. The collector current of Q1 comes from the base of Q2 and quickly removes the excess charge stored in Q2 during its previous saturation state. This causes a reduction in the storage time of the circuit as compared to the DTL type of input. The result is a reduction of the turn-off time of the gate.VCC = 5 V
Y
C
1 kΩQ3BA4 kΩ 1.6 kΩ
Q2VCC = 5 V
Q1R1
Figure 13.11 Open-collector TTL gate
Digital Integrated Circuits 505 
The open-collector TTL gate will operate without the external resistor when connected to 
inputs of other TIT gates, although this is not recommended because of the low noise immunity 
encountered. Without an external resistor, the output of the gate will be an open circuit when Q3 is off. An open circuit to an input of a TTL gate behaves as if it has a high-level input (but a 
small amount of noise can change this to a low level). When Q3 conducts, us collector will have 
a current path supplied by the input of the loading gate through V
CC, the 4-kΩ resistor, and the 
forward-biased base-emitter junction.
Open-collector gates are used in three major applications: driving a lamp or relay, perform-
ing wired logic, and for the construction of a common-bus system. An open-collector output can drive a lamp placed in its output through a limiting resistor. When the output is low, the saturated transistor Q3 forms a path for the current that turns the lamp on. When the output transistor is 
off, the lamp turns off because there is no path for the current.
If the outputs of several open-collector TTL gates are tied together with a single external 
resistor, a wired-AND logic is performed. Remember that a positive-logic AND function gives a high level only if all variables are high; otherwise, the function is low. With outputs of open-collector gates connected, together, the common output is high only when all output transistors are off (or high). If an output transistor conducts, it forces the output to the low state.
The wired logic performed with open-collector TTL gates is depicted in Fig. 13-12. The 
physical wiring in (a) shows how the outputs must be connected to a common resistor. The graph-ic symbol for such a connection is demonstrated in (b). The AND function formed by connecting together the two outputs is called a wired-AND function. The AND gate is drawn with the lines going through the center of the gate to distinguish it from a conventional gate. The wired-AND gate is not a physical gate but only a symbol to designate the function obtained from the indicated connection. The Boolean function obtained from the circuit of Fig. 13-12 is the AND operation between the outputs of the two NAND gates:
Y = (AB)′ ⋅ (CD)′ = (AB + CD)′
The second expression is preferred since it shows an operation commonly referred to as an AND-OR-INVERT function (see Section 3-7).
Open-collector gates can be tied together to form a common bus. At any time, all gate out-
puts tied to the bus, except one, must be maintained in their high state. The selected gate may A
BYVCC
OC
C
DOC          A
B
YOC
C
DOC
  (a) Physical connection            (b) Wired logic graphic symbol
Figure 13.12 Wired-AND of two open-collector (oc) gates, Y = (AB + CD)′
506 Chapter 13
be either in the high or low state, depending on whether we want to transmit a 1 or 0 on the bus. 
Control circuits must be used to select the particular gate that drives the bus at any given time.
Figure 13-13 demonstrates the connection of four sources tied to a common bus line. Each 
of the four inputs drives an open-collector inverter, and the outputs of the inverters are tied to-gether to form a single bus line. The figure shows that three of the inputs are 0, which produces a 1 or high level on the bus. The fourth input, I
4, can now transmit information through the com-
mon bus line into inverter 5. Remember that an AND operation is performed in the wired logic. If I
4 = 1, the output of gate 4 is 0 and the wired-AND operation produces a 0. If I4 = 0, the output of 
gate 4 is 1 and the wired-AND operation produces a 1. Thus, if all other outputs are maintained at 1, the selected gate can transmit its value through the bus. The value transmitted is the comple-ment of I
4, but inverter 5 in the receiving end can easily invert this signal again to make Y = I4.
13.5.2 Totem-pole Output
The output impedance of a gate is normally a resistive plus a capacitive load. The capacitive load consists of the capacitance of the output transistor, the capacitance of the fan-out gates, and any stray wiring capacitance. When the output changes from the low to the high state, the output transistor of the gate goes from saturation to cutoff and the total load capacitance, C, charges exponentially from the low to the high voltage level with a time constant equal to RC. For the open-collector gate, R is the external resistor marked R
L. For a typical operating value of C = 15 
pF and RL = 4 kΩ, the propagation delay of a TTL open-collector gate during the turn-off time 
is 35 ns. With an active pull-up circuit replacing the passive pull-up resistor RL, the propagation Y
I2I10
01
1oc-1
oc-2
I30 1oc-3
I401
oc-4105VCC
Bus line
Figure 13.13 Open-collector gates forming a common bus line
Digital Integrated Circuits 507 
delay is reduced to 10 ns. This configuration, shown in Fig. 13-14, is called a totem-pole output 
because transistor Q4 “sits” upon Q3.
The TTL gate with the totem-pole output is the same as the open-collector gate, except for 
the output transistor Q4 and the diode D1. When the output Y is in the low state, Q2 and Q3 are 
driven into saturation as in the open-collector gate. The voltage in the collector of Q2 is VBE(Q3) 
+ VCE(Q2) or 0.7 + 0.2 = 0.9 V . The output Y = VCE(Q3) = 0.2 V . Transistor Q4 is cutoff because 
its base must be one VBE drop plus one diode drop, or 2 × 0.6 = 1.2 V , to start conducting. Since 
the collector of Q2 is connected to the base of Q4, the latter’ s voltage is only 0.9 V instead of the 
required 1.2 V , and so Q4 is cutoff. The reason for placing1 the diode in the circuit is to provide a 
diode drop in the output path and thus ensure that Q4 is cutoff when Q3 is saturated.
When the output changes to the high state because one of the inputs drops to the low state, 
transistors Q2 and Q3 go into cutoff. However, the output remains momentarily low because the 
voltages across the load capacitance cannot change instantaneously. As soon as Q2 turns off, Q4 conducts because its base is connected to V
CC through the 1.6-kΩ resistor. The current needed 
to charge the load capacitance causes Q4 to momentarily saturate, and the output voltage rises with a time constant RC. But R in this case is equal to 130 Ω, plus the saturation resistance of 
Q4, plus the resistance of the diode, for a total of approximately 150 Ω. This value of R is much 
smaller than the passive pull-up resistance used in the open-collector circuit. As a consequence, the transition from the low to high level is much faster.
As the capacitive load charges, the output voltage rises and the current in Q4 decreases, 
bringing the transistor into the active region. Thus, in contrast to the other transistors, Q4 is in 
the active region when in a steady-state condition. The final value of the output voltage is then 
5 V , minus a V
BE drop in Q4, minus a diode drop in D1  to about 3.6 V . Transistor Q3 goes into 
cutoff very fast, but during the initial transition time both Q3 and Q4 are on and a peak current is drawn from the power supply. This current spike generates noise in the power supply distribution system. When the change of state is frequent, the transient current spikes increase the power sup-ply current requirement and the average power dissipation of the circuit increases.Y
1 kΩQ34 kΩ1.6 kΩ
Q2VCC = 5 V
Q1Q4130 Ω
D1
Figure 13.14 TTL gate with totem-pole output
508 Chapter 13
The wired-logic connection is not allowed with totem-pole output circuits. When two to-
tem-poles are wired together with the output of one gate high and the output of the second gate 
low, the excessive amount of current drawn can produce enough heat to damage the transistors in the circuit (see Problem 13-7). Some TTL gates are constructed to withstand the amount of cur -
rent that flows under this condition. In any case, the collector current in the low gate may be high enough to move the transistor into the active region and produce an output voltage in the wired connection greater than 0.8 V , which is not a valid binary signal for TTL gates.
13.5.3 Schottky TTL Gate
As mentioned before, a reduction in storage time results in a reduction of propagation delay. This is because the time needed for a transistor to come out of saturation delays the switching of the transistor from the on condition to the off condition. Saturation can be eliminated by placing a Schottky diode between the base and collector of each saturated transistor in the circuit. The Schottky diode is formed by the junction of a metal and semiconductor, in contrast to a conven-tional diode which is formed by the junction of p-type and n-type semiconductor material. The voltage across a conducting Schottky diode is only 0.4 V , as compared to 0.7 V in a conventional diode. The presence of a Schottky diode between the base and collector prevents the transistor from going into saturation. The resulting transistor is called a Schottky transistor. The use of Schottky transistors in a TTL decreases the propagation delay without a sacrifice of power dis-sipation.
The Schottky TTL gate is shown in Fig. 13-15. Note the special symbol used for the Schott-
ky transistors and diodes. The diagram shows all transistors to be of the Schottky type except Q4. 
3.5 kΩ
Q3900 Ω
Q2VCC
Q1Q450 Ω
2.8 kΩ
Q5
Q6250 Ω500 Ω
Figure 13.15 Schottky TTL gate
Digital Integrated Circuits 509 
An exception is made of Q4 since it does not saturate but stays in the active region. Note also that 
resistor values have been reduced to further decrease the propagation delay.
In addition to using Schottky transistors and lower resistor values, the circuit of Fig. 13-15 
includes other modifications not available in the standard gate of Fig. 13-14. Two new transistors, Q5 and Q6 have been added, and Schottky diodes are inserted between each input terminal and ground. There is no diode in the totem-pole circuit. However, the new combination of Q5 and Q4 still gives the two V
BE drops necessary to prevent Q4 from conducting when the output is low. 
This combination comprises a double emitter-follower called a Darlington pair. The Darling-ton pair provides a very high current gain and extremely low resistance. This is exactly what is needed during the low-to-high swing of the output, resulting in a decrease of propagation delay.
The diodes in each input shown in the circuit help clamp any ringing that may occur in the 
input lines. Under transient switching conditions, signal lines appear inductive; this, along with stray capacitance, cause signals to oscillate or “ring.” When the output of a gate switches from the high to the low state, the ringing waveform at the input may have excursions below ground as great as 2−3 V , depending on line length. The diodes connected to ground help clamp this ringing since they conduct as soon as the negative voltage exceeds 0.4 V . When the negative excursion is limited, the positive swing is also reduced. The success of the clamp diodes in limiting line effects has been so successful that all versions of TTL gates use them.
The emitter resistor of Q2 in Fig. 13-14 has been replaced in Fig. 13-15 by a circuit consist-
ing of transistor Q6 and two resistors. The effect of this circuit is to reduce the turn-off current spikes discussed previously. The analysis of this circuit, which helps to reduce the propagation time of the gate, is too involved to present in this brief discussion.
13.5.4 Three-state Gate
As mentioned earlier, the outputs of two TTL gates with totem-pole structures cannot be con-nected together as in open-collector outputs. There is, however, a special type of totem-pole gate that allows the wired connection of outputs for the purpose of forming a common-bus system. When a totem-pole output TTL gate has this property, it is called a three-state (or tri-state) gate.
A three-state gate exhibits three output states: (1) a low-level state when the lower transis-
tor in the totem-pole is on and the upper transistor is off; (2) a high-level state when the upper transistor in the totem-pole is on and the lower transistor is off: and (3) a third state when both transistors in the totem-pole are off. The third state provides an open circuit or high-impedance state which allows a direct wire connection of many outputs to a common line. Three-state gates eliminate the need for open-collector gates in bus configurations.
Figure 13-16(a) shows the graphic symbol of a three-state buffer gate. When the control 
input C is high, the gate is enabled and behaves like a normal buffer with the output equal to the input binary value. When the control input is low, the output is an open circuit which gives a high impedance (the third state) regardless of the value of input A. Some three-state gates produce a 
high-impedance state when the control input is high. This is shown symbolically in Fig. 13-16(b). Here we have two small circles, one for the inverter output and the other to indicate that the gate is enabled when C is low.
The circuit diagram of the three-state inverter is shown in Fig. 13-16(c). Transistors Q6, Q7, 
and Q8 associated with the control input form a circuit similar to the open-collector gate. Tran-
sistors Q1−Q5, associated with the data input, form a totem-pole TTL circuit. The two circuits 
are connected together through diode D1. As in an open-collector circuit, transistor Q8 turns off  
510 Chapter 13
when the control input at C is in the low-level state. This prevents diode D1 from conducting, and 
also, the emitter in Q1 connected to Q8 has no conduction path. Under this condition, transistor Q8 has no effect on the operation of the gate and the output in Y depends only on the data input 
at A.
When the control input is high, transistor Q8 turns on, and the current flowing from V
CC 
through diode D1 causes transistor Q8 to saturate. The voltage at the base of Q5 is now equal to CAY = A if C = High
Y high-impedence
    if C = Lo w
          CAY = A′ if C = Lo w
Y high-impedence
    if C = High
          (a) Three-state buffer gate          (b) Three-state inverter gate
Q3Q2Q4
D1Q1Q5
Y
A
Q6 C Q7
Q8VCC
 Data
input
Control
  input
(c) Circuit diagram for the three-state inverter of (b)
Figure 13.16 Three-state TTL gate
Digital Integrated Circuits 511 
the voltage across the saturated transistor, Q8, plus one diode drop, or 0.9 V . This voltage turns 
off Q5 and Q4 since it is less than two VBE drops. At the same time, the low input to one of the 
emitters of Q1 forces transistor Q3 (and Q2) to turn off. Thus both Q3 and Q4 in the totem-pole are turned off and the output of the circuit behaves like an open circuit with a very high output impedance.
A three-state bus is created by wiring several three-state outputs together. At any given time, 
only one control input is enabled while all other outputs are in the high-impedance state. The single gate not in a high-impedance state can transmit binary information through the common bus. Extreme care must be taken that all except one of the outputs are in the third state; otherwise, we have the undesirable condition of having two active totem-pole outputs connected together.
An important feature of most three-state gates is that the output enable delay is longer than 
the output disable delay. If a control circuit enables one gate and disables another at the same time, the disabled gate enters the high-impedance state before the other gate is enabled. This eliminates the situation of both gates being active at the same time.
There is a very small leakage current associated with the high-impedance condition in a 
three-state gate. Nevertheless, this current is so small that as many as 100 three-state outputs can be connected together to form a common bus line.
13.6 Emitter-coupled Logic (ECL)
Emitter-coupled logic (ECL) is a nonsaturated digital logic family. Since transistors do not satu-rate, it is possible to achieve propagation delays of 2 ns and even below 1ns. This logic family has the lowest propagation delay of any family and is used mostly in systems requiring very-high-speed operation. Its noise immunity and power dissipation, however, are the worst of all the logic families available.
A typical basic circuit of the ECL family is shown in Fig. 13-17. The outputs provide both 
the OR and NOR functions. Each input is connected to the base of a transistor. The two voltage levels are about −0.8 V for the high state and about −1.8 V for the low state. The circuit consists of a differential amplifier, a temperature- and voltage-compensated bias network, and an emitter-follower output. The emitter outputs require a pull-down resistor for current to flow. This is ob-tained from the input resistor, R
P, of another similar gate or from an external resistor connected 
to a negative voltage supply.
The internal temperature- and voltage-compensated bias circuit supplies a reference volt-
age to the differential amplifier. Bias voltage VBB is set at −1.3 V , which is the midpoint of the 
signal logic swing. The diodes in the voltage divider, together with Q6, provide a circuit that 
maintains a constant VBB value despite changes in temperature or supply voltage. Any one of the 
power supply inputs could be used as ground. However, the use of the VCC node as ground and 
VEE at −5.2 V results in best noise immunity.
If any input in the ECL gate is high, the corresponding transistor is turned on and Q5 is 
turned off. An input of − 0.8 V causes the transistor to conduct and places −1.6 V on the emit-
ters of all transistors (VBE drop in ECL transistors is 0.8 V). Since VBB = −1.3 V . the base voltage 
of Q5 is only 0.3 V more positive than its emitter. Q5 is cutoff because its VBE voltage needs at 
least 0.6 V to start conducting. The current in resistor RC2 flows into the base of Q8 (provided 
there is a load resistor). This current is so small that only a negligible voltage drop occurs across R
C2. The OR output of the gate is one VBE drop below ground, or −0.8 V , which is the high state. 
The current flowing through RC1 and the conducting transistor causes a drop of about 1 V below 
512 Chapter 13
ground (see Problem 13-9). The NOR output is one VBE drop below this level, or at −1.8 V , which 
is the low state.
If all inputs are at the low level, all input transistors turn off and Q5 conducts. The voltage 
in the common-emitter node is one VBE drop below VBB or − 2.1 V . Since the base of each input 
is at a low level of −1.8 V , each base-emitter junction has only 0.3 V and all input transistors are 
cutoff. RC2 draws current through Q5 that results in a voltage drop of about 1 V , making the OR 
output one VBE drop below this, at −1.8 V or the low level. The current in RC1 is negligible and the 
NOR output is one VBE drop below ground, at −0.8 V or the high level. This verifies the OR and 
NOR operations of the circuit.
The propagation delay of the ECL gate is 2 ns, and the power dissipation is 25 mW . This 
gives a speed-power product of 50, which is about the same as for Schottky TTL. The noise 
margin is about 0.3 V and not as good as in the TTL gate. High fan-out is possible in the ECL gate because of the high input impedance of the differential amplifier and the low output imped-ance of the emitter-follower. Because of the extreme high speed of the signals, external wires act like transmission lines. Except for very short wires of a few centimeters, ECL outputs must use coaxial cables with a resistor termination to reduce line reflections.
The graphic symbol for the ECL gate is shown in Fig. 13-18(a). Two outputs are available, 
one for the NOR function and the other for the OR function. The outputs of two or more ECL gates can be connected together to form wired logic. As shown in Fig. 13-18(b), an external 6.1 kQ3Differential Input Amplif ier
Q2VCC1 = GND
Q1 Q4Q5
AVCC2 = GND
D C B VEE = –5.2 V RE
779  RP
50 k  RP
50 k  RP
50 k  RP
50 k4.98 kQ6VBB =RC2
RC1 220245 907
–1.3 VQ7Q8    Int ernal
Temperatur e
 and Voltag e
Compensat ed
Bias Net work Emit ter
Follow er
 Outputs
   OR
Output
  NOR
Output
Figure 13.17 ECL basic gate
Digital Integrated Circuits 513 
wired connection of two NOR outputs produces a wired-OR function. An internal wired con-
nection of two OR outputs is employed in some ECL ICs to produce a wired-AND (sometimes 
called dot-AND) logic. This property may be utilized when ECL gates are used to form the OR-AND-INVERT and the OR-AND functions.
13.7 Metal-Oxide Semiconductor (MOS)
The field-effect transistor (FET) is a unipolar transistor, since its operation depends on the flow of only one type of carrier. There are two types of field-effect transistors: the junction field-effect transistor (JFET) and the metal-oxide semi-conductor (MOS). The former is used in linear cir -
cuits and the latter in digital circuits. MOS transistors can be fabricated in less area than bipolar transistors.
The basic structure of the MOS transistor is shown in Fig. 13-19. The p-channel MOS 
consists of a lightly doped substrate of n-type silicon material. Two regions are heavily doped by diffusion with p-type impurities to form the source and drain. The region between the two 
p-type sections serves as the channel. The gate is a metal plate separated from the channel by 
an insulated dielectric of silicon dioxide. A negative voltage (with respect to the substrate) at the gate terminal causes an induced electric field in the channel which attracts p-type carriers from the substrate. As the magnitude of the negative voltage on the gate increases, the region below the gate accumulates more positive carriers, the conductivity increases, and current can flow from source to drain provided a voltage difference is maintained between these two terminals.BA (A + B)′  NOR
(A + B)    OR           BA(A + B) ′ + (C + D) ′ =
[(A + B)(C + D)]′
DC
(A + B)(C + D)
     (a) Single gate         (b) Wired combination of two gates
Figure 13.18 Graphic symbols of ECL gates
drain (–)gate (–)
source
n-type substrat eP p ++ ++
                           drain (+)gate (+)
source
p-type substrat en n –– ––
    (a) p-channel    (b) n-channel
Figure 13.19 Basic structure of MOS transistor
514 Chapter 13
There are four basic types of MOS structures. The channel can be a p- or n-type, depending 
on whether the majority carriers are holes or electrons. The mode of operation can be enhance-
ment or depletion, depending on the state of the channel region at zero gate voltage. If the chan-nel is initially doped lightly with p-type impurity (diffused channel), a conducting channel exists at zero gate voltage and the device is said to operate in the depletion mode. In this mode, current 
flows unless the channel is depleted by an applied gate field. If the region beneath the gate is left initially uncharged, a channel must be induced by the gate field before current can flow. Thus, the channel current is enhanced by the gate voltage and such a device is said to operate in the enhancement mode.
The source is the terminal through which the majority carriers enter the bar. The drain is the 
terminal through which the majority carriers leave the bar. In a p-channel MOS, the source termi-nal is connected to the substrate and a negative voltage is applied to the drain terminal. When the gate voltage is above a threshold voltage V
T (about −2 V), no current flows in the channel and the 
drain-to-source path is like an open circuit. When the gate voltage is sufficiently negative below V
T, a channel is formed and p-type carriers flow from source to drain. P-type carriers are positive 
and correspond to a positive current flow from source to drain.
In the n-channel MOS, the source terminal is connected to the substrate and a positive 
voltage is applied to the drain terminal. When the gate voltage is below the threshold voltage VT 
(about 2 V) no current flows in the channel, When the gate voltage is sufficiently positive above V
T to form the channel, n-type carriers flow from source to drain. N-type carriers are negative, 
which corresponds to a positive current flow from drain to source. The threshold voltage may vary from 1 to 4 V depending on the particular process used.
The graphic symbols for the MOS transistors are shown in Fig. 13-20. The accepted symbol 
for the enhancement type is the one with the broken-line connection between source and drain. In this symbol, the substrate can be identified and is shown connected to the source. We will use an alternative symbol that omits the substrate; in this symbol, the arrow is placed in the source terminal to show the direction of positive current flow (from source to drain in the p-channel and 
from drain to source in the n-channel).
Because of the symmetrical construction of source and drain, the MOS transistor can be 
operated as a bilateral device. Although normally operated so that carriers flow from source to drain, there are circumstances when it is convenient to allow carrier flow from drain to source (see Problem 13-12).
One advantage of the MOS device is that it can be used not only as a transistor, but as a 
resistor as well. A resistor is obtained from the MOS by permanently biasing the gate terminal for conduction. The ratio of the source-drain voltage to the channel current then determines the value of the resistance. Different resistor values may be constructed during manufacturing by fixing the channel length and width of the MOS device.
gatedrain
substrat e
sour ceGD
S               gatedrain
substrat e
sour ceGD
S
  (a) p-channel     (b) n-channel
Figure 13.20 Symbols for MOS transistors
Digital Integrated Circuits 515 
Three logic circuits using MOS devices are shown in figure 13-21. For an n-channel MOS, 
supply voltage VDD is positive (about 5 V) to allow positive current flow from drain to source. The 
two voltage levels are a function of the threshold voltage VT. The low level is anywhere from zero 
to VT, and the high level ranges VT to VDD. The n-channel gates usually employ positive logic. The 
p-channel MOS circuits use a negative voltage for VDD to allow positive current flow from source 
to drain. The two voltage levels are both negative above and below the negative threshold voltage 
VT. P-channel gates usually employ negative logic.
The inverter circuit shown in Fig. 13-21(a) uses two MOS devices. Q1 acts as the load resis-
tor and Q2 as the active device. The load resistor MOS has its gate connected to VDD, thus main-
taining it always in the conduction state. When the input voltage is low (below VT), Q2 turns off. 
Since Q1 is always on, the output voltage is at about VDD. When the input voltage is high (above 
VT), Q2 turns on. Current flows from VDD through the load resistor Q1 and into Q2. The geometry 
of the two MOS devices must be such that the resistance of Q2, when conducting, is much less 
than the resistance of Q1 to maintain the output Y at a voltage below VT.
The NAND gate shown in Fig. 13-21(b) uses transistors in series. Inputs A and B must both 
be high for all transistors to conduct and cause the output to go low. If either input is low, the corresponding transistor is turned off and the output is high. Again, the series resistance formed by the two active MOS devices must be much less than the resistance of the load resistor MOS. The NOR gate shown in Fig. 13-21(c) uses transistors in parallel. If either input is high, the cor -
responding transistor conducts and the output is low. If all inputs are low, all active transistors are off and the output is high.
13.8 Complementary MOS (CMOS)
Complementary MOS circuits take advantage of the fact that both n-channel and p-channel de-vices can be fabricated on the same substrate. CMOS circuits consist of both types of MOS VDD
Y = A′
A Q2Q1
     VDD
Y = (AB) ′
A
B
   VDD
Y = (A + B) ′
A B
 
        (a) Inverter    (b) NAND gate       (c) NOR gate
Figure 13.21 n-channel MOS logic circuits
516 Chapter 13
devices interconnected to form logic functions. The basic circuit is the inverter, which consists 
of one p-channel transistor and one n-channel transistor as shown in Fig. 13-22(a). The source terminal of the p-channel device is at V
DD, and the source terminal of the n-channel device is at 
ground. The value of VDD may be anywhere from +3 to +18 V . The two voltage levels are 0 V for 
the low level and VDD for the high level.
To understand the operation of the inverter, we must review the behavior of the MOS tran-
sistor from the previous section:
1. The n-channel MOS conducts when its gate-to-source voltage is positive.
2. The p-channel MOS conducts when its gate-to-source voltage is negative.
3. Either type of device is turned off if its gate-to-source voltage is zero.
Now consider the operation of the inverter. When the input is low, both gates are at zero 
potential. The input is at − VDD relative to the source of the p-channel device and at 0 V relative 
to the source of the n-channel device. The result is that the p-channel device is turned on and the n-channel device is turned off. Under these conditions, there is a low-impedance path from V
DD to the output and a very-high-impedance path from output to ground. Therefore, the output VDD
Y = A′ A
nP
VDD
Y = (AB) ′
A
BVDD
Y = (A + B) ′A
B(a) Inverter
              (b) NAND gate          (c) NOR gate
Figure 13.22 CMOS logic circuits
Digital Integrated Circuits 517 
voltage approaches the high level VDD under normal loading conditions. When the input is high, 
both gates are at VDD and the situation is reversed: The p-channel device is off and the n-channel 
device is on. The result is that the output approaches the low level of 0 V .
In either logic state, one MOS transistor is on while the other is off. Because one transistor 
is always turned off, the dc power dissipation of the CMOS circuit is extremely low, usually on 
the order of 10 nW . The major power drain occurs when the CMOS circuit changes state.
CMOS logic is usually specified for single-supply operation over the 5−15V range, but 
some circuits may be operated at 3 V or 18 V , Operating CMOS at large values of supply voltage produces a greater power dissipation. The propagation delay time decreases and the noise margin improves with increased power supply voltage. The propagation delay of the inverter is about 25 ns. The noise margin is usually about 40% of the V
DD supply voltage value. The advantages of 
CMOS, i.e., low power dissipation, excellent noise immunity, high packing density, and a wide range of supply voltages, make it a strong contender for a popular standard as a digital circuit family.
Two other CMOS basic gates are shown in Fig. 13-22. A two-input NAND gate consists of 
two p-type units in parallel and two n-type units in series, as shown in Fig. 13-22(b). If all inputs are high, both p-channel transistors turn off and both n-channel transistors turn on. The output has a low impedance to ground and produces a low state. If any input is low, the associated n-channel transistor is turned off and the associated p-channel transistor is turned on. The output is coupled to V
DD and goes to the high state. Multiple-input NAND gates may be formed by placing 
equal numbers of p-type and n-type transistors in parallel and series, respectively, in an arrange-ment similar to that shown in Fig. 13-22(b).
A two-input NOR gate consists of two n-type units in parallel and two p-type units in se-
ries, as shown in Fig. 13-22(c). When all inputs are low, both p-channel units are on and both n-channel units are off. The output is coupled to V
DD and goes to the high state. If any input is high, 
the associated p-channel transistor is turned off and the associated n-channel transistor turns on. This connects the output to ground, causing a low-level output.
REFERENCES
1. Taub, H., and D. Schilling, Digital Integrated Electronics. New Y ork: McGraw-Hill Book Co.,  
1977.
2. Grimch. V . H., and H. G. Jackson, Introduction to Integrated Circuits. New Y ork: McGraw-Hill Book 
Co., 1975.
3. Morris, R. L., and J. R. Miller, Eds., Designing with TTL Integrated Circuits. New Y ork: McGraw-Hill 
Book Co., 1971.
4. Garret. L S., “integrated-Circuit Digital Logic Families.” IEEE Spectrum (October, November, De-
cember. 1970).
5. De Falco, J. A., “Comparison and Uses of TTL Circuits,” Computer Design (February, 1972).
6. Blood, W . R, Jr., MECL System Design Handbook. Phoenix, Ariz.: Motorola Semiconductor Products 
Inc., 1972.
7. Data Book Series SSD-2038: COS/MOS Digital Integrated Circuits, Somerville, N.J.: RCA Solid State Division, 1974.
518 Chapter 13
PROBLEMS
13-1. (a) Determine the high-level output voltage of the RTL gate for a fan-out of 5. (b) Determine the 
minimum input voltage required to drive an RTL transistor to saturation when hFE = 20. (c) From 
the results in (a) and (b), determine the noise margin of the RTL gate when the input is high and the fan-out is 5.
13-2. Show that the output transistor of the DTL gate of Fig. 13-5 goes into saturation when all inputs are high. Assume that h
FE = 20.
13-3. Connect the output Y of the DTL gate shown in Fig. 13-5 to N inputs of other similar gates. Assume 
that the output transistor is saturated and its base current is 0.44 mA. Let hFE = 20.
(a) Calculate the current in the 2-kΩ resistor.
(b) Calculate the current coming from each input connected to the gate.
(c) Calculate the total collector current in the output transistor as a function of N.
(d) Find the value of N that will keep the transistor in saturation.
(e) What is the fan-out of the gate?
13-4. Draw the interconnection of I2L gates to form a 2 × 4 decoder.
13-5. Let all inputs in the open-collector TTL gate of Fig. 13-11 be in the high state of 3 V .
(a) Determine the voltages in the base, collector, and emitter of all transistors.
(b) Determine the minimum hFE of Q2 that ensures that this transistor saturates.
(c) Calculate the base current of Q3.
(d) Assume that the minimum hFE of Q3 is 6.18. What is the maximum current that can be tolerated 
in the collector to ensure saturation of Q3?
(e) What is the minimum value of RL that can be tolerated to ensure saturation of Q3?
13-6. (a) Using the actual output transistors of two open-collector TTL gates, show (by means of a truth 
table) that when connected together to an external resistor and VCC, the wired connection produces 
an AND function. (b) Prove that two open-collector TTL inverters when connected together produce the NOR function.
13-7. It was stated in Section 13-5 that totem-pole outputs should not be tied together to form wired logic. To see why this is prohibitive, connect two such circuits together and let the output of one gate be in the high state and the output of the other gate be in the low state. Show that the load current (which 
is the sum of the base and collector currents of the saturated transistor Q4 in Fig. 13-14) is about 32 
mA. Compare this value with the recommended load current in the high state of 0.4 mA.
13-8. For the following conditions, list the transistors that are off and those that are conducting in the three-state TTL gate of Fig. 13-16(c). (For Q1 and Q6, it would be necessary to list the states in the 
base-emitter and base-collector junctions separately.)
(a) When C is low and A is low.
(b) When C is low and A is high.
(c) When C is high.
 What is the state of the output in each case?
13-9. Calculate the emitter current I
E across RE in (he ECL gate of Fig. 13-17 when:
(a) At least one input is high at −0.8 V .
(b) All inputs are low at −1.8 V .
Digital Integrated Circuits 519 
 Now assume that IC = IE. Calculate the voltage drop across the collector resistor in each case and 
show that it is about 1 V as required.
13-10. Calculate the noise margin of the ECL gate.
13-11. Using the NOR outputs of two ECL gates, show that when connected together to an external resistor 
and negative supply voltage, the wired connection produces an OR function.
13-12. The MOS transistor is bilateral, i. e., current may flow from source to drain or from drain to source. 
Using this property, derive a circuit that implements the Boolean function:
Y = (AB + CD + AED + CEB)′
 using six MOS transistors.
13-13. (a) Show the circuit of a four-input NAND gate using CMOS transistors. (b) Repeat for a four-input NOR gate.
MORE SOL vED quESTIONS
1. Why we go for Digital integrated circuits?
 Digital : Processing of discretized information (signal).
1.  Accurate.
2.  Flexible.
3.  It requires less operational energy.
4.  Repeatability.
2. Why there are different Logic Families?
1.  Space satellite, Digital wristwatch – low power consumption
2.  Scientific Computer – high speed
3.  Digital Control of equipment in industrial environment – noise immunity
4.  Compatibility
5.  Flexibility
6.  Cost
7.  Size, Packing Density
8.  Evolution
3. Transistor-inverter is key to development of logic circuit. Why?
 Diodes, Switches can be used to build OR and AND circuit but not NOT circuit. Hence, with these 
it is not possible to develop every type of logic circuits.

AppendixANSWERS TO SELECTED PROBLEMS
Chapter 1
1-1.  0, 1,2, 10, 11, 12. 20, 21, 22, 100, 101, 102, 110. 111, 112, 120, 121. 122, 200, 201.
1-2.  (a) 1313, 102210
  (b) 223, 11314.52
  (c) 1304, 336313
  (d) 331, 13706
1-3,  (100021.1111 ...)3; (3322.2)4; (505.333 ...)7; (372.4)8; (FA.8)16.
1-4.  1100.0001; 10011100010000; 10l0l00001.00111; 11111001110.
1-5.  2.53125; 46.3125; 117.75; 109.875.
1-6. decitnal binary octal hexadecimal
  225.225  11100001.001110011   341.16314   E1.399
  215.75  11010111.110   327.6   D7.C
  403.9843 110010011.111111   623.77   193.FC
10949.8125 10101011000101.1101 25305.64 2AC5.D
1-7.  (a) 73.375
  (b) 151
  (c) 78.5
  (d) 580
  (e) 0.62037 
  (f) 35
  (g) 8.333
  (h) 260
1-8.  l’s complement: 0101010; 1000111; 1111110; 01111; 11111.
  2’ s complement: 0101011; 1001000; 1111111; 10000; 00000.
522 Appendix
1-9.  9’s complement: 86420; 90099; 09909; 89999; 99999. 
  10’ s complement: 86421; 90100; 09910; 90000; 00000.
1-10.  '(175)11.
1-14.  (a) Six possible tables. 
  (b) Four possible tables.
1-15.  (a) 1000 0110 0010 0000
  (b) 1011 1001 0101 0011
  (c) 1110 1100 0010 0000
  (d) 1000011 0101100
1-17.  0000, 0001, 0010, 0011,0100, 0101. 0110,0111, 1011, 1100, 1101, 1110.
1-18.  00001, 01110, 01101, 01011, 01000, 10110, 10101, 10011, 10000, 11111.
1-20  000, 001, 010, 101, 110, 111, representing 0, 1,2, 3, 4, 5, respectively.
1-21.  Two bits for suit, four bits for number. J = 1011, Q = 1100, K = 1101.
1-23.  (a) 0000 0000 0000 0001 0010 0111
  (b) 0000 0000 0000 0010 1001 0101
  (c) 1110 0111 1110 1000 1111 0101
1-24.  (a) 597 in BCD
  (b) 264 in excess −  3
  (c) Not valid for 2421 code of Table 1-2
  (d) FG in alphanumeric
1-25.  00100000001 + 10000011010 = 10100011011.
1-26.  L = (A + B) . C .
Chapter 2
2-1.	 	 Closure,	 associative,	 commutative,	 distributive;	 identity	for	+	is	2;	identity	for	•	is	0;	
no inverses.
2-2  All postulates are satisfied except for postulate 5; there is no complement.
2-5.  (a) x
  (b) x
  (c) y
  (d) z(x + y)
  (e) 0
  (f) y (x + w)
2-6.  (a) A' B′  + B(A + C)
  (b) BC + AC′
  (c) A + CD
  (d) A + B′CD
Combinational Logic with MSI and LSI  523 
2-7.  (a) 1
  (b) B′D′ + A(D′ + BC′ )
  (c) 1
  (d) (A ′ + B)(C + D)
2-11.  (b) F = ( x′ + y)′ + ( x + y) ′ + (y + z′ )′ has only OR and NOT operators.
  (c) F = [(xy) ′ ⋅ (x′y′)′ ⋅ (y′z)′]′ has only AND and NOT operators. 
2-12.  (a) T1= A′(B′+ C′)
  (b) T2 = A + BC = T′1
2-13.  (a) ∑(1, 3, 5, 7, 9, 11, 13, 15) = ∏ (0, 2, 4, 6, 8, 10, 12, 14)
  (b) ∑(1. 3, 5, 9, 12, 13, 14) = ∏ (0, 2, 4, 6, 7, 8, 10, U, 15)
  (c) ∑(0, 1, 2, 8, 10, 12, 13, 14, 15) = ∏ (3, 4, 5, 6, 7, 9, 11)
  (d) ∑(0, I, 3, 7) = ∏(2, 4, 5, 6)
  (e) ∑(0. 1, 2, 3, 4. 5, 6. 7), no maxterms 
  (f) ∑(3, 5. 6, 7) = ∏ (0. 1. 2, 4)
2-14.  (a) ∏ (0, 2, 4, 5, 6)
  (b) ∏(1,3,4,5, 7,8,9, 10. 12, 15)
  (c) ∑(1, 2, 4, 5)
  (d) ∑(5.7,8.9, 10, 11, 13, 14, 15)
2-18.  F= x ⊕  y = x′ y +  xy′ ; (dual of F ) = (x′+ y)(x +y′ )= xy+ x′ y′ = F′ .
2-20.  F = xy + xz + yz.
Chapter 3
3-1.  (a) y
  (b) ABD + ABC + BCD
  (c) BCD + ABD′
  (d) wx + w′ x′y
3-2.  (a) xy + x′ z′
  (b) C + A′ B
  (c) a′ + bc
  (d) xy + xz + yz
3-3.  (a) D + B′C
  (b) BD + B′ D′ + A′ B or BD + B′ D′ + A′ D′
  (c) In′  + k′ m′n
  (d) B′D′ + A′ BD + ABC
  (e) xy′ + x′z + wx′ y
524 Appendix
3-4.  (a) A′B′D′ + B′C′D′ + AD′ E
  (b) DE + A′ B′C + B′ C′E′
  (c) BDE′  + B′CD′ + B′D′E′ + A′ B′D′ + CDE′
3-5.  (a) F1 = ∏(0, 3, 5, 6); F2 = ∏(0, 1, 2, 4)
  (b) F1 = x′y′z + x′yz′ + xy′ z′ + xyz;  F2 = xy + xz + yz
  (c) F1 = (x + y + z)(x + y′ + z′)(x′ +y + z′ )(x′ + y′  + z);
         F2 = (x + y)(x + z)(y + z)
3-6.  (a) y
  (b) (B + C′ )(A + B)(A + C + D)
  (c) (w + z′ )(x′ + z)
3-7.  (a) z′ + xy = ( x + z′ )(y + z′ )
  (b) C′D + A′ B′CD′ + ABCD′  =(A + B′  + D)(C + D)(C ′ + D′ )
  (c) A′C′ + AD′  + B′ D′ = (A′ + D′ )(C′ + D′ )(A + B′  + C′ )
  (d) B′D′ + A′ CD′ + A′ BD = ( A′ + B′ )(B + D′ )(B′ + C + D)
  (e) w′z′ + υw′x′ + υ′wz = ( υ′ + w′ )(w′ + z)(w + x + z′ )(υ + x + z′ )
3-8  (a) x
yz’
z’ x
y
z’
3-9.  (a) F1 = A + D′ E′ + CD′  = (A′D + A′ C′E)′
  (b) F2 = A′ B′ + C′ D′ + B′ C′ = (BD + BC + AC) ′
3-11.  (a) F= BD + D′ (AB′C + A′ B′C)
3-12.  (a) (A ′ + B′  + C′ )(A + B′  + C + D′ )(A + B + C′  + D) 
  (b) (C + D)(C ′ + D′ )(A + B)(A ′ + B′ )
3-13.  AND-AND → AND. AND-NAND → NAND, NOR-NAND →  OR, NOR-AND  
→ NOR, OR-OR →  OR, OR-NOR →  NOR. NAND-NOR →  AND, NAND-OR → 
NAND.
3-15.  (a) F = 1
  (b) F = CD′  + B′D′ + ABC D
3-16.  (a) F = A′ C + B′ D′; A′(C + D′ )(B′ + C′ )
  (b) x′z′ + w′ z; (w′ + z′)(x′ + z)
  (c) AC + CE′  + A′ C′D; (A′ + C)(C + E)(A + C′  + D) 
       or AC + CD′  + A′ C′E; (A′ + C)(C + E)(A + C′  + E′ )
  (d) A ′B + B′ E′; (A′ + B′ )(B + E')
3-17.  (a) B′(A + C ′ + D′)
  (b) A′D + ABC′
  (c) B′D + B′ C + CD
Combinational Logic with MSI and LSI  525 
3-18.  F = x′ y + xz (needs four NAND); F = (x′ + z)(x  + y) (needs four NOR).
3-19.  d = ABC′ DE + AB′CDE′  + ABCD′ E.
3-20.  B′D' (A′ + C)  + BD ( A′ + C′ ); [B′ + D( A′ + C′ )] [B + D′ (A′ + C)];  
  [D′ + B ( A′ + C′ )] [D + B′ (A′ + C)].
3-21.  f ⋅ g = x'yz' + w′ xy′z + wxy′ z′.
3-24.  (a) F= A′ CEF′ G′
  (b) F = ABCDEFG + A′ CEF′ G′ + BC′ D′EF
  (c) F = A′B′C′DEF′  + A′BC′D′E + CE′ F + A′BD′EF
Chapter 4
4-1.  Inputs: a, b, c, d.
  Outputs: F = abc + abd + bcd + acd + a′ b′c′ + a′ c′d′ + a′b′d′
   + b′c′d′; F = ∏(3, 5, 6, 9, 10, 12)(cannot be simplified further).
4-2.  Inputs: A3A2A1.
  Outputs:  B6 to B1 ; B1 = A1; B2 = 0; B5 = A1 A2 B4 = A1(A2A3 + A2A3); B5 =. A3(A1 + 
A2 ); B6 = A 2  A3.
4-3.  Outputs: w , x.y, z; w = a0a1b0b1; x = a1a′0b1 + b1b0a′0
   y = a1b0b′1 + a0a′1b1 + a0b′0b1 + a′0a1b0; z = a0b0.
4-4.  Outputs:  w, x.y, z; x = a1b1+ a1a0b0 + b1b0a0;
   y = a′1a′0b1 + a′1d1b′0 + a′1a0b′1b0 + a1a′0b′0 + a1a′0b′1 + a1a0b1b0
   z = a0b′0 + c′0b′0.
4-5.  Inputs: A,B, C, D.
  Outputs:  w, x, y, z; w = A′ B′C; x = BC′  + B′ C;y = C;  z = D′ .
4-6.  Inputs:  A, B, C, D
  Outputs: F4F3F2F1; F1 = D;  F2 = CD′  + C′ D; F3 = (C + D) 
   B' + BC′ D′; F4 = (B + C + D)  A′ + AB′ C′D′.
4-7.  Inputs:  F8F4F2F1
  Outputs:  SSSS LLLL84 21
184 21
010 10;
   L2 = L8 = S8 = 0;  L1 = L4 = F1; S1 = F2; S2 = F4; S4 = L8.
4-8.  Inputs: A, B, C, D.
  Output:  F = AB + AC.
4-10.  Inputs:  A, B, C, D.
  Outputs:  w, x, y, z; w = A;  x = A′ C + BCD + A′ B + A′ D
    y = AC′ D′ + A′ C′D + ACD + A′ CD′ or y = AC′ D′ + B′ C′D + ACD + 
B′CD';  z = D.
526 Appendix
4-11  Inputs: w, x, y, z.
  Outputs:  E  ABC D
100 ; E = wx + wy;  A = wx′ y′;
   101
   B = w′ x + xy;  C = w′ y + wxy′ ; D = z.
4-12.  Inputs: A, B, C, D (Blank display for invalid input bit combinations)
  Outputs:  a = A′ C + A′ BD + B′ C′D′ + AB′ C 
   b = A′ B′ + AC ′D′ + A′ CD + ABC′ 
   c = A′ B + A′ D + B′ C′D′ + AB′ C′
   d = A′ CD′ + A′ B′C + B′ C′D′ + AB′ C′ + A′ BC′D 
   e = A′ CD′ + B′ C′D′ 
   f = A′ BC′ + A′ C′D′ + A′ BD′ + AB′ C′ 
   g = A′ CD′ + A′ B′C + A′ BC′ + AB′ C′
  (Total of 21 NAND gates)
4-13.  Full-adder circuit. 
4-14.  Full-adder circuit.
4-17.  
x
xy
yzx
y
zx’
y’
z’
zS
C
4-18.  F = ABC′  + A′ B + B′  = A′ + B′  + C′  (two NOR gates).
4-19.  (a) Full-adder, F1 is the sum, F2 is the carry 
  (b) F = A′ B′C′ + A′ BC + AB′ C + ABC′
4-26.  Input variables: A . B. C. D; output variables: w , x, y, z. 
  w  = A, x = A ⊕ B, y = x ⊕ C, z = y  ⊕ D.
4-27.  C=x ⊕ y ⊕ z ⊕ P (three exclusive-OR gates).
4-28.  A
BH A
H ACD
E
F
GH A
Combinational Logic with MSI and LSI  527 
Chapter 5
5-1.  Same as Fig. 5-2 except that B = 1101.
5-3.  The exclusive-OR gate is used to form the 1’ s complement of B when V = 1.
  The 2's complement is obtained by adding 1 = V to the input carry.
5-4.  C5= G4+ P4G3 + P4P3G2 + P4P3P2G1 + P4P3P2P1C1.
5-5.  (b) C4 = (G ′3P′3 + G′3G′2P′2 + G′3G′2G′1P′1 + G′3G′2G′1C′1)'
5-6.  (c) C4 = (P ′3 + G′3P′2 + G′3G′2P′1; + G ′3G′2G′1C′1)
5-7.   (a) 60 ns 
  (b) 120 ns
5-9.  312.
5-10.  Inputs: x8, x4 x2, x1; outputs: y8, y4, y2, y1
  y1 = x′1, y2 = x2, y4 = x2 ⊕ x4, y5 = (x2 + x4 + x8)′.
5-15.  All ten AND gates require four inputs equivalent to the minterms m0 through m9.
5-17.  F1(x, y, z) = ∑(0, 1, 6).
  F ′2(x, y, z) = ∑(4, 5) (use NOR gale). 
  F3(x, y, z) = ∑(0, 1, 6, 7) = F1 + m7.
5-22.  Inputs: D0D1D2D3; outputs: x , y, E. Priority given to input with highest subscript num-
ber.
  x = D2 + D3 y = D3 + D1D′2; E = D0 + D1 + D2 + D3.
5-23.  I0, through I7 = C′, 1, C ′, 0, C′ , C′, 0, C.
5-27.  (a) 1024 × 5
  (b) 256 × 8
  (c) 1024 × 2
Chapter 6
6-4.  Q J K' Q(t + 1) = JQ′ + K′Q
0 0 0 0
0 0 1 0
0 1 0 1
0 1 1 1
1 0 0 0
1 0 1 1
1 1 0 0
1 1 1 1
528 Appendix
6-5.  Q SD R Q (t + 1) = S+ R′Q
0 0 0 0
0 0 1 0
0 1 0 1
0 1 1 1
1 0 0 1
1 0 1 0
1 1 0 1
1 1 1 1
6-7.  Output of gate:   123 4 5 678 9
(a) 110 1 1 001 1
(b) 011 0 1 101 0
(c) 111 0 0 110 1
(d) 100 1 1 110 0
(e) 110 1 1 001 1
(f) 110 1 1 101 0 CP = 1
110 1 1 001 1 CP = 0
6-9.  11/0 00/0
01/1
10/111/1
01/0
10/0
Inputs:  xy
Output:  Sz = 0 z = 1
00/1
6-10  A counter with a repeated sequence: 00, 01, 10.
6-11.  x = I; binary sequence is: 1. 8, 4, 2, 9, 12, 6, 11, 5, 10, 13, 14, 15, 7, 3.
  x = 0; binary sequence is: 0, 8, 12, 14, 7, 11, 13, 6, 3, 9, 4, 10, 5, 2, 1.
6-12.
P .S. Next state Output z
xy = 00 xy = 01 xy = 10 xy = 00 xy = 01 xy = 10 xy = 11 xy = 11
A B A BA B A B A B
0 0 1 00 0 1 1 0 1 0 0 0 0
0 1 0 10 1 1 0 1 1 1 0 0 0
1 0 1 01 0 0 0 1 0 0 0 0 1
1 1 1 01 0 1 0 1 0 1 0 0 1
               A (t + 1) = xB + y′B′A′ + yA + x′ A; B(t + 1) = xA′ B′ + x′A′B + yA′B
Combinational Logic with MSI and LSI  529 
6-13.  Present Next State Output
State    0 1    0 1
a    f b    0 0
b    d a    0 0
d    g a    1 0
f    f b    1 1
g    g d    0 1
6-14.  State: a fbc edghggha
Input: 0111001001 1
Output: 01000111010
6-15.  State: a fbabdgdggda
Input: 01110 010011
Output: 01000111010
6-17.  J K′ Q (t + 1)
0 0 0
0 1 Q (t)
1 0 Q′(t)
1 1 1Q (t) Q (t +1) J K′
0 0 0 X
0 1 1 X
1 0 X 0
1 1 X 1
6-18.  SD R Q(t + 1)
0 0 Q(t)
0 1 0
1 0 1
1 1 1Q(t) Q (t + 1) SD R
  0 0 0 X
  0 1 1 X
  1 0 0 1
  1 1 X
10
Xeither}
6-19. (a) TA = A + B′  x; TB = A + BC′ x + BCx′  + B′ C′x′; 
       TC = Ax = r Cx + A′ B′C′x′
 (b) SA = A′ B′x; RA = A;  SB = A + C′ x′; RB = BC′  x + C x';
      SC = A′  B' x + Ax;  RC = A′  x
 (c) JA = B' x,  KA = 1; JB = A + C'x', KB = CV + Cx';
      JC = A'B'x + Ax,  KC = x; y = A'x
6-20.  (A = 23, B = 22 C = 21, D = 20); TA = ( D + C + B) x;
  TB = ( D + C) x; TC = Dx;  TD = 0.
6-21.  JA = x,  KA = x′ ; JB = Ax',  KB = 1; JC = Bx + Ax,  KC = Bx′ .
6-22.  JQ8 = Q1Q2Q4 JQ4 = Q1 Q2 JQ2 = Q'8 Q1 JQ1 = 1
  KQ8 = Q1  KQ4 = Q1 Q2 KQ2 = Q1 KQ1 = 1
530 Appendix
6-23  24 21
ABCD

; TA = BCD + A'B;  TB = CD + A′ B; TC = D + A′ B; TD = 1.
6-25.  JA = yC + xy  JB = xAC  JC = x′ B + yAB′
  KA=x′ +y′B′  KB = A'C + x′ C + yC' KC = A'B′  + xB + y' B′
6-26  (a) A(t + 1) = AB′ C′x′ + A′ BC′x + AB'C'x' + AB′ Cx.
       B (t + 1) = A′ BC′x′ + A′ B′Cx.
       C (t + 1) = ABC′ x′ + A′ BC'x′  + A'BCx' + AB′ C'x′+ AB′ Cx′.
       d(A, B, C, x) = ∑(0, 1, 12. 13, 14, 15) (don′ t-care terms).
Chapter 7
7-1.  Use an external HAND gate.
7-2.  (a)  Change inverter associated with CP into a buffer gate, or (b) use flip-flops that trig-
ger on the negative edge.
7-8.  A = 0010, 0001, 1000, 1100; Q = 1, 1, 1, 0.
7-9.  D = x ⊕ y ⊕ Q; JQ = x′y; KQ = ( x′ + y) '
7-11.  200 ns; 5 MHz.
7-12.  Ten flip-flops will be complemented.
7-15.  1010 →  1011 →  0100   1110 →  1111 →  0000
  1100 → 1101    Self-starting.
7-16.  
101   110      111                     Not self-starting.000 → 001 → 010 → 011 → 100
  
7-27.  (a) Unused states (in decimal):    2     4    5     6   9   10   11   13
         Next state (in decimal):          9   10    2   11   4   13     5     6
  (b) 2 → 9 → 4 → 8         8 is a valid state
       10 →  13 →  6 →  11 →  5 →  0            0 is a valid state
7-29.  (a) 13, 32
  (b) 32, 768
7-32.  (a) 16
  (b) 8, 16
  (c) 16
  (d) 16 + 255k where k is the number of l’ s in the word to be stored
Chapter 8
8-3.  A shift-right register with serial input x and shift control P .
8-5.  (a) (1) B ← A; (2) A ← B: (3) C ← D; (4) BUS ← B 
  (b) (1) 01000; (2) 10010; (3) 00110
Combinational Logic with MSI and LSI  531 
8-7.        operation          address MUX     data MUX        destination decoder
        ________        ___________        _________        _______________
  (a)     write             10           11                −
  (b)     read             11            −                 10
8-9. A mod-9 counter that counts the binary states from 0 through 8.
8-12. S: A ← shr A , B←shr B, Bn← A1, A←A1,
8-14.  PR forms the product of BR and AR by successive additions of the contents of BR a 
number of times equal to the number in AR.  The multiplication starts when 5 becomes 
1 and terminates with D = 1.
8-15.  (a) 000000
  (b) 011000 (24)
  (b) 000011 (3)
  (c) 100011 (− 29)
  (d) 001110 (14) 
  (f) 010001 (17) 
  (g) 101111 (− 17)
  (h) 000101 (5)
8-19.  (1 − 2-26) × 2225 and 2−256.
8-20.  (105 − 1) × 1099 and 10−95.
8-21. coefficient exponent
(a) 0 111111000000 1 000111
(b) 0 011111100000 1 000010
(c) 0 000111111000 1 000001
8-22. (a) 8
 (b) 16
  (b) 65,536
  (c) 8,388,607
8-25.  q4t3:    MAR ← PC
  q4t4:    MBR ←  M, PC ←  PC + 1
  q4t5:    R ← MBR,  T ← 0
Chapter 9
9-2.  Four selection lines for each.
9-4.  (a) 64 × 8 RAM
  (b) 6
  (c) 8
  (d) 8 multiplexers of 2 × 1 each
532 Appendix
9-7.  (c)
9-8. s2s1s0Cin = 0000  0001 0010 0011 0100 0101 0110 0111.
           F = 0000  0001 B B + 1  B B + l 1111 0000.
9-9. (a) F = B + Ā B plus l’s complement of A
(b) F = B + Ā + 1 B plus 2’s complement of A
(c) F = A + B − 1 l’s complement of (A + B) minus one
(d) F = A + B l’s complement of (A + B)
(e) F = Ā l’s complement of A
(f) F = Ā + 1 2*s complement of A
(g) F = Ā − 1 l’s complement of A minus one
(h) F = Ā l’s complement of A
9-10.  Xi = Ai; Yi = s′ Bi; Cin = s.
9-11.  F = 2’s complement of (B  − A) and a borrow occurs if A < B.
5-12.  X1 = Ai(s'1 + s0); Yi = B'is'1s0+ B'is1.
9-13.  X1 = Ai(s'1 + s0) + A'is'1s'0; Y1 = Bis1 + B'is'1s0.
9-16.  Let x = s2s'1s'0, y = s2s1s'0
                    Xi, = x′Ai + AiBi + y Bi; Yi = Bis0 + B′is1y'; Zi = s′2Ci
9-17.  Same as Table 9-4 with the OR and AND selection variables interchanged.
9-18.  (a) E = 1 if F = all l’ s
  (b) C = 1 if A > B
  (c) A > B if C = 1   A < 5 if C  = 0
       A ≥  B if C = 1  or E = 1  A = B if E = 1
       A < B if C = 0 and E  = 0 A ≠ B if E = 0
9-24.  R5 ← R1 + R 2 R6 ← crc R 6
  R 5 ← crc R l5 R5 ← R5 + R 6
  R 6 ← R3 + R 4 R5 ← crc R 5
9-26.  J Ai = KAi = BiK'ip10 + B'iKip10; Ki + 1, = A'iBi + A'iKi + BiKi.
  where Ki is input borrow and Ki + 1 is output borrow
9-27.  JAi = B'i p11 + P12 + B'iP13; KAi = P11 + 3iP12 + B'iP13.
9-28.  JAi = KAi = Ei; Ei + 1 = EiAi; Ei = p14.s1s0Y1
0 0 Bi′
0 1 Bi′
1 0 1
1 1 0
Combinational Logic with MSI and LSI  533 
Chapter 10
10-3.  A negative zero will occur after the computation of (− A) + (+ B)  provided A = B. This 
can be avoided by clearing A3 if A = 0 when A ≥ B.
10-7.  DT0 = q'mT0 + P2,T3; DT1 = qmT0; DT2 = T1 + P'1T3; DT3 = T2.
10-11. (a) 0   Same as Table 10-2
       1   A  ← A + B+ 1, S ← Cn, E ← Cn + 1, go to 3
       2   A ← A + B, S ← Cn, E ← Cn + 1
       3   If (E  = 1) then (go to 6)
       4   If (S  = 1) then (go to 7)
       5   V ← 0, go to 0
       6   If (S = 1) then (go to 5)
       7   V ← 1, go to 0
10-11. A microinstruction with 26 zeros.
10-12. 1    R 1 ← R1, C ← 0
  2    If (S = 1) then (go to 4)
  3    R 1 ← crc R 1, go to 8
  4    R 1 ← shl R 1
  5    R 1 ← R1
  6    If (S = 1) then (go to 8)
  7    R 1 ← 0
  8    Next routine starts here
10-17. 2t (1 + k ).
10-18. TG1 = qm + T'0; TG2 = T1 + P2T3
10-19. 2’ s complement of k .
10-20. (rn − 1) (rn = 1) < (r2n = l)for r  ≥ 2.
10-21. JG, = qsT0 + S'T2 + T4 + T6; KG1 = 1
  JG2 = qaT0 + T1 + E'T5;  KG2 = ST2 + T3 + T7
  JG3 = ST2;    KG3 = ET5 + T7
10-23. T0:    x = 1, if (qm = 1) then (go to T1) else (go to T0)
  T1:    P ← 0, go to T2
  T2:    If (A  = 0) then (go to T0) else (go to T3)
  T3:    P ← P + B, A ← A − 1, go to T2
Chapter 11
11-2.  (a) CLE (b) CLE
        SPA       SHL
        CME       overflow if E ≠ Al6
        SHR
534 Appendix
11-4.  (a) location (b) location
1 SKI 5 SKO
2 BUN 1 6 BUN  5
3 INP 7 OUT
11-5.  An overflow occurs if the signs of the two numbers are the same but the sign of the 
result is different.
11-6.  (b) Value of A = (0011)16 = (17)10
11-8. 11 µs.
11-9. (a) Fq1t2: A ← A + B, E ←  carry
          Fq1t3E: A ← A + 1
  (c) Must detect both positive and negative zero
11-10. ORA      Fq8t1: B ← M  SUB Fq11t1:   B ←  M, A ← Ā
                Fq8t2: A ← A ∨ B               Fq11t2   A ← A + 1
  SWP      Fq10t1: B ← M                Fq10t3:   A ← A + B
                Fq10t2: A ← B,  B ← A BSA ql2t3:   A ← PC, PC ←  B (AD)
                Fq10t3: M ← B  BPA q13A′16t3:   PC ← B (AD)
11-11. (b) Instruction: AND ADD STO IS2 BSB BUN REG I/O
       Time (µ s):    6    6    5   7    5    4    4   4
11-12. SBA can be done in a variety of ways:
  (a) use procedure defined in problem 9-25;
  (b) swap A and B, then complement and add;
  (c) form the 2′ s complement in B as in problem 9-29.
  ADM    q9t3:   MAR ←  B (AD)
               q9t4:   B ←  M
              q9t5:   A ← B, B ←  A
              q9t6:   A ←A + B
              q9t7:   A ← B, B ←  A
              q9t8:   M ←  B, G, ← 0
Chapter 12
12-2.  The width of the data bus.
12-3.  4096 words, 8192 bytes.
12-8.  49.
12-9. (b) Relative: Two-byte instruction, A  ← M[PC + AD8].
  AR( L) ← M [PC], PC ← PC + 1
  If AR(8) = 0 then AR( H) ← 0 else AR( H) ← all i's
  AR ← M[AR]
  A ← A + T
Combinational Logic with MSI and LSI  535 
12-10. (a) 00 FB
  (b) 71FB: (c)7125
12-14.
(a)PC S P Stack
013 F 3 A 56 5 A, 14
(b) 67 A E 3 A 58 42, 01, 5 A, 14
(c) 014 2 3  A 56 5 A, 14
(d) 145 A 3 A 54 —
12-17. (a) PC, A, B, C, D, E, F, G, status register
  (b) Ten memory cycles
12-18. x = I'0 I'1; y = I'0 I'2  R = I0 + I1 + I2+ I3.
12-19. FF00, FF08, FF10, FFI8.
12-20. (a) 16
  (b) 11, 7
  (c) 4, 4 ×  16
12-21. 24 terminals.
12-22. 32 RAM chips with a 5 ×  32 decoder. Eight ROM chips with a 3 ×  8 decoder. Use line 
13 for CS2. Address range: 0000-0FFF for RAM; 1000-IFFF for ROM.
12-23. (a) 8. 4
  (c) RAM: 0000 −  07FF; ROM: 4O00 −  4FFF; interface: 8000 −  800F
Chapter 13
13-1.  (a) 1.05 V
  (b) 0.82 V
  (c) 0.23 V
13-2.  IB = 0.44 mA, Ics = 2.4 mA
13-3.  (a) 2.4 mA
  (b) 0.82 mA
  (c) 2.4 + 0.82 N
  (d) 7.8
  (e) 7
13-5.  (b) 3.53
  (c) 2.585 mA
  (d) 16 mA
  (e) 300 Ω
13-9.  (a) 4.62 mA
  (b) 4 mA
13-10. 0.3 V .

IndexA
Access time, 262, 279, 318, 417, 440, 453
Accumulator register, 324, 346, 408–411, 429, 451–452, 
460, 490
design of, 324
Active pull-on, 506Active region, 495–496, 499, 504, 507–509Addend, 5, 105, 138–140, 146, 240, 290Adder, 105–106, 108
BCD, 144binary, 144–145decimal, 143full, 105–106half, 105–106parallel, 138–139, 141serial, 241, 269sign-magnitude, 2862’ s complement, 286
Adder-subtractor, 370, 377–378, 402–403Addition, 4, 12, 18, 38, 70, 73, 105, 140, 143, 287, 289, 
326, 338
parallel, 287serial, 287with sign-1’ s complement, 287, 293with sign-2’ s complement, 287
Address, 162–163, 167, 235, 259–260, 267, 270, 279, 
281
Address bus, 279–280, 446, 449, 451, 473, 486, 489, 
491
Addressing modes, 456–457, 460–463, 489
base register, 463direct, 461immediate, 461implied, 460indexed, 462indirect, 463present-page, 461register, 460register-indirect, 460
relative, 461zero-page, 461
Address register, 258–260, 267, 273, 279–280, 379, 396, 
451, 484, 487
Adjacent squares, 67–68, 70–75, 87, 91, 108Algebraic manipulation, 41, 105, 121, 130, 196, 219Algorithm, 146, 200, 290, 362, 380, 386Alphanumeric codes, 18
ASC11, 19card code, 19–20, 167EBCDIC, 19–21, 30
ALU, 317–322, 325
design, 317
Analog computer, 2AND, 24–27, 30, 34, 39, 41, 43, 46AND gate, 26, 41, 53, 76, 83, 106, 119, 157, 170, 185, 
390, 498, 505
AND-OR-INVERT, 83–86, 142, 168, 175Application notes, 173Arithmetic addition, 14, 31, 144, 287, 324, 327, 355Arithmetic circuit, 326, 328–332, 334, 336, 357
design, 326
Arithmetic logic unit(see ALU), 317, 319, 325, 335–336, 
358, 445
Arithmetic microoperation, 281Arithmetic shift, 291–292, 314, 359Asynchronous counter, 243Asynchronous transmission, 481–482Augend, 5, 138–140, 146, 290
B
Base of number, 4, 10, 294Base of transistor, 494, 511Base register, 462–463
addressing, 462
538 Index
BCD, 15, 30, 62, 71, 111, 136, 145
BCD adder, 144–145, 177BCD correction, 145BCD counter, 217, 226, 245, 249, 269BCD-to-decimal decoder, 149–151, 176BCD-to seven segment decoder, 133–134, 147Bidirectional bus, 448–449Bidirectional shift–register, 341Binary, 1–3, 15, 22Binary adder, 144–146, 175Binary addition, 23, 143Binary arithmetic, 23–24Binary cell, 20, 229, 263–264, 266, 269Binary code, 14–16, 18, 20, 111, 144, 297, 344, 460Binary coded decimal, 15, 249, 272–273Binary codes, 3, 14–16, 103, 143, 297
alphanumeric, 18–19decimal, 5, 15
Binary counter, 199, 215–217, 247, 249–250, 270, 352
with parallel load, 238, 249
Binary information, 16, 23, 103, 131, 156, 180, 229, 
240, 258, 285
Binary logic, 3, 23–24, 26, 35
definition, 23
Binary multiplication, 175Binary numbers, 3, 9, 12, 29, 129, 289, 403
conversion of, 6–7, 161’ s complement, 281, 283, 2872’ s complement, 14, 29, 174, 288
Binary operator, 31–32, 34, 77Binary signal, 26, 57, 109–110, 312, 508Binary storage, 3, 15, 20, 229, 263, 265, 270Binary-to decimal conversion, 177Binary variable, 24, 39, 51, 104, 107, 147, 298, 309, 
424, 430
Bipolar, 356, 402, 493–494, 513Bit, 14–20, 29, 131, 156, 217Bit-slice microprocessor, 320Bit-time, 241BJT, 493, 519Boolean algebra, 23, 26, 31–40, 44, 46, 48, 58, 67, 103
definition, 31operator precedence, 38postulates, 36–37properties, 35simplification, 65–66, 68, 70theorems, 36two-valued, 23, 32–34
Boolean function, 39–41, 44–46, 48, 53
complement, 9, 12, 29, 47implementation, 41, 76simplification, 65–66, 70truth table, 24, 37, 64, 113, 126
Boolean function implementation, 118, 125, 157product of sums, 48, 75sum of products, 48, 53, 75, 83, 76with AND-OR-INVERT, 142with NAND, 118, 120, 183with NOR, 82, 100, 126
Boolean variable, 197Borrow, 5, 11, 109, 340, 533Branch, 380, 397, 400, 415, 417, 457, 462, 471
conditional, 284–285to subroutine, 397–398, 415unconditional, 380, 401, 411, 457
Branch address, 397–398, 400, 468, 470Buffer gate, 231–232, 448, 509, 528Bus, 464, 468, 471, 473, 476, 531
bidirectional, 448, 451for microprocessor, 454, 457, 459
Bus buffer, 444–445, 450Bus granted, 449–450, 484Bus organization, 318–319, 360Bus request, 449–450, 484, 487Bus transfer, 276–277, 315Byte, 452, 454, 467–468, 489, 539
C
Calculator, 3, 489, 491Call subroutine, 399, 459, 465–466, 489, 491
canonical between, 47
Card code, 19–20, 167–168Carry, 11, 108, 142, 145, 252, 320, 338, 352, 459Carry bit, 138, 342, 345, 348, 386, 459Carry look–ahead, 320Carry propagation, 140–141Central processor unit, 3, 317, 399, 407, 443, 449, 451Character, 19, 21, 297, 411–412, 482Characteristic, 182, 184, 197, 205, 376, 497Character string, 297Chip, 26, 28, 137, 444, 447, 471, 474, 483, 501Chip select, 471–473, 477, 484, 490Circuit design, 207, 407Circular shift, 255, 284, 346, 359, 425Classical method, 137, 139–140, 143, 392Clear, 10, 95, 181, 373, 385, 391, 429, 434, 457, 468Clock, 180, 182, 188, 192, 230, 237, 254, 272, 375Clocked flip-flops, 185–186Clocked sequential circuit, 193, 203, 206, 229, 233, 363Clock generator, 180, 231, 362, 408, 417, 450Clock pulses, 180, 182, 185, 231, 237, 254, 363, 397, 
418, 424
Closure, 31, 33, 62, 483, 522CMOS, 55–58, 61, 517, 519
logic circuit, 104, 331, 333
Code conversion, 111–112Codes, 14, 16, 131, 306, 456, 482
Index 539 
Code transformation, 400–401, 434–435
Coefficient, 4, 6, 92, 295–297, 314, 552Coincidence, 50, 67, 69, 117, 266Collector, 83, 494, 496, 499, 501, 504–506Combinational circuit, 103–105, 108, 114, 133, 135, 
164, 171, 197, 202
analysis, 108design, 114
Combinational logic, 98, 103–104, 108, 112, 114, 138, 
160, 162
with decoders, 137with MSI and LSI, 137–138, 140, 142, 160, 164with multiplexers, 160–161, 277, 341with PLA, 171, 177with ROM, 234
Commutative law, 31Comparator, 145, 147, 175Compare, 146–147, 175Complement, 9–11, 13, 37, 47, 76, 83, 85, 104, 244
of a function, 42–43
Complementary MOS (see CMOS), 515Complements, 9, 11, 13, 148, 172, 246, 350
subtraction, 9, 11, 29, 31
Computer, 1–3, 18, 21, 133, 144, 271, 297, 302, 309
design, 28
Computer console, 368, 438, 442Computer instruction, 303
types, 303
Conditional code, 284Control address register, 368–369, 378, 383, 398Control function, 272, 321, 346, 425, 434
conditional, 284
Control logic design, 362, 364, 366, 366, 370, 388, 394Control memory, 344, 346, 368, 377
writable, 368
Control of processor, 382, 405Control organization, 344, 364, 377, 396, 429Control state diagram, 364, 373–374, 390, 402, 405Control-type instructions, 457–458Control unit, 2–3, 254, 317, 378, 419, 429, 460Control word, 236, 343, 345, 368, 385, 401Counter, 215, 244, 246, 249
BCD, 249binary, 247design of, 230, 247johnson, 257mod-N, 253ripple, 269self starting, 218, 269synchronous, 247, 249
CP (see clock pulses), 210, 224, 231, 243CPU, 317, 320, 444, 462, 483Crystal, 26, 450Current, 59, 265, 270, 495Cutoff, 495, 497, 504Cycle stealing, 484
D
Darlington pair, 507Data book, 62, 173, 268, 402, 517Data bus, 486, 488, 536Data counter, 458Data path, 318
gating, 318
Data-processor, 362, 369, 371, 390, 404Data selector, 156DC current gain, 495Decimal adder, 143, 175, 293Decimal addition, 314Decimal codes, 15Decimal data, 293–294, 315Decimal numbers, 92, 143, 249, 294, 314
conversion to binary, 2939’ s complement, 13, 16, 29, 133, 294, 53510’ s complement, 11, 29–30
Declaration statement, 274Decorder, 163
BCD-to-seven-segment, 133–134, 147BCD-to-decimal, 149–151, with enable input, 403implementation, 313, 364
Decoder/demultiplexer, 154, 176Decrement, 281, 327–328, 459, 491De morgan’ s theorem, 37, 42, 123, 127Demultiplexer, 153–154, 176Depletion mode, 514Design algorithm, 360–363, 369Destructive read-out, 259, 261, 266D flip-flop, 183, 204, 220, 223, 242, 376
edge triggered, 185, 189, 230, 244
Digital circuit, 60, 64, 87, 114, 363, 517Digital computer, 18, 21, 28, 268, 396, 439Digital integrated circuits, 28, 62, 492Digital logic gates, 51–52, 54, 65, 103Digital multiplexer, 156–157Digital system, 16, 27, 156, 271, 369, 444, 447Diode, 492, 497, 507, 509, 519Diode characteristic, 497Diode-transistor logic (see DTL), 492DIP , 27Direct address, 302Direct clear, 192Direct memory access, 450, 476, 484Discrete information, 1, 20Distributive law, 32, 35, 39, 47, 62DMA transfer, 476, 484, 487Don’t care conditions, 87, 150
540 Index
Drain, 513–515, 517
DTL, 492, 497, 499, 518–519
basic gate, 493, 500modified gate, 500
Dual-in-line package, 27Duality, 35, 37, 47, 57Dynamic indicator, 183
E
EBCDIC, 19–21, 30, 167ECL, 55–57, 61, 511
basic gate, 61, 511
Edge-triggered flip-flop, 187, 189–190, 192Effective address, 462–463Electronics, 55, 98, 173, 268, 492, 517Emitter, 492, 493, 512, 518Emitter-coupled logic (see ECL), 55, 492, 511Emitter-follower, 509, 512Enable, 362, 417, 469, 519Encoder, 154–155End around carry, 12–14, 288End carry, 11–12, 289, 410, 452Enhancement mode, 514EPROM, 166Equivalence, 50, 54, 57, 130, 132, 360Equivalence function, 50, 54, 77, 129, 135, 146Error-detection codes, 16Even function, 54Excess-3 code, 15, 21, 29, 112, 114, 116Excitation table, 204–208Exclusive-NOR, 50–52, 57, 142, 490Exclusive-OR, 49–51, 77, 109, 131, 220, 283
functions, 131Implementation, 275, 282
execute cycle, 419, 421, 477exponent, 297, 314, 532
F
FA ( see full adder), 139, 290, 329
Fan-out, 59, 61, 493, 499, 518FET, 493, 513Fetch cycle, 306–308Field, 32, 170, 378, 381, 397, 401, 513Firmware, 386Fixed-point, 285–286, 295, 386, 402Flag bit, 411, 479–480Flat package, 27Flip-flop, 124, 180–189
basic circuit, 182, 511characteristic equation, 182–184characteristic table, 182, 185clocked, 180, 182Direct coupled, 181direct inputs, 192d type, 190–191, 230edge-triggered, 189–191excitation table, 205–208, 211input functions, 197–198JK type, 184–185, 207, 243master-slave, 185, 187, 290RS type, 182triggering, 185, 187, 193T type, 207, 360
Floating type, 294
normalized, 296, 314
Floppy disk, 483Flowchart, 363–364FPLA, 170, 433Full-adder, 106, 336, 348, 355, 526Full-subtractor, 110–111, 136
G
Gate, 53, 58, 60, 64, 79, 84, 120, 180, 331Gated latch, 184, 230Gray code, 18
H
Half-adder, 105–107, 142Half-subtractor, 109–110Handshake, 477–479
transfer with, 477
Hardware, 166, 378, 445, 470Hard-wired control, 365, 369, 386, 418, 430, 437
Design, 369Example, 369
Hexadecimal code, 413, 417, 423, 440, 458Hexadecimal numbers, 8–9
conversion to binary, 293
High-impedance state, 448, 450, 509High-level signal, 183High-threshold logic, 499–500Hold command, 484HTL, 499–500Huntington postulates, 33, 35, 50, 62Hysteresis loop, 265
I
ICIC logic families, 58–61, 64
characteristics of, 59–60voltage levels, 60
IC RAM, 264Identity element, 31–33
Index 541 
Immediate mode, 461, 490
Implication, 49–51, 64Implied, 157, 301–302Increment, 251, 272, 282Indexed addressing, 462–463Index register, 462–463Indirect addressing, 463Inhibition, 49–51, 64Input carry, 138–139, 141, 331, 334Input device, 3, 400, 409, 411, 439Input equations, 197Input functions, 197–198Input-output instructions, 413, 417, 438, 442Input-output interface, 444, 474Input register, 22, 409, 411Instruction code, 300–301Instruction format, 301, 315Instruction register, 304, 315, 401, 408, 410, 468Integrated circuit gates, 56Integrated circuit memory, 263–264Integrated circuits, 137, 173, 508, 512, 519Integrated circuit type
10102, 55–5610107, 55–562901, 3222910, 3964002, 56–574022, 2587400, 55–587404, 55–567442, 1517475, 2307485, 14774L85, 175–1767487, 3567490, 24574138, 14874148, 15574157, 15774161, 249, 42874175, 23074182, 142, 17474194, 23874283, 139, 17482S83, 14582S100, 1689408, 396Integrated-injection logic (See IIL), 55, 492, 500Interregister transfer, 273, 281, 384Interrupt, 449–450, 463, 468, 470
priority, 469
Interrupt acknowledge, 449, 469, 471Interrupt enable, 468–469Interrupt request, 449, 468, 487, 489Interval timer, 483Invalid state, 218, 257, 270Inverse, 32, 62Inverter, 26, 41, 51, 79, 118, 127, 165, 231, 519I/O bus, 445, 476, 479I
2L, 55, 492, 500, 502, 519
basic gate, 501interconnection, 492
Isolated, 188, 476–477
J
JK flip flop, 184–185, 194, 205, 208, 349, 391
master-slave, 188–189
Johnson counter, 256–257, 270Jump instruction, 457Junction transistor, 493
K
Karnaugh map, 65
L
Large scale integration, 28Latch, 181, 184, 230, 488, 492
D type, 190, 220, 230, 365SR type, 181
LIFO, 397, 463Literal, 41, 43, 68, 93, 108Load input, 232, 252, 282, 434Logical word, 300, 412
negative logic, 57–59, 64positive logic, 57–59, 64, 491
Logic circuit, 55, 104, 145, 332, 520
design of, 331
Logic design, 133, 244, 317, 320, 336Logic gates, 25, 54, 186, 309, 441Logic microoperations, 273, 283, 297, 313, 360Logic operations, 49, 272, 283, 297, 325, 331, 334, 413, 
439
Logic polarity, 59, 78Look-ahead carry, 141–143, 174
generator, 141, 174
LSI, 28, 55, 137, 152, 158, 168, 173, 443, 446LSI circuits, 138, 173, 492LSI components, 173, 402–444, 446, 449LSI functions, 55, 173, 492
asynchronous receiver-transmitter, 429bit-slice microprocessor, 320central processor unit, 3, 317, 399, 443, 451direct memory access, 450, 476, 484input-output interface, 444, 474microcomputer, 466, 470, 472, 474, 488
542 Index
microprocessor, 320, 445, 449, 454, 467, 474
microprogram sequencer, 396, 398parallel peripheral interface, 476–478, 480, 486programmable logic array, 167–170, 234, 310, 365, 
367, 393, 402
random access memory, 229, 262, 368, 443, 445read only memory, 161–162, 166serial communication interface, 476, 480, 483
M
M(see memory word), 259, 279, 422, 477Macrooperation, 304, 384, 485Magnetic core memory, 261–262Magnetic flux, 265–266Magnitude comparator, 145–147Mantissa, 295Map method, 65, 91, 96, 98
alternative versions, 65
Mapping function, 401MAR, 310, 360, 423Mask, 166, 168, 298, 468Master clock, 180, 231, 279, 408Master-slave flip-flop, 187–188, 492Maxterm, 44, 47MBR, 260–261Medium scale integration, 28Memory, 2, 22, 167, 179
access time, 262integrated circuit, 27, 204, 263magnetic core, 261, 265random access, 229, 262, 445read only, 138, 161, 166, 307, 365, 443scratchpad, 321–323stack, 397–3982-port, 322–323volatile, 262, 444
Memory address, 260, 273, 279, 301, 409, 472, 489Memory address map, 472–473, 490Memory address register, 258–260, 270, 273, 305Memory buffer register, 259–260, 270, 304, 408, 418Memory cycle, 262, 438, 452–453, 490
stealing, 484
Memory enable, 264, 323Memory mapped I/O, 476–477, 490Memory organization, 471Memory read, 305, 321, 323, 417, 426, 488Memory reference instructions, 413–415, 421, 442Memory register, 22, 258, 278Memory select, 321Memory stack, 398, 457, 463Memory transfer, 275, 277, 279, 315, 453Memory unit, 22, 236, 246, 252, 258–259, 261
examples, 9Memory word, 258–259, 275, 302, 304, 422, 438Memory write, 312, 321, 410, 426, 488Metal-oxide semiconductor (see SOM), 55, 492, 494, 
513
Microcomputer, 3, 173, 402, 429, 444, 456, 472Microcomputer chip, 449, 447, 483Microinstruction, 369, 377, 380, 384, 401, 438
fields of, 401
Microoperation, 272, 284, 299, 342, 350, 422
arithmetic, 410, 412interregister transfer, 273, 281, 304, 315logic, 271–272shift, 269, 272
Microprocessor, 3, 320
control signals, 237, 258–259, 449, 484, 488instructions, 308, 417, 458–460, 490memory connection, 474–475organization, 266, 304, 449, 463, 471, 477sequencing, 313, 377, 396, 443, 454
Microprogram, 365, 368, 376, 381, 384, 399Microprogram control, 365, 368–369, 437, 444
of computer, 402, 407of CPU, 402example, 402of processor, 392, 405
Microprogram sequencer, 396–399, 400, 405, 443Minterm, 43–44, 46, 68, 70, 73, 77, 93, 128, 234Minuend, 5, 11, 9, 109, 289Mod-N counter, 253MOS, 55, 62, 492, 494, 513–515, 519
basic gate, 501
MOS transistor, 494, 513–514, 516–517, 519Move instruction, 306, 457, 488MSI, 242, 270, 310, 428, 528, 536MSI circuit, 28, 145, 174, 229, 253, 429MSI functions, 138, 161, 173, 175, 232
accumulator, 324BCD adder, 144–145binary adder, 144–146bus buffer, 447–448, 485counters, 215, 217, 226, 242decoder, 147, 151, 154demultiplexer, 153–154, 176encoder, 154–156johnson counter, 256–257, 270look-ahead carry generator, 141–143, 174magnitude comparator, 145–147multiplexer, 156–157priority encoder, 156, 470, 491random access memory, 229, 262, 368, 443, 445read only memory, 161–162, 167register, 348, 360, 367, 370shifter, 341, 359shift- register, 241, 243
Index 543 
Multilevel NAND circuits, 117
Multilevel NOR circuits, 124Multiplexer, 156–157
implementation with, 156–157
Multiplicand, 386–387, 388, 404Multiplication, 294, 317, 361, 386Multiplier, 386–387Multiprocessor, 445, 487MUX (see multiplexer), 341, 378, 429, 531
N
NAND, 30, 50, 52, 56, 64, 79NAND circuits, 117
Analysis, 117Multilevel, 117
NAND gate, 79–80, 85, 515, 517, 517
graphic symbols, 78
Negative edge, 186–189Negative logic, 57, 59, 64, 78, 515
graphic symbol, 51, 58
Negative zero, 288–289, 402Next-state, 268, 348, 391, 396Noise margin, 60–61, 493Nondegenerate forms, 84Nonnumeric data, 297NOR, 181, 191, 223, 512, 524, 527NOR circuits, 117, 124, 147
analysis, 117multilevel, 117
NOR gate, 54, 58–59, 64, 125, 127
graphic symbols, 59, 78
NOT, 170, 334, 358, 374Number base conversions, 6
O
Octal number, 148, 296, 314
conversion to binary, 293conversion to decimal, 293
Odd function, 54One flip-flop per state, 364–366, 369
example, 364
Open collector gate, 506–507, 509
common bus, 447, 449, 479wired logic, 83, 265, 505
Operation, 494, 500, 505Operation-code, 302, 308, 409, 440, 454Operation-type instructions, 457–458Operator precedence, 38OR, 34–35, 38OR-AND-INVERT, 83, 85–86OR gate, 51, 76, 151Output carry, 138–139status bit, 338, 340
Output device, 21, 409, 411Output register, 409, 411, 417, 429Overflow, 383, 403, 532, 535
status bit, 434, 457
P
Packing, 299–300, 500–501, 520Paging, 461Parallel adder, 138–141
with look ahead carry, 143
Parallel load, 231–233, 238Parallel peripheral interface, 476–478, 480Parallel transfer, 238, 269, 277Parity bit, 131–132Parity check, 17, 132Parity generator, 131–132, 136PC board, 447Peripheral interface, 476–478, 480, 483, 490Pipeline register, 400–401, 405PLA, 395–396PLA control, 393–396, 405
example, 393
PLA program table, 168, 170–172, 177, 394Pointer, 397–399Polarity indicator, 59, 78Polling, 469–470Pop stack, 398–399, 465Positive edge, 187–189, 192, 247Positive logic, 57–59, 64, 78, 493Postulate, 36–37, 522Power dissipation, 59–61, 64, 493, 502, 512, 517Present-page, 461, 489–490Present state, 179, 183, 185, 195, 199Prime implicant, 93, 95
essential, 93
Printed circuit board, 447Priority encoder, 155, 176, 470, 489, 491Priority interrupt, 469–471, 483Processor logic design, 317–318, 320, 322, 324, 328, 
332, 356, 360
Processor organization 318, 360Processor unit, 317–318, 320–321
control of, 317
Product of maxterms, 45–46, 48, 63, 77, 99Product of sums, 48, 65, 75, 80Product term, 79, 170–171Program counter, 304, 306, 408, 410, 414, 461Programmable interface, 443, 474Programmable logic array, 167–168, 170, 234, 310, 365
control logic with, 366–367field programmable, 168, 170, 402program table, 394–395
544 Index
Program memory, 444
PROM, 166Propagation delay, 60, 64, 142, 186, 491Push stack, 399
R
Radix, 285, 294, 296Radix-point, 285, 296RALU, 320RAM, 321, 445, 471RAM chip, 471–472Random-access, 229, 262Read, 266–268Read cycle, 268, 270, 305, 452Read only memory, 161–162, 166–167
combinational logic with, 164, 172in control logic, 163truth table, 24, 37, 39types of, 472
Reflected code, 30, 72, 96, 135Register, 21–22, 30, 230–231, 409, 489
with parallel load, 231–232
Register-indirect, 458, 460Register mode, 460, 490Register operations, 425Register pair, 452, 458–459Register-reference instructions, 414, 416, 420, 423Register stack, 398, 464, 485Register transfer, 444, 458, 464Register transfer language, 272, 274, 282Register transfer logic, 271–272, 274, 296, 304, 316Relative addressing, 461, 489Replacement operator, 274Reset, 181, 212, 468, 481Resistor, 492, 497–498Resistor-transistor logic (see RTL), 492Return address, 397–398, 416Return from subroutine, 399, 457, 459, 467, 489Ring counter, 255–257
switch-tail, 255
Ring counter controller, 365Ripple counter, 242–244ROM (see read only memory), 447, 454, 471ROM chip, 472–474, 490RS flip-flop, 181–184RTL, 492, 497
basic gate, 493, 500
S
Saturation region, 495–496, 499Schottky transistor, 508Schottky TTL, 60–61, 503, 508Scratchpad memory, 314, 321–322, 356, 360Self starting counter, 218Sense amplifier, 266–268Sense wire, 266Sequencer, 396–397, 399Sequencer register, 386
control example, 386
Sequential circuit, 103, 114
analysis, 356, 493asynchronous, 180, 185clocked, 229, 233design, 348, 352synchronous, 248, 269
Sequential logic, 179–180, 182, 216, 220, 375, 393
control, 272digital system, 179, 215, 236implementation
Serial addition, 139, 240Serial input, 235–238Serial output, 235–237, 320Serial transfer, 236–237, 490Set, 223, 233, 298, 331, 375, 411, 453Seven-segment decoder, 133–134Shifter, 319–321
design, 319
Shift microoperation, 284, 300
arithmetic, 281, 283logic, 283–284
Shift register, 238, 240, 269, 281
bidirectional, 238, 240, 271with parallel load, 270, 313
Sign bit, 293, 314, 338, 345, 414, 452Sign-magnitude, 286–287, 294, 317Sign-9’ s complement, 294Sign-1’ s complement, 287, 289, 314, 440Sign-10’ s complement, 294, 314, 316Sign-2’ s complement, 290, 292, 294Skip instruction, 414, 416–417, 457Small-scale integration, 28Software, 386, 445, 470, 488Source, 25, 193, 236, 321, 457Speed-power product, 502–503, 512SSI, 55, 137, 365, 447, 470, 503Stack, 397–399, 452, 457Stack pointer, 397–399, 465, 489Standard forms, 43, 48, 76–77, 83, 96Standard product, 43Start bit, 482–483State, 374–375, 389, 394, 405, 448State assignment, 202–203, 223State diagram, 199–201, 219, 224, 374, 390State equation, 195–196
design, 196
State reduction, 198–200, 202State table, 194–195, 198Status register, 338–339, 342
Index 545 
Stop bit, 482
Storage register, 258–259Subroutine, 396–397, 399, 407, 415, 465Subtraction, 4, 11, 29, 33, 295, 297, 371–372
with sign-magnitude, 289with sign-2’ s complement, 287
Subtractor, 111, 176, 281, 331, 376, 403
full, 110–111half, 109–110
Subtrahend, 5, 11, 109, 289, 414Sum of minterms, 45–48Sum of products, 48, 75, 82, 108, 168, 170Switching circuit, 25, 30, 194, 223Symbolic microprogram, 380–381, 385Sync character, 482Synchronous counter, 242, 247, 249, 352System design, 407, 419, 443, 446, 448
T
Tabulation method, 89, 92, 96Teletype, 1, 21–22, 482Teletypewriter, 3, 407, 411, 429T flip-flop, 185–186, 206, 217Three-state bus, 511Three-state gate, 448, 509, 511Threshold voltage, 514–515Time constant, 506–507Timing and control, 408, 417, 445, 450, 454Timing diagram, 207, 246, 254Timing sequence, 272, 363, 419, 424Timing variables, 284, 308, 432, 441Toggle, 185, 192Totem-pole gate, 509Transfer, 30, 50, 184Transfer-type instructions, 457Transistor, 55, 492, 494, 496, 500
characteristics, 494circuit, 478, 492
Transistor-transistor logic (see TTL), 55, 492–502Trigger, 185, 192, 244Triggering of flip-flops, 185, 417Tri-state, 447, 503, 509, 519True/complement, one/zero element, 327TTL, 55, 60, 139, 502, 504
open collector, 503–505Schottky, 61, 64, 5037400 series, 55standard, 423, 483three-state, 448, 503totem-pole, 503, 505, 509
Two-level implementation, 76, 78, 82, 163
2-port memory, 322–323
U
UART , 429
Unconditional branch, 380, 401, 460Unipolar, 493, 513Universal gate, 117, 124Unused state, 214–215, 257, 270Up-down counter, 247
V
V ectored interrupt, 468–469Veitch diagram, 65, 97Venn diagram, 38–39, 43, 65VLSI, 28V olatile memory, 444V oltage, 58, 60, 495, 499, 505
W
Wired-AND, 83, 505–506, 520Wired logic, 83, 505, 512, 518Word, 162, 167, 207, 258, 262, 266Word time, 236, 254, 272
generation of, 254
Write, 398, 400, 403Write cycle, 268, 270, 453
X
XOR (see exclusive core), 50, 177, 197, 299, 331, 338, 
383
Z
Zero indication, 338Zero page, 461–462, 489–490
www.allitebooks.com

Fundamentals  
of Logic Design
SEVENTH EDITION
Charles H. Roth, Jr.
University of Texas at Austin
Larry L. Kinney
University of Minnesota, Twin Cities
$XVWUDOLDä%UD]LOä-DSDQä.RUHDä0H[LFRä6LQJDSRUHä6SDLQ ä8QLWHG.LQJGRPä8QLWHG6WDWHV
www.allitebooks.com

Fundamentals of Logic Design, Seventh 
Edition
Charles H. Roth, Jr. and Larry L. Kinney
3XEOLVKHU*OREDO(QJLQHHULQJ7LP$QGHUVRQ
6HQLRU'HYHORSPHQWDO(GLWRU+LOGD*RZDQV(GLWRULDO$VVLVWDQW7DQ\D$OWLHUL6HQLRU0DUNHWLQJ0DQDJHU.DWH,DQQRWWL0HGLD(GLWRU&KULV9DOHQWLQH&RQWHQW3URMHFW0DQDJHU-HQQLIHU=LHJOHU3URGXFWLRQ6HUYLFH53.(GLWRULDO6HUYLFHV&RS\HGLWRU3DWULFLD'DO\3URRIUHDGHU0DUWKD0F0DVWHU,QGH[HU6KHOO\*HUJHU.QHFKWO&RPSRVLWRUGLDFUL7HFK6HQLRU$UW'LUHFWRU0LFKHOOH.XQNOHU,QWHUQDO'HVLJQHU&DUPHOD3HULHUD&RYHU'HVLJQHU5RVH$OFRUQ&RYHU,PDJHk.XGU\DVKND6KXWWHUVWRFNFRP
kWRYRYDQ6KXWWHUVWRFNFRP
5LJKWV$FTXLVLWLRQV6SHFLDOLVW$PEHU+RVHD7H[WDQG,PDJH3HUPLVVLRQV5HVHDUFKHU
.ULVWLLQD3DXO
6HQLRU0DQXIDFWXULQJ3ODQQHU'RXJ:LONHk20142010DQG2004&HQJDJH/HDUQLQJ
$//5,*+765(6(59(' 1RSDUWRIWKLVZRUNFRYHUHGE\WKH
FRS\ULJKWKHUHLQPD\EHU HSURGXFHGWUDQVPLWWHGVWRUHGRUXVH G
LQDQ\IRUPRUE\DQ\PHDQVJUDSKLFHOHFWURQLFRUPHFKDQLFDO 
LQFOXGLQJEXWQRWOLPLWHGWRSKRWRFRS\LQJUHFRUGLQJVFDQQLQJ 
GLJLWL]LQJWDSLQJZHEGLVWULEXWLRQLQIRUPDWLRQQHWZRUNVRU
LQIRUPDWLRQVWRUDJHDQGUHWULHYDOV\VWHPVH[FHSWDVSHUPLWWHGXQGHU6HFWLRQ107RU108RIWKH19768QLWHG6WDWHV&RS\ULJKW$FWZLWKRXWWKHSULRUZULWWHQSHUPLVVLRQRIWKHSXEOLVKHU
)RUSURGXFWLQIRUPDWLRQDQGWHFKQRORJ\DVVLVWDQFHFRQWDFWXVD W
Cengage Learning Customer & Sales Support, 1-800-354-9706 
)RUSHUPLVVLRQWRXVHPDWHULDOIURPWKLVWH[WRUSURGXFWVXEP LWDOO
UHTXHVWVRQOLQHDWwww.cengage.com/permissions 
)XUWKHUSHUPLVVLRQVTXHVWLRQVFDQEHHPDLOHGWR
permissionrequest@cengage.com
/LEUDU\RI&RQJUHVV&RQWURO1XPEHU 2012952056
,6%1 13978-1-133-62847-7
,6%1 101133628478
Cengage Learning200)LUVW6WDPIRUG3ODFH6XLWH 400
6WDPIRUG&70690286$
&HQJDJH/HDUQLQJLVDOHDGLQJSURYLGHURIFXVWRPL]HGOHDUQLQJ
VROXWLRQVZLWKRėFHORFDWLRQVDURXQGWKHJOREHLQFOXGLQJ6LQJDSRUHWKH8QLWHG.LQJGRP$XVWUDOLD0H[LFR%UD]LODQG-DSDQ/RFDWH\RXUORFDORėFHDWinternational.cengage.com/region 
&HQJDJH/HDUQLQJSURGXFWVDU HUHSUHVHQWHGLQ&DQDGDE\  
1HOVRQ(GXFDWLRQ/WG
)RU\RXUFRXUVHDQGOHDUQLQJVROXWLRQVYLVLW  
 www.cengage.com/engineering 
3XUFKDVHDQ\RIRXUSURGXFWVDW\RXUORFDOFROOHJHVWRUHRUDWRXU
SUHIHUUHGRQOLQHVWRUH www.cengagebrain.com
([FHSWZKHUHRWKHUZLVHQRWHGDOOFRQWHQWLVk&HQJDJH/HDUQLQJ 2014
Printed in the United States of America
1 2 3 4 5 6 7   16 15 14 13
www.allitebooks.com

Dedication
Dedicated to the memory of Karen Kinney and our daughters, 
Laurie and Kristina.
 —Larry Kinney
www.allitebooks.com

Brief Contents
 1 Introduction  
Number Systems and Conversion 1
 2 Boolean Algebra 29
 3 Boolean Algebra (Continued) 60
 4 Applications of Boolean Algebra  Minterm and Maxterm Expansions 87
 5 Karnaugh Maps 123
 6 Quine-McCluskey Method 167
 7 Multi-Level Gate Circuits  NAND and NOR Gates 193
 8 Combinational Circuit Design  and Simulation Using Gates 225
 9 Multiplexers, Decoders, and Programmable  Logic Devices 252
www.allitebooks.com

viii  Brief Contents
 10 Introduction to VHDL 294
 11 Latches and Flip-Flops 331
 12 Registers and Counters 370
 13 Analysis of Clocked Sequential Circuits 412
 14 Derivation of State Graphs and Tables 453
 15 Reduction of State Tables  
State Assignment 497
 16 Sequential Circuit Design 545
 17 VHDL for Sequential Logic 585
 18 Circuits for Arithmetic Operations 626
 19 State Machine Design with SM Charts 660
 20 VHDL for Digital System Design 684
  Appendices 713
www.allitebooks.com

ixContents
Preface xvii
How to Use This Book for Self-Study xxiiAbout the Authors xxiii
 Unit 1 Introduction  
Number Systems and Conversion 1
Objectives  1
Study Guide  2
1.1 Digital Systems and Switching Circuits  61.2 Number Systems and Conversion  81.3 Binary Arithmetic  121.4 Representation of Negative Numbers  16
 Sign and Magnitude Numbers  16
 2’s Complement Numbers  16
 Addition of 2’s Complement Numbers  17
 1’s Complement Numbers  19
 Addition of 1’s Complement Numbers  19
1.5 Binary Codes  21
Problems  24
 Unit 2 Boolean Algebra 29
Objectives  29Study Guide  30
2.1 Introduction  362.2 Basic Operations  372.3 Boolean Expressions and Truth Tables  39
www.allitebooks.com

x  Contents
2.4 Basic Theorems  41
2.5 Commutative, Associative, Distributive, and  
DeMorgan’s Laws  43
2.6 Simplification Theorems  462.7 Multiplying Out and Factoring  492.8 Complementing Boolean Expressions  52
Problems  53
 Unit 3 Boolean Algebra (Continued) 60
Objectives  60Study Guide  61
3.1 Multiplying Out and Factoring Expressions  663.2 Exclusive-OR and Equivalence Operations  683.3 The Consensus Theorem  703.4 Algebraic Simplification of Switching Expressions  723.5 Proving Validity of an Equation  74
Programmed Exercises  77Problems  82
 Unit 4 Applications of Boolean Algebra  
Minterm and Maxterm Expansions 87
Objectives  87Study Guide  88
4.1 Conversion of English Sentences to Boolean Equations  944.2 Combinational Logic Design Using a Truth Table  964.3 Minterm and Maxterm Expansions  974.4 General Minterm and Maxterm Expansions  1004.5 Incompletely Specified Functions  1034.6 Examples of Truth Table Construction  1044.7 Design of Binary Adders and Subtracters  108
Problems  114
 Unit 5 Karnaugh Maps 123
Objectives  123Study Guide  124
5.1 Minimum Forms of Switching Functions  1345.2 Two- and Three-Variable Karnaugh Maps  136
www.allitebooks.com

Contents  xi
5.3 Four-Variable Karnaugh Maps  141
5.4  Determination of Minimum Expressions Using  
Essential Prime Implicants  144
5.5 Five-Variable Karnaugh Maps  1495.6 Other Uses of Karnaugh Maps  1525.7 Other Forms of Karnaugh Maps  153
Programmed Exercises  154Problems  159
 Unit 6 Quine-McCluskey Method 167
Objectives  167Study Guide  168
6.1 Determination of Prime Implicants  1736.2 The Prime Implicant Chart  1766.3 Petrick’s Method  1796.4 Simplification of Incompletely Specified Functions  1816.5 Simplification Using Map-Entered Variables  1826.6 Conclusion  184
Programmed Exercise  185Problems  189
 Unit 7 Multi-Level Gate Circuits  
NAND and NOR Gates 193
Objectives  193Study Guide  194
7 .1 Multi-Level Gate Circuits  1997 .2 NAND and NOR Gates  2047 .3 Design of Two-Level NAND- and NOR-Gate Circuits  2067 .4 Design of Multi-Level NAND- and NOR-Gate Circuits  2097 .5 Circuit Conversion Using Alternative Gate Symbols  2107 .6 Design of Two-Level, Multiple-Output Circuits  214
  Determination of Essential Prime Implicants for  
Multiple-Output Realization  216
7 .7 Multiple-Output NAND- and NOR-Gate Circuits  217
Problems  218
www.allitebooks.com

xii  Contents
 Unit 8 Combinational Circuit Design  
and Simulation Using Gates 225
Objectives  225
Study Guide  226
8.1 Review of Combinational Circuit Design  2298.2 Design of Circuits with Limited Gate Fan-In  2308.3 Gate Delays and Timing Diagrams  2328.4 Hazards in Combinational Logic  2348.5 Simulation and Testing of Logic Circuits  240
Problems  243Design Problems  246
Seven-Segment Indicator  246
 Unit 9 Multiplexers, Decoders, and Programmable  
Logic Devices 252
Objectives  252
Study Guide  253
9.1 Introduction  2609.2 Multiplexers  2619.3 Three-State Buffers  2659.4 Decoders and Encoders  2689.5 Read-Only Memories  2719.6 Programmable Logic Devices  275
 Programmable Logic Arrays  275
 Programmable Array Logic  278
9.7 Complex Programmable Logic Devices  2809.8 Field-Programmable Gate Arrays  282
 Decomposition of Switching Functions  283
Problems  286
 Unit 10 Introduction to VHDL 294
Objectives  294Study Guide  295
10.1 VHDL Description of Combinational Circuits  29910.2 VHDL Models for Multiplexers  30410.3 VHDL Modules  306
 Four-Bit Full Adder  308
www.allitebooks.com

Contents  xiii
10.4 Signals and Constants  311
10.5 Arrays  31210.6 VHDL Operators  31510.7 Packages and Libraries  31610.8 IEEE Standard Logic  31810.9 Compilation and Simulation of VHDL Code  321
Problems  322Design Problems  327
 Unit 11 Latches and Flip-Flops 331
Objectives  331Study Guide  332
11.1 Introduction  33611.2 Set-Reset Latch  33811.3 Gated Latches  34211.4 Edge-Triggered D Flip-Flop  34611.5 S-R Flip-Flop  34911.6 J-K Flip-Flop  35011.7 T Flip-Flop  35111.8 Flip-Flops with Additional Inputs  35211.9 Asynchronous Sequential Circuits  35411.10 Summary  357
Problems  358Programmed Exercise  367
Unit 12 Registers and Counters 370
Objectives  370Study Guide  371
12.1 Registers and Register Transfers  376
 Parallel Adder with Accumulator  378
12.2 Shift Registers  38012.3 Design of Binary Counters  38412.4 Counters for Other Sequences  389
 Counter Design Using D Flip-Flops  393
12.5 Counter Design Using S-R and J-K Flip-Flops  39512.6 Derivation of Flip-Flop Input Equations—Summary  398
Problems  402
xiv  Contents
 Unit 13 Analysis of Clocked Sequential Circuits 412
Objectives  412
Study Guide  413
13.1 A Sequential Parity Checker  41913.2 Analysis by Signal Tracing and Timing Charts  42113.3 State Tables and Graphs  425
 Construction and Interpretation of Timing Charts  430
13.4 General Models for Sequential Circuits  432
Programmed Exercise  436Problems  441
 Unit 14 Derivation of State Graphs and Tables 453
Objectives  453Study Guide  454
14.1 Design of a Sequence Detector  45714.2 More Complex Design Problems  46314.3 Guidelines for Construction of State Graphs  46714.4 Serial Data Code Conversion  47314.5 Alphanumeric State Graph Notation  47614.6 Incompletely Specified State Tables  478
Programmed Exercises  480Problems  486
 Unit 15 Reduction of State Tables  
State Assignment 497
Objectives  497Study Guide  498
15.1 Elimination of Redundant States  50515.2 Equivalent States  50715.3 Determination of State Equivalence Using an  
Implication Table  509
15.4 Equivalent Sequential Circuits  51215.5 Reducing Incompletely Specified State Tables  51415.6 Derivation of Flip-Flop Input Equations  51715.7 Equivalent State Assignments  51915.8 Guidelines for State Assignment  52315.9 Using a One-Hot State Assignment  528
Problems  531
Contents  xv
 Unit 16 Sequential Circuit Design 545
Objectives  545
Study Guide  546
16.1 Summary of Design Procedure for Sequential Circuits  54816.2 Design Example—Code Converter  54916.3 Design of Iterative Circuits  553
 Design of a Comparator  553
16.4 Design of Sequential Circuits Using ROMs and PLAs  55616.5 Sequential Circuit Design Using CPLDs  55916.6 Sequential Circuit Design Using FPGAs  56316.7 Simulation and Testing of Sequential Circuits  56516.8 Overview of Computer-Aided Design  570
Design Problems  572Additional Problems  578
 Unit 17 VHDL for Sequential Logic 585
Objectives  585Study Guide  586
17 .1 Modeling Flip-Flops Using VHDL Processes  59017 .2 Modeling Registers and Counters  
Using VHDL Processes  594
17 .3 Modeling Combinational Logic Using VHDL Processes  59917 .4 Modeling a Sequential Machine  60117 .5 Synthesis of VHDL Code  60817 .6 More About Processes and Sequential Statements  611
Problems  613Simulation Problems  624
 Unit 18 Circuits for Arithmetic Operations 626
Objectives  626Study Guide  627
18.1 Serial Adder with Accumulator  62918.2 Design of a Binary Multiplier  63318.3 Design of a Binary Divider  637
Programmed Exercises  644Problems  648
xvi  Contents
 Unit 19 State Machine Design with SM Charts 660
Objectives  660
Study Guide  661
19.1 State Machine Charts  66219.2 Derivation of SM Charts  66719.3 Realization of SM Charts  672
Problems  677
 Unit 20 VHDL for Digital System Design 684
Objectives  684Study Guide  685
20.1 VHDL Code for a Serial Adder  68820.2 VHDL Code for a Binary Multiplier  69020.3 VHDL Code for a Binary Divider  70020.4 VHDL Code for a Dice Game Simulator  70220.5 Concluding Remarks  705
Problems  706Lab Design Problems  709
 A  Appendices 713
A MOS and CMOS Logic  713B VHDL Language Summary  719C Tips for Writing Synthesizable VHDL Code  724D Proofs of Theorems  727E Answers to Selected Study Guide Questions and Problems  729
References  785
Index  786Description of the CD  792
xviiPreface
Purpose of the Text
This text is written for a first course in the logic design of digital systems. It is writ-
ten on the premise that the student should understand and learn thoroughly certain fundamental concepts in a first course. Examples of such fundamental concepts are the use of Boolean algebra to describe the signals and interconnections in a logic circuit, use of systematic techniques for simplification of a logic circuit, interconnec-tion of simple components to perform a more complex logic function, analysis of a sequential logic circuit in terms of timing charts or state graphs, and use of a control circuit to control the sequence of events in a digital system.
The text attempts to achieve a balance between theory and application. For this 
reason, the text does not overemphasize the mathematics of switching theory; how-ever, it does present the theory that is necessary for understanding the fundamental concepts of logic design. After completing this text, the student should be prepared for a more advanced digital systems design course that stresses more intuitive con-cepts like the development of algorithms for digital processes, partitioning of digi-tal systems into subsystems, and implementation of digital systems using currently available hardware. Alternatively, the student should be prepared to go on to a more advanced course in switching theory that further develops the theoretical concepts that have been introduced here.
Contents of the Text
After studying this text, students should be able to apply switching theory to the solution of logic design problems. They will learn both the basic theory of switch-ing circuits and how to apply it. After a brief introduction to number systems, they will study switching algebra, a special case of Boolean algebra, which is the basic mathematical tool needed to analyze and synthesize an important class of switching 
xviii  Preface
circuits. Starting from a problem statement, they will learn to design circuits of logic 
gates that have a specified relationship between signals at the input and output ter-minals. Then they will study the logical properties of flip-flops, which serve as mem-ory devices in sequential switching circuits. By combining flip-flops with circuits of logic gates, they will learn to design counters, adders, sequence detectors, and simi-lar circuits. They will also study the VHDL hardware description language and its application to the design of combinational logic, sequential logic, and simple digital systems.
As integrated circuit technology continues to improve to allow more components 
on a chip, digital systems continue to grow in complexity. Design of such complex systems is facilitated by the use of a hardware description language such as VHDL. This text introduces the use of VHDL in logic design and emphasizes the relation-ship between VHDL statements and the corresponding digital hardware. VHDL allows digital hardware to be described and simulated at a higher level before it is implemented with logic components. Computer programs for synthesis can convert a VHDL description of a digital system to a corresponding set of logic components and their interconnections. Even though use of such computer-aided design tools helps to automate the logic design process, we believe that it is important to under-stand the underlying logic components and their timing before writing VHDL code. By first implementing the digital logic manually, students can more fully appreciate the power and limitations of VHDL.
Although the technology used to implement digital systems has changed signifi-
cantly since the first edition of this text was published, the fundamental principles of logic design have not. Truth tables and state tables still are used to specify the behav-ior of logic circuits, and Boolean algebra is still a basic mathematical tool for logic design. Even when programmable logic devices (PLDs) are used instead of indi-vidual gates and flip-flops, reduction of logic equations is still desirable in order to fit the equations into smaller PLDs. Making a good state assignment is still desirable, because without a good assignment, the logic equations may require larger PLDs.
Strengths of the Text
Although many texts are available in the areas of switching theory and logic design, this text is designed so that it can be used in either a standard lecture course or in a self-paced course. In addition to the standard reading material and problems, study guides and other aids for self-study are included in the text. The content of the text is divided into 20 study units. These units form a logical sequence so that mastery of the material in one unit is generally a prerequisite to the study of succeeding units. Each unit consists of four parts. First, a list of objectives states precisely what you are expected to learn by studying the unit. Next, the study guide contains reading assignments and study questions. As you work through the unit, you should write out  
the answers to these study questions. The text material and problem set that  follow 
Preface  xix
are similar to a conventional textbook. When you complete a unit, you should 
review the objectives and make sure that you have met them. Each of the units has  undergone extensive class testing in a self-paced environment and has been revised based on student feedback.
The study units are divided into three main groups. The first 9 units treat Boolean 
algebra and the design of combinational logic circuits. Units 11 through 16, 18 and 19 are mainly concerned with the analysis and design of clocked sequential logic circuits, including circuits for arithmetic operations. Units 10, 17 , and 20 introduce the VHDL hardware description language and its application to logic design.
The text is suitable for both computer science and engineering students. Material 
relating to circuit aspects of logic gates is contained in Appendix A so that this mate-rial can conveniently be omitted by computer science students or other students with no background in electronic circuits. The text is organized so that Unit 6 on the Quine-McCluskey procedure may be omitted without loss of continuity. The three units on VHDL can be studied in the normal sequence, studied together after the other units, or omitted entirely.
Supplements and Resources
This book comes with support materials for both the instructor and the student. The supplements are housed on the book’s companion website. To access the additional course materials, please visit www.cengagebrain.com. At the cengagebrain.com 
home page, search for the ISBN of your title (from the back cover of your book) using the search box at the top of the page. This will take you to the product page where these resources can be found.
Instructor Resources
An instructor’s solution manual (ISM) is available that includes suggestions for using the text in a standard or self-paced course, quizzes on each of the units, and suggestions for laboratory equipment and procedures. The instructor’s manual also contains solutions to problems, to unit quizzes, and to lab exercises.
The ISM is available in both print and digital formats. The digital version is avail-
able to registered instructors at the publisher’s website. This website also includes both a full set of PowerPoint slides containing all graphical images and tables in the text, and a set of Lecture Builder PowerPoint slides of all equations and example problems.
Student Resources
Since the computer plays an important role in the logic design process, integration of computer usage into the first logic design course is very important. A  computer-aided logic design program, called LogicAid, is included on the CD that accompanies this 
xx Preface
text. LogicAid allows the student to easily derive simplified logic equations from 
minterms, truth tables, and state tables. This relieves the student of some of the more 
tedious computations and permits the solution of more complex design problems in a shorter time. LogicAid also provides tutorial help for Karnaugh maps and deriva-
tion of state graphs.
Several of the units include simulation or laboratory exercises. These exercises 
provide an opportunity to design a logic circuit and then test its operation. The SimUaid logic simulator, also available on the book’s accompanying CD, may be used 
to verify the logic designs. The lab equipment required for testing either can be a breadboard with integrated circuit flip-flops and logic gates or a circuit board with a programmable logic device. If such equipment is not available, the lab exercises can be simulated with SimUaid or just assigned as design problems. This is especially important for Units 8, 16, and 20 because the comprehensive design problems in these units help to review and tie together the material in several of the preceding units.
The DirectVHDL software on the CD provides a quick way to check and simu-
late VHDL descriptions of hardware. This software checks the syntax of the VHDL code as it is typed in so that most syntax errors can be corrected before the simula-tion phase.
Changes from Previous Editions
The text has evolved considerably since the fifth edition. Programmable logic and the VHDL hardware description language were added, and an emphasis was placed on the role of simulation and computer-aided design of logic circuits. The discussion of VHDL, hazards, latches and one-hot state assignments was expanded. Numerous problems were added. Several additional changes have been made for the seventh edition. The discussion of number systems was reorganized so that one’s comple-ment number systems can be easily omitted. In the unit on Boolean algebra, the laws of switching algebra are first derived using switch networks and truth tables; these are used to define Boolean algebra and, then, further theorems of Boolean algebra are derived that are useful in simplifying switching algebra expressions. The discussion of adders is expanded to include carry-lookahead adders. Alterna-tive implementations of multiplexers are included and also a discussion of active high and active low signals. Other types of gated latches are discussed, and a brief introduction to asynchronous sequential circuits is included. There is more discus-sion of incompletely specified state tables and how they may occur, and reducing incompletely specified state tables is briefly discussed. Problems have been added throughout the book with an emphasis on more challenging problems than the typi-cal exercises. In addition, the logic design and simulation software that accompanies the text has been updated and improved.
Preface  xxi
Acknowledgments
To be effective, a book designed for self-study cannot simply be written. It must 
be tested and revised many times to achieve its goals. We wish to express our  appreciation to the many professors, proctors, and students who participated in this process. Special thanks go to Dr. David Brown, who helped teach the self-paced course, and who made many helpful suggestions for improving the fifth edition.  Special thanks to graduate teaching assistant, Mark Story, who developed many new problems and solutions for the fifth edition and who offered many suggestions for improving the consistency and clarity of the presentation.
The authors especially thank the most recent reviewers of the text. Among 
 others, they are
Clark Guest, University of California, San DiegoJayantha Herath, St Cloud State UniversityNagarajan Kandasamy, Drexel UniversityAvinash Karanth Kodi, Ohio UniversityJacob Savir, Newark College of EngineeringMelissa C. Smith, Clemson UniversityLarry M. Stephens, University of South Carolina
Feedback from the readers, both critical and appreciative, is welcome. Please send your comments, concerns, and suggestions to globalengineering@cengage.com.
Charles H. Roth, Jr. Larry L. Kinney
xxiiIf you wish to learn all of the material in this text to mastery level, the following 
study procedures are recommended for each unit:
1. Read the Objectives of the unit. These objectives provide a concise summary of 
what you should be able to do when you complete studying the unit.
2. Work through the Study Guide. After reading each section of the text, write out 
the answers to the corresponding study guide questions. In many cases, blank spaces are left in the study guide so that you can write your answers directly in this book. By doing this, you will have the answers conveniently available for later review. The study guide questions generally will help emphasize some of the important points in each section or will guide you to a better understanding of some of the more difficult points. If you cannot answer some of the study guide questions, this indicates that you need to study the corresponding section in the text more before proceeding. The answers to selected study guide ques-tions are given in the back of this book; answers to the remaining questions generally can be found within the text.
3. Several of the units (Units 3, 5, 6, 11, 13, 14, and 18) contain one or more pro-grammed exercises. Each programmed exercise will guide you step-by-step through the solution of one of the more difficult types of problems encountered in this text. When working through a programmed exercise, be sure to write down your answer for each part in the space provided before looking at the answer and continuing with the next part of the exercise.
4. Work the assigned Problems at the end of the unit. Check your answers against those at the end of the book and rework any problems that you missed.
5. Reread the Objectives of the unit to make sure that you can meet all of them. If in doubt, review the appropriate sections of the text.
6. If you are using this text in a self-paced course, you will need to pass a readi-ness test on each unit before proceeding with the next unit. The purpose of the readiness test is to make sure that you have mastered the objectives of one unit before moving on to the next unit. The questions on the test will relate directly to the objectives of the unit, so that if you have worked through the study guide and written out answers to all of the study guide questions and to the problems assigned in the study guide, you should have no difficulty passing the test.How to Use This Book 
for Self-Study
www.allitebooks.com

xxiiiAbout the Authors
Charles H. Roth, Jr. is Professor Emeritus of Electrical and Computer Engineering 
at the University of Texas at Austin. He has been on the UT faculty since 1961. He received his BSEE degree from the University of Minnesota, his MSEE and EE degrees from the Massachusetts Institute of Technology, and his PhD degree in EE from Stanford University. His teaching and research interests included logic design, digital systems design, switching theory, microprocessor systems, and computer-aided design. He developed a self-paced course in logic design which formed the basis of his textbook, Fundamentals of Logic Design. He is also the author of Digital Systems Design Using VHDL, two other textbooks, and several software packages. He is the author or co-author of more than 50 technical papers and reports. Six PhD students and 80 MS students have received their degrees under his supervision. He received several teaching awards including the 1974 General Dynamics Award for Outstanding Engineering Teaching.
Larry L. Kinney is Professor Emeritus in Electrical and Computer Engineering 
at the University of Minnesota Twin Cities. He received the BS, MS, and PhD in Electrical Engineering from the University of Iowa in 1964, 1965, and 1968, respec-tively, and joined the University of Minnesota in 1968. He has taught a wide variety of courses including logic design, microprocessor/microcomputer systems, com-puter design, switching theory, communication systems and error-correcting codes. His major areas of research interest are testing of digital systems, built-in self-test, computer design, microprocessor-based systems, and error-correcting codes.

1Introduction 
Number Systems and ConversionUNIT
1
Objectives
1. Introduction
The first part of this unit introduces the material to be studied later. In addition to getting an overview of the material in the first part of the course, you should be able to explain
a. The difference between analog and digital systems and why digital systems are capable of greater accuracy
b. The difference between combinational and sequential circuits
c. Why two-valued signals and binary numbers are commonly used in digital systems
2. Number systems and conversionWhen you complete this unit, you should be able to solve the following types of problems:
a. Given a positive integer, fraction, or mixed number in any base (2 through 16); convert to any other base. Justify the procedure used by using a power series expansion for the number.
b. Add, subtract, multiply, and divide positive binary numbers. Explain the addition and subtraction process in terms of carries and borrows.
c. Write negative binary numbers in sign and magnitude, 1’s complement, and 2’s complement forms. Add signed binary numbers using 1’s complement and 2’s complement arithmetic. Justify the methods used. State when an overflow occurs.
d. Represent a decimal number in binary-coded-decimal (BCD), 6-3-1 -1 code, excess-3 code, etc. Given a set of weights, construct a weighted code.
2 Unit 1
Study Guide
1. Study Section 1.1, Digital Systems and Switching Circuits, and answer the follow-
ing study questions:
(a) What is the basic difference between analog and digital systems?
(b) Why are digital systems capable of greater accuracy than analog systems?
(c) Explain the difference between combinational and sequential switching 
circuits.
(d) What common characteristic do most switching devices used in digital 
 systems have?
(e) Why are binary numbers used in digital systems?
2. Study Section 1.2, Number Systems and Conversion. Answer the following study questions as you go along:
(a) Is the first remainder obtained in the division method for base conversion 
the most or least significant digit?
(b) Work through all of the examples in the text as you encounter them and 
make sure that you understand all of the steps.
(c) An easy method for conversion between binary and hexadecimal is illus-
trated in Equation (1 -1). Why should you start forming the groups of four bits at the binary point instead of the left end of the number?
(d) Why is it impossible to convert a decimal number to binary on a digit-by-digit 
basis as can be done for hexadecimal?
Number Systems and Conversion  3
(e) Complete the following conversion table.
Binary 
(base 2)Octal (base 8)Decimal (base 10)Hexadecimal (base 16)
0   0   0   0
1
10
11
100101110111
10001001101010111100110111101111
10000 20 16 10
(f  ) Work Problems 1.1, 1.2, 1.3, and 1.4.
3. Study Section 1.3, Binary Arithmetic.
(a) Make sure that you can follow all of the examples, especially the propaga-
tion of borrows in the subtraction process.
(b) To make sure that you understand the borrowing process, work out a 
detailed analysis in terms of powers of 2 for the following example:
1100
−101
111
4. Work Problems 1.5, 1.6, and 1.17(a).
5. Study Section 1.4, Representation of Negative Numbers.
(a) In digital systems, why are 1’s complement and 2’s complement commonly 
used to represent negative numbers instead of sign and magnitude?
4 Unit 1
(b) State two different ways of forming the 1’s complement of an n-bit binary 
number.
(c) State three different ways of forming the 2’s complement of an n-bit binary 
number.
(d) If the word length is n=4 bits (including sign), what decimal number does 
10002 represent in sign and magnitude?
In 2’s complement?
In 1’s complement?
(e) Given a negative number represented in 2’s complement, how do you find 
its magnitude?
Given a negative number represented in 1’s complement, how do you find 
its magnitude?
(f  ) If the word length is 6 bits (including sign), what decimal number does 
1000002 represent in sign and magnitude?
In 2’s complement?
In 1’s complement?
(g) What is meant by an overflow? How can you tell that an overflow has 
occurred when performing 1’s or 2’s complement addition?
Does a carry out of the last bit position indicate that an overflow has 
occurred?
Number Systems and Conversion  5
(h) Work out some examples of 1’s and 2’s complement addition for various 
combinations of positive and negative numbers.
(i) What is the justification for using the end-around carry in 1’s complement 
addition?
(j) The one thing that causes the most trouble with 2’s complement numbers 
is the special case of the negative number which consists of a 1 followed 
by all 0’s (1000  . . .  000). If this number is n bits long, what number does it 
represent and why? (It is not negative zero.)
(k) Work Problems 1.7 and 1.8.
6. Study Section 1.5, Binary Codes.
(a) Represent 187 in BCD code, excess-3 code, 6-3-1 -1 code, and 2-out-of-5 code.
(b) Verify that the 6-3-1 -1 code is a weighted code. Note that for some decimal 
digits, two different code combinations could have been used. For example, either 0101 or 0110 could represent 4. In each case the combination with the smaller binary value has been used.
(c) How is the excess-3 code obtained?
(d) How are the ASCII codes for the decimal digits obtained? What is the rela-
tion between the ASCII codes for the capital letters and lowercase letters?
(e) Work Problem 1.9.
7. If you are taking this course on a self-paced basis, you will need to pass a readi-ness test on this unit before going on to the next unit. The purpose of the readi-ness test is to determine if you have mastered the material in this unit and are ready to go on to the next unit. Before you take the readiness test:
(a) Check your answers to the problems against those provided at the end of 
this book. If you missed any of the problems, make sure that you under-stand why your answer is wrong and correct your solution.
(b) Make sure that you can meet all of the objectives listed at the beginning 
of this unit.
61.1 Digital Systems and Switching Circuits
Digital systems are used extensively in computation and data processing, control 
systems, communications, and measurement. Because digital systems are capable of greater accuracy and reliability than analog systems, many tasks formerly done by analog systems are now being performed digitally.
In a digital system, the physical quantities or signals can assume only discrete 
values, while in analog systems the physical quantities or signals may vary continu-ously over a specified range. For example, the output voltage of a digital system might be constrained to take on only two values such as 0 volts and 5 volts, while the output voltage from an analog system might be allowed to assume any value in the range −10 volts to +10 volts.
Because digital systems work with discrete quantities, in many cases they can be 
designed so that for a given input, the output is exactly correct. For example, if we multiply two 5-digit numbers using a digital multiplier, the 10-digit product will be correct in all 10 digits. On the other hand, the output of an analog multiplier might have an error ranging from a fraction of one percent to a few percent depending on the accuracy of the components used in construction of the multiplier. Furthermore, if we need a product which is correct to 20 digits rather than 10, we can redesign the digital multiplier to process more digits and add more digits to its input. A similar improvement in the accuracy of an analog multiplier would not be possible because of limitations on the accuracy of the components.
The design of digital systems may be divided roughly into three parts—system 
design, logic design, and circuit design. System design involves breaking the overall system into subsystems and specifying the characteristics of each subsystem. For example, the system design of a digital computer could involve specifying the num-ber and type of memory units, arithmetic units, and input-output devices as well as the interconnection and control of these subsystems. Logic design involves deter-mining how to interconnect basic logic building blocks to perform a specific func-tion. An example of logic design is determining the interconnection of logic gates and flip-flops required to perform binary addition. Circuit design involves specifying the interconnection of specific components such as resistors, diodes, and transistors Introduction 
Number Systems and Conversion
Number Systems and Conversion  7
to form a gate, flip-flop, or other logic building block. Most contemporary circuit 
design is done in integrated circuit form using appropriate computer-aided design tools to lay out and interconnect the components on a chip of silicon. This book is largely devoted to a study of logic design and the theory necessary for understand-ing the logic design process. Some aspects of system design are treated in Units 18 and 20. Circuit design of logic gates is discussed briefly in Appendix A.
Many of a digital system’s subsystems take the form of a switching circuit 
(Figure 1 -1). A switching circuit has one or more inputs and one or more outputs which take on discrete values. In this text, we will study two types of switching  circuits—combinational and sequential. In a combinational circuit, the output values depend only on the present value of the inputs and not on past values. In a sequential circuit, the outputs depend on both the present and past input values. In other words, in order to determine the output of a sequential circuit, a sequence of input values must be specified. The sequential circuit is said to have memory because it must “remember” something about the past sequence of inputs, while a combinational cir-cuit has no memory. In general, a sequential circuit is composed of a combinational circuit with added memory elements. Combinational circuits are easier to design than sequential circuits and will be studied first.
FIGURE 1-1
Switching Circuit
© Cengage Learning 2014Switching
CircuitInputs Outputs...Z1
Z2...ZnX1
X2
Xm
The basic building blocks used to construct combinational circuits are logic 
gates. The logic designer must determine how to interconnect these gates in order to convert the circuit input signals into the desired output signals. The relationship between these input and output signals can be described mathematically using Boolean  algebra. Units 2 and 3 of this text introduce the basic laws and theorems of Boolean algebra and show how they can be used to describe the behavior of circuits of logic gates.
Starting from a given problem statement, the first step in designing a combina-
tional logic circuit is to derive a table or the algebraic logic equations which describe the circuit outputs as a function of the circuit inputs (Unit 4). In order to design an economical circuit to realize these output functions, the logic equations which describe the circuit outputs generally must be simplified. Algebraic methods for this simplification are described in Unit 3, and other simplification methods (Karnaugh map and Quine-McCluskey procedure) are introduced in Units 5 and 6. Implemen-tation of the simplified logic equations using several types of gates is described in Unit 7 , and alternative design procedures using programmable logic devices are developed in Unit 9.
The basic memory elements used in the design of sequential circuits are called 
flip-flops (Unit 11). These flip-flops can be interconnected with gates to form coun-ters and registers (Unit 12). Analysis of more general sequential circuits using timing 
8 Unit 1
diagrams, state tables, and graphs is presented in Unit 13. The first step in designing 
a sequential switching circuit is to construct a state table or graph which describes the relationship between the input and output sequences (Unit 14). Methods for going from a state table or graph to a circuit of gates and flip-flops are developed in Unit 15. Methods of implementing sequential circuits using programmable logic are discussed in Unit 16. In Unit 18, combinational and sequential design techniques are applied to the realization of systems for performing binary addition, multiplica-tion, and division. The sequential circuits designed in this text are called synchro-nous sequential circuits because they use a common timing signal, called a clock,  to  synchronize the operation of the memory elements.
Use of a hardware description language, VHDL, in the design of combinational 
logic, sequential logic, and digital systems is introduced in Units 10, 17 , and 20. VHDL is used to describe, simulate, and synthesize digital hardware. After writing VHDL code, the designer can use computer-aided design software to compile the hardware description and complete the design of the digital logic. This allows the completion of complex designs without having to manually work out detailed circuit descriptions in terms of gates and flip-flops.
The switching devices used in digital systems are generally two-state devices, that 
is, the output can assume only two different discrete values. Examples of switching devices are relays, diodes, and transistors. A relay can assume two states—closed or open—depending on whether power is applied to the coil or not. A diode can be in a conducting state or a nonconducting state. A transistor can be in a cut-off or satu-rated state with a corresponding high or low output voltage. Of course, transistors can also be operated as linear amplifiers with a continuous range of output voltages, but in digital applications greater reliability is obtained by operating them as two-state devices. Because the outputs of most switching devices assume only two differ-ent values, it is natural to use binary numbers internally in digital systems. For this reason binary numbers and number systems will be discussed first before proceeding to the design of switching circuits.
1.2 Number Systems and Conversion
When we write decimal (base 10) numbers, we use a positional notation; each digit is multiplied by an appropriate power of 10 depending on its position in the number. For example,
953.78
10=9×102+5×101+3×100+7×10−1+8×10−2
Similarly, for binary (base 2) numbers, each binary digit is multiplied by the appro-priate power of 2:
1011.11
2 =1×23+0×22+1×21+1×20+1×2−1+1×2−2
 =8+0+2+1+1
2+1
4=113
4=11.7510
www.allitebooks.com

Number Systems and Conversion  9
Note that the binary point separates the positive and negative powers of 2 just 
as the decimal point separates the positive and negative powers of 10 for decimal numbers.
Any positive integer R  
(R>1) can be chosen as the radix or base of a num-
ber system. If the base is R, then R  digits (0, 1, . . . , R  − 1) are used. For example, if 
R=8, then the required digits are 0,  1, 2, 3, 4, 5, 6, and 7. A number written in posi-
tional notation can be expanded in a power series in R. For example,
N=(a4 a3 a2 a1a0 . a−1a−2 a−3)R
=a4×R4+a3×R3+a2×R2+a1×R1+a0×R0
       +a−1×R−1+a−2×R−2+a−3×R−3
where ai is the coefficient of Ri and 0 ≤ai≤R−1. If the arithmetic indicated in the 
power series expansion is done in base 10, then the result is the decimal equivalent of 
N. For example,
147.38 =1×82+4×81+7×80+3×8−1=64+32+7+3
8
  = 103.37510
The power series expansion can be used to convert to any base. For example, 
converting 14710 to base 3 would be written as
14710=1×(101)2+(11)×(101)1+(21)×(101)0
where all the numbers on the right-hand side are base 3 numbers. ( Note: In  
base 3, 10 is 101, 7 is 21, etc.) To complete the conversion, base 3 arithmetic would  
be used. Of course, this is not very convenient if the arithmetic is being done by hand.  Similarly, if 147
10 is being converted to binary, the calculation would be
14710=1×(1010 )2+(100)×(1010 )1+(111)×(1010 )0
Again this is not convenient for hand calculation but it could be done easily in a computer where the arithmetic is done in binary. For hand calculation, use the power series expansion when converting from some base into base 10.
For bases greater than 10, more than 10 symbols are needed to represent the 
digits. In this case, letters are usually used to represent digits greater than 9. For example, in hexadecimal (base 16), 
A represents 1010, B represents 1110, C represents 
1210, D represents 1310, E represents 1410, and F represents 1510. Thus,
A2F16=10×162+2×161+15×160=2560 +32+15=260710
Next, we will discuss conversion of a decimal integer to base R  using the division 
method. The base R equivalent of a decimal integer N can be represented as
N=(an an−1 · · · a2 a1 a0)R=an Rn+an−1Rn−1+· · ·+a2R2+a1R1+a0
10 Unit 1
If we divide N by R , the remainder is a0:
N
R =an Rn−1+an−1Rn−2+· · ·+a2 R1+a1=Q1, remainder a0
Then we divide the quotient Q1 by R :
Q1
R=an Rn−2+an−1Rn−3+· · ·+a3 R1+a2=Q2, remainder a1
Next we divide Q2 by R :
Q2
R =an Rn−3+an−1Rn−4+· · ·+a3=Q3, remainder a2
This process is continued until we finally obtain an. Note that the remainder obtained 
at each division step is one of the desired digits and the least significant digit is 
obtained first.
Convert 5310 to binary.
2 y53
2 y26   rem. =1=a0
2 y13   rem. =0=a1
2 y6   rem. =1=a2   5310=1101012
2 y3   rem. =0=a3
2 y1   rem. =1=a4
      0   rem. =1=a5
Conversion of a decimal fraction to base R can be done using successive multipli-
cations by R . A decimal fraction F can be represented as
F=(.a−1 a−2 a−3 · · · a−m)R=a−1R−1+a−2 R−2+a−3 R−3+· · ·+a−m  R−m
Multiplying by R  yields
FR=a−1+a−2 R−1+a−3  R−2+· · ·+a−m   R−m+1=a−1+F1
where F1 represents the fractional part of the result and a−1 is the integer part. 
 Multiplying F1 by R  yields
F1R=a−2+a−3 R−1+· · ·+a−m  R−m+2=a−2+F2Example
Number Systems and Conversion  11
Next, we multiply F2 by R :
F2R=a−3+· · ·+a−m  R−m+3=a−3+F3
This process is continued until we have obtained a sufficient number of digits. Note 
that the integer part obtained at each step is one of the desired digits and the most significant digit is obtained first.
Convert 0.62510 to binary.
F= .625         F1= .250         F2= .500   
×   2    ×   2    ×   2       .62510=.1012
 1.250     0.500     1.000    
  (a−1=1) ( a−2=0)      ( a−3=1)
This process does not always terminate, but if it does not terminate, the result is 
a repeating fraction.
Convert 0.710 to binary.
    .7
    2
(1).4
    2
(0).8
    2
(1).6
    2
(1).2
    2
(0).4  ⟵ process starts repeating here because 0.4 was previously
    2   obtained
(0).8   0.710=0.1  0110  0110  0110 . . . 2
Conversion between two bases other than decimal can be done directly by using 
the procedures given; however, the arithmetic operations would have to be carried out using a base other than 10. It is generally easier to convert to decimal first and then convert the decimal number to the new base.Example
Example
12 Unit 1
Convert 231.34 to base 7 .
231.34=2 ×16+3×4+1+3
4=45.7510
7 y45    .75
7 y  6   rem. 3         7
        0   rem. 6 (5).25     45.7510=63.5151 . . . 7
     7
(1).75
     7
(5).25
     7
(1).75
Conversion from binary to hexadecimal (and conversely) can be done by inspec-
tion because each hexadecimal digit corresponds to exactly four binary digits (bits). Starting at the binary point, the bits are divided into groups of four, and each group is replaced by a hexadecimal digit:
 1001101.010111
2=('*0100
4   ('*1101
D    .   ('*0101
5  ('*1100
C=4D.5C16 (1 -1)
As shown in Equation (1 -1), extra 0’s are added at each end of the bit string as 
needed to fill out the groups of four bits.
1.3 Binary Arithmetic
Arithmetic operations in digital systems are usually done in binary because design of logic circuits to perform binary arithmetic is much easier than for decimal. Binary arithmetic is carried out in much the same manner as decimal, except the addition and multiplication tables are much simpler.
The addition table for binary numbers is
0+0=0
0+1=1
1+0=1
1+1=0    and carry 1 to the next column
Carrying 1 to a column is equivalent to adding 1 to that column.Example
Number Systems and Conversion  13
Add 1310 and 1110 in binary.
1 1 1 1 ⟵carries
1310 =  1101
1110 =  1011
11000 =2410
The subtraction table for binary numbers is
0−0=0
0−1=1   and borrow 1 from the next column
1−0=1
1−1=0
Borrowing 1 from a column is equivalent to subtracting 1 from that column.Example
(a) 1←⏤  (indicates (b) 1  1     1       1 ←⏤  borrows (c)   1   1  1←⏤  borrows
 11101 a borrrow 10000 111001
 ‒ 10011 from the ‒       11 ‒     1011
 1010 3rd column) 1101 101110
Note how the borrow propagates from column to column in the second example. 
In order to borrow 1 from the second column, we must in turn borrow 1 from the 
third column, etc. An alternative to binary subtraction is the use of 2’s complement arithmetic, as discussed in Section 1.4.
Binary subtraction sometimes causes confusion, perhaps because we are so used 
to doing decimal subtraction that we forget the significance of the borrowing pro-cess. Before doing a detailed analysis of binary subtraction, we will review the bor-rowing process for decimal subtraction.
If we number the columns (digits) of a decimal integer from right to left (start-
ing with 0), and then we borrow 1 from column n, what we mean is that we subtract 
1 from column n and add 10 to column n−1. Because 1 ×10
n=10×10n−1, the 
value of the decimal number is unchanged, but we can proceed with the subtraction.  Consider, for example, the following decimal subtraction problem:
column 2       column 1
205
−  18
187⏤⟶
↙Examples 
of Binary  Subtraction
14 Unit 1
A detailed analysis of the borrowing process for this example, indicating first a bor-
row of 1 from column 1 and then a borrow of 1 from column 2, is as follows:
205−18=[2×102+0×101+5×100]
  −[           1×101+8×100]
                 note borrow from column 1
=[2×102+(0−1)×101+(10+5)×100]
−[               1 ×101+       8×100]
                                      note borrow from column 2
=[(2−1)×102+(10+0−1)×101+15×100]
−[                         1 ×101+ 8 ×100]
=[1×102        +  8×101          + 7 ×100]=187
The analysis of borrowing for binary subtraction is exactly the same, except that we 
work with powers of 2 instead of powers of 10. Thus for a binary number, borrowing 1 from column n  is equivalent to subtracting 1 from column n  and adding 2
 (102) to col-
umn n −1. The value of the binary number is unchanged because 1 ×2n=2×2n−1.
A detailed analysis of binary subtraction example (c) follows. Starting with the 
rightmost column, 1 − 1 = 0. To subtract in the second column, we must borrow from the third column. Rather than borrow immediately, we place a 1 over the third column to indicate that a borrow is necessary, and we will actually do the borrowing when we get to the third column. (This is similar to the way borrow signals might propagate in a computer.) Now because we have borrowed 1, the second column becomes 10, and 10 − 1 = 1. In order to borrow 1 from the third column, we must 
borrow 1 from the fourth column (indicated by placing a 1 over column 4). Column 3 then becomes 10, subtracting off the borrow yields 1, and 1 − 0 = 1. Now in column 4, 
we subtract off the borrow leaving 0. In order to complete the subtraction, we must borrow from column 5, which gives 10 in column 4, and 10 − 1 = 1.
The multiplication table for binary numbers is
0×0=0
0×1=0
1×0=0
1×1=1
The following example illustrates multiplication of 13
10 by 1110 in binary:
        1101
        1011
        1101
        1101
     0000
  1101      
10001111 =14310
Number Systems and Conversion  15
Note that each partial product is either the multiplicand (1101) shifted over the 
appropriate number of places or is zero.
When adding up long columns of binary numbers, the sum of the bits in a single 
column can exceed 112, and therefore the carry to the next column can be greater 
than 1. For example, if a single column of bits contains five 1’s, then adding up the 1’s gives 101
2, which means that the sum bit for that column is 1, and the carry to 
the next column is 102. When doing binary multiplication, a common way to avoid 
carries greater than 1 is to add in the partial products one at a time as illustrated by the following example:
        1111     multiplicand
        1101     multiplier
        1111     first partial product
     0000     second partial product
     (01111)     sum of first two partial products
      1111      third partial product
(1001011)     sum after adding third partial product
   1111             fourth partial product
11000011     final product (sum after adding fourth partial product)
The following example illustrates division of 14510 by 1110 in binary:
                      1101
1011   ∣ 1001001
              1011  
                 1110
                 1011    
                    1101   The quotient is 1101 with a remainder
                    1011   of 10.
                       10
Binary division is similar to decimal division, except it is much easier because the only two possible quotient digits are 0 and 1. In the above example, if we start by comparing the divisor (1011) with the upper four bits of the dividend (1001), we find that we cannot subtract without a negative result, so we move the divisor one place to the right and try again. This time we can subtract 1011 from 10010 to give 111 as a result, so we put the first quotient bit of 1 above 10010. We then bring down the next dividend bit (0) to get 1110 and shift the divisor right. We then subtract 1011 from 1110 to get 11, so the second quotient bit is 1. When we bring down the next dividend bit, the result is 110, and we cannot subtract the shifted divisor, so the third quotient bit is 0. We then bring down the last dividend bit and subtract 1011 from 1101 to get a final remainder of 10, and the last quotient bit is 1.
16 Unit 1
1.4 Representation of Negative Numbers
Up to this point we have been working with unsigned positive numbers. The most 
common methods for representing both positive and negative numbers are sign and magnitude, 2’s complement, and 1’s complement. In each of these methods, the leftmost bit of a number is 0 for positive numbers and 1 for negative numbers. As discussed below, if n bits are used to represent numbers, then the sign and magni-
tude and 1’s complement methods represent numbers in the range −(2
(n−1)−1) to 
+(2(n−1)−1) and both have two representations for 0, a positive 0 and a negative 0. 
In 2’s complement, numbers in the range −2(n−1) to +(2(n−1)−1) are represented 
and there is only a positive 0. If an operation, such as addition or subtraction, is per-formed on two numbers and the result is outside the range of representation, then we say that an overflow has occurred.
Sign and Magnitude Numbers
In an n-bit sign and magnitude system, a number is represented by a sign bit, 0 for 
positive and 1 for negative, followed by n−1  bits that represent the magnitude of 
the number. With n −1 bits the magnitude can be 0 to 2(n−1)−1. With the sign bit, 
numbers in the range −(2(n−1)−1) to +(2(n−1)−1) are represented including a posi-
tive and negative 0. This is illustrated in Table 1 -1 for n=4. For example, 0011 repre-
sents +3 and 1011 represents −3. Note that 1000 represents minus 0.
Designing logic circuits to perform arithmetic on sign and magnitude binary 
numbers is awkward. One method is to convert the numbers into 2’s (or 1’s) comple-ment and, after performing the arithmetic operation, convert the result back to sign and magnitude.
2’s Complement Numbers
In the 2’s complement number system, a positive number, N, is represented by a 
0 followed by the magnitude of N as in the sign and magnitude system; however, Positive 
Integers 
(all systems)Negative Integers
+N −NSign and 
Magnitude2’s Complement 
N*1’s Complement 
N
+0 0000 −0 1000 —— 1111
+1 0001 −1 1001 1111 1110
+2 0010 −2 1010 1110 1101
+3 0011 −3 1011 1101 1100
+4 0100 −4 1100 1100 1011
+5 0101 −5 1101 1011 1010
+6 0110 −6 1110 1010 1001
+7 0111 −7 1111 1001 1000
−8 —— 1000 ——TABLE 1-1 
Signed Binary 
Integers (word 
length: n =4)
© Cengage Learning 2014
Number Systems and Conversion  17
a negative number, −N, is represented by its 2’s complement, N*. If the word length 
is n bits, the 2’s complement of a positive integer N is defined as
 N*=2n−N  (1 -2)
(Note that in this equation all numbers N, 2n, and N* are treated as unsigned posi-
tive numbers; if they are expressed in binary, n + 1 bits are required to represent 2n.) 
Table 1 -1 shows the result for n=4. In Table 1 -1, the 2’s complement representation 
of negative numbers −1 through −7 can be obtained by taking the 2’s complement 
of positive numbers 1 through 7 (i.e., by subtracting from 16). For example, the 2’s 
complement of 5 is 16 − 5 = 11 or, using binary numbers, (10000) − (0101) = (1011). 
After completing the subtractions, all combinations of 4-bits have been used to rep-resent the numbers −7 , . . . , −1, 0, 1, . . . 7; the only unused combination is 1000. Since 
the leftmost bit of 1000 is 1, it should be a negative number. To determine its magni-tude, note that the magnitude of a negative number can be obtained by taking its 2’s complement; that is, from Equation (1 -2),
 
N=2n−N*  (1 -3)
Applying Equation (1 -3) to 1000 produces (10000) − (1000) = (1000) or, in decimal, 
16 − 8 = 8. Hence, 1000 represents −8. In general, in an n-bit 2’s complement system 
the number 1 followed by all 0’s represents −2(n−1).
Using Equation (1 -2) directly on binary numbers requires subtraction of n+1 
bit numbers. This can be avoided by noting that Equation (1 -2) can be written as
N*=(2n−1−N)+1
In binary, 2n−1 consists of n 1’s. Subtracting a number from all 1’s does not produce 
any borrows, and the subtraction can be done by replacing 0’s with 1’s and 1’s with 
0’s (i.e., simply complement N bit-by-bit). For example, if n =7 and N=0101100,
2n−1=1111111
     −  0101100
1010011
+   0000001
N*=1010100
N* is obtained by complementing N bit-by-bit and then adding 1. An alternative way to form the 2’s complement of N is to start at the right and leave any 0’s on the right 
end and the first 1 unchanged, then complement all bits to the left of the first 1. In the preceding example, the 100 on the right end of N is unchanged while the 0101 on 
the left is complemented bit-by-bit.
Addition of 2’s Complement Numbers
The addition of n -bit signed binary numbers is straightforward using the 2’s comple-
ment system. The addition is carried out just as if all the numbers were positive, and any carry from the sign position is ignored. This will always yield the correct result 
18 Unit 1
except when an overflow occurs. When the word length is n bits, we say that an over-
flow has occurred if the correct representation of the sum (including sign) requires 
more than n bits. The different cases which can occur are illustrated below for n=4.
1. Addition of two positive numbers, sum <2n−1
+3  0011
+4  0100
+7  0111   (correct answer)
2. Addition of two positive numbers, sum ≥2n−1
+5  0101
+6  0110
  1011    ⟵ wrong answer because of overflow ( +11 requires
        5 bits including sign)
3. Addition of positive and negative numbers (negative number has greater  magnitude)
−5  0101
−6  1010
−1  1111   (correct answer)
4. Same as case 3 except positive number has greater magnitude
+5   1011
+6   0110
+1  (1)0001  ⟵ correct answer when the carry from the sign bit
      is ignored (this is not an overflow)
5. Addition of two negative numbers, 0sum 0≤2n−1
−3   1101
−4   1100
−7  (1)1001  ⟵ correct answer when the last carry is ignored
      (this is not an overflow)
6. Addition of two negative numbers, 0sum 0>2n−1
−5   1011
−6   1010
 (1)0101  ⟵ wrong answer because of overflow
      (−11 requires 5 bits including sign)
Note that an overflow condition (cases 2 and 6) is easy to detect because in case 2 the addition of two positive numbers yields a negative result, and in case 6 the addition of two negative numbers yields a positive answer (for four bits).
www.allitebooks.com

Number Systems and Conversion  19
The proof that throwing away the carry from the sign bit always gives the correct 
answer follows for cases 4 and 5:
Case  4:  −A +B (where B >A)
   A*+B=(2n−A)+B=2n+(B−A)>2n
Throwing away the last carry is equivalent to subtracting 2n, so the result is (B−A), 
which is correct.
Case  5:  −A−B (where A +B≤2n−1)
    A*+B*=(2n−A)+(2n−B)=2n+2n−(A+B)
Discarding the last carry yields 2n−(A+B)=(A+B)*, which is the correct rep-
resentation of − (A+B).
1’s Complement Numbers
In the 1’s complement system a negative number, −N, is represented by the 1’s com-
plement of N, N, defined as
 N=(2n−1)−N  (1 -4)
As explained above, (2n−1) consists of all 1’s, and subtracting a bit from 1 is the 
same as complementing the bit. Hence, the 1’s complement of N can be obtained 
by complementing N bit-by-bit. Table 1 -1 illustrates 1’s complement for n =4. Note 
that the 1’s complement of 0000 is 1111, which represents minus zero. Note that 1’s 
complement has two representations of 0, as does sign and magnitude.
Addition of 1’s Complement Numbers
The addition of 1’s complement numbers is similar to 2’s complement except that instead of discarding the last carry, it is added to the n -bit sum in the position fur-
thest to the right. This is referred to as an end-around carry. The addition of posi-
tive numbers is the same as illustrated for cases 1 and 2 under 2’s complement. The remaining cases are illustrated below 
(n=4).
3. Addition of positive and negative numbers (negative number with greater  magnitude)
+5   0101
−6   1001
−1   1110   (correct answer)
4. Same as case 3 except positive number has greater magnitude
−5 1010
+6 0110
(1) 0000
      1  (end-around carry)
0001  (correct answer, no overflow)
20 Unit 1
5. Addition of two negative numbers, 0sum 0<2n−1
−3 1100
−4 1011
(1) 0111
      1  (end-around carry)
1000  (correct answer, no overflow)
6. Addition of two negative numbers, |sum|≥2n−1
−5 1010−6 1001
(1) 0111
      1  (end-around carry)
0100  (wrong answer because of overflow)
Again, note that the overflow in case 6 is easy to detect because the addition of two 
negative numbers yields a positive result.
The proof that the end-around carry method gives the correct result follows for 
cases 4 and 5:
Case  4:   −A+B   (where B >A)
        A+B=(2n−1−A)+B=2n+(B−A)−1
The end-around carry is equivalent to subtracting 2n and adding 1, so the result is 
(B − A), which is correct.
Case  5:    −A −B   (A+B<2n−1)
     A+B=(2n−1−A)+(2n−1−B)=2n+[2n−1−(A+B)]−1
After the end-around carry, the result is 2n−1−(A+B)=(A+B) which is the 
correct representation for − (A+B).
The following examples illustrate the addition of 1’s and 2’s complement num-
bers for a word length of n =8:
1. Add −11 and −20 in 1’s complement.
+11 =00001011      +20 =00010100
taking the bit-by-bit complement,
−11 is represented by 11110100 and −20 by 11101011
   11110100     (−11)
   11101011 +(−20)
(1) 11011111
                 1   (end-around carry)
   11100000 =−31
Number Systems and Conversion  21
2. Add −8 and +19 in 2’s complement
+8=00001000
complementing all bits to the left of the first 1, −8, is represented by 11111000
   11111000 ( −8)
   00010011 +19
(1)00001011 =+11
(discard last carry )
Note that in both cases, the addition produced a carry out of the furthest left bit 
position, but there is no overflow because the answer can be correctly represented 
by eight bits (including sign). A general rule for detecting overflow when adding two n-bit signed binary numbers (1’s or 2’s complement) to get an n-bit sum is:
An overflow occurs if adding two positive numbers gives a negative answer or if adding two negative numbers gives a positive answer.
An alternative method for detecting overflow in 2’s complement addition is as 
follows:
An overflow occurs if and only if the carry out of the sign position is not equal to the carry into the sign position.
1.5 Binary Codes
Although most large computers work internally with binary numbers, the input-output equipment generally uses decimal numbers. Because most logic circuits only accept two-valued signals, the decimal numbers must be coded in terms of binary signals. In the simplest form of binary code, each decimal digit is replaced by its binary equivalent. For example, 937 .25 is represented by
9 3 7 . 2 5
1001  0011  0111  .  0010  0101
This representation is referred to as binary-coded-decimal (BCD) or more explicitly as 8-4-2-1 BCD. Note that the result is quite different than that obtained by convert-ing the number as a whole into binary. Because there are only ten decimal digits, 1010 through 1111 are not valid BCD codes.CCC CC
22 Unit 1
Table 1 -2 shows several possible sets of binary codes for the ten decimal dig-
its. Many other possibilities exist because the only requirement for a valid code is 
that each decimal digit be represented by a distinct combination of binary digits. To translate a decimal number to coded form, each decimal digit is replaced by its cor-responding code. Thus 937 expressed in excess-3 code is 1100 0110 1010. The 8-4-2-1 (BCD) code and the 6-3-1 -1 code are examples of weighted codes. A 4-bit weighted code has the property that if the weights are w
3, w2, w1, and w0, the code a3a2a1a0 
represents a decimal number N,  where
N=w3 a3+w2 a2+w1a1+w0 a0
For example, the weights for the 6-3-1 -1 code are w3=6, w2=3, w1=1, and w0=1. 
The binary code 1011 thus represents the decimal digit
N=6·1+3·0+1·1+1·1=8
The excess-3 code is obtained from the 8-4-2-1 code by adding 3 (0011) to each 
of the codes. The 2-out-of-5 code has the property that exactly 2 out of the 5 bits are 1 for every valid code combination. This code has useful error-checking properties because if any one of the bits in a code combination is changed due to a malfunc-tion of the logic circuitry, the number of 1 bits is no longer exactly two. The table shows one example of a Gray code. A Gray code has the property that the codes for successive decimal digits differ in exactly one bit. For example, the codes for 6 and 7 differ only in the fourth bit, and the codes for 9 and 0 differ only in the first bit. A Gray code is often used when translating an analog quantity, such as a shaft position, into digital form. In this case, a small change in the analog quantity will change only one bit in the code, which gives more reliable operation than if two or more bits changed at a time. The Gray and 2-out-of-5 codes are not weighted codes. In general, 
the decimal value of a coded digit cannot be computed by a simple formula when a 
non-weighted code is used.
Many applications of computers require the processing of data which contains 
numbers, letters, and other symbols such as punctuation marks. In order to transmit Decimal 
Digit8-4-2-1 Code (BCD)6-3-1-1 CodeExcess-3 Code2-out-of-5 CodeGray Code
0 0000 0000 0011 00011 0000
1 0001 0001 0100 00101 00012 0010 0011 0101 00110 00113 0011 0100 0110 01001 00104 0100 0101 0111 01010 01105 0101 0111 1000 01100 11106 0110 1000 1001 10001 10107 0111 1001 1010 10010 10118 1000 1011 1011 10100 10019 1001 1100 1100 11000 1000TABLE 1-2 
Binary Codes for 
Decimal Digits 
© Cengage Learning 2014
Number Systems and Conversion  23
such alpha numeric data to or from a computer or store it internally in a computer, 
each symbol must be represented by a binary code. One common alphanumeric code is the ASCII code (American Standard Code for Information Interchange). This is a 7-bit code, so 2
7(128) different code combinations are available to represent letters, 
numbers, and other symbols. Table 1 -3 shows a portion of the ASCII code; the code combinations not listed are used for special control functions such as “form feed” or “end of transmission.” The word “Start” is represented in ASCII code as follows:
1010011 1110100 1100001 1110010 1110100
S tart
TABLE 1-3 ASCII Code 
 © Cengage Learning 2014ASCII Code ASCII Code ASCII Code
Character A6A5A4A3A2A1A0Character A6A5A4A3A2A1A0Character A6A5A4A3A2A1A0
space 010000 0 @ 100000 0 ’ 1100000
! 010000 1 A 100000 1 a 1100001
“ 010001 0 B 100001 0 b 1100010
# 010001 1 C 100001 1 c 1100011
$ 010010 0 D 100010 0 d 1100100
% 010010 1 E 100010 1 e 1100101
& 010011 0 F 100011 0 f 1100110
′ 010011 1 G 100011 1 g 1100111
( 010100 0 H 100100 0 h 1101000
) 010100 1 I 100100 1 i 1101001
* 010101 0 J 100101 0 j 1101010
+ 010101 1 K 100101 1 k 1101011
, 010110 0 L 100110 0 l 1101100
− 010110 1 M 100110 1 m 1101101
. 010111 0 N 100111 0 n 1101110
/ 010111 1 O 100111 1 o 1101111
0 011000 0 P 101000 0 p 1110000
1 011000 1 Q 101000 1 q 1110001
2 011001 0 R 101001 0 r 1110010
3 011001 1 S 101001 1 s 1110011
4 011010 0 T 101010 0 t 1110100
5 011010 1 U 101010 1 u 111 0101
6 011011 0 V 101011 0 v 111 0110
7 011011 1 W 101011 1 w 111 0111
8 011100 0 X 101100 0 x 111 1000
9 011100 1 Y 101100 1 y 111 1001
: 011101 0 Z 101101 0 z 111 1010
; 011101 1 [ 101101 1 { 111 1011
< 011110 0 \ 101110 0 | 111 1100
= 011110 1 ] 101110 1 } 111 1101
> 011111 0 ^ 101111 0 ~ 111 1110
? 0 1 1 1 1 1 1 — 1 0 1 1 1 1 1 delete 1 111111
24 Unit 1
Problems
1.1 Convert to hexadecimal and then to binary:
 (a) 757.2510 (b) 123.1710 (c) 356.8910 (d) 1063.510
1.2 Convert to octal. Convert to hexadecimal. Then convert both of your answers to 
decimal, and verify that they are the same.
(a) 111010110001.0112  (b) 10110011101.112
1.3 Convert to base 6: 3BA.2514 (do all of the arithmetic in decimal).
1.4 (a) Convert to hexadecimal: 1457.1110. Round to two digits past the hexadecimal point.
(b) Convert your answer to binary, and then to octal.
(c) Devise a scheme for converting hexadecimal directly to base 4 and convert your 
answer to base 4.
(d) Convert to decimal: DEC. A16.
1.5  Add, subtract, and multiply in binary:
 (a) 1111 and 1010 (b) 110110 and 11101 (c) 100100 and 10110
1.6  Subtract in binary. Place a 1 over each column from which it was necessary to borrow.
 (a) 11110100 − 1000111 (b) 1110110 − 111101 (c) 10110010 − 111101
1.7 Add the following numbers in binary using 2’s complement to represent negative 
numbers. Use a word length of 6 bits (including sign) and indicate if an overflow 
occurs.
 (a) 21 + 11 (b) (−14) + (−32) (c) (−25) + 18
 (d) (−12) + 13 (e) (−11) + (−21)
Repeat (a), (c), (d), and (e) using 1’s complement to represent negative numbers.
1.8 A computer has a word length of 8 bits (including sign). If 2’s complement is used to 
represent negative numbers, what range of integers can be stored in the computer? If 1’s complement is used? (Express your answers in decimal.)
1.9 Construct a table for 7-3-2-1 weighted code and write 3659 using this code.
1.10 Convert to hexadecimal and then to binary.
 (a) 1305.375
10 (b) 111.3310 (c) 301.1210 (d) 1644.87510
1.11 Convert to octal. Convert to hexadecimal. Then convert both of your answers to 
decimal, and verify that they are the same.
 (a) 101111010100.1012 (b) 100001101111.012
Number Systems and Conversion  25
1.12 (a) Convert to base 3: 375.548 (do all of the arithmetic in decimal).
(b) Convert to base 4: 384.7410.
(c) Convert to base 9: A52.A411 (do all of the arithmetic in decimal).
1.13 Convert to hexadecimal and then to binary: 544.19.
1.14 Convert the decimal number 97.710 into a number with exactly the same value rep-
resented in the following bases. The exact value requires an infinite repeating part in 
the fractional part of the number. Show the steps of your derivation.
 (a) binary (b) octal (c) hexadecimal (d) base 3 (e) base 5
1.15 Devise a scheme for converting base 3 numbers directly to base 9. Use your method 
to convert the following number to base 9: 1110212.202113
1.16 Convert the following decimal numbers to octal and then to binary:
 (a) 298363∕64 (b) 93.70 (c) 298331∕32 (d) 109.30
1.17 Add, subtract, and multiply in binary:
 (a) 1111 and 1001 (b) 1101001 and 110110 (c) 110010 and 11101
1.18 Subtract in binary. Place a 1 over each column from which it was necessary to  borrow.
 (a) 10100100 −01110011 (b) 10010011 −01011001
 (c) 11110011 −10011110
1.19 Divide in binary:
 (a) 11101001 ÷101 (b) 110000001 ÷1110 (c) 1110010 ÷1001
Check your answers by multiplying out in binary and adding the remainder.
1.20 Divide in binary:
 (a) 10001101 ÷110 (b) 110000011 ÷1011 (c) 1110100 ÷1010
1.21 Assume three digits are used to represent positive integers and also assume the fol-
lowing operations are correct. Determine the base of the numbers. Did any of the additions overflow?
(a) 654 +013=000
(b) 024 +043+013+033=223
(c) 024 +043+013+033=201
1.22 What is the lowest number of bits (digits) required in the binary number approxi-
mately equal to the decimal number 0.6117
10 so that the binary number has the same 
or better precision?
1.23 Convert 0.363636 . . . 10 to its exact equivalent base 8 number.
26 Unit 1
1.24 (a)  Verify that a number in base b can be converted to base b3 by partitioning the 
digits of the base b number into groups of three consecutive digits starting at 
the radix point and proceeding both left and right and converting each group 
into a base b3 digit. (Hint: Represent the base b number using the power series 
 expansion.)
(b) Verify that a number in base b3 can be converted to base b by expanding each 
digit of the base b3 number into three consecutive digits starting at the radix 
point and proceeding both left and right.
1.25 (a)  Show how to represent each of the numbers (5−1), (52−1), and (53−1) as 
base 5 numbers.
(b) Generalize your answers to part (a) and show how to represent (bn−1) as a 
base b number, where b can be any integer larger than 1 and n any integer larger 
than 0. Give a mathematical derivation of your result.
1.26 (a)  Show that the number 121b, where b is any base greater than 2, is a perfect 
square (i.e., it is equal to the square of some number).
(b) Repeat part (a) for the number 12321b, where b >3.
(c) Repeat part (a) for the number 14641b, where b >6.
(d) Repeat part (a) for the number 1234321b, where b >4.
1.27 (a) Convert (0.12)3 to a base 6 fraction.
(b) Convert (0.375 )10 to a base 8 fraction.
(c) Let N=(0.a−1a−2 · · · a−m)R be an any base R fraction with at most m nonzero 
digits. Determine the necessary and sufficient conditions for N to be rep-
resentable as a base S fraction with a finite number of nonzero digits; say N=
(0.b−1b−2 · · · b−n)S. (Hint: Part (a) gives an example. Note that
(a−1R−1+a−2 R−2+· · · a−m  R−m)Sn
must be an integer.)
(d) Generalize part (a) to determine necessary and sufficient conditions for a spe-
cific, but not every, base R fraction, N=(0.a−1a−2 · · · a−m)R, to be representable 
as a base S fraction with a finite number of nonzero digits.
1.28 Construct a table for 4-3-2-1 weighted code and write 9154 using this code.
1.29 Is it possible to construct a 5-3-1 -1 weighted code? A 6-4-1 -1 weighted code? Justify 
your answers.
1.30 Is it possible to construct a 5-4-1 -1 weighted code? A 6-3-2-1 weighted code? Justify 
your answers.
1.31 Construct a 6-2-2-1 weighted code for decimal digits. What number does 1100 0011 
represent in this code?
Number Systems and Conversion  27
1.32 Construct a 5-2-2-1 weighted code for decimal digits. What numbers does 1110 0110 
represent in this code?
1.33 Construct a 7-3-2-1 code for base 12 digits. Write B4A9 using this code.
1.34 (a)  It is possible to have negative weights in a weighted code for the decimal digits, 
e.g., 8, 4, −2, and −1 can be used. Construct a table for this weighted code.
(b) If d is a decimal digit in this code, how can the code for 9 − d be obtained?
1.35 Convert to hexadecimal, and then give the ASCII code for the resulting hexadecimal 
number (including the code for the hexadecimal point):
 (a) 222.2210 (b) 183.8110
1.36 Repeat 1.7 for the following numbers:
 (a) (−10)+(−11) (b) (−10)+(−6) (c) (−8)+(−11)
 (d) 11+9 (e) (−11)+(−4)
1.37 Because A−B=A+(−B), the subtraction of signed numbers can be accomplished 
by adding the complement. Subtract each of the following pairs of 5-bit binary num-
bers by adding the complement of the subtrahend to the minuend. Indicate when an overflow occurs. Assume that negative numbers are represented in 1’s complement. Then repeat using 2’s complement.
 (a) 
  01001
−11010 (b)   11010
−11001 (c)   10110
−01101 (d)   11011
−00111 (e)   11100
−10101
1.38 Work Problem 1.37 for the following pairs of numbers:
 (a)   11010
−10100 (b)   01011
−11000 (c)   10001
−01010 (d)   10101
−11010
1.39 (a)  A=101010 and B=011101 are 1’s complement numbers. Perform the follow-
ing operations and indicate whether overflow occurs.
  (i) A+B (ii) A−B
 (b) Repeat part (a) assuming the numbers are 2’s complement numbers.
1.40 (a)  Assume the integers below are 1’s complement integers. Find the 1’s comple-
ment of each number, and give the decimal values of the original number and of its complement.
  (i) 0000000 (ii) 1111111 (iii) 00110011 (iv) 1000000
(b) Repeat part (a) assuming the numbers are 2’s complement numbers and finding 
the 2’s complement of them.
1.41 An alternative algorithm for converting a base 20 integer, d
n−1dn−2 · · · d1d0, into a 
base 10 integer is stated as follows: Multiply di by 2i and add i 0’s on the right, and 
then add all of the results.
28 Unit 1
(a) Use this algorithm to convert GA720 to base 10. ( G20 is 1610.)
(b) Prove that this algorithm is valid.
(c) Consider converting a base 20 fraction, 0. d−1d−2 · · · d−n+1d−n, into a base 10 
fraction. State an algorithm analogous to the one above for doing the conversion.
(d) Apply your algorithm of part (c) to 0. FA720.
1.42 Let A and B be positive integers, and consider the addition of A and B in an n-bit 2’s 
complement number system.
(a) Show that the addition of A and B produces the correct representation of the 
sum if the magnitude of (A+B) is<2n−1−1 but it produces a representation 
of a negative number of magnitude 2n−(A+B) if the magnitude of (A+B) 
is>2n−1−1.
(b) Show that the addition of A and (−B) always produces the correct representa-
tion of the sum. Consider both the case where A≥B and the case A<B.
(c) Show that the addition of (2n−A)+(2n−B), with the carry from the sign posi-
tion ignored, produces the correct 2’s complement representation of −(A+B) if 
the magnitude of A+B is less than or equal to 2n−1. Also, show that it produces 
an incorrect sum representing the positive number 2n−(A+B) if the magni-
tude of ( A+B)>2n−1.
1.43 Let A and B be integers and consider the addition of A and B in an n-bit 1’s comple-
ment number system. Prove that addition of A and B using the end-around carry 
produces the correct representation of the sum provided overflow does not occur. 
Consider the four cases: A and B both positive, A positive and B negative with the 
magnitude of A greater than the magnitude of B, A positive and B negative with the 
magnitude of A less than or equal to the magnitude of B, and A and B both negative.  
1.44 Prove that in a 2’s complement number system addition overflows if and only if the 
carry from the sign position does not equal the carry into the sign position. Consider 
the three cases: adding two positive numbers, adding two negative numbers, and adding two numbers of opposite sign.
1.45 Restate the method for detecting overflow of Problem 1.44 so that it applies to 1’s 
complement numbers.
1.46 Let B=b
n−1bn−2 · · · b1b0 be an n-bit 2’s complement integer. Show that the deci-
mal value of B is −bn−12n−1+bn−22n−2+bn−32n−3+· · ·+b12+b0. (Hint: Con-
sider positive (bn−1=0) and negative (bn−1 = 1) numbers separately, and note that 
the magnitude of a negative number is obtained by subtracting each bit from 1  
(i.e., complementing each bit) and adding 1 to the result.)
www.allitebooks.com

29Boolean Algebra
Objectives
A list of some of the laws of switching algebra, which is a special case of Boolean 
algebra, is given in Table 2-3. Additional theorems of Boolean algebra are given in Table 2-4. When you complete this unit, you should be familiar with and be able to use these laws and theorems of Boolean algebra.
1. Understand the basic operations and laws of Boolean algebra.
2. Relate these operations and laws to circuits composed of AND gates, OR gates, 
and INVERTERS. Also relate these operations and laws to circuits composed of switches.
3. Prove any of these laws in switching algebra using a truth table.
4. Apply these laws to the manipulation of algebraic expressions including:
a. Multiplying out an expression to obtain a sum of products (SOP)
b. Factoring an expression to obtain a product of sums (POS)
c. Simplifying an expression by applying one of the laws
d. Finding the complement of an expressionUNIT
2
30 Unit 2
Study Guide
1. In this unit you will study Boolean algebra, the basic mathematics needed 
for the logic design of digital systems. Just as when you first learned ordinary  algebra, you will need a fair amount of practice before you can use Boolean algebra effectively. However, by the end of the course, you should be just as comfortable with Boolean algebra as with ordinary algebra. Fortunately, many of the rules of Boolean algebra are the same as for ordinary algebra, but watch out for some surprises!
2. Study Sections 2.1 and 2.2, Introduction and Basic Operations.
(a) How does the meaning of the symbols 0 and 1 as used in this unit differ 
from the meaning as used in Unit 1?
(b) Two commonly used notations for the inverse or complement of 
A are A 
and A′. The latter has the advantage that it is much easier for typists, print-
ers, and computers. (Have you ever tried to get a computer to print a bar over a letter?) We will use 
A′ for the complement of A. You may use either 
notation in your work, but please do not mix notations in the same equa-tion. Most engineers use +GPS03BOEr	PSOPTZNCPM
GPS"/%BOEXF
will follow this practice. An alternative notation, often used by mathemati-cians, is ∨for OR and ∧for AND.
(c) Many different symbols are used for AND, OR, and INVERTER logic 
blocks. Initially we will use
1
11
010 11++
......for
ANDforORforINVERTER
+
0 10 1 1 0 ++ The shapes of these symbols conform to those commonly used in industrial 
practice. We have added the +BOErGPSDMBSJUZ5IFTFTZNCPMTQPJOUJOUIF
direction of signal flow. This makes it easier to read the circuit diagrams in 
comparison with the square or round symbols used in some books.
(d) Determine the output of each of the following gates:
(e) Determine the unspecified inputs to each of the following gates if the out-
puts are as shown:
Boolean Algebra 31
3. Study Section 2.3, Boolean Expressions and Truth Tables.
(a) How many variables does the following expression contain?
How many literals?
A′BC′D +AB +B′CD +D′
(b) For the following circuit, if A=B=0 and C=D =E=1, indicate the 
output of each gate (0 or 1) on the circuit diagram:
C
D
B
EF A++
(c) Derive a Boolean expression for the circuit output. Then substitute 
A=B=0 and C=D =E=1 into your expression and verify that the 
value of F obtained in this way is the same as that obtained on the circuit 
diagram in (b).
(d) Write an expression for the output of the following circuit and complete 
the truth table:
A B A′ A′B (A′B)′A
F =BF
(e) When filling in the combinations of values for the variables on the left side 
of a truth table, always list the combinations of 0’s and 1’s in binary order. 
For example, for a three-variable truth table, the first row should be 000, the next row 001, then 010, 011, 100, 101, 110, and 111. Write an expression for the output of the following circuit and complete the truth table:
BCA
F =F+A B C B′ A+B′ C(A+B′)
(f) Draw a gate circuit which has an output
Z=[BC′ +F(E+AD ′)]′
(Hint: Start with the innermost parentheses and draw the circuit for AD′ 
first.)
32 Unit 2
4. Study Section 2.4, Basic Theorems.
(a) Prove each of the Theorems (2-4) through (2-8D) by showing that it is valid 
for both X =0 and X =1.
(b) Determine the output of each of these gates:
A
A
A
AA′
A
A′
AA
0
AA
1
01A++++
(c) State which of the basic theorems was used in simplifying each of the 
 following expressions:
(AB ′+C)·0=0               A(B +C′)+1=1
(BC′ +A)(BC′ +A)=BC′ +A  X(Y′+Z)+[X(Y′+Z)]′=1
(X′+YZ)(X ′+YZ) ′=0        D′(E′+F    )+D′(E′+F   )=D′(E′+F    )
5. Study Section 2.5, Commutative, Associative, Distributive, and DeMorgan’s Laws.
(a) State the associative law for OR.
(b) State the commutative law for AND.
(c) Simplify the following circuit by using the associative laws. Your answer 
should require only two gates.
(d) For each gate determine the value of the unspecified input(s):
(e) Using a truth table, verify the distributive law, Equation (2-11).1
1
100 110
0
0+ +A
B
C
D
E
FG +
+
Boolean Algebra 33
(f) Illustrate the distributive laws, Equations (2-11) and (2-11D), using AND 
and OR gates.
(g) Verify Equation (2-3) using the second distributive law.
(h) Show how the second distributive law can be used to factor RS +T′.
6. Study Section 2.6, Simplification Theorems.
(a) By completing the truth table, prove that XY′+Y=X+Y.
(b) Which one of Theorems in Table 2-4 was applied to simplify each of the 
following expressions? Identify X and Y in each case.
(A+B)(DE )′+DE =A+B+DE
AB ′+AB ′C′D =AB ′
(A′+B)(CD +E′)+(A′+B)(CD +E′)′=A′+B
(A+BC′ +D′E)(A +D′E)=A+D′EX Y XY′ XY′+Y X+Y
0  0
0  11  01  1
34 Unit 2
(c) Simplify the following circuit to a single gate:
(d) Work Problems 2.1, 2.2, 2.3, and 2.4.
7. Study Section 2.7 , Multiplying Out and Factoring.
(a) Indicate which of the following expressions are in the product-of-sums 
form, sum-of-products form, or neither:
          AB ′+D′EF  ′+G
       ( A+B′C′)(A ′+BC)
  AB ′(C′+D +E′)(F  ′+G)
X′Y+WX(X′+Z)+A′B′C′
 Your answer should indicate one expression as a product-of-sums form, one 
as sum-of-products form, and two as neither, not necessarily in that order.
(b) When multiplying out an expression, why should the second distributive 
law be applied before the ordinary distributive law when possible?
(c) Factor as much as possible using the ordinary distributive law:
AD +B′CD +B′DE
Now factor your result using the second distributive law to obtain a prod-uct of sums.
(d) Work Problems 2.5, 2.6, and 2.7 .
8. Probably the most difficult part of the unit is using the second distributive law for factoring or multiplying out an expression. If you have difficulty with Problems 2.5 or 2.6, or you cannot work them quickly, study the examples in 
Section 2.7 again, and then work the following problems.
Multiply out:
(a) 
(B′+D +E)(B′+D +A)(AE +C′)
(b) (A+C′)(B′+D)(C′+D′)(C+D)EA
B
CC Z
D+
+
Boolean Algebra 35
As usual, when we say multiply out, we do not mean to multiply out by brute 
force, but rather to use the second distributive law whenever you can to cut 
down on the amount of work required.
The answer to (a) should be of the following form: XX+XX +XX and 
(b) of the form: XXX +XXXX X, where each X represents a single variable or 
its complement.
Now factor your answer to (a) to see that you can get back the original 
expression.
9. Study Section 2.8, Complementing Boolean Expressions.
10. Find the complement of each of the following expressions as indicated. In your answer, the complement operation should be applied only to single variables.
(a) 
(ab ′c′)′=
(b) (a′+b+c+d′)′=
(c) (a′+bc)′=
(d) (a′b′+cd)′=
(e) [a(b′+c′d)]′=
11. Because (X′)′=X, if you complement each of your answers to 10, you should 
get back the original expression. Verify that this is true.
(a) 
(b) 
(c) 
(d) 
(e) 
12. Given that F =a′b+b′c, F ′=
Complete the following truth table and verify that your answer is correct:
a b ca ′bb ′ca ′b+b′c (a+b′)( b+c′) F′
0 0 0
0 0 10 1 00 1 11 0 01 0 11 1 01 1 1
36 Unit 2
13. A fully simplified expression should have nothing complemented except the 
individual variables. For example, F=(X+Y)′(W +Z) is not a minimum 
product of sums. Find the minimum product of sums for F.
14. Work Problems 2.8 and 2.9.
15. Find the dual of (M +N′)P′.
16. Review the laws of Table 2-3 and the first three theorems of Table 2-4. Make sure that you can recognize when to apply them even if an expression has been substituted for a variable.
17. Reread the objectives of this unit. If you are satisfied that you can meet these objectives, take the readiness test.
[Note: You will be provided with a copy of Tables 2-3 and 2-4 when you take the readiness test this time. However, by the end of Unit 3, you should know all the laws and theorems by memory.]
Boolean Algebra
2.1 Introduction
The basic mathematics needed for the study of logic design of digital systems is Boolean algebra. George Boole developed Boolean algebra in 1847 and used it to solve problems in mathematical logic. Boolean algebra has many other applications, including set theory and mathematical logic; however, we primarily consider its appli-cation to switching circuits. All of the switching devices we will use are essentially two-state devices (e.g., switches which are open or closed and transistors with high or low 
Boolean Algebra 37
output voltages). Consequently, we will emphasize the special case of Boolean algebra 
in which all of the variables assume only one of two values; this two-valued Boolean algebra is often called switching algebra. Claude Shannon first applied Boolean alge-
bra to the design of switching circuits in 1939. First, we develop some of the properties of switching algebra and use these to define a general Boolean algebra.
We will use a Boolean variable, such as 
X or Y, to represent the input or out-
put of a switching circuit. We will assume that each of these variables can take on only two different values. The symbols “0” and “1” are used to represent these two different values. Thus, if 
X is a Boolean (switching) variable, then either X=0  
or X=1.
The symbols “0” and “1” used in Boolean algebra do not have a numeric value; 
instead they represent two different states in a logic circuit and are the two values of a switching variable. In a logic gate circuit, 0 (usually) represents a range of low voltages, and 1 represents a range of high voltages. In a switch circuit, 0 (usually) represents an open switch, and 1 represents a closed circuit. In general, 0 and 1 can be used to represent the two states in any binary-valued system.
2.2 Basic Operations
The basic operations of Boolean (switching) algebra are called AND, OR, and com-plement (or inverse). In the case of switch circuits these operations correspond to different configurations of switches. To apply switching algebra to a switch circuit, each switch contact is labeled with a variable. If contact 
X is open, the variable X is 
defined to be 0; if contact X is closed, the variable X is defined to be 1.
The contacts in a switch can be normally open (NO) or normally closed (NC). When the switch position is changed, the NO contact closes and the NC contact opens, so the NO and NC contacts are always in opposite states. If 
X is the variable assigned 
to the NO contact, then the variable assigned to the NC contact is the complement of 
X, denoted as X′, where the prime (′ ) denotes complementation.
The complement of 0 is 1, and the complement of 1 is 0. Symbolically, we write
0′=1   and   1′=0X X = 0 → switch open
X = 1 → switch closed
A
NO contact
NC contactB
38 Unit 2
If Xis a switching variable,
X′=1  if  X =0   and   X′=0  if  X =1
An alternate name for complementation is inversion, and the electronic circuit 
which forms the inverse of X is referred to as an inverter. Symbolically, we represent 
an inverter by
where the circle at the output indicates inversion. A low voltage at the inverter input 
produces a high voltage at the output and vice versa.
In a general switch circuit, the value 0 is assigned to the connection between 
two terminals in the circuit if there is no connection (open circuit) between the terminals, and a 1 is assigned if there is a connection (closed circuit) between the terminals. If the switch circuit only contains two switches, the switch contacts must be connected in series or in parallel. When switch contacts 
A and B  are connected 
in series, there is an open circuit between the terminals if either A or B  or both are 
open (0), and there is a closed circuit between the terminals only if both A and B 
are closed (1).
This is summarized in the following truth table:
The operation defined by the table is called AND and it is written algebraically as 
C =A ·B. The “ ·” symbol is frequently omitted in a Boolean expression, and we will 
usually write AB instead of A ·B. The AND operation is also referred to as logical 
(or Boolean) multiplication.
When switches A and B  are connected in parallel, there is a closed circuit between 
the terminals if either A or B is closed (1), and there is an open circuit between the 
terminals only if both A and B  are open (0).A BC=A·B
0  0 0
0  1 01  0 01  1 1
A
B12XX ′
A
1B C = 0 → open circuit between terminals 1 and 2
C = 1 → closed circuit between terminals 1 and 22
www.allitebooks.com

Boolean Algebra 39
This is summarized in the following truth table:
The operation defined by the table is called OR and it is written algebraically as 
C=A+B. This type of OR operation is sometimes referred to as inclusive OR as 
opposed to exclusive OR, which is defined later. The OR operation is also referred 
to as logical (or Boolean) addition.
Logic gates operate so that the voltage on inputs and outputs of a gate is either in a 
low voltage range or a high voltage range, except when the signals are changing. Switch-ing algebra can be applied to logic gates by assigning 0 and 1 to the two voltage ranges. Usually, a 0 is assigned to the low voltage range and a 1 to the high voltage range.
A logic gate which performs the AND operation is represented by
The gate output is 
C=1 if and only if the gate inputs A=1 and B =1.
A logic gate which performs the OR operation is represented by
The gate output is C=1 if and only if the gate inputs A=1 or B =1 (or both). 
Electronic circuits which realize inverters and AND and OR gates are described in Appendix A.
2.3 Boolean Expressions and Truth Tables
Boolean expressions are formed by application of the basic operations to one or more variables or constants. The simplest expressions consist of a single constant or variable, such as 0, 
X, or Y ′. More complicated expressions are formed by combin-
ing two or more other expressions using AND or OR, or by complementing another expression. Examples of expressions are
 
AB′+C (2-1)
 [A(C+D)]′+BE (2-2)
Parentheses are added as needed to specify the order in which the operations are 
performed. When parentheses are omitted, complementation is performed first fol-lowed by AND and then OR. Thus in Expression (2-1), B′ is formed first, then 
AB′, 
and finally AB′+C.A BC=A+B
0  0 0
0  1 11  0 11  1 1
A
BC = A  B
A
BC = A + B +
40 Unit 2
Each expression corresponds directly to a circuit of logic gates. Figure 2-1 gives 
the circuits for Expressions (2-1) and (2-2).
An expression is evaluated by substituting a value of 0 or 1 for each variable. If 
A =B =C =1 and D =E =0, the value of Expression (2-2) is
[A(C +D)]′+BE =[1(1+0)]′+1·0=[1(1)]′+0=0+0=0
Each appearance of a variable or its complement in an expression will be referred 
to as a literal. Thus, the following expression, which has three variables, has 10 literals:
ab ′c+a′b+a′bc ′+b′c′
When an expression is realized using logic gates, each literal in the expression cor-
responds to a gate input.
A truth table (also called a table of combinations) specifies the values of a 
Boolean expression for every possible combination of values of the variables in the expression. The name truth table comes from a similar table which is used in sym-bolic logic to list the truth or falsity of a statement under all possible conditions. We can use a truth table to specify the output values for a circuit of logic gates in terms of the values of the input variables. The output of the circuit in Figure 2-2(a) is F=A′+B. Figure 2-2(b) shows a truth table which specifies the output of the 
circuit for all possible combinations of values of the inputs 
A and B . The first two 
columns list the four combinations of values of A and B , and the next column gives 
the corresponding values of A′. The last column, which gives the values of A′+B, is 
formed by ORing together corresponding values of A′ and B  in each row.
FIGURE 2-2
Two-Input Circuit 
and Truth Table
© Cengage Learning 2014+A
BF = A′ + BA′
(a)FIGURE 2-1
Circuits for 
Expressions (2-1) 
and (2-2)
© Cengage Learning 2014A
A
BB E
EAB ′
(AB ′ + C )
(C + D)A(C + D)[ A(C + D)] ′
[A(C + D)] ′ + BE(a)
(b)CB
C
DB′
+++
A B A′ F=A′+B
0   0 1 1
0   1 1 1
1   0 0 0
(b)1   1 0 1
Boolean Algebra 41
Next, we will use a truth table to specify the value of Expression (2-1) for all 
possible combinations of values of the variables A, B, and C. On the left side of 
Table 2-1, we list the values of the variables A, B, and C. Because each of the three 
variables can assume the value 0 or 1, there are 2 ×2×2=8 combinations of values 
of the variables. These combinations are easily obtained by listing the binary num-
bers 000, 001, …  , 111. In the next three columns of the truth table, we compute B′, 
AB′, and AB′+C, respectively.
Two expressions are equal if they have the same value for every possible combi-
nation of the variables. The expression (A +C)(B′+C) is evaluated using the last 
three columns of Table 2-1. Because it has the same value as AB′+C for all eight 
combinations of values of the variables A, B, and C, we conclude
 AB′+C =(A +C)(B′+C) (2-3)
If an expression has n variables, and each variable can have the value 0 or 1, the 
number of different combinations of values of the variables is
2  ×  2  ×  2  ×  . . . 
n times = 2n
Therefore, a truth table for an n-variable expression will have 2n rows.
2.4 Basic Theorems
The following basic laws and theorems of Boolean algebra involve only a single variable:
Operations with 0 and 1:TABLE 2-1
© Cengage Learning 2014 A  B  C B′ AB′ AB′+C A +C B′+C (A +C )(B′+C )
0  0  0 1 0 0 0 1 0
0  0  1 1 0 1 1 1 1
0  1  0 0 0 0 0 0 0
0  1  1 0 0 1 1 1 1
1  0  0 1 1 1 1 1 1
1  0  1 1 1 1 1 1 1
1  1  0 0 0 0 1 0 0
1  1  1 0 0 1 1 1 1
X +0=X (2-4) X ·1=X (2-4D )
X +1=1 (2-5) X ·0=0 (2-5D )
42 Unit 2
Idempotent laws:
X +X =X (2-6) X ·X =X (2-6D )
Involution law:
(X′)′=X (2-7)
Laws of complementarity:
X +X′=1 (2-8) X ·X′=0 (2-8D )
AA
A
AA
A=Each of these theorems is easily proved by showing that it is valid for both of the 
possible values of X. For example, to prove X +X′=1, we observe that if
X =0,  0+0′=0+1=1,  and   if   X =1,   1+1′=1+0=1
Any expression can be substituted for the variable X in these theorems. Thus, by 
Theorem (2-5),
(AB ′+D)E +1=1
and by Theorem (2-8D),
(AB ′+D)(AB ′+D)′=0
We will illustrate some of the basic theorems with circuits of switches. As before, 
0 will represent an open circuit or open switch, and 1 will represent a closed circuit or closed switch. If two switches are both labeled with the variable 
A, this means that 
both switches are open when A =0 and both are closed when A =1. Thus the circuit
can be replaced with a single switch:
This illustrates the theorem A ·A =A. Similarly,
which illustrates the theorem A +A =A. A switch in parallel with an open circuit is 
equivalent to the switch alone
AA
=
(A + 0 = A)
Boolean Algebra 43
while a switch in parallel with a short circuit is equivalent to a short circuit.
If a switch is labeled A′, then it is open when A is closed and conversely. Hence, A  
in parallel with A′ can be replaced with a closed circuit because one or the other of the 
two switches is always closed.
Similarly, switch A in series with A′ can be replaced with an open circuit (why?).
2.5 Commutative, Associative, Distributive,  
and DeMorgan’s Laws
Many of the laws of ordinary algebra, such as the commutative and associative laws, 
also apply to Boolean algebra. The commutative laws for AND and OR, which fol-low directly from the definitions of the AND and OR operations, areA
(A + 1 = 1)=
A
A′
(A + A′ = 1)=
(A  A′ = 0)=AA ′
XY=YX   (2-9) X+Y=Y+X   (2-9D )
This means that the order in which the variables are written will not affect the result of applying the AND and OR operations.
The associative laws also apply to AND and OR:
 
(XY)Z=X(YZ)=XYZ (2-10)
 (X+Y)+Z=X+(Y+Z)=X+Y+Z (2-10D )
When forming the AND (or OR) of three variables, the result is independent of which pair of variables we associate together first, so parentheses can be omitted as indicated in Equations (2-10) and (2-10D).
44 Unit 2
When the preceding laws are interpreted as switch circuits, they simply indicate 
that the order in which switch contacts are connected does not change the logic 
operation of the circuit.
We will prove the associative law for AND by using a truth table (Table 2-2). 
On the left side of the table, we list all combinations of values of the variables X,Y, 
and Z. In the next two columns of the truth table, we compute XY and Y Z for 
each combination of values of X, Y, and Z. Finally, we compute (XY)Z and X(YZ). 
Because (XY)Z and X(YZ) are equal for all possible combinations of values of the 
variables, we conclude that Equation (2-10) is valid.
Figure 2-3 illustrates the associative laws using AND and OR gates. In 
Figure 2-3(a) two two-input AND gates are replaced with a single three-input AND gate. Similarly, in Figure 2-3(b) two two-input OR gates are replaced with a single three-input OR gate.
When two or more variables are ANDed together, the value of the result will be 1 
if all of the variables have the value 1. If any of the variables have the value 0, the result of the AND operation will be 0. For example,
XYZ =1 iff X=Y=Z=1
When two or more variables are ORed together, the value of the result will be 1 
if any of the variables have the value 1. The result of the OR operation will be 0 iff all of the variables have the value 0. For example,
X+Y+Z=0 iff X =Y=Z=0TABLE 2-2
Proof of  
Associative  
Law for AND
© Cengage Learning 2014X  Y  Z XY YZ (XY  )Z X(YZ  )
0 0 0 0 0 0 0
0 0 1 0 0 0 0
0 1 0 0 0 0 0
0 1 1 0 1 0 0
1 0 0 0 0 0 0
1 0 1 0 0 0 0
1 1 0 1 0 0 0
1 1 1 1 1 1 1
FIGURE 2-3
Associative Laws  
for AND and OR
© Cengage Learning 2014AA
B
CBC=
(AB) C = ABC
(a)
AA
BCBC =
(A + B) + C = A + B + C
(b)+++
Boolean Algebra 45
Using a truth table, it is easy to show that the distributive law is valid:
 X(Y +Z)=XY +XZ (2-11)
In addition to the ordinary distributive law, a second distributive law is valid for 
Boolean algebra but not for ordinary algebra:
 X +YZ =(X +Y)(X +Z) (2-11D )
Proof of the second distributive law follows:
(X +Y)(X +Z)=X(X +Z)+Y(X +Z)=XX +XZ +YX +YZ
(by (2-11))
=X +XZ +XY +YZ =X ·1+XZ +XY +YZ
(by (2-6D ) and (2-4D ))
=X(1+Z +Y)+YZ =X ·1+YZ =X +YZ
(by (2-11), (2-5), and (2-4D ))
The ordinary distributive law states that the AND operation distributes over OR, 
while the second distributive law states that OR distributes over AND. This second 
law is very useful in manipulating Boolean expressions. In particular, an expression like 
A +BC, which cannot be factored in ordinary algebra, is easily factored using 
the second distributive law:
A +BC =(A +B)(A +C)
The next laws are called DeMorgan’s laws.
 (X +Y  )′=X′Y′ (2-12)
 (XY)′=X′+Y′ (2-13)
We will verify these laws using a truth table:
The laws we have derived for switching algebra are summarized in Table 2-3. One 
definition of Boolean algebra is a set containing at least two distinct elements with the operations of AND, OR, and complement defined on the elements that satisfy X  Y X  ′ Y′ X +Y (X +Y )′ X′Y′ XY (XY  )′ X′+Y′
0 0 1 1 0 1 1 0 1 1
0 1 1 0 1 0 0 0 1 1
1 0 0 1 1 0 0 0 1 11 1 0 0 1 0 0 1 0 0
46 Unit 2
the laws in Table 2-3. This definition is not minimal (i.e., the laws are not independent 
since some can be derived from others). It is chosen for convenience so that other Boolean algebra theorems can be derived easily. One minimal set of laws referred to as Huntington’s postulates are operations with 0 and 1, commutative laws, distribu-tive laws, and complementation laws. The other laws can be algebraically derived from this minimal set.
The Boolean algebra laws were given in pairs to show the algebra satisfies a dual-
ity. Given a Boolean algebra expression the dual of the expression is obtained by interchanging the constants 0 and 1 and interchanging the operations of AND and OR. Variables and complements are left unchanged. The laws listed in Table 2-3 show that given a Boolean algebra identity, another identity can be obtained by taking the dual of both sides of the identity. The dual of AND is OR and the dual of OR is AND:
 
(XYZ . . .)D=X +Y +Z +· · ·    (X +Y +Z +· · ·)D=XYZ . . .  (2-14)
2.6 Simplification Theorems
The following theorems are useful in simplifying Boolean expressions:Uniting:
      XY +XY ′=X (2-15) (X +Y  )(X +Y′)=X (2-15D )
Absorption:   X +XY =X (2-16) X(X +Y  )=X (2-16D )Operations with 0 and 1:
1. X +0=X 1D. X·1=X
2. X +1=1 2D. X·0=0
Idempotent laws:3. 
X +X =X 3D. X·X =X
Involution law:
4. (X′)′=X
Laws of complementarity:
5. X +X′  =1 5D. X·X′=0
Commutative laws:6. 
X +Y =Y +X 6D. XY =YX
Associative laws:
7. (X +Y )+Z=X +(Y +Z )
=X +Y +Z7D. (XY  )Z=X(YZ  )=XYZ
Distributive laws:8. 
X(Y +Z )=XY +XZ 8D. X +YZ =(X +Y )(X +Z )
DeMorgan’s laws:9. 
(X +Y )′=X′Y′ 9D. (XY  )′=X′+Y  ′TABLE 2-3 
Laws of Boolean 
Algebra
© Cengage Learning 2014
Boolean Algebra 47
Elimination:   X +X  ′Y =X +Y (2-17) X(X′+Y    )=X  Y (2-17D )
Consensus:     XY +X′Z +YZ =XY +X′Z (2-18)
 (X +Y  )(X′+Z)(Y +Z)=(X +Y  )(X′+Z) (2-18D )
In each case, one expression can be replaced by a simpler one. Since each expression 
corresponds to a circuit of logic gates, simplifying an expression leads to simplifying the corresponding logic circuit.
In switching algebra, each of the above theorems can be proved by using a truth 
table. In a general Boolean algebra, they must be proved algebraically starting with the basic theorems.
Proof of 
(2-15):  XY +XY ′=X(Y +Y′)=X(1)=X
Proof of (2-16):  X +XY =X ·1+XY =X(1+Y)=X ·1=X
Proof of (2-17):  X +X′Y =(X +X′)(X +Y   )=1(X +Y   )=X +Y
Proof of (2-18):  XY +X′Z +YZ =XY +X′Z +(1)YZ =
XY +X′Z +(X +X′)YZ =XY +XYZ +X′Z +X′YZ =
XY +X′Z (using absorption twice )
After proving one theorem in a pair of theorems, the other theorem follows by the duality property of Boolean algebra. Alternatively, the other theorem can be proved using the dual steps used to prove the first theorem. For example, (2-16D) can be proved using the dual steps of the (2-16) proof.
Proof of 
(2-16D ):  X(X +Y  )=(X +0)(X +Y   )=X +(0·Y   )=X +0=X
We will illustrate the elimination theorem using switches. Consider the following 
circuit:
Its transmission is T =Y +XY ′ because there is a closed circuit between the termi-
nals if switch Y is closed or switch X is closed and switch Y′ is closed. The following 
circuit is equivalent because if Y is closed (Y =1) both circuits have a transmission 
of 1; if Y is open (Y′=1) both circuits have a transmission of X.
The following example illustrates simplification of a logic gate circuit using one 
of the theorems. In Figure 2-4, the output of circuit (a) is
F=A(A′+B)Y
XY ′
Y
X
48 Unit 2
By the elimination theorem, the expression for F simplifies to AB. Therefore, circuit (a) 
can be replaced with the equivalent circuit (b).
Any expressions can be substituted for X and Y in the theorems.FIGURE 2-4
Equivalent Gate 
Circuits
© Cengage Learning 2014A
BAFA
BF
(a) (b)+
Simplify Z =A′BC+A′
This expression has the same form as absorption theorem (2-16) if we let X=A′ 
and Y =BC.
Therefore, the expression simplifies to Z =X+XY=X=A′.
Simplify  Z=[A+B′C+D+EF ]  [A+B′C+(D+EF  )′]
  Substituting : Z=[     X     +    Y      ] [      X       +      Y′          ]
Then, by the uniting theorem (2-15D), the expression reduces to
Z=X=A+B′C
Simplify   Z=(AB+C) (B ′D+C′E′)+(AB+C)′
Substituting : Z=       X′                     Y          +        X
By the elimination theorem (2-17): Z =X+Y=B′D+C′E′+(AB+C)′
Note that in this example we let X=(AB+C)′ rather than (AB+C) in order to 
match the form of the elimination theorem (2-17).
The theorems of Boolean algebra that we have derived are summarized in 
Table 2-4. The theorem for multiplying out and factoring is derived in Unit 3.Example 1
Example 2
Example 3
www.allitebooks.com

Boolean Algebra 49
2.7 Multiplying Out and Factoring
The two distributive laws are used to multiply out an expression to obtain a sum-of- 
products (SOP) form. An expression is said to be in sum-of-products form when all 
products are the products of single variables. This form is the end result when an expression is fully multiplied out. It is usually easy to recognize a sum-of-products expression because it consists of a sum of product terms:
 
AB′+CD ′E+AC ′E′ (2-19)
However, in degenerate cases, one or more of the product terms may consist of a 
single variable. For example,
 ABC′ +DEFG +H (2-20)
and 
A+B′+C+D′E (2-21)
are still considered to be in sum-of-products form. The expression
(A+B)CD+EF
is not in sum-of-products form because the A+B term enters into a product but is 
not a single variable.
When multiplying out an expression, apply the second distributive law first when 
possible. For example, to multiply out (A+BC  )(A+D+E ) let
X=A,    Y=BC,    Z=D+EUniting theorems:
1. XY+XY ′=X 1D. (X+Y    )(X+Y′)=X
Absorption theorems:2. 
X+XY=X 2D. X(X+Y  )=X
Elimination theorems:3. 
X+X′Y=X+Y 3D. X(X′+Y   )=XY
Duality:
4. (X+Y+Z + · · ·)D=XYZ . . . 4D. ( XYZ . . . )D=X+Y+Z + · · ·
Theorems for multiplying out and factoring:
5. (X+Y   )(X′+Z   )=XZ+X′Y 5D. XY+X′Z=(X+Z  )(X′+Y   )
Consensus theorems:
6. XY+YZ+X′Z=XY+X′Z 6D.(X+Y )(Y+Z )(X′+Z )=(X+Y )(X′+Z )TABLE 2-4 
Theorems of 
Boolean Algebra
© Cengage Learning 2014
50 Unit 2
Then
(X+Y)(X+Z)=X+YZ=A+BC(D+E)=A+BCD +BCE
Of course, the same result could be obtained the hard way by multiplying out the 
original expression completely and then eliminating redundant terms:
(A+BC)(A +D+E)=A+AD +AE+ABC +BCD +BCE
=A(1+D+E+BC) +BCD +BCE
=A+BCD +BCE
You will save yourself a lot of time if you learn to apply the second distributive law instead of doing the problem the hard way.
Both distributive laws can be used to factor an expression to obtain a product-of-
sums form. An expression is in product-of-sums (POS) form when all sums are the 
sums of single variables. It is usually easy to recognize a product-of-sums expression since it consists of a product of sum terms:
 
(A+B′)(C+D′+E)(A+C′+E′) (2-22)
However, in degenerate cases, one or more of the sum terms may consist of a single 
variable. For example,
 (A+B)(C+D+E)F (2-23)
and 
AB′C(D′+E) (2-24)
are still considered to be in product-of-sums form, but (A+B)(C+D)+EF is not. 
An expression is fully factored iff it is in product-of-sums form. Any expression not 
in this form can be factored further.
The following examples illustrate how to factor using the second distributive law:
Factor A+B′CD. This is of the form X+YZ where X=A, Y=B′, and Z =CD, so
A+B′CD=(X+Y)(X+Z)=(A+B′)(A+CD)
A+CD can be factored again using the second distributive law, so
A+B′CD=(A+B′)(A+C)(A+D)
Factor AB′+C′D.
AB ′+C′D=(AB ′+C′)(AB ′+D)   ←note how X+YZ=(X+Y)(X+Z)   
was applied here                                        
=(A+C′)(B ′+C′)(A+D)(B ′+D)←the second distributive law was applied
again to each term                                     Example 1
Example 2
Boolean Algebra 51
Factor C ′D+C′E′+G′H.
C′D+C′E′+G′H=C′(D+E′)+G′H ←first apply the ordinary
 distributive law,
 XY+XZ=X(Y+Z)
= (C′+G′H)((D+E′)+G′H) ←then apply the second
 distributive law
= (C′+G′)(C′+H)(D+E′+G′)(D+E′+H) ←now identify X, Y, and Z
 in each expression and
 complete the factoring
As in Example 3, the ordinary distributive law should be applied before the second 
law when factoring an expression.
A sum-of-products expression can always be realized directly by one or more 
AND gates feeding a single OR gate at the circuit output. Figure 2-5 shows the cir-cuits for Equations (2-19) and (2-21). Inverters required to generate the comple-mented variables have been omitted.
A product-of-sums expression can always be realized directly by one or more 
OR gates feeding a single AND gate at the circuit output. Figure 2-6 shows the cir-cuits for Equations (2-22) and (2-24). Inverters required to generate the comple-ments have been omitted.
The circuits shown in Figures 2-5 and 2-6 are often referred to as two-level cir-
cuits because they have a maximum of two gates in series between an input and the circuit output.
FIGURE 2-5
Circuits for  
Equations  
(2-19) and  
(2-21)
© Cengage Learning 2014AA
B′
C
D′
E
A
C′
E′B′
CD′
E++
 FIGURE 2-6
Circuits for 
Equations (2-22) 
and (2-24)
© Cengage Learning 2014AA
B′
C
D′
E
A
C′
E′B′
C D′
E++
++Example 3
52 Unit 2
2.8 Complementing Boolean Expressions
The inverse or complement of any Boolean expression can easily be found by suc-
cessively applying DeMorgan’s laws.
DeMorgan’s laws are easily generalized to n variables:
 (X1+X2+X3+· · ·+Xn)′=X1′X2′X3′ . . . Xn′ (2-25)
 (X1X2X3 . . . Xn)′=X1′+X2′+X3′+· · ·+Xn′ (2-26)
For example, for n =3,
(X1+X2+X3)′=(X1+X2)′X′3=X′1X′2 X′3
Referring to the OR operation as the logical sum and the AND operation as logical product, DeMorgan’s laws can be stated as
The complement of the product is the sum of the complements.
The complement of the sum is the product of the complements.
To form the complement of an expression containing both OR and AND operations, 
DeMorgan’s laws are applied alternately.
Example 1 To find the complement of (A′+B)C′, first apply (2-13) and then (2-12).
[(A′+B)C′]′=(A′+B)′+(C′)′=AB ′+C
 [(AB ′+C)D′+E]′=[(AB ′+C)D′]′E′                       (by (2-12))
                                    =[(AB ′+C)′+D]E′                 (by (2-13))
                                    =[(AB ′)′C′+D]E′                     (by (2-12))
                                    =[(A′+B)C′+D]E′                 (by (2-13))   
(2-27)
Note that in the final expressions, the complement operation is applied only to single variables.Example 2
Boolean Algebra 53
The inverse of F =A′B +AB ′ is
F′=(A′B +AB ′)′=(A′B)′(AB ′)′=(A +B′)(A ′+B)
    =AA′ +AB +B′A′+BB′ =A′B′+AB
We will verify that this result is correct by constructing a truth table for F and F ′:
In the table, note that for every combination of values of A and B  for which 
F=0, F ′=1; and whenever F=1, F ′=0.
The dual of an expression may be found by complementing the entire expression 
and then complementing each individual variable. For example, to find the dual of 
AB′ + C,
(AB ′+C)′=(AB ′)′C′=(A′+B)′C′,   so   (AB ′+C)D=(A +B′)C
Problems
2.1 Prove the following theorems algebraically:
(a) X(X′+Y)=XY (b) X +XY =X
(c) XY +XY ′=X (d) (A +B)(A +B′)=A
2.2 Illustrate the following theorems using circuits of switches:(a) 
X +XY =X (b) X +YZ =(X +Y)(X +Z)
In each case, explain why the circuits are equivalent.
2.3 Simplify each of the following expressions by applying one of the theorems. State 
the theorem used.
(a) X′Y′Z +(X′Y′Z)′ (b) (AB ′+CD)(B′E +CD)
(c) ACF +AC ′F (d) A(C +D′B)+A′
(e) (A′B +C +D)(A′B +D) (f) (A +BC)+(DE +F )(A +BC)′
2.4 For each of the following circuits, find the output and design a simpler circuit having 
the same output. ( Hint: Find the circuit output by first finding the output of each 
gate, going from left to right, and simplifying as you go.)A  B A′B AB′ F=A′B+AB ′ A′B′ AB F′ = A′B′+AB
0  0 0 0 0 1 0 1
0  1 1 0 1 0 0 0
1  0 0 1 1 0 0 0
1  1 0 0 0 0 1 1
54 Unit 2
2.5 Multiply out and simplify to obtain a sum of products:
(a) (A +B)(C +B)(D′+B)(ACD ′+E)
(b) (A′+B +C′)(A′+C′+D)(B′+D ′)
2.6 Factor each of the following expressions to obtain a product of sums:(a) 
AB +C′D′ (b) WX +WY ′X +ZYX
(c) A′BC +EF +DEF ′ (d) XYZ +W ′Z +XQ ′Z
(e) ACD ′+C′D′+A′C (f) A +BC +DE
(The answer to (f) should be the product of four terms, each a sum of three  variables.)
2.7 Draw a circuit that uses only one AND gate and one OR gate to realize each of the 
following functions:
(a) (A +B +C +D)(A +B +C +E)(A +B +C +F )
(b) WXYZ +VXYZ +UXY Z
2.8 Simplify the following expressions to a minimum sum of products.(a) [
(AB)′+C′D]′ (b) [A +B(C′+D)]′ (c) ((A +B′)C)′(A +B)(C +A)′
2.9 Find F and G and simplify:A
B
A
BBBA
AYEF
DB
C1
(a)
(b)+
+
++++
A
A
TTGPFB
R
T
R
SS(a)
(b)+
+++
+
Boolean Algebra 55
2.10 Illustrate the following equations using circuits of switches:
(a) XY+XY ′=X (b) (X+Y′)Y=XY
(c) X+X′ZY =X+YZ (d) (A+B)C+(A+B)C′=A+B
(e) (X+Y)(X+Z)=X+YZ (f) X(X+Y)=X
2.11 Simplify each of the following expressions by applying one of the theorems. State 
the theorem used.
(a) (A′+B′+C)(A′+B′+C)′ (b) AB(C′+D)+B(C′+D)
(c) AB+(C′+D)(AB)′ (d) (A′BF +CD ′)(A′BF +CEG )
(e) [AB ′+(C+D)′+E′F](C+D) (f) A′(B+C)(D′E+F )′+(D′E+F )
2.12 Simplify each of the following expressions by applying one of the theorems. State 
the theorem used.
(a) (X+Y′Z)+(X+Y′Z)′
(b) [W +X′(Y+Z)][W ′+X′(Y+Z)]
(c) (V′W +UX)′(UX +Y+Z+V′W)
(d) (UV ′+W ′X)(UV ′+W ′X+Y′Z)
(e) (W ′+X)(Y+Z′)+(W ′+X)′(Y+Z′)
(f) (V′+U+W)[(W +X)+Y+UZ ′]+[(W +X)+UZ ′+Y]
2.13 For each of the following circuits, find the output and design a simpler circuit that 
has the same output. (Hint: Find the circuit output by first finding the output of each gate, going from left to right, and simplifying as you go.)
(a) 
(b) 
(c) A
BF1
+++
F2A
B+
A
B
CD
A
BF3
+++
56 Unit 2
(d) 
2.14 Draw a circuit that uses only one AND gate and one OR gate to realize each of the 
following functions:
(a) ABCF +ACEF +ACD F
(b) (V+W +Y+Z)(U+W +Y+Z)(W +X+Y+Z)
2.15 Use only DeMorgan’s relationships and Involution to find the complements of the 
following functions:
(a) f(A, B, C, D )=[A+(BCD )′][(AD)′+B(C′+A)]
(b) f(A, B, C, D )=AB ′C+(A′+B+D)(ABD ′+B′)
2.16 Using just the definition of the dual of a Boolean algebra expression, find the duals 
of the following expressions:
(a) f(A, B, C, D )=[A+(BCD )′][(AD)′+B(C′+A)]
(b) f(A, B, C, D )=AB ′C+(A′+B+D)(ABD ′+B′)
2.17 For the following switching circuit, find the logic function expression describing the cir-
cuit by the three methods indicated, simplify each expression, and show they are equal.
(a)  subdividing it into series and parallel connections of subcircuits until single 
switches are obtained
(b)  finding all paths through the circuit (sometimes called tie sets), forming an AND 
term for each path and ORing the AND terms together
(c)  finding all ways of breaking all paths through the circuit (sometimes called cut 
sets), forming an OR term for each cut set and ANDing the OR terms together.
2.18 For each of the following Boolean (or switching) algebra expressions, indicate which, 
if any, of the following terms describe the expression: product term, sum-of-products, 
sum term, and product-of-sums. (More than one may apply.)
(a) X′Y (b) XY′+YZ
(c) (X′+Y)(WX +Z) (d) X+Z
(e) (X′+Y)(W +Z)(X+Y′+Z′)A
BC
DZ
A
BC+
++
B′A′
C
B
A
C′
Boolean Algebra 57
2.19 Construct a gate circuit using AND, OR, and NOT gates that corresponds one to one 
with the following switching algebra expression. Assume that inputs are available 
only in uncomplemented form. (Do not change the expression.)
(WX′ +Y)[(W +Z)′+(XYZ ′)]
2.20 For the following switch circuit:(a)  derive the switching algebra expression that corresponds one to one with the 
switch circuit.
(b)  derive an equivalent switch circuit with a structure consisting of a parallel 
 connection of groups of switches connected in series. (Use 9 switches.)
(c)  derive an equivalent switch circuit with a structure consisting of a series 
 connection of groups of switches connected in parallel. (Use 6 switches.)
2.21 In the following circuit, F =
(A′+B)C. Give a truth table for G so that H is as speci-
fied in its truth table. If G can be either 0 or 1 for some input combination, leave its 
value unspecified.
2.22 Factor each of the following expressions to obtain a product of sums:(a) 
A′B′+A′CD +A′DE ′ (b) H′I′+JK
(c) A′BC +A′B′C+CD ′ (d) A′B′+(CD ′+E)
(e) A′B′C+B′CD ′+EF ′ (f) WX′Y+W ′X′+W ′Y′
2.23 Factor each of the following expressions to obtain a product of sums:(a) W +U′Y
V (b) TW +UY ′+V
(c) A′B′C+B′CD ′+B′E′ (d) ABC +ADE ′+ABF ′
2.24 Simplify the following expressions to a minimum sum of products. Only individual 
variables should be complemented.
(a) [(XY ′)′+(X′+Y)′Z] (b) (X+(Y′(Z+W)′)′)′
(c) [(A′+B′)′+(A′B′C)′ + C′D]′ (d) (A+B)CD +(A+B)′B′A′
C
A C′D
+A F
GB 
C 
A 
B 
C H A B C H
0000
0011010101111000101111001111
58 Unit 2
2.25 For each of the following functions find a sum-of-products expression for F ′.
(a) F(P, Q, R, S )=(R′+PQ)S
(b) F(W, X, Y, Z )=X+YZ(W +X′)
(c) F(A, B, C, D )=A′+B′+ACD
2.26 Find F, G, and H, and simplify:
(a) A
BBC F ++
(b) A
B
CG
+
(c) W
X
Y
ZH
+
2.27 Draw a circuit that uses two OR gates and two AND gates to realize the following 
function:
F=(V+W +X)(V+X+Y)(V+Z)
2.28 Draw a circuit to realize the function:
F=ABC +A′BC +AB ′C+ABC ′
(a)  using one OR gate and three AND gates. The AND gates should have two 
inputs.
(b) using two OR gates and two AND gates. All of the gates should have two inputs.
Boolean Algebra 59
2.29 Prove the following equations using truth tables:
(a) (X+Y)(X′+Z)=XZ +X′Y
(b) (X+Y)(Y+Z)(X′+Z)=(X+Y)(X′+Z)
(c) XY+YZ +X′Z=XY +X′Z
(d) (A+C)(AB +C′)=AB +AC ′
(e) W ′XY +WZ =(W ′+Z)(W +XY)
(Note: Parts (a), (b), and (c) are theorems that will be introduced in Unit 3.)
2.30 Show that the following two gate circuits realize the same function.
XY+X
Zf+ F
f+
f+
f+Y
Z
G(a)
(b)
60Boolean Algebra (Continued)UNIT
3
Objectives
When you complete this unit, you should know from memory and be able to use 
any of the laws and theorems of Boolean algebra listed in Unit 2. Specifically, you should be able to
1. Apply these laws and theorems to the manipulation of algebraic expressions 
including:
a. Simplifying an expression
b. Finding the complement of an expression
c. Multiplying out and factoring an expression
2. Prove any of the theorems using a truth table or give an algebraic proof.
3. Define the exclusive-OR and equivalence operations. State, prove, and use the basic theorems that concern these operations.
4. Use the consensus theorem to delete terms from and add terms to a switching algebra expression.
5. Given an equation, prove algebraically that it is valid or show that it is not valid.
Boolean Algebra (Continued)  61
Study Guide
1. Study Section 3.1, Multiplying Out and Factoring Expressions.
(a) List three laws or theorems which are useful when multiplying out or fac-
toring expressions.
(b) Use Equation (3-3) to factor each of the following:
ab ′c+bd=
abc+(ab)′d= 
(c) In the following example, first group the terms so that (3-2) can be applied 
two times.
 F1=(x+y′+z)(w′+x′+y)(w+x+y′)(w′+y+z′)
After applying (3-2), apply (3-3) and then finish multiplying out by using (3-1).
If we did not use (3-2) and (3-3) and used only (3-1) on the original F1 
expression, we would generate many more terms:
 F1=(w′x+w′y′+w′z+xx′+x′y′+x′z+xy+yy′+yz)
 (ww′ +w′x+w′y′+wy+xy+yy′+wz ′+xz′+y′z′)
 =(w′x + w′ xy′ + w′ xz + · · · + yzy′ z′)
49 terms in all
This is obviously a very inefficient way to proceed! The moral to this story 
is to first group the terms and apply (3-2) and (3-3) where possible.
(d) Work Programmed Exercise 3.1. Then work Problem 3.6, being careful not 
to introduce any unnecessary terms in the process.
(e) In Unit 2 you learned how to factor a Boolean expression, using the two 
distributive laws. In addition, this unit introduced use of the theorem
 XY+X′Z=(X+Z)(X′+Y)
in the factoring process. Careful choice of the order in which these laws 
and theorems are applied may cut down the amount of work required to factor an expression. When factoring, it is best to apply Equation (3-1) first, 
62 Unit 3
using as X the variable or variables which appear most frequently. Then 
Equations (3-2) and (3-3) can be applied in either order, depending on 
 circumstances.
(f  ) Work Programmed Exercise 3.2. Then work Problem 3.7 .
2. Checking your answers:
A good way to partially check your answers for correctness is to substitute 0’s or 
1’s for some of the variables. For example, if we substitute A=1 in the first and 
last expression in Equation (3-5), we get
1·C+0·BD ′+0·BE + 0 ·C′DE = (1+B+C′)(1+B+D)
 ·(1+B+E)(1+D′+E )(0+C )
 C=1·1·1·1·C  ✓
Similarly, substituting A=0, B =0, we get
0+0+0+C′DE = (0+C′)(0+D)(0+E )(D′+E )(1+C)
 =C′DE   ✓
Verify that the result is also correct when A=0 and B =1.
3. The method which you use to get your answer is very important in this unit. If it 
takes you two pages of algebra and one hour of time to work a problem that can 
be solved in 10 minutes with three lines of work, you have not learned the mate-rial in this unit! Even if you get the correct answer, your work is not satisfactory if you worked the problem by an excessively long and time-consuming method. It is important that you learn to solve simple problems in a simple  manner—otherwise, 
when you are asked to solve a complex problem, you will get bogged down and never get the answer. When you are given a problem to solve, do not just plunge in, but first ask yourself, “What is the easiest way to work this problem?” For example, when you are asked to multiply out an expression, do not just multiply it out by brute force, term by term. Instead, ask yourself, “How can I group the terms and which theorems should I apply first in order to reduce the amount of work?” (See Study Guide Part 1.) After you have worked out Problems 3.6 and 3.7 , compare your solutions with those in the solution book. If your solution required substan-tially more work than the one in the solution book, rework the problem and try to get the answer in a more straightforward manner.
Boolean Algebra (Continued)  63
4. Study Section 3.2, Exclusive-OR and Equivalence Operations.
(a) Prove Theorems (3-8) through (3-13). You should be able to prove these 
both algebraically and by using a truth table.
(b) Show that (xy′+x′y)′=xy+x′y′. Memorize this result.
(c) Prove Theorem (3-15).
(d) Show that (x≡0)=x′, (x≡x)=1, and (x≡y)′=(x≡y′).
(e) Express (x≡y)′ in terms of exclusive OR.
(f  ) Work Problems 3.8 and 3.9.
5. Study Section 3.3, The Consensus Theorem. The consensus theorem is an impor-
tant method for simplifying switching functions.
(a) In each of the following expressions, find the consensus term and 
 eliminate it:
abc ′d+a′be+bc ′de
(a′+b+c)(a+d)(b+c+d)
ab ′c+a′bd+bcd ′+a′bc
(b) Eliminate two terms from the following expression by applying the con-
sensus theorem:
A′B′C+BC ′D′+A′CD+AB ′D′+BCD +AC ′D′
(Hint: First, compare the first term with each of the remaining terms to see if a consensus exists, then compare the second term with each of the remaining terms, etc.)
64 Unit 3
(c) Study the example given in Equations (3-22) and (3-23) carefully. Now let 
us start with the four-term form of the expression (Equation 3-22):
 A′C′D+A′BD+ABC +ACD ′
Can this be reduced directly to three terms by the application of the consen-
sus theorem? Before we can reduce this expression, we must add another term. Which term can be added by applying the consensus theorem?
Add this term, and then reduce the expression to three terms. After this 
reduction, can the term which was added be removed? Why not?
(d) Eliminate two terms from the following expression by applying the dual 
consensus theorem:
 
(a′+c′+d)(a′+b+c)(a+b+d)(a′+b+d)(b+c′+d)
Use brackets to indicate how you formed the consensus terms. (Hint: First, find the consensus of the first two terms and eliminate it.)
(e) Derive Theorem (3-3) by using the consensus theorem.
 (f) Work Programmed Exercise 3.3. Then work Problem 3.10.
6. Study Section 3.4, Algebraic Simplification of Switching Expressions.
(a) What theorems are used for:
Combining terms?
Eliminating terms?Eliminating literals?Adding redundant terms?Factoring or multiplying out?
(b) Note that in the example of Equation (3-27), the redundant term 
WZ′ was 
added and then was eliminated later after it had been used to eliminate 
another term. Why was it possible to eliminate WZ′ in this example?
Boolean Algebra (Continued)  65
If a term has been added by the consensus theorem, it may not always be 
possible to eliminate the term later by the consensus theorem. Why?
(c) You will need considerable practice to develop skill in simplifying switch-
ing expressions. Work through Programmed Exercises 3.4 and 3.5.
(d) Work Problem 3.11.
(e) When simplifying an expression using Boolean algebra, two frequently 
asked questions are
(1) Where do I begin?(2) How do I know when I am finished?
In answer to (1), it is generally best to try simple techniques such as combining terms or eliminating terms and literals before trying more complicated things such as using the consensus theorem or adding redundant terms.  Question (2) is gener-ally difficult to answer because it may be impossible to simplify some expressions without first adding redundant terms. We will usually tell you how many terms to expect in the minimum solution so that you will not have to waste time trying to simplify an expression which is already minimized. In Units 5 and 6, you will learn systematic techniques which will guarantee finding the  minimum solution.
7. Study Section 3.5, Proving Validity of an Equation.
(a) When attempting to prove that an equation is valid, is it permissible to add 
the same expression to both sides? Explain.
(b) Work Problem 3.12.
(c) Show that (3-33) and (3-34) are true by considering both 
x=0 and x=1.
(d) Given that a′(b+d′)=a′(b+e′), the following “proof” shows that d =e:
 a′(b+d′)=a′(b+e′)
 a+b′d=a+b′e
 b′d=b′e
 d=e
State two things that are wrong with the “proof.” Give a set of values for a,
 b, d, and e  that demonstrates that the result is incorrect.
8. Reread the objectives of this unit. When you take the readiness test, you will be expected to know from memory the laws and theorems listed in Unit 2. Where appropriate, you should know them “forward and backward”; that is, given either side of the equation, you should be able to supply the other. Test yourself to see if you can do this. When you are satisfied that you can meet the objectives, take the readiness test.
66In this unit we continue our study of Boolean algebra to learn additional methods 
for manipulating Boolean expressions. We introduce another theorem for multiplying out and factoring that facilitates conversion between sum-of-products and product-of-sums expressions. These algebraic manipulations allow us to realize a switching func-tion in a variety of forms. The exclusive-OR and equivalence operations are introduced along with examples of their use. The consensus theorem provides a useful method for simplifying an expression. Then methods for algebraic simplification are reviewed and summarized. The unit concludes with methods for proving the validity of an equation.
3.1 Multiplying Out and Factoring Expressions
Given an expression in product-of-sums form, the corresponding sum-of-products expression can be obtained by multiplying out, using the two distributive laws:
 
X(Y+Z)=XY+XZ (3-1)
 (X+Y)(X+Z)=X+YZ (3-2)
In addition, the following theorem is very useful for factoring and multiplying out:
            $'&
(X+Y )(X ′+Z)=XZ+X′Y
  ('''''* (3-3)
Note that the variable that is paired with X on one side of the equation is paired 
with X′ on the other side, and vice versa. In switching algebra, (3-3) can be proved by 
showing that both sides of the equation are the same for X=0 and also for X=1.
If X=0, (3-3) reduces to Y (1+Z )=0+1·Y or Y =Y.
If X=1, (3-3) reduces to (1+Y )Z=Z+0·Y or Z =Z.
An algebraic proof valid in any Boolean algebra is
(X+Y )(X ′+Z)=XX′ +XZ+X′Y+YZ
=0+XZ+X′Y+YZ =XZ+X′Y     (using   consensus)
The following example illustrates the use of Theorem (3-3) for f actoring:
     $''&
AB+A′C=(A+C)(A ′+B)
  ('''*Boolean Algebra (Continued)
Boolean Algebra (Continued)  67
AC+A′BD ′+A′BE+A′C′DE
=AC +A′(BD ′+BE+C′DE)
XZ   X′        Y
=(A+BD ′+BE+C′DE)(A′+C)
=[A+C′DE+B(D′+E)](A′+C)
X              Y       ZNote that the theorem can be applied when we have two terms, one which contains 
a variable and another which contains its complement.
Theorem (3-3) is very useful for multiplying out expressions. In the following 
example, we can apply (3-3) because one factor contains the variable Q, and the 
other factor contains Q ′.
           
(Q+AB ′)(C ′D+Q′)=QC ′D+Q′AB ′
    
If we simply multiplied out using the distributive law, we would get four terms 
instead of two:
(Q+AB ′)(C′D+Q′)=QC ′D+QQ′ +AB ′C′D+AB ′Q′
Because the term AB′C′D is difficult to eliminate, it is much better to use (3-3) 
instead of the distributive law.
In general, when we multiply out an expression, we should use (3-3) along with 
(3-1) and (3-2). To avoid generating unnecessary terms when multiplying out, (3-2) and (3-3) should generally be applied before (3-1), and terms should be grouped to expedite their application.
Example (A+B+C′)(A+B+D)(A+B+E)(A+D′+E)(A′+C)
=(A+B+C′D)(A+B+E)[AC+A′(D′+E)]
=(A+B+C′DE)(AC+A′D′+A′E)
=AC+ABC +A′BD ′+A′BE+A′C′DE (3-4)
What theorem was used to eliminate ABC? (Hint: let X=AC.)
In this example, if the ordinary distributive law (3-1) had been used to multiply 
out the expression by brute force, 162 terms would have been generated, and 158 of these terms would then have to be eliminated.
The same theorems that are useful for multiplying out expressions are useful for 
factoring. By repeatedly applying (3-1), (3-2), and (3-3), any expression can be con-verted to a product-of-sums form.
Example of 
 Factoring
a
a
aa
a
68 Unit 3
=(A+B+C′DE)(A+C′DE+D′+E)(A′+C)
=(A+B+C′)(A+B+D)(A+B+E)(A+D′+E)(A′+C) (3-5)
This is the same expression we started with in (3-4).
3.2 Exclusive-OR and Equivalence Operations
The exclusive- OR operation (⊕) is defined as follows:
0 ⊕ 0=0   0 ⊕ 1=1
1 ⊕ 0=1   1 ⊕ 1=0
The truth table for X ⊕ Y is
From this table, we can see that X ⊕ Y=1 iff X=1 or Y =1, but not both. The 
 ordinary OR operation, which we have previously defined, is sometimes called inclu-
sive OR because X+Y=1 iff X=1 or Y =1, or both.
Exclusive OR can be expressed in terms of AND and OR. Because X ⊕ Y=1 iff 
X is 0 and Y is 1 or X is 1 and Y is 0, we can write
 X ⊕ Y=X′Y+XY ′ (3-6)
The first term in (3-6) is 1 if X=0 and Y=1; the second term is 1 if X=1 and Y =0. 
Alternatively, we can derive Equation (3-6) by observing that X ⊕ Y=1 iff X=1 
or Y =1 and X and Y are not both 1. Thus,
 X ⊕ Y=(X+Y )(XY  )′=(X+Y )(X′+Y′)=X′Y+XY ′ (3-7)
In (3-7), note that (XY)′=1 if X and Y are not both 1.
We will use the following symbol for an exclusive-OR gate:X  Y X ⊕ Y
0   0 0
0   1 11   0 11   1 0
⊕X
YX ⊕ Y
Boolean Algebra (Continued)  69
The following theorems apply to exclusive OR:
X ⊕ 0=X (3-8)
X ⊕ 1=X′ (3-9)
X ⊕ X=0 (3-10)
X ⊕ X ′=1 (3-11)
X ⊕ Y=Y ⊕ X (commutative   law) (3-12)
(X ⊕ Y) ⊕ Z=X ⊕ (Y ⊕ Z)=X ⊕ Y ⊕ Z (associative   law) (3-13)
X(Y ⊕ Z)=XY ⊕ XZ (distributive   law) (3-14)
(X ⊕ Y)′=X ⊕ Y ′=X′ ⊕ Y=XY+X′Y′ (3-15)
Any of these theorems can be proved by using a truth table or by replacing X ⊕ Y 
with one of the equivalent expressions from Equation (3-7). Proof of the distributive 
law follows:
XY ⊕ XZ =XY(XZ)′+(XY  )′XZ=XY(X′+Z′)+(X′+Y′)XZ
=XYZ ′+XY ′Z
=X(YZ ′+Y′Z)=X(Y ⊕ Z  )
The equivalence operation (≡) is defined by
 (0≡0)=1  ( 0 ≡1)=0
(1≡0)=0    (1≡1)=1 (3-16)
The truth table for X≡Y is
From the definition of equivalence, we see that (X≡Y)=1 iff X=Y. Because 
(X≡Y)=1 iff X=Y=1 or X=Y=0, we can write
 (X≡Y)=XY+X′Y′ (3-17)
Equivalence is the complement of exclusive OR:
 (X ⊕ Y  )′=(X′Y+XY ′)′=(X+Y′)(X ′+Y )
=XY+X′Y′=(X≡Y ) (3-18)
Just as for exclusive OR, equivalence is commutative and associative.
We will use the following symbol for an equivalence gate:X YX≡Y
0  0  1
0  1  01  0  0
1  1  1
X ≡ YX
Y
70 Unit 3
Because equivalence is the complement of exclusive OR, an alternate symbol for the 
equivalence gate is an exclusive-OR gate with a complemented output:
The equivalence gate is also called an exclusive-NOR gate.
In order to simplify an expression which contains AND and OR as well as 
 exclusive OR and equivalence, it is usually desirable to first apply (3-6) and (3-17) 
to eliminate the ⊕ and ≡operations. As an example, we will simplify
F=(A′B≡C)+(B ⊕ AC ′)
By (3-6) and (3-17),
F=[(A′B)C+(A′B)′C′]+[B′(AC ′)+B(AC ′)′]
=A′BC+(A+B′)C′+AB ′C′+B(A′+C)
=B(A′C+A′+C)+C′(A+B′+AB ′)=B(A′+C)+C′(A+B′)
When manipulating an expression that contains several exclusive-OR or equiva-
lence operations, it is useful to note that
(XY ′+X′Y)′=XY+X′Y′                             (3-19)
For example,
A′ ⊕ B ⊕ C=[A′B′+(A′)′B] ⊕ C
=(A′B′+AB)C′+(A′B′+AB ′)C                   (by  (3-6))
=(A′B′+AB)C′+(A′B+AB ′)C                 (by  (3-19))
=A′B′C′+ABC ′+A′BC+AB ′C
3.3 The Consensus Theorem
The consensus theorem is very useful in simplifying Boolean expressions. Given an expression of the form 
XY+X′Z+YZ, the term Y Z is redundant and can be 
eliminated to form the equivalent expression XY+X′Z.
The term that was eliminated is referred to as the consensus term. Given a pair 
of terms for which a variable appears in one term and the complement of that vari-able in another, the consensus term is formed by multiplying the two original terms together, leaving out the selected variable and its complement. For example, the consensus of ab  and a′c is bc; the consensus of abd and b′de ′ is 
(ad)(de ′)=ade ′. The 
consensus of terms ab ′d and a ′bd′ is 0.
The consensus theorem, given in Equation (2-18), is
XY+X′Z+YZ=XY+X′Z                                 (3-20)⊕X
Y(X ⊕ Y)′ = (X ≡ Y )
Boolean Algebra (Continued)  71
The consensus theorem can be used to eliminate redundant terms from Boolean 
expressions. For example, in the following expression, b′c is the consensus of a′b′ and 
ac, and ab is the consensus of ac and bc ′, so both consensus terms can be  eliminated:
a′b′+ac+bc ′+b′c+ab=a′b′+ac+bc ′
The brackets indicate how the consensus terms are formed.
The dual form of the consensus theorem, given in Equation (2-18D), is
(X+Y)(X′+Z)(Y+Z)=(X+Y)(X′+Z)                      (3-21)
Note again that the key to recognizing the consensus term is to first find a pair of 
terms, one of which contains a variable and the other its complement. In this case, the consensus is formed by adding this pair of terms together leaving out the selected variable and its complement. In the following expression, 
(a+b+d′) is a consensus 
term and can be eliminated by using the dual consensus theorem:
(a+b+c′)(a+b+d′)(b+c+d′)=(a+b+c′)(b+c+d′)
The final result obtained by application of the consensus theorem may depend 
on the order in which terms are eliminated.
A′C′D+A′BD+BCD +ABC +ACD ′                      (3-22)↓
Example
First, we eliminate B CD as shown. (Why can it be eliminated?)
Now that B CD has been eliminated, it is no longer there, and it cannot be used to 
eliminate another term. Checking all pairs of terms shows that no additional terms can be eliminated by the consensus theorem.
Now we start over again:
A′C′D+A′BD+BCD +ABC +ACD ′                      (3-23)
This time, we do not eliminate BCD; instead we eliminate two other terms by the 
consensus theorem. After doing this, observe that BCD can no longer be eliminated. 
Note that the expression reduces to four terms if BCD is eliminated first, but that it 
can be reduced to three terms if B CD is not eliminated.
Sometimes it is impossible to directly reduce an expression to a minimum number 
of terms by simply eliminating terms. It may be necessary to first add a term using the consensus theorem and then use the added term to eliminate other terms. For 
example, consider the expression
F=ABCD +B′CDE +A′B′+BCE′
If we compare every pair of terms to see if a consensus term can be formed, we find that the only consensus terms are 
ACDE (from ABCD and B′CDE) and A′CE′ 
72 Unit 3
(from A′B′ and B CE′). Because neither of these consensus terms appears in the 
original expression, we cannot directly eliminate any terms using the consensus 
 theorem. However, if we first add the consensus term ACDE to F, we get
F=ABCD +B′CDE +A′B′+BCE′ +ACD E
Then, we can eliminate ABCD and B ′CDE using the consensus theorem, and F 
reduces to
F=A′B′+BCE′ +ACD E
The term ACDE is no longer redundant and cannot be eliminated from the final 
expression.
3.4 Algebraic Simplification of  
Switching Expressions
In this section we review and summarize methods for simplifying switching expres-
sions, using the laws and theorems of Boolean algebra. This is important because simplifying an expression reduces the cost of realizing the expression using gates. Later, we will learn graphical methods for simplifying switching functions, but we will learn algebraic methods first. In addition to multiplying out and factoring, three basic ways of simplifying switching functions are combining terms, eliminating terms, and eliminating literals.
1. Combining terms. Use the theorem 
XY+XY ′=X to combine two terms. For 
example,
abc ′d′+abcd ′=abd ′ [X=abd ′, Y=c] (3-24)
When combining terms by this theorem, the two terms to be combined should 
 contain exactly the same variables, and exactly one of the variables should appear complemented in one term and not in the other. Because 
X+X=X, a given term 
may be duplicated and combined with two or more other terms. For example,
ab ′c+abc+a′bc=ab ′c+abc+abc+a′bc=ac+bc
The theorem still can be used, of course, when X and Y are replaced with more com-
plicated expressions. For example,
(a+bc)(d+e′)+a′(b′+c′)(d+e′)=d+e′
[X=d+e′, Y=a+bc, Y′=a′(b′+c′)]
Boolean Algebra (Continued)  73
2. Eliminating terms. Use the theorem X+XY=X to eliminate redundant terms 
if possible; then try to apply the consensus theorem (XY+X′Z+YZ=XY +
X′Z) to eliminate any consensus terms. For example,
               a ′b+a′bc=a′b [X=a′b]
a′bc ′+bcd+a′bd=a′bc ′+bcd [X=c, Y=bd,  Z=a′b] (3-25)
3. Eliminating literals. Use the theorem X+X′Y=X+Y to eliminate redundant 
literals. Simple factoring may be necessary before the theorem is applied.
Example A′B+A′B′C′D′+ABCD ′=A′(B+B′C′D′)+ABCD ′
=A′(B+C′D′)+ABCD ′
=B(A′+ACD ′)+A′C′D′
=B(A′+CD ′)+A′C′D′
=A′B+BCD ′+A′C′D′          (3-26)
The expression obtained after applying steps 1, 2, and 3 will not necessarily have 
a minimum number of terms or a minimum number of literals. If it does not and no 
further simplification can be made using steps 1, 2, and 3, the deliberate introduction of redundant terms may be necessary before further simplification can be made.
4. Adding redundant terms. Redundant terms can be introduced in several ways 
such as adding 
xx′, multiplying by (x+x′), adding yz to xy+x′z, or adding xy 
to x. When possible, the added terms should be chosen so that they will combine 
with or eliminate other terms.
WX +XY+X′Z′+WY ′Z′  (add WZ ′ by consensus theorem)
= WX +XY+X′Z′+WY ′Z′+WZ ′ (eliminate WY ′Z′)
= WX +XY+X′Z′+WZ ′  (eliminate  WZ ′)
= WX +XY+X′Z′    (3-27)
The following comprehensive example illustrates the use of all four methods:
A′B′C′D′+A′BC′D′+A′BD+ A ′BC′D +ABCD +ACD ′+B′CD ′
          ➀A′C′D′                                ➁
=A′C′D′+BD(A′+AC)+ACD ′+B′CD ′
                                     ➂
=A′C′D′+A′BD+BCD +ACD ′+B′CD ′
                                          +ABC➃ Example
Example
74 Unit 3
                                                                     consensus ACD ′
=A′C′D′+A′BD+BCD  +ACD ′+B′CD ′+ABC
                                             consensus BCD
=A′C′D′+A′BD+B′CD ′+ABC  (3-28)
What theorems were used in steps 1, 2, 3, and 4?
If the simplified expression is to be left in a product-of-sums form instead of a 
sum-of-products form, the duals of the preceding theorems should be applied.
Example
 (A′+B′+C′)(A ′+B′+C)(B ′+C)(A+C)(A+B+C)
          ➀(A′+B′)                                                     ➁
=(A′+B′)(B ′+C)(A+C)=(A′+B′)(A+C)
                           ➂    (3-29)
What theorems were used in steps 1, 2, and 3?
In general, there is no easy way of determining when a Boolean expression has a 
minimum number of terms or a minimum number of literals. Systematic methods for 
finding minimum sum-of-products and minimum product-of-sums expressions will be discussed in Units 5 and 6.
3.5 Proving Validity of an Equation
Often we will need to determine if an equation is valid for all combinations of values of the variables. Several methods can be used to determine if an equation is valid:
1. Construct a truth table and evaluate both sides of the equation for all combina-
tions of values of the variables. (This method is rather tedious if the number of variables is large, and it certainly is not very elegant.)
2. Manipulate one side of the equation by applying various theorems until it is identical with the other side.
3. Reduce both sides of the equation independently to the same expression.
4. It is permissible to perform the same operation on both sides of the equation provided that the operation is reversible. For example, it is all right to com-plement both sides of the equation, but it is not permissible to multiply both sides of the equation by the same expression. (Multiplication is not reversible because division is not defined for Boolean algebra.) Similarly, it is not permis-sible to add the same term to both sides of the equation because subtraction is not defined for Boolean algebra.
Boolean Algebra (Continued)  75
To prove that an equation is not valid, it is sufficient to show one combination of 
values of the variables for which the two sides of the equation have different values. 
When using method 2 or 3 above to prove that an equation is valid, a useful strat-egy is to
1. First reduce both sides to a sum of products (or a product of sums).
2. Compare the two sides of the equation to see how they differ.
3. Then try to add terms to one side of the equation that are present on the other side.
4. Finally try to eliminate terms from one side that are not present on the other.
Whatever method is used, frequently compare both sides of the equation and let the 
difference between them serve as a guide for what steps to take next.
Show that
A′BD ′+BCD +ABC ′+AB ′D=BC′D′+AD +A′BC
Starting with the left side, we first add consensus terms, then combine terms, and finally eliminate terms by the consensus theorem.
A′BD ′+BCD +ABC ′+AB ′D
=A′BD ′+BCD +ABC ′+AB ′D+BC′D+A′BC+ABD
(add consensus of A′BD ′ and ABC ′)
      (add consensus of A ′BD ′ and BCD )
            (add consensus of BCD  and ABC ′)
=AD +A′BD ′+BCD +ABC ′+BC′D′+A′BC=BC′D′+AD +A′BC
                                                              (eliminate consensus of BC′D′ and AD )
                                                      (eliminate consensus of AD and A ′BC)
                                     (eliminate consensus of BC ′D′ and A ′BC)             (3-30)
Show that the following equation is valid:
A′BC′D+(A′+BC)(A +C′D′)+BC′D+A′BC′
                    =ABCD +A′C′D′+ABD +ABCD ′+BC′D
First, we will reduce the left side:
A′BC′D+(A′+BC)(A +C′D′)+BC′D+A′BC′
                                                                                      (eliminate A′BC′D using absorption)
=(A′+BC)(A +C′D′)+BC′D+A′BC′
                                                                                      (multiply out using (3-3))
=ABC +A′C′D′+BC′D+A′BC′
                                                                                      (eliminate A′BC′ by consensus)
=ABC +A′C′D′+BC′DExample 2Example 1
76 Unit 3
Now we will reduce the right side:
                                                      =ABCD +A′C′D′+ABD +ABCD ′+BC′D
(combine ABCD  and ABCD ′)
                                                      =ABC +A′C′D′+ABD +BC′D
(eliminate ABD  by consensus)
                                                      =ABC +A′C′D′+BC′D
Because both sides of the original equation were independently reduced to the same 
expression, the original equation is valid.
As we have previously observed, some of the theorems of Boolean algebra are 
not true for ordinary algebra. Similarly, some of the theorems of ordinary algebra are not true for Boolean algebra. Consider, for example, the cancellation law for 
ordinary algebra:
 If x+
y=x+z,   then   y=z (3-31)
The cancellation law is not true for Boolean algebra. We will demonstrate 
this by  constructing a counterexample in which x+y=x+z but y=z. Let 
x=1, y=0, z=1. Then,
1+0=1+1 but 0 ≠1
In ordinary algebra, the cancellation law for multiplication is
 If   xy=xz,  then  y=z (3-32)
This law is valid provided x≠0.
In Boolean algebra, the cancellation law for multiplication is also not valid when 
x=0. (Let x=0, y=0, z=1; then 0 ·0=0·1, but 0 ≠1). Because x=0 about 
half of the time in switching algebra, the cancellation law for multiplication cannot 
be used.
Even though Statements (3-31) and (3-32) are generally false for Boolean alge-
bra, the converses
 If   y=z,    then    x+y=x+z (3-33)
 If   y=z,    then        xy=xz (3-34)
are true. Thus, we see that although adding the same term to both sides of a 
Boolean equation leads to a valid equation, the reverse operation of canceling or subtracting a term from both sides generally does not lead to a valid equation. Similarly, multiplying both sides of a Boolean equation by the same term leads to a valid equation, but not conversely. When we are attempting to prove that an equation is valid, it is not permissible to add the same expression to both sides of the equation or to multiply both sides by the same expression, because these operations are not reversible.
Boolean Algebra (Continued)  77
Programmed Exercise 3.1
Cover the answers to this exercise with a sheet of paper and slide it down as you 
check your answers. Write your answer in the space provided before looking at the correct answer.
The following expression is to be multiplied out to form a sum of products:
(A+B+C′)(A′+B′+D)(A′+C+D′)(A+C′+D)
First, find a pair of sum terms which have two literals in common and apply the sec-ond distributive law. Also, apply the same law to the other pair of terms.
Answer (A+C′+BD)[A′+(B′+D)(C+D′)]
(Note: This answer was obtained by using (X+Y)(X+Z)=X+YZ.)
Next, find a pair of sum terms which have a variable in one and its complement in the other. Use the appropriate theorem to multiply these sum terms together without introducing any redundant terms. Apply the same theorem a second time.
Answer (A+C′+BD)(A′+B′D′+CD)=A(B′D′+CD)+A′(C′+BD) or 
A(B′+D)(C+D′)+A′(C′+BD)=A(B′D′+CD)+A′(C′+BD)
(Note: This answer was obtained using (X+Y)(X′+Z)=XZ+X′Y.)
Complete the problem by multiplying out using the ordinary distributive law.
Final Answer AB′D′+ACD +A′C′+A′BD
Programmed Exercise 3.2
Cover the answers to this exercise with a sheet of paper and slide it down as you check your answers. Write your answer in the space provided before looking at the correct answer.
The following expression is to be factored to form a product of sums:
WXY ′+W ′X′Z+WY ′Z+W ′YZ′
First, factor as far as you can using the ordinary distributive law.
78 Unit 3
Answer WY ′(X+Z)+W ′(X′Z+YZ′)
Next, factor further by using a theorem which involves a variable and its comple-
ment. Apply this theorem twice.
Answer (W+X′Z+YZ′)[W ′+Y′(X+Z)]
=[W+(X′+Z′)(Y+Z)][W ′+Y′(X+Z)]
or
 WY ′(X+Z) +  W ′(X′+Z′)(Y+Z)
=[W+(X′+Z′)(Y+Z)][W ′+Y′(X+Z)]
[Note: This answer was obtained by using AB+A′C=(A+C)(A′+B).]
Now, complete the factoring by using the second distributive law.
Final answer (W+X′+Z′)(W+Y+Z)(W ′+Y′)(W ′+X+Z)
Programmed Exercise 3.3
Cover the answers to this exercise with a sheet of paper and slide it down as you check your answers. Write your answer in the space provided before looking at the correct answer.
The following expression is to be simplified using the consensus theorem:
AC′+AB ′D+A′B′C+A′CD ′+B′C′D′
First, find all of the consensus terms by checking all pairs of terms.
Answer The consensus terms are indicated.
AC′ AB′D
AB′C′A′B′C
A′B′D′A′B′D′
A′CD′
B′CDB′C′D′ + + + +
Boolean Algebra (Continued)  79
Can the original expression be simplified by the direct application of the consensus 
theorem?
Answer No, because none of the consensus terms appears in the original expression.
Now add the consensus term B′CD to the original expression. Compare the added 
term with each of the original terms to see if any consensus exists. Eliminate as many 
of the original terms as you can.
Answer                                      ( AB ′D)
AC ′+AB ′D+A′B′C+A′CD ′+B′C′D′+B′CD
                                                           ( A′B′C)
Now that we have eliminated two terms, can B ′CD also be eliminated? What is the 
final reduced expression?
Answer No, because the terms used to form B ′CD are gone. Final answer is
AC′+A′CD ′+B′C′D′+B′CD
Programmed Exercise 3.4
Keep the answers to this exercise covered with a sheet of paper and slide it down as you check your answers.
Problem: The following expression is to be simplified
ab ′cd ′e+acd+ac
f′gh′+abcd ′e+acde ′+e′h′
State a theorem which can be used to combine a pair of terms and apply it to com-
bine two of the terms in the above expression.
Answer Apply XY+XY ′=X to the terms ab ′cd ′e and abcd ′e, which reduces the  
expression to
acd ′e+acd+acf ′gh′+acde ′+e′h′
80 Unit 3
Now state a theorem (other than the consensus theorem) which can be used to 
 eliminate terms and apply it to eliminate a term in this expression.
Answer Apply X+XY=X to eliminate acde ′. (What term corresponds to X?) The result is
acd ′e+acd+acf′gh′+e′h′
Now state a theorem that can be used to eliminate literals and apply it to eliminate a literal from one of the terms in this expression. (Hint: It may be necessary to fac-tor out some common variables from a pair of terms before the theorem can be applied.)
Answer Use X+X′Y=X+Y to eliminate a literal from acd ′e. To do this, first factor ac out 
of the first two terms: acd ′e+acd=ac(d+d′e). After eliminating d′, the resulting 
expression is
ace+acd+acf′gh′+e′h′
(a) Can any term be eliminated from this expression by the direct application of the 
consensus theorem?
(b) If not, add a redundant term using the consensus theorem, and use this redun-
dant term to eliminate one of the other terms.
(c) Finally, reduce your expression to three terms.
Answer (a) No
(b) Add the consensus of ace  and e ′h′:
ace+acd+acf′gh′+e′h′+ach ′
Now eliminate ac f′gh′ (by X+XY=X)
ace+acd+e′h′+ach ′
(c) Now eliminate ach ′ by the consensus theorem. The final answer is
ace+acd+e′h′
Boolean Algebra (Continued)  81
Programmed Exercise 3.5
Keep the answers to this exercise covered with a sheet of paper and slide it down as 
you check your answers.
Z=(A+C′+F ′+G)(A+C′+F+G)(A+B+C′+D′+G)
(A+C+E+G)(A ′+B+G)(B+C′+F+G)             
This is to be simplified to the form
(X+X+X)(X+X+X)(X+X+X)
where each X represents a literal.
State a theorem which can be used to combine the first two sum terms of Z and 
apply it. (Hint: The two sum terms differ in only one variable.)
Answer (X+Y)(X+Y′)=X
Z=(A+C′+G)(A+B+C′+D′+G)(A+C+E+G)(A ′+B+G)
            ( B+C′+F+G)
Now state a theorem (other than the consensus theorem) which can be used to 
eliminate a sum term and apply it to this expression.
Answer X(X+Y)=X
Z=(A+C′+G)(A+C+E+G)(A ′+B+G)(B+C′+F+G)
Next, eliminate one literal from the second term, leaving the expression other-
wise unchanged. (Hint: This cannot be done by the direct application of one theo-rem; it will be necessary to partially multiply out the first two sum terms before eliminating the literal.)
Answer (A+C′+G)(A+C+E+G)=A+G+C′(C+E)=A+G+C′E
Therefore,
Z=(A+C′+G)(A+E+G)(A′+B+G)(B+C′+F+G)
82 Unit 3
(a) Can any term be eliminated from this expression by the direct application of the 
consensus theorem?
(b) If not, add a redundant sum term using the consensus theorem, and use this 
redundant term to eliminate one of the other terms.
(c) Finally, reduce your expression to a product of three sum terms.
Answer (a) No
(b) Add B+C′+G (consensus of A+C′+G and A′+B+G).
Use X(X+Y)=X, where X=B+C′+G, to eliminate B +C′+F+G.
(c) Now eliminate B+C′+G by consensus. The final answer is
Z=(A+C′+G)(A+E+G)(A′+B+G)
Problems
3.6 In each case, multiply out to obtain a sum of products: (Simplify where possible.)
(a) (W+X′+Z′)(W ′+Y′)(W ′+X+Z′)(W+X′)(W+Y+Z)
(b) (A+B+C+D)(A′+B′+C+D′)(A′+C)(A+D)(B+C+D)
3.7 Factor to obtain a product of sums. (Simplify where possible.)
(a) BCD +C′D′+B′C′D+CD
(b) A′C′D′+ABD ′+A′CD+B′D
3.8 Write an expression for F and simplify.
3.9 Is the following distributive law valid? A ⊕ BC =(A ⊕ B)(A ⊕ C) Prove your answer.
3.10 (a) Reduce to a minimum sum of products (three terms):
(X+W)(Y ⊕ Z)+XW′
(b) Reduce to a minimum sum of products (four terms):
(A ⊕ BC)+BD+ACD
(c) Reduce to a minimum product of sums (three terms):
(A′+C′+D′)(A′+B+C′)(A+B+D)(A+C+D)F
+A
DDBA
⊕
Boolean Algebra (Continued)  83
3.11 Simplify algebraically to a minimum sum of products (five terms):
(A+B′+C+E′)(A+B′+D′+E)(B′+C′+D′+E′)
3.12 Prove algebraically that the following equation is valid:
A′CD ′E+A′B′D′+ABCE +ABD =A′B′D′+ABD +BCD ′E
3.13 Simplify each of the following expressions:
(a) KLMN′ +K′L′MN +MN′
(b) KL ′M ′+MN′ +LM ′N′
(c) (K+L′)(K′+L′+N)(L′+M+N′)
(d) (K′+L+M ′+N)(K′+M ′+N+R)(K′+M ′+N+R′)KM
3.14 Factor to obtain a product of sums:
(a) K′L′M+KM′ N+KLM +LM ′N′(four terms )
(b) KL+K′L′+L′M ′N′+LMN ′       (four terms )
(c) KL+K′L′M+L′M ′N+LM ′N′    (four terms )
(d) K′M ′N+KL ′N′+K′MN′ +LN    (four terms )
(e) WXY +WX′ Y+WYZ +XYZ ′     (three terms )
3.15 Multiply out to obtain a sum of products:
(a) (K′+M ′+N)(K′+M)(L+M ′+N′)(K′+L+M)(M+N)(three terms )
(b) (K′+L′+M ′)(K+M+N′)(K+L)(K′+N)(K′+M+N)
(c) (K′+L′+M)(K+N′)(K′+L+N′)(K+L)(K+M+N′)
(d) (K+L+M)(K′+L′+N′)(K′+L′+M ′)(K+L+N)
(e) (K+L+M)(K+M+N)(K′+L′+M ′)(K′+M ′+N′)
3.16 Eliminate the exclusive OR, and then factor to obtain a minimum product of sums:
(a) (KL ⊕ M)+M ′N′
(b) M ′(K ⊕ N ′)+MN +K′N
3.17 Algebraically prove identities involving the equivalence (exclusive-NOR) operation:
(a) x≡0=x′
(b) x≡1=x
(c) x≡x=1
(d) x≡x′=0
(e) x≡y=y≡x
(f  ) (x≡y)≡z=x≡(y≡z)
(g) (x≡y)′=x′≡y=x≡y′
3.18 Algebraically prove identities involving the exclusive-OR operation:
(a) x ⊕ 0=x
(b) x ⊕ 1=x′
(c) x ⊕ x=0
(d) x ⊕ x′=1
(e) x ⊕ y=y ⊕ x
(f  ) (x ⊕ y) ⊕ z=x ⊕ ( y ⊕ z)
(g) (x ⊕ y)′=x′ ⊕ y=x ⊕ y′
84 Unit 3
3.19 Algebraically prove the following identities:
(a) x+y=x ⊕ y ⊕ xy
(b) x+y=x≡y≡xy
3.20 Algebraically prove or disprove the following distributive identities:
(a) x( y ⊕ z)=xy ⊕ xz
(b) x+( y ⊕ z)=(x+y) ⊕ (x+z)
(c) x(y≡z)=xy≡xz
(d) x+(y≡z)=(x+y)≡(x+z)
3.21 Simplify each of the following expressions using only the consensus theorem (or its 
dual):
(a) BC′D′+ABC ′+AC ′D+AB ′D+A′BD ′ (reduce to three terms )
(b) W ′Y′+WYZ +XY ′Z+WX′ Y (reduce to three terms )
(c) (B+C+D)(A+B+C)(A′+C+D)(B′+C′+D′)
(d) W ′XY+WXZ +WY ′Z+W ′Z′
(e) A′BC′ +BC′D′+A′CD+B′CD+A′BD
(f  ) (A+B+C)(B+C′+D)(A+B+D)(A′+B′+D′)
3.22 Factor Z=ABC +DE+ACF +AD ′+AB ′E′ and simplify it to the form (X+X)
(X+X)(X+X+X+X) (where each X represents a literal). Now express Z as a 
minimum sum of products in the form:
XX+XX+XX+XX
3.23 Repeat Problem 3.22  for F =A′B+AC+BC′D′+BEF +BDF.
3.24 Factor to obtain a product of four terms and then reduce to three terms by applying 
the consensus theorem: X′Y′Z′+XYZ
3.25 Simplify each of the following expressions:
(a) xy+x′yz′+yz
(b) (xy′+z)(x+y′)z
(c) xy′+z+(x′+y)z′
(d) a′d(b′+c)+a′d′(b+c′)+(b′+c)(b+c′)
(e) w′x′+x′y′+yz+w′z′
(f  ) A′BCD +A′BC′D+B′EF+CDE ′G+A′DEF +A′B′EF (reduce to a sum of 
three terms)
(g) [(a′+d′+b′c)(b+d+ac ′)]′+b′c′d′+a′c′d (reduce to three terms)
3.26 Simplify to a sum of three terms:
(a) A′C′D′+AC ′+BCD +A′CD ′+A′BC+AB ′C′
(b) A′B′C′+ABD +A′C+A′CD ′+AC ′D+AB ′C′
3.27 Reduce to a minimum sum of products:
F=WXY ′+(W ′Y′≡X)+(Y ⊕ WZ)
Boolean Algebra (Continued)  85
3.28 Determine which of the following equations are always valid (give an algebraic 
proof):
(a) a′b+b′c+c′a=ab ′+bc ′+ca ′
(b) (a+b)(b+c)(c+a)=(a′+b′)(b′+c′)(c′+a′)
(c) abc+ab ′c′+b′cd+bc ′d+ad=abc+ab ′c′+b′cd+bc ′d
(d) xy ′+x′z+yz′=x′y+xz′+y′z
(e) (x+y)(y+z)(x+z)=(x′+y′)(y′+z′)(x′+z′)
(f  ) abc ′+ab ′c+b′c′d+bcd=ab ′c+abc ′+ad+bcd+b′c′d
3.29 The following circuit is implemented using two half-adder circuits. The expressions 
for the half-adder outputs are S=A ⊕ B, and C=AB. Derive simplified sum-of-
products expressions for the circuit outputs SUM and Co. Give the truth table for 
the outputs.
3.30 The output of a majority circuit is 1 if a majority (more than half) of its inputs are 
equal to 1, and the output is 0 otherwise. Construct a truth table for a three-input 
majority circuit and derive a simplified sum-of-products expression for its output.
3.31 Prove algebraically:
(a) (X′+Y′)(X≡Z)+(X+Y)(X ⊕ Z)=(X ⊕ Y)+Z′
(b) (W ′+X+Y′)(W+X′+Y)(W+Y′+Z)=X′Y′+WX +XYZ +W ′YZ
(c) ABC+A′C′D′+A′BD ′+ACD =(A′+C)(A+D′)(B+C′+D)
3.32 Which of the following statements are always true? Justify your answers.
(a) If A+B=C, then AD′+BD ′=CD ′
(b) If A′B+A′C=A′D, then B +C=D
(c) If A+B=C, then A+B+D=C+D
(d) If A+B+C=C+D, then A+B=D
3.33 Find all possible terms that could be added to each expression using the consensus 
theorem. Then reduce to a minimum sum of products.
(a) A′C′+BC+AB ′+A′BD+B′C′D′+ACD ′
(b) A′C′D′+BC′D+AB ′C′+A′BC
3.34 Simplify the following expression to a sum of two terms and then factor the result to 
obtain a product of sums: abd ′f′+b′cegh′+abd ′f+acd ′e+b′ce
3.35 Multiply out the following expression and simplify to obtain a sum-of-products 
expression with three terms: (a+c)(b′+d)(a+c′+d′)(b′+c′+d′)CoA
BS
CA
BS
C
CiYX SUM
86 Unit 3
3.36 Factor and simplify to obtain a product-of-sums expression with four terms: 
abc ′+d′e+ace+b′c′d′
3.37 (a) Show that x ⊕ y=(x≡y)′
(b) Realize a′b′c′+a′bc+ab ′c+abc ′ using only two-input equivalence gates.
3.38 In a Boolean algebra, which of the following statements are true? Prove your answer.
(a) If x( y+a′)=x( y+b′), then a =b.
(b) If a′b+ab ′=a′c+ac ′, then b =c.
3.39 The definition of Boolean algebra given in Unit 2 is redundant (i.e., not all of the 
properties are independent). For example, show that the associative property 
a+(b+c)=(a+b)+c can be proved using the other properties of Boolean 
 algebra. (Hint: Consider expanding [a+(b+c)][(a+b)+c] in two different 
ways. Be sure to not use the associative property.)
87Applications of Boolean Algebra UNIT
4
Objectives
1. Given a word description of the desired behavior of a logic circuit, write the 
output of the circuit as a function of the input variables. Specify this function as an algebraic expression or by means of a truth table, as is appropriate.
2. Given a truth table, write the function (or its complement) as both a minterm expansion (standard sum of products) and a maxterm expansion (standard product of sums). Be able to use both alphabetic and decimal notation.
3. Given an algebraic expression for a function, expand it algebraically to obtain the minterm or maxterm form.
4. Given one of the following: minterm expansion for 
F, minterm expansion for F′, 
maxterm expansion for F, or maxterm expansion for F′, find any of the other 
three forms.
5. Write the general form of the minterm and maxterm expansion of a function of n variables.
6. Explain why some functions contain don’t-care terms.
7. Explain the operation of a full adder and a full subtracter and derive logic equa-tions for these modules. Draw a block diagram for a parallel adder or subtracter and trace signals on the block diagram.Minterm and Maxterm 
Expansions
88 Unit 4
Study Guide
In the previous units, we placed a dot (·) inside the AND-gate symbol, a plus sign (+) 
inside the OR-gate symbol, and a ⊕ inside the exclusive OR. Because you are now 
familiar with the relationship between the shape of the gate  symbol and the logic 
function performed, we will omit the ·,+, and ⊕ and use the standard gate symbols 
for AND, OR, and exclusive OR in the rest of the book.
1. Study Section 4.1, Conversion of English Sentences to Boolean Equations.
(a) Use braces to identify the phrases in each of the following sentences:
(1) The tape reader should stop if the manual stop button is pressed,
if an error occurs, or if an end-of-tape signal is present.
(2) He eats eggs for breakfast if it is not Sunday and
he has eggs in the refrigerator.
(3) Addition should occur iff an add instruction is given and
the signs are the same, or if a subtract instruction is given and
the signs are not the same.
(b) Write a Boolean expression which represents each of the sentences in (a). 
Assign a variable to each phrase, and use a complemented variable to rep-
resent a phrase which contains “not”.
(Your answers should be in the form F=S′E, F=AB+SB′, and 
F=A+B+C, but not necessarily in that order.)
(c) If X represents the phrase “ N is greater than 3”, how can you represent the 
phrase “ N is less than or equal to 3”?
(d) Work Problems 4.1 and 4.2.
2. Study Section 4.2, Combinational Logic Design Using a Truth Table.  Previously, 
you have learned how to go from an algebraic expression for a function to a 
truth table; in this section you will learn how to go from a truth table to an alge-braic expression.
(a) Write a product term which is 1 iff a =
0, b=0, and c =1.
(b) Write a sum term which is 0 iff a =0, b=0, and c =1.
(c) Verify that your answers to (a) and (b) are complements.
Applications of Boolean Algebra Minterm and Maxterm Expansions  89
(d) Write a product term which is 1 iff a =1, b=0, c=0, and d =1.
(e) Write a sum term which is 0 iff a =0, b=0, c=1, and d =1.
(f  ) For the given truth table, write F as a sum of four 
 product terms which correspond to the four 1’s of F.
(g) From the truth table write F as a product of four sum 
terms which correspond to the four 0’s of F.
(h) Verify that your answers to both (f  ) and (g) reduce to 
F=b′c′+a′c.
3. Study Section 4.3, Minterm and Maxterm Expansions.
(a) Define the following terms:
minterm (for n  variables)
maxterm (for n  variables)
(b) Study Table 4-1 and observe the relation between the values of A, B, and C 
and the corresponding minterms and maxterms.
If A=0, then does A or A′ appear in the minterm?
In the maxterm?If 
A=1, then does A or A′ appear in the minterm?
In the maxterm?What is the relation between minterm, m
i, and the corresponding 
 maxterm, Mi?
(c) For the table given in Study Guide Question 2(f  ), write the minterm expan-
sion for F in m -notation and in decimal notation.
For the same table, write the maxterm expansion for F in M -notation and 
in decimal notation.
Check your answers by converting your answer to 2(f  ) to m -notation and 
your answer to 2(g) to M -notation.a  b  c F
0  0  0 1
0  0  1 10  1  0 00  1  1 11  0  0 11  0  1 01  1  0 01  1  1 0
90 Unit 4
(5) A′BC′ +AB ′C+ABC (6) AB′C′(d) Given a sum-of-products expression, how do you expand it to a standard 
sum of products (minterm expansion)?
(e) Given a product-of-sums expression, how do you expand it to a standard 
product of sums (maxterm expansion)?
(f  ) In Equation (4-11), what theorems were used to factor f to obtain the 
 maxterm expansion?
(g) Why is the following expression not a maxterm expansion?
f(A, B, C, D )=(A+B′+C+D)(A′+B+C′)(A′+B+C+D′)
(h) Assuming that there are three variables (A, B, C ), identify each of the 
 following as a minterm expansion, maxterm expansion, or neither:
(1) AB+B′C′ (2) (A′+B+C′)(A+B′+C )
Note that it is possible for a minterm or maxterm expansion to have only 
one term.
4. (a)  Given a minterm in terms of its variables, the procedure for conversion to 
decimal notation is
(1) Replace each complemented variable with a _____ and replace each 
uncomplemented variable with a _____.
(2) Convert the resulting binary number to decimal.
(b) Convert the minterm AB′C′DE to decimal notation.
(c) Given that m13 is a minterm of the variables A, B, C, D , and E , write the 
minterm in terms of these variables.
(d) Given a maxterm in terms of its variables, the procedure for conversion to 
decimal notation is
(1) Replace each complemented variable with a _____ and replace each 
uncomplemented variable with a _____.
(2) Group these 0’s and 1’s to form a binary number and convert to decimal.
(e) Convert the maxterm A′+B+C+D′+E′ to decimal notation.
(f  ) Given that M13 is a maxterm of the variables A, B, C, D, and E , write the 
maxterm in terms of these variables.
(g) Check your answers to (b), (c), (e), and (f  ) by using the relation Mi=mi′.
(h) Given f(a, b, c , d, e )=Π  M(0, 10, 28 ), express f in terms of a, b, c , d, and e. 
(Your answer should contain only five complemented variables.)(3) A+B+C (4) (A′+B)(B′+C )(A′+C )
Applications of Boolean Algebra Minterm and Maxterm Expansions  91
5. Study Section 4.4, General Minterm and Maxterm Expansions.  Make sure that 
you understand the notation here and can follow the algebra in all of the equa-
tions. If you have difficulty with this section, ask for help before you take the 
readiness test.
(a) How many different switching functions of four variables are possible?
(b) Explain why there are 22n switching functions of n  variables.
(c) Write the function of Figure 4-1 in the form of Equation (4-13) and show 
that it reduces to Equation (4-3).
(d) For Equation (4-19), write out the indicated summations in full for the 
case n =2.
(e) Study Tables 4-3 and 4-4 carefully and make sure you understand why each 
table entry is valid. Use the truth table for f and f′ (Figure 4-1) to verify the 
entries in Table 4-4. If you understand the relationship between Table 4-3 and the truth table for 
f and f′, you should be able to perform the conver-
sions without having to memorize the table.
(f  ) Given that f(A, B, C )=Σm(0, 1, 3, 4, 7 )
The maxterm expansion for f is ____________________________________
The minterm expansion for f′ is ____________________________________
The maxterm expansion for f′ is ____________________________________
(g) Work Problems 4.3 and 4.4.
6. Study Section 4.5, Incompletely Specified Functions.
(a) State two reasons why some functions have don’t-care terms.
(b) Given the following table, write the minterm expansion 
for Z in decimal form.
(c) Write the maxterm expansion in decimal form.
(d) Work Problems 4.5 and 4.6.A  B  C Z
0  0  0 1
0  0  1 X
0  1  0 00  1  1
X
1  0  0 X
1  0  1 11  1  0 01  1  1 0
92 Unit 4
7. Study Section 4.6, Examples of Truth Table Construction.  Finding the truth 
table from the problem statement is probably the most difficult part of the 
process of designing a switching circuit. Make sure that you understand how to do this.
8. Work Problems 4.7 through 4.10.
9. Study Section 4.7 , Design of Binary Adders.
(a) For the given parallel adder, show the 0’s and 1’s at the full adder (FA) 
inputs and outputs when the following unsigned numbers are added: 11+14=25. Verify that the result is correct if C
4S3S2S1S0 is taken as a 5-bit 
sum. If the sum is limited to 4 bits, explain why this is an overflow condition.
(b) Review Section 1.4, Representation of Negative Numbers.  If we use the 2’s 
complement number system to add (−5)+(−2), verify that the FA inputs 
and outputs are exactly the same as in part (a). However, for 2’s comple-ment, the interpretation of the results is quite different. After discarding 
C4, verify that the resultant 4-bit sum is correct, and therefore no overflow 
has occurred.
(c) If we use the 1’s complement number system to add (−5)+(−2), show the 
FA inputs and outputs on the diagram below before the end-around carry is added in. Assume that 
C0 is initially 0. Then add the end-around carry 
(C4) to the rightmost FA, add the new carry (C1) into the next cell, and 
continue until no further changes occur. Verify that the resulting sum is the correct 1’s complement representation of −7.
10. (a)  Work the following subtraction example. As you subtract each column, 
place a 1 over the next column if you have to borrow, otherwise place a 0. For each column, as you compute 
xi − yi − bi, fill in the corresponding val-
ues of bi+1 and di in the truth table. If you have done this correctly, the 
resulting table should match the full subtracter truth table (Table 4-6).FA FA FA FAC4 C0S3 S2 S1 S0
FA FA FA FAC4C0
Applications of Boolean Algebra Minterm and Maxterm Expansions  93
                               ←borrows
   1 1 0 0 0 1 1 0     ←X
−0 1 0 1 1 0 1 0      ←Y
                               ←difference
(b) Work Problems 4.11 and 4.12.
11. Read the following and then work Problem 4.13 or 4.14 as assigned: 
When  looking at an expression to determine the required number of gates, keep in mind that the number of required gates is generally not equal to the number 
of AND and OR operations which appear in the expression. For example,
AB+CD+EF(G+H)
contains four AND operations and three OR operations, but it only requires three AND gates and two OR gates:
12. Reread the objectives of this unit. Make sure that you understand the difference in the procedures for converting maxterms and minterms from decimal to alge-braic notation. When you are satisfied that you can meet the objectives, take the readiness test. When you come to take the readiness test, turn in a copy of your solution to assigned simulation exercise.xi  yi  bibi+1 di
0  0  0
0  0  10  1  00  1  11  0  01  0  11  1  01  1  1
A
B
C
D
E
F G
H
94In this unit you will learn how to design a combinational logic circuit starting 
with a word description of the desired circuit behavior. The first step is usually to translate the word description into a truth table or into an algebraic expres-sion. Given the truth table for a Boolean function, two standard algebraic forms of the  function can be derived—the standard sum of products (minterm expansion) and the  standard product of sums (maxterm expansion). Simplification of either of 
these standard forms leads directly to a realization of the circuit using AND and OR gates.
4.1 Conversion of English Sentences 
to Boolean Equations
The three main steps in designing a single-output combinational switching circuit are
1. Find a switching function that specifies the desired behavior of the circuit.
2. Find a simplified algebraic expression for the function.
3. Realize the simplified function using available logic elements.
For simple problems, it may be possible to go directly from a word description of the 
desired behavior of the circuit to an algebraic expression for the output function. In other cases, it is better to first specify the function by means of a truth table and then derive an algebraic expression from the truth table.
Logic design problems are often stated in terms of one or more English sentences. 
The first step in designing a logic circuit is to translate these sentences into Boolean equations. In order to do this, we must break down each sentence into phrases and associate a Boolean variable with each phrase. If a phrase can have a value of true or false, then we can represent that phrase by a Boolean variable. Phrases such as “she goes to the store” or “today is Monday” can be either true or false, but a command like “go to the store” has no truth value. If a sentence has several phrases, we will mark each phrase with a brace. The following sentence has three phrases:
 Mary watches TV if it is Monday night and she has finished her homework.        
                Applications of Boolean Algebra 
Minterm and Maxterm  Expansions
Applications of Boolean Algebra Minterm and Maxterm Expansions  95
The “if” and “and” are not included in any phrase; they show the relationships among 
the phrases.
We will define a two-valued variable to indicate the truth or falsity of each phrase:
F=1 if “Mary watches TV” is true; otherwise, F=0.
A=1 if “it is Monday night” is true; otherwise, A=0.
B=1 if “she has finished her homework” is true; otherwise B=0.
Because F is “true” if A and B  are both “true”, we can represent the sentence by 
F=A  · B
The following example illustrates how to go from a word statement of a problem 
directly to an algebraic expression which represents the desired circuit behavior. An alarm circuit is to be designed which operates as follows:
The alarm will ring iff the alarm switch is turned on and the door is not closed, or it is after 6 p.m. and the window is not closed.
The first step in writing an algebraic expression which corresponds to the above sentence is to associate a Boolean variable with each phrase in the sentence. This variable will have a value of 1 when the phrase is true and 0 when it is false. We will use the following assignment of variables:
 The alarm will ring
Z           iff         the alarm switch is on
A            and
 
 the door is not closed  
′B     or            it is after 6 
P.M.             
C           and
 
the window is not closed.
D′
This assignment implies that if Z=1, the alarm will ring. If the alarm switch is turned 
on, A=1, and if it is after 6 p.m., C=1. If we use the variable B to represent the 
phrase “the door is closed”, then B′ represents “the door is not closed”. Thus, B=1 
if the door is closed, and B′=1(B=0) if the door is not closed. Similarly, D=1 if 
the window is closed, and D′=1 if the window is not closed. Using this assignment of 
variables, the above sentence can be translated into the following Boolean equation:
Z=AB ′+CD ′
This equation corresponds to the following circuit:
A
B
DCZ
In this circuit, A is a signal which is 1 when the alarm switch is on, C is a signal from 
a time clock which is 1 when it is after 6 p.m., B is a signal from a switch on the door 
96 Unit 4
which is 1 when the door is closed, and similarly D is 1 when the window is closed. 
The output Z is connected to the alarm so that it will ring when Z =1.
4.2 Combinational Logic Design 
Using a Truth Table
The next example illustrates logic design using a truth table. A switching circuit has 
three inputs and one output, as shown in Figure 4-1(a). The inputs A, B, and C rep-
resent the first, second, and third bits, respectively, of a binary number N. The output 
of the circuit is to be f=1 if N ≥0112 and f=0 if N <0112. The truth table for f is 
shown in Figure 4-1(b).
Next, we will derive an algebraic expression for f from the truth table by using 
the combinations of values of A, B, and C for which f=1. The term A′BC is 1 only 
if A=0, B=1, and C=1. Similarly, the term AB′C′ is 1 only for the combination 
100, AB′C is 1 only for 101, ABC′ is 1 only for 110, and ABC is 1 only for 111. ORing 
these terms together yields
 f=A′BC+AB ′C′+AB ′C+ABC ′+ABC (4-1)
This expression equals 1 if A, B, and C take on any of the five combinations of values 
011, 100, 101, 110, or 111. If any other combination of values occurs, f is 0 because 
all five terms are 0.
Equation (4-1) can be simplified by first combining terms using the uniting theo-
rem and then eliminating A′ using the elimination theorem:
 f=A′BC+AB ′+AB=A′BC+A=A+BC (4-2)
Equation (4-2) leads directly to the following circuit:FIGURE 4-1
Combinational 
Circuit with Truth 
Table
© Cengage Learning 2014A
B
Cf
(a)ABC f f ′
001
1010011100101100100000010110101111 1 1 0
(b)
B
CAf
Applications of Boolean Algebra Minterm and Maxterm Expansions  97
Instead of writing f in terms of the 1’s of the function, we may also write f in terms 
of the 0’s of the function. The function defined by Figure 4-1 is 0 for three combinations 
of input values. Observe that the term A+B+C is 0 only if A=B=C=0. Similarly, 
A+B+C′ is 0 only for the input combination 001, and A+B′+C is 0 only for the 
combination 010. ANDing these terms together yields
 f=(A+B+C)(A+B+C′)(A+B′+C) (4-3)
This expression equals 0 if A, B, and C take on any of the combinations of values 000, 
001, or 010. For any other combination of values, f is 1 because all three terms are l. 
Because Equation (4-3) represents the same function as Equation (4-1) they must both 
reduce to the same expression. Combining terms and using the second distributive law, Equation (4-3) simplifies to
 
f=(A+B)(A+B′+C)=A+B(B′+C)=A+BC (4-4)
which is the same as Equation (4-2).
Another way to derive Equation (4-3) is to first write f′ as a sum of products, 
and then complement the result. From Figure 4-1, f′is 1 for input combinations 
ABC=000, 001, and 010, so
f′=A′B′C′+A′B′C+A′BC′
Taking the complement of f′ yields Equation (4-3).
4.3 Minterm and Maxterm Expansions
Each of the terms in Equation (4-1) is referred to as a minterm. In general, a minterm 
of n variables is a product of n literals in which each variable appears exactly once 
in either true or complemented form, but not both. (A literal is a variable or its com-
plement.) Table 4-1 lists all of the minterms of the three variables A, B, and C. Each 
minterm has a value of 1 for exactly one combination of values of the variables A, B, 
and C. Thus if A=B=C=0, A′B′C′=1; if A=B=0 and C=1, A′B′C=1; and 
so forth. Minterms are often written in abbreviated form— A′B′C′ is designated m0, 
A′B′C is designated  m1, etc. In general, the minterm which corresponds to row i of 
the truth table is designated mi (i is usually written in decimal).
Row No. A  B  C Minterms Maxterms
0 0  0  0 A′B′C′=m0A+B+C   =M0
1 0  0  1 A′B′C =m1A+B+C′  =M1
2 0  1  0 A′BC′ =m2A+B′+C  =M2
3 0  1  1 A′BC  =m3A+B′+C′  =M3
4 1  0  0 AB′C′ =m4A′+B+C  =M4
5 1  0  1 AB′C  =m5A′+B+C′  =M5
6 1  1  0 ABC′   =m6A′+B′+C =M6
7 1  1  1 ABC   =m7A′+B′+C′=M7TABLE 4-1
Minterms and 
Maxterms for  
Three Variables
© Cengage Learning 2014
98 Unit 4
When a function f is written as a sum of minterms as in Equation (4-1), this 
is referred to as a minterm expansion or a standard sum of products.1 If f=1 for 
row i of the truth table, then mi must be present in the minterm expansion because 
mi=1 only for the combination of values of the variables corresponding to row i 
of the table. Because the minterms present in f are in one-to-one correspondence 
with the 1’s of f in the truth table, the minterm expansion for a function f is unique. 
Equation (4-1) can be rewritten in terms of m -notation as
 f(A, B, C )=m3+m4+m5+m6+m7 (4-5)
This can be further abbreviated by listing only the decimal subscripts in the form
 f(A, B, C )=Σ  m(3,  4,   5,   6,   7) (4-5a)
Each of the sum terms (or factors) in Equation (4-3) is referred to as a maxterm. 
In general, a maxterm of n variables is a sum of n literals in which each variable 
appears exactly once in either true or complemented form, but not both. Table 4-1 
lists all of the maxterms of the three variables A, B, and C. Each maxterm has a value 
of 0 for exactly one combination of values for A, B, and C. Thus, if A=B=C=0, 
A+B+C=0; if A=B=0 and C=1, A+B+C′=0; and so forth. Maxterms 
are often written in abbreviated form using M-notation. The maxterm which cor-
responds to row i  of the truth table is designated Mi. Note that each maxterm is the 
complement of the corresponding minterm, that is, Mi=mi′.
When a function f is written as a product of maxterms, as in Equation (4-3), this 
is referred to as a maxterm expansion or standard product of sums. If f=0 for row i 
of the truth table, then Mi must be present in the maxterm expansion because Mi=0 
only for the combination of values of the variables corresponding to row i of the 
table. Note that the maxterms are multiplied together so that if any one of them is 0, f  
will be 0. Because the maxterms are in one-to-one correspondence with the 0’s of f 
in the truth table, the maxterm expansion for a function f is unique. Equation (4-3) 
can be rewritten in M -notation as
 f(A, B, C )=M0 M1M2 (4-6)
This can be further abbreviated by listing only the decimal subscripts in the form
 f(A, B, C )=Π M(0, 1, 2 ) (4-6a)
where Π means a product.
Because if f≠1 then f=0, it follows that if mi is not present in the minterm 
expansion of f, then Mi is present in the maxterm expansion. Thus, given a minterm 
expansion of an n -variable function f in decimal notation, the maxterm expansion 
is obtained by listing those decimal integers (0≤i≤2n−1) not in the minterm list. 
Using this method, Equation (4-6a) can be obtained directly from Equation (4-5a).
1Other names used in the literature for standard sum of products are canonical sum of products and 
 disjunctive normal form. Similarly, a standard product of sums may be called a canonical product of 
sums or a conjunctive normal form.
Applications of Boolean Algebra Minterm and Maxterm Expansions  99
Given the minterm or maxterm expansions for f, the minterm or maxterm 
expansions for the complement of f are easy to obtain. Because f′ is 1 when f is 0, 
the minterm expansion for f′ contains those minterms not present in f. Thus, from 
Equation (4-5),
 f′=m0+m1+m2=Σ   m(0,  1,   2) (4-7)
Similarly, the maxterm expansion for f′ contains those maxterms not present in f. 
From Equation (4-6), 
f′=Π M(3,  4,   5,   6,   7)=M3M4M5M6M7 (4-8)
Because the complement of a minterm is the corresponding maxterm, Equation (4-8) 
can be obtained by complementing Equation (4-5):
f′=(m3+m4+m5+m6+m7)′=m3′m4′m5′m6′m7′=M3M4M5M6M7
Similarly, Equation (4-7) can be obtained by complementing Equation (4-6):
f′=(M0M1M2)′=M0′+M1′+M2′=m0+m1+m2
A general switching expression can be converted to a minterm or maxterm 
expansion either using a truth table or algebraically. If a truth table is constructed 
by evaluating the expression for all different combinations of the values of the vari-ables, the minterm and maxterm expansions can be obtained from the truth table by the methods just discussed. Another way to obtain the minterm expansion is to first write the expression as a sum of products and then introduce the missing variables in each term by applying the theorem 
X+X′=1.
Find the minterm expansion of f(a, b, c , d)=a′(b′+d)+acd ′.
 f=a′b′+a′d+acd ′
=a′b′(c+c′)(d+d′)+a′d(b+b′)(c+c′)+acd ′(b+b′)
=a′b′c′d′+a′b′c′d+a′b′cd ′+a′b′cd+a′b′c′d+a′b′cd
   +a′bc ′d+a′bcd+abcd ′+ab ′cd ′  (4-9)
Duplicate terms have been crossed out, because X+X=X. This expression can 
then be converted to decimal notation:
 f=a′b′c′d′+a′b′c′d+a′b′cd ′+a′b′cd+a′bc ′d+a′bcd+abcd ′+ab ′cd ′
0  0  0  0        0   0  0 1          0  0  1 0         0  0 11         0 10 1         0 111         1 1 1 0        10 10
f=Σ   m(0, 1, 2, 3, 5, 7, 10, 14) 
(4-10)
The maxterm expansion for f can then be obtained by listing the decimal integers 
(in the range 0 to 15) which do not correspond to minterms of f:
f=Π M(4,  6,   8,   9,   11,   12,   13,   15)Example
100 Unit 4
An alternate way of finding the maxterm expansion is to factor f to obtain a 
product of sums, introduce the missing variables in each sum term by using XX′=0, 
and then factor again to obtain the maxterms. For Equation (4-9),
f=a′(b′+d)+acd ′
=(a′+cd ′)(a+b′+d)=(a′+c)(a ′+d′)(a+b′+d)
=(a′+bb′+c+dd′)(a ′+bb′+cc′+d′)(a+b′+cc′+d)
=(a′+bb′+c+d)(a ′+bb′+c+d′)(a ′+bb′+c+d′)
  (a′+bb′+c′+d′)(a+b′+cc′+d)
=(a′+b+c+d)(a ′+b′+c+d)(a ′+b+c+d′)(a ′+b′+c+d′)
          1000                 1100                  1001                 1101
  (a′+b+c′+d′)(a ′+b′+c′+d′)(a+b′+c+d)(a+b′+c′+d)
               1011                  1111                   0100                  0110
=Π   M(4, 6, 8, 9, 11, 12, 13, 15) 
 (4-11)
Note that when translating the maxterms to decimal notation, a primed variable is 
first replaced with a 1 and an unprimed variable with a 0.
Because the terms in the minterm expansion of a function F correspond one-to-
one with the rows of the truth table for which F=1, the minterm expansion of F is 
unique. Thus, we can prove that an equation is valid by finding the minterm expan-sion of each side and showing that these expansions are the same.
Show that a ′c+b′c′+ab=a′b′+bc+ac ′.
We will find the minterm expansion of each side by supplying the missing vari-
ables. For the left side,
a′c(b+b′)+b′c′(a+a′)+ab(c+c′)
       =a′bc+a′b′c+ab ′c′+a′b′c′+abc+abc ′
       =m3+m1+m4+m0+m7+m6
For the right side,
a′b′(c+c′)+bc(a+a′)+ac ′(b+b′)
       =a′b′c+a′b′c+abc+a′bc+abc ′+ab ′c′
       =m1+m0+m7+m3+m6+m4
Because the two minterm expansions are the same, the equation is valid.
4.4 General Minterm and Maxterm Expansions
Table 4-2 represents a truth table for a general function of three variables. Each ai 
is a constant with a value of 0 or 1. To completely specify a function, we must assign values to all of the a
i’s. Because each ai can be specified in two ways, there are 28 Example
Applications of Boolean Algebra Minterm and Maxterm Expansions  101
ways of filling the F column of the truth table; therefore, there are 256 different func-
tions of three variables (this includes the degenerate cases, F identically equal to 0 
and F identically equal to 1). For a function of n variables, there are 2n rows in the 
truth table, and because the value of F can be 0 or 1 for each row, there are 22n pos-
sible functions of n  variables.
From Table 4-2, we can write the minterm expansion for a general function of 
three variables as follows:
 F=a0m0+a1m1+a2m2+ · · · +a7m7=a7
i=0aimi (4-12)
Note that if ai=1, minterm mi is present in the expansion; if ai=0, the correspond-
ing minterm is not present. The maxterm expansion for a general function of three 
variables is
 F=(a0+M0)(a1+M1)(a2+M2) · · · (a7+M7)=q7
i=0(ai+Mi) (4-13)
Note that if ai=1, ai+Mi=1, and Mi drops out of the expansion; however, Mi 
is present if ai=0.
From Equation (4-13), the minterm expansion of F ′ is
 F′=cq7
i=0(ai+Mi)d′=a7
i=0ai′Mi′=a7
i=0ai′mi (4-14)
Note that all minterms which are not present in F are present in F ′.
From Equation (4-12), the maxterm expansion of F ′ is
 F′=ca7
i=0aimid′=q7
i=0(ai′+ mi′)=q7
i=0(ai′ + Mi) (4-15)
Note that all maxterms which are not present in F are present in F′. Generalizing 
Equations (4-12), (4-13), (4-14), and (4-15) to n  variables, we have
 F=a2n−1
i=0aimi=q2n−1
i=0(ai+Mi) (4-16)A  B  C F
0  0  0 a0
0  0  1 a1
0  1  0 a2
0  1  1 a3
1  0  0 a4
1  0  1 a5
1  1  0 a6
1  1  1 a7TABLE 4-2
General Truth 
Table for Three 
Variables
© Cengage Learning 2014
102 Unit 4
 F′=a2n−1
i=0 ai′ mi=q2n−1
i=0(ai′+ Mi) (4-17)
Given two different minterms of n variables, mi and mj, at least one variable 
appears complemented in one of the minterms and uncomplemented in the other. 
Therefore, if i≠j, mi mj=0. For example, for n=3, m1m3=(A′B′C)(A′BC)=0. 
Given minterm expansions for two functions
 f1=a2n−1
i=0ai mi   f2=a2n−1
j=0bj   mj (4-18)
the product is
 f1 f2=aa2n−1
i=0ai mibaa2n−1
j=0bj mjb=a2n−1
i=0 a2n−1
j=0ai bj mi mj
=a2n−1
i=0ai bi mi      (because mi mj=0 unless i=j) 
(4-19)
Note that all of the cross-product terms (i≠j) drop out so that f1  f2 contains only 
those minterms which are present in both f1 and f2. For example, if
f1=Σ m(0, 2, 3, 5, 9, 11)  and f2=Σ m(0, 3, 9, 11, 13, 14)
f1  f2=Σ m(0, 3, 9, 11)
Table 4-3 summarizes the procedures for conversion between minterm and max-
term expansions of F and F′, assuming that all expansions are written as lists of 
decimal numbers. When using this table, keep in mind that the truth table for an 
n-variable function has 2n rows so that the minterm (or maxterm) numbers range 
from 0 to 2n−1. Table 4-4 illustrates the application of Table 4-3 to the three- 
variable function given in Figure 4-1.
TABLE 4-3
Conversion of 
Forms
© Cengage Learning 2014
GIVEN FORMDESIRED FORM
Minterm 
Expansion  
of FMaxterm 
Expansion  
of FMinterm 
Expansion  
of F ′Maxterm 
Expansion  
of F ′
Minterm 
Expansion  
of F____________ maxterm nos. 
are those nos. 
not on the minterm list for 
Flist minterms not present in 
Fmaxterm nos. are the same as minterm nos. of 
F
Maxterm 
Expansion  
of Fminterm nos. are those nos. not on the maxterm list for 
F____________ minterm nos. 
are the same as maxterm nos. of 
Flist maxterms not present in 
F
Applications of Boolean Algebra Minterm and Maxterm Expansions  103
4.5 Incompletely Specified Functions
A large digital system is usually divided into many subcircuits. Consider the follow-
ing example in which the output of circuit N1 drives the input of circuit N2.
Let us assume that the output of N1 does not generate all possible combinations of 
values for A, B, and C. In particular, we will assume that there are no combinations 
of values for w, x, y, and z which cause A, B, and C to assume values of 001 or 110. 
Hence, when we design N2, it is not necessary to specify values of F for ABC=001 
or 110 because these combinations of values can never occur as inputs to N2. For 
example, F might be specified by Table 4-5.
The X’s in the table indicate that we don’t care whether the value of 0 or 1 is 
assigned to F for the combinations ABC=001 or 110. In this example, we don’t 
care what the value of F is because these input combinations never occur anyway. 
The function F is then incompletely specified. The minterms A′B′C and ABC′ are 
referred to as don’t-care minterms, since we don’t care whether they are present in the function or not.TABLE 4-4
Application of 
Table 4.3
© Cengage Learning 2014
GIVEN FORMDESIRED FORM
Minterm 
Expansion  
of fMaxterm 
Expansion 
of fMinterm 
Expansion 
of f′Maxterm 
Expansion  
of f′
f=
Σ m(3, 4, 5, 6, 7 ) ____________ Π M(0, 1, 2 )Σ m(0, 1, 2 )Π M(3, 4, 5, 6, 7 )
f=
Π  M(0, 1, 2 )  Σ m(3, 4, 5, 6, 7 )_________ Σ m(0, 1, 2 )Π M(3, 4, 5, 6, 7 )
w
N1A
B
CN2x
y
zF
TABLE 4-5
Truth Table with 
Don’t-Cares
© Cengage Learning 2014A  B  C F
0  0  0 1
0  0  1 X
0  1  0 00  1  1 11  0  0 01  0  1 01  1  0
X
1  1  1 1
104 Unit 4
When we realize the function, we must specify values for the don’t-cares. It is 
desirable to choose values which will help simplify the function. If we assign the 
value 0 to both X’s, then
F=A′B′C′+A′BC+ABC =A′B′C′+BC
If we assign 1 to the first X and 0 to the second, then
F=A′B′C′+A′B′C+A′BC+ABC =A′B′+BC
If we assign 1 to both X’s, then
F=A′B′C′+A′B′C+A′BC+ABC ′+ABC =A′B′+BC+AB
The second choice of values leads to the simplest solution.
We have seen one way in which incompletely specified functions can arise, and 
there are many other ways. In the preceding example, don’t-cares were present because certain combinations of circuit inputs did not occur. In other cases, all input combinations may occur, but the circuit output is used in such a way that we do not care whether it is 0 or 1 for certain input combinations.
When writing the minterm expansion for an incompletely specified function, we 
will use m to denote the required minterms and d to denote the don’t-care minterms. 
Using this notation, the minterm expansion for Table 4-5 is
F=Σ m
(0,  3,  7)+Σ d(1,  6)
For each don’t-care minterm there is a corresponding don’t-care maxterm. For exam-ple, if F=
X (don’t-care) for input combination 001, m1 is a don’t-care minterm  
and M1 is a don’t-care maxterm. We will use D to represent a don’t-care maxterm, and 
we write the maxterm expansion of the function in Table 4-5 as
F=Π M(2,  4,   5) · Π D(1,  6)
which implies that maxterms M2, M4, and M5 are present in F and don’t-care 
 maxterms M1 and M6 are optional.
4.6 Examples of Truth Table Construction
We will design a simple binary adder that adds two 1 -bit binary numbers, a and b, to 
give a 2-bit sum. The numeric values for the adder inputs and output are as follows:
ab Sum
00 0 0 (0+0=0)
01 0 1 (0+1=1)
10 0 1 (1+0=1)
11 1 0 (1+1=2)Example 1
Applications of Boolean Algebra Minterm and Maxterm Expansions  105
We will represent inputs to the adder by the logic variables A and B and the 2-bit 
sum by the logic variables X and Y, and we construct a truth table:
Because a numeric value of 0 is represented by a logic 0 and a numeric value of 1 by 
a logic l, the 0’s and 1’s in the truth table are exactly the same as in the previous table. From the truth table,
X=AB   and   Y=A′B+AB ′=A ⊕ BAB XY
00 00
01 0110 0111 10
A X
Y
ZB
C
DN1
N2N3TRUTH TABLE:
N1$%&
A BN2$%&
C DN3$'%'&
X  Y  Z
0  0 0  0 0  0  0
0  0 0  1 0  0  10  0 1  0 0  1  00  0 1  1 0  1  10  1 0  0 0  0  10  1 0  1 0  1  00  1 1  0 0  1  10  1 1  1 1  0  01  0 0  0 0  1  01  0 0  1 0  1  11  0 1  0 1  0  01  0 1  1 1  0  11  1 0  0 0  1  11  1 0  1 1  0  01  1 1  0 1  0  11  1 1  1 1  1  0An adder is to be designed which adds two 2-bit binary numbers to give a 3-bit 
binary sum. Find the truth table for the circuit. The circuit has four inputs and three outputs as shown:
Inputs 
A and B  taken together represent a binary number N1. Inputs C and D  taken 
together represent a binary number N2. Outputs X, Y, and Z taken together rep-
resent a binary number N3, where N3=N1+N2 (+ of course represents ordinary 
addition here).
In this example we have used A, B, C, and D  to represent both numeric values 
and logic values, but this should not cause any confusion because the numeric and Example 2
106 Unit 4
logic values are the same. In forming the truth table, the variables were treated like 
binary numbers having numeric values. Now we wish to derive the switching func-
tions for the output variables. In doing so, we will treat A, B, C, D , X, Y, and Z as 
switching variables having nonnumeric values 0 and 1. (Remember that in this case the 0 and 1 may represent low and high voltages, open and closed switches, etc.)
From inspection of the table, the output functions are
X(A, B, C, D )=Σ m(7,  10,  11,  13,  14,  15)
Y(A, B, C, D )=Σ m(2,  3,  5,  6,  8,  9,  12,  15)
Z(A, B, C, D )=Σ m(1,   3,  4,  6,  9,  11,  12,  14)
ABCD F
0000 0
0001 00010 10011 00100 00101 00110 10111 01000 01001 01010 11011 01100 01101 11110 11111 1Design an error detector for 6-3-1 -1 binary-coded-decimal digits. The output (F) is 
to be 1 iff the four inputs (A, B, C, D ) represent an invalid code combination.
The valid 6-3-1 -1 code combinations are listed in Table 1 -2. If any other combi-
nation occurs, this is not a valid 6-3-1 -1 binary-coded-decimal digit, and the circuit 
output should be F=1 to indicate that an error has occurred. This leads to the fol-
lowing truth table:
The corresponding output function is
F=Σ  m(2,  6,  10,   13,   14,   15)
=A′B′CD ′+A′BCD ′+AB ′CD ′+ABCD ′+ABC ′D+ABCD
=A′CD ′+ACD ′+ABD =CD ′+ABDExample 3
(''''' * 
('''' *('''' ' (' ('''' *('
Applications of Boolean Algebra Minterm and Maxterm Expansions  107
The realization using AND and OR gates is
C
A
BF
DD′
The four inputs to a circuit (A, B, C, D ) represent an 8-4-2-1 binary-coded-decimal 
digit. Design the circuit so that the output (Z) is 1 iff the decimal number repre-
sented by the inputs is exactly divisible by 3. Assume that only valid BCD digits 
occur as inputs.
The digits 0, 3, 6, and 9 are exactly divisible by 3, so Z=1 for the input combina-
tions ABCD =0000,   0011,   0110,   and   1001. The input combinations 1010, 1011, 1100, 
1101, 1110, and 1111 do not represent valid BCD digits and will never occur, so Z is 
a don’t-care for these combinations. This leads to the following truth table:Example 4
ABCDZ
00 0 0 1
00 0 1 000 1 0 000 1 1 101 0 0 001 0 1 001 1 0 101 1 1 010 0 0 010 0 1 110 1 0
X
10 1 1 X
11 0 0 X
11 0 1 X
11 1 0 X
11 1 1 X
The corresponding output function is
Z=Σ m(0,  3,  6,  9)+Σ   d(10,   11,  12,  13,  14,  15)
In order to find the simplest circuit which will realize Z, we must choose some of 
the don’t-cares (X’s) to be 0 and some to be 1. The easiest way to do this is to use a 
Karnaugh map as described in Unit 5.
108 Unit 4
4.7 Design of Binary Adders and Subtracters
In this section, we will design a parallel adder that adds two 4-bit unsigned binary 
numbers and a carry input to give a 4-bit sum and a carry output (see Figure 4-2). One approach would be to construct a truth table with nine inputs and five out-puts and then derive and simplify the five output equations. Because each equation would be a function of nine variables before simplification, this approach would be very difficult, and the resulting logic circuit would be very complex. A better method is to design a logic module that adds two bits and a carry, and then connect four of these modules together to form a 4-bit adder as shown in Figure 4-3. Each of the modules is called a full adder. The carry output from the first full adder serves as the carry input to the second full adder, etc.
FIGURE 4-2
Parallel Adder 
for 4-Bit Binary 
Numbers
© Cengage Learning 20144-bit
Parallel
Adder
A3B3A2B2A1B1A0B0S3
C4 C0S2 S1 S0
FIGURE 4-3
Parallel Adder 
Composed of Four 
Full Adders
© Cengage Learning 2014Full
Adder
A3 B3S3
C40
11
1Full
Adder
A2 B2S2
C31
00
0Full
Adder
A1 B1S1
C21
11
1Full
Adder
A0 B0S0
C10
1
end-around carry for 1’s complement1C0
0
1
In the example of Figure 4-3, we perform the following addition:
 10110 (carries )
   1011
+  1011
 10110
The full adder to the far right adds A0+B0+C0=1+1+0 to give a sum of 
102, which gives a sum S0=0 and a carry out of C1=1. The next full adder adds 
A1+B1+C1=1+1+1=112, which gives a sum S1=1 and a carry C2=1. The 
carry continues to propagate from right to left until the left cell produces a final carry of C
4=1.
Applications of Boolean Algebra Minterm and Maxterm Expansions  109
Figure 4-4 gives  the truth table for a full adder with inputs  X, Y, and Cin. The outputs 
for each row of the table are found by adding up the input bit s (X+Y+Cin) and split-
ting the res ult into a carry out (Ci+1) and a s um bit (Si). For example, in the 101 row 
1+0+1=102, so Ci+1=1 and Si=0. Figure 4-5 shows  the implementation of the full 
adder us ing gates . The logic equations  for the full adder derived from the truth table are
Sum =X′Y′Cin+X′YC′in+XY ′C′in+XYCin
=X′(Y′Cin+YC′in)+X(Y′C′in+YCin)
=X′(Y ⊕ Cin)+X(Y ⊕ Cin)′=X ⊕ Y ⊕ Cin (4-20)
Cout=X′YCin+XY ′Cin+XYC ′in+XYCin
=(X′YCin+XYCin)+(XY ′Cin+XYCin)+(XYC ′in+XYCin)
=YCin+XCin+XY (4-21)
Note that the term XYCin wa s used three times in simplifying Cout. Figure 4-5 shows 
the logic circuit for Equations (4-20) and (4-21).FIGURE 4-4
Truth Table for a 
Full Adder
© Cengage Learning 2014XYCin Cout Sum
00 0 0 0
00 1 0 101 0 0 101 1 1 010 0 0 110 1 1 011 0 1 011 1 1 1Full
AdderSumX
Y
CinCout
FIGURE 4-5
Implementation of 
Full Adder
© Cengage Learning 2014
y
cincincoutx
x
yy
x
cinSum
Although des igned for uns igned binary numbers , the parallel adder of Figure 4-3 can 
also be us ed for s igned binary numbers  with negative numbers  expressed in complement 
form. When 2’ s complement is  used, the las t carry (C4) is discarded, and there is  no carry 
into the firs t cell. Becaus e C0=0, the equations  for the firs t cell may be s implified to
S0=A0 ⊕ B0  and  C1=A0 B0
When 1’ s complement is u sed, the end-around carry is accomplished by connecting 
C4 to the C0 input, as shown by the dashed line in Figure 4-3.
When adding signed binary numbers with negative numbers expressed in com-
plement form, the sign bit of the sum is wrong when an overflow occurs . That is , an 
overflow has occurred if adding two positive numbers gives a negative result, or 
adding two negative numbers gives a positive result. We will define a signal V that 
110 Unit 4
is 1 when an overflow occurs. For Figure 4-3, we can use the sign bits of A, B, and S 
(the sum) to determine the value of V:
V=A3′B3′S3+A3B3S3′ (4-22)
If the number of bits is large, a parallel binary adder of the type shown in 
Figure 4-4 may be rather slow because the carry generated in the first cell might 
have to propagate all of the way to the last cell.
Subtraction of binary numbers is most easily accomplished by adding the com-
plement of the number to be subtracted. To compute A−B, add the complement of 
B to A. This gives the correct answer because A+(−B)=A−B. Either 1’s or 2’s 
complement is used depending on the type of adder employed.
The circuit of Figure 4-6 may be used to form A−B using the 2’s complement 
representation for negative numbers. The 2’s complement of B can be formed by 
first finding the 1’s complement and then adding 1. The 1’s complement is formed by inverting each bit of B, and the addition of 1 is effectively accomplished by putting a 1 
into the carry input of the first full adder.
FIGURE 4-6
Binary Subtracter 
Using Full Adders
© Cengage Learning 2014Full
Adder
B′4 B′2 B′1 B′3S4
A4B4 A3B3 A2B2 A1B1Full
AdderS3
Full
AdderS2
Full
AdderS1
c2c1 = 1c3 c4c5
(Ignore last
carry)
A=0110 ( +6)
B=0011    (+3)
The adder output is
    0110 ( +6)
  +1100 (1’s complement of 3)
+          1   (first carry input)
(1) 0011 =3=6−3
Alternatively, direct subtraction can be accomplished by employing a full sub-
tracter in a manner analogous to a full adder. A block diagram for a parallel subtracter which subtracts 
Y from X is shown in Figure 4-7 . The first two bits are subtracted in 
the rightmost cell to give a difference d1, and a borrow signal (b2=1) is generated if 
it is necessary to borrow from the next column. A typical cell (cell i) has inputs xi, yi, 
and bi, and outputs bi+1 and di. An input bi=1 indicates that we must borrow 1 from 
xi in that cell, and borrowing 1 from xi is equivalent to subtracting 1 from xi. In cell  i,  Example
Applications of Boolean Algebra Minterm and Maxterm Expansions  111
bits bi and yi are subtracted from xi to form the difference di, and a borrow signal 
(bi+1=1) is generated if it is necessary to borrow from the next column.
Table 4-6 gives the truth table for a binary full subtracter. Consider the following 
case, where xi=0, yi=1 and bi=1:FIGURE 4-7
Parallel Subtracter
© Cengage Learning 2014
Full
Subtracterbn + 1 bndn
xnynFull
Subtracter
Cell ibi + 1 bidi
xiyiFull
Subtracterb3 b2b1 = 0d2
x2y2Full
Subtracterd1
x1y1
xiyibibi+1di
0 0 0 0  0
0 0 1 1  10 1 0 1  10 1 1 1  01 0 0 0  11 0 1 0  01 1 0 0  01 1 1 1  1TABLE 4-6
Truth Table 
for Binary Full 
Subtracter
© Cengage Learning 2014
Column i   
Before 
BorrowColumn i   
After 
Borrow
xi 01 0
−bi −1 −1
−yi −1 −1
di 0 (bi+1=1)
Note that in column i , we cannot immediately subtract yi and bi from xi. Hence, we 
must borrow from column i +1. Borrowing 1 from column i+1 is equivalent to set-
ting bi+1 to 1 and adding 10 (210) to xi. We then have di=10−1−1=0. Verify that 
Table 4-6 is correct for the other input combinations and use it to work out several 
examples of binary subtraction.
The ripple carry adder is relatively slow because, in the worst case, a carry propa-
gates through all stages of the adder, and there are two gate delays per stage. There are several techniques for reducing the carry propagation time. One is called a carry-lookahead adder . In the parallel adder the carry out of the ith stage can be written as
C
i+1=Ai Bi +Ci(Ai+Bi)=Ai Bi+Ci(Ai ⊕ Bi)=Gi+PiCi
112 Unit 4
where Gi=Ai Bi indicates the condition for the ith stage to generate a carry out and 
Pi=Ai  ⊕ Bi (or Pi=Ai+Bi) indicates the condition for the ith stage to propagate a 
carry in to the carry out. Then Ci+2 can be expressed in terms of Ci.
Ci+2=Gi+1+Pi+1Ci+1=Gi+1+(Gi+Ci Pi)Pi+1=Gi+1+Pi+1Gi+Pi+1PiCi
This can be continued to express Ci+2, Ci+3, etc. in terms of Ci.
Ci+1=Gi+PiCi
Ci+2=Gi+1+Pi+1Gi+Pi+1PiCi
Ci+3=Gi+2+Pi+2Gi+1+Pi+2 Pi+1Gi+Pi+2 Pi+1PiCi
Ci+4=Gi+3+Pi+3Gi+2+Pi+3 Pi+2Gi+1+Pi+3 Pi+2 Pi+1Gi+Pi+3 Pi+2 Pi+1PiCi (4-23)
Assuming that the maximum fan-in of the gates is not exceeded, each of these equa-
tions can be implemented in a two-level circuit so, if a change in Ci propagates to 
Cj ( j=i+1, i +2, · · ·), it does so with a delay of two gates. Equations (4-23) are the 
carry-lookahead equations. If a circuit implements, for example, four of the equa-tions, it is a 4-bit carry-lookahead circuit.
Figure 4-8 shows a 4-bit parallel adder using a 4-bit carry-lookahead circuit. (The 
sum outputs are not shown.) After the generate and propagate outputs of the  full adders are stable, if a change in C
0 propagates to Ci (i=1, 2, 3,   or 4), it does so in 
two gate delays. Similarly, if a change in C1 propagates to Ci (i=2, 3,   or 4), it does so 
in two gate delays. In the 4-bit ripple-carry adder a change in C0 propagating to C4 
requires 8 gate delays.
FIGURE 4-8
4-Bit Adder with 
Carry-Lookahead
© Cengage Learning 2014A0B0
G0P0Full
AdderA1B1
G1P1
C0C1A2B2
G2P2A3B3
G3P3Full
AdderFull
AdderFull
AdderC3 C2
C44-bit Carry-Lookahead
Circuit
The carry-lookahead circuit can be increased in size to reduce the delay in longer parallel adders; however, the gate fan-in increases linearly with the size of the carry-lookahead circuit so the size is limited by the maximum fan-in available. For longer adders the carry-lookahead circuits can be cascaded. For example, a 16-bit paral-lel adder can be implemented using four 4-bit carry-lookahead circuits, as shown in Figure 4-9. Now the speed of the circuit is determined by the number of carry- lookahead circuits required. In Figure 4-9 the propagation delay from C
0 to C16 
would be 8 gate delays; a 16-bit ripple-carry adder would have a delay of 32 gates.
To reduce the delay of the adder without increasing the size of the carry- 
lookahead circuit, a second level of carry-lookahead circuits can be connected to the first level carry-lookahead circuits. To illustrate this, the equations for the four carry-lookahead circuits in Figure 4-9 are written in same form as Equation (4-23).
Applications of Boolean Algebra Minterm and Maxterm Expansions  113
C4 =G0+P0C0
 where G0=G3+P3G2+P3P2G1+P3P2 P1G0 and P0=P3P2 P1P0
C8 =G4+P4C4
 where G4=G7+P7G6+P7P6G5+P7P6P5G4 and P4=P7P6P5P4
C12 =G8+P8C8 
 where G8=G11+P11G10+P11P10G9+P11P10P9G8 and P8=P11P10P9P8
C16 =G12+P12C12
 where G12=G15+P15G14+P15P14G13+P15P14P13G12 and P12=P15P14P13P12
Now these equations for C4, C8, C12, and C16 can be written in terms of C0.
C4=G0 +P0C0
C8=G4 +P4G0+P4  P0C0
C12=G8 +P8G4 +P8 P4G0+P8 P4 P0C0
C16=G12 +P12G8+P12  P8G4+P12 P8 P4G0+P12 P8 P4 P0C0
These equations are the same as those for a 4-bit carry-lookahead circuit. The first 
level carry-lookahead circuits can be modified to produce Gi and Pi instead of Ci,  
i=0, 4, 8, and 12. These provide inputs to a second level carry-lookahead circuit, as 
shown in Figure 4-10. Now the propagation delay from C0 to Ci, i=4, 8, 12, and 16, 
is just two gate delays.FIGURE 4-9
16-Bit Adder with 
Carry-Lookahead
© Cengage Learning 2014A0–3B0–3
G0–3 P0–3C0–3
C0 C4A4–7B4–7
G4–7 P4–7C4–7
C8A8–11B8–11
G8–11 P8–11C8–11
C12A12–15B12–15
G12–15 P12–15Full
AddersFull
AddersFull
AddersFull
AddersC0–3
4-bit
Carry-Lookahead4-bit
Carry-Lookahead4-bit
Carry-Lookahead4-bit
Carry-LookaheadC16
FIGURE 4-10
16-Bit Adder with 
Second Level  
Carry-Lookahead
© Cengage Learning 2014C0–3
C0 C4C4–7
C8C8–11
C12Full
AddersFull
AddersFull
AddersFull
AddersC12–15
4-bit
Carry-Lookahead4-bit
Carry-Lookahead4-bit
Carry-Lookahead4-bit
Carry-Lookahead
C16G0 P0G4 P4G8 P8G12 P12
4-bit Carry-Lookahead CircuitA12–15B12–15 A8–11B8–11 A0–3B0–3 A4–7B4–7
G0–3 P0–3 G4–7 P4–7 G8–11 P8–11 G12–15 P12–15
114 Unit 4
Ci+1=Gi+PiGi−1+Pi Pi−1Gi−2+Pi Pi−1Pi−2Gi−3+Pi Pi−1Pi−2Pi−3Ci−3
C4=G3+P3G2+P3P2G1+P3P2P1G0+P3P2P1P0C0=G0+P0C0
Thi s expression can be expanded to express Ci+1 in terms of Ci−1.
Ci+1=Gi+Ci Pi+Gi=(Gi−1+Ci−1Pi−1)Pi=Gi+PiGi−1+Pi Pi−1Ci−1
Thi s procedure can be continued to obtain
Ci+1=Gi+CiPi
Ci+1=Gi+PiGi−1+Pi Pi−1Ci−1
Ci+1=Gi+PiGi−1+Pi Pi−1Gi−2+Pi Pi−1Pi−2Ci−2
Ci+1=Gi+PiGi−1+Pi Pi−1Gi−2+Pi Pi−1Pi−2Gi−3+Pi Pi−1Pi−2Pi−3Ci−3
and so on.
Problems
4.1 Represent each of the following sentences by a Boolean equation.
(a)  The company safe should be unlocked only when Mr. Jones i s in the office or 
Mr. Evans i s in the office, and only when the company is open for business , and 
only when the security guard is present.
(b)  You should wear your overshoes if you are outside in a heavy rain and you are 
wearing your new suede shoes , or if your mother tells you to.
(c)  You should laugh at a joke if it is funny, it i s in good ta ste, and it is not offen sive 
to others , or if it is told in class by your professor (regardless of whether it is 
funny and in good taste) and it is not offensive to others .
(d)  The elevator door should open if the elevator is stopped, it is level with the floor, 
and the timer has not expired, or if the elevator is stopped, it is level with the 
floor, and a button is pressed.
4.2 A flow rate sensing device used on a liquid transport pipeline functions a s follows . 
The device provides a 5-bit output where all five bits are zero if the flow rate is less than 10 gallons per minute. The first bit is 1 if the flow rate is at least 10 gallons per minute; the first and second bits are 1 if the flow rate is at least 20 gallons per minute; the first, second, and third bit s are 1 if the flow rate is at lea st 30 gallons per minute; 
and so on. The five bits , represented by the logical variables 
A, B, C, D, and E, are 
used as inputs to a device that provides two outputs Y and Z.
(a)  Write an equation for the output Y if we want Y to be 1 iff the flow rate is less 
than 30 gallons per minute.
(b)  Write an equation for the output Z if we want Z to be 1 iff the flow rate is at least 
20 gallons per minute but less than 50 gallons per minute.
Applications of Boolean Algebra Minterm and Maxterm Expansions  115
4.3 Given F1=Σ m(0, 4, 5, 6 ) and F2=Σ m(0, 3, 6, 7 ) find the minterm expression 
for F1+F2. State a general rule for finding the expression for F1+F2 given the 
 minterm expansions for F1 and F2. Prove your answer by using the general form of 
the  minterm expansion.
4.4 (a) How many switching functions of two variables ( x and y) are there?
(b) Give each function in truth table form and in reduced algebraic form.
4.5 A combinational circuit is divided into two subcircuits N1 and N2 as shown. The 
truth table for N1 is given. Assume that the input combinations ABC=110 and 
ABC=010 never occur. Change as many of the values of D, E, and F to don’t-cares 
as you can without changing the value of the output Z.
4.6 Work (a) and (b) with the following truth table:
(a)  Find the simplest expression for F, and specify the values of the don’t-cares that 
lead to this expression.
(b)  Repeat (a) for G. (Hint: Can you make G the same as one of the inputs by prop-
erly choosing the values for the don’t-care?)
4.7 Each of three coins has two sides , heads and tails . Represent the heads or tails status 
of each coin by a logical variable ( A for the first coin, B for the second coin, and C 
for the third) where the logical variable is 1 for heads and 0 for tails . Write a logic 
function F(A, B, C ) which i s 1 iff exactly one of the coin s is head s after a to ss of the 
coins . Express F
(a) as a minterm expansion.
(b) as a maxterm expansion.N1N2
A
B
CD
E
F ZABC DEF
000 1 1 0
001 0 0 1010 0 1 1011 1 1 1100 1 0 0101 1 0 1110 0 1 0111 0 0 0
A B C F G
000 1 0001
X1
010 0 X
011 0 1100 0 0101
X1
110 1 X
111 1 1
116 Unit 4
4.8 A switching circuit has four inputs as shown. A and B represent the first and second 
bits of a binary number N1. C and D  represent the first and second bits of a binary 
number N2. The output is to be 1 only if the product N1×N2 is less than or equal to 2.
(a) Find the minterm expansion for F.
(b) Find the maxterm expansion for F.
Express your answers in both decimal notation and algebraic form.
4.9 Given: F (a, b, c )=abc ′+b′.
(a) Express F as a minterm expansion. (Use m -notation.)
(b) Express F as a maxterm expansion. (Use M -notation.)
(c) Express F ′ as a minterm expansion. (Use m -notation.)
(d) Express F ′ as a maxterm expansion. (Use M - notation.)
4.10 Work Problem 4.9 using:
F(a, b, c , d)=(a+b+d)(a′+c)(a′+b′+c′)(a+b+c′+d′)
4.11 (a) Implement a full subtracter using a minimum number of gates.
(b) Compare the logic equations for the full adder and full subtracter. What is the 
relation between si and di? Between ci+1 and bi+1?
4.12 Design a circuit which will perform the following function on three 4-bit numbers:
(X3 X2 X1 X0+Y3Y2Y1Y0)−Z3Z2Z1Z0
It will give a result S3S2S1S0, a carry, and a borrow. Use eight full adders and any other 
type of gates. Assume that negative numbers are represented in 2’s complement.
4.13 A combinational logic circuit has four inputs ( A, B, C, and D ) and one output Z. 
The output is 1 iff the input has three consecutive 0’s or three consecutive 1’s. For example, if 
A=1, B=0, C=0, and D=0, then Z=1, but if A=0, B=1, C=0, 
and D=0, then Z=0. Design the circuit using one four-input OR gate and four 
three-input AND gates.
4.14 Design a combinational logic circuit which has one output Z and a 4-bit input 
ABCD representing a binary number. Z should be 1 iff the input is at least 5, but is 
no greater than 11. Use one OR gate (three inputs) and three AND gates (with no more than three inputs each).
4.15 A logic circuit realizing the function 
f has four inputs A, B, C, and D . The three inputs 
A, B, and C are the binary representation of the digits 0 through 7 with A being the 
most-significant bit. The input D is an odd-parity bit, i.e., the value of D is such that A
FB
C
DN1
N2
Applications of Boolean Algebra Minterm and Maxterm Expansions  117
A, B, C, and D  always contain an odd number of 1’s. (For example, the digit 1 is rep-
resented by ABC=001 and D=0, and the digit 3 is represented by ABCD=0111.) 
The function f has value 1 if the input digit is a prime number. (A number is prime if 
it is divisible only by itself and 1; 1 is considered to be prime and 0 is not.)
(a) List the minterms and don’t-care minterms of f in algebraic form.
(b) List the maxterms and don’t-care maxterms of f in algebraic form.
4.16 A priority encoder circuit has four inputs, x3, x2, x1, and x0. The circuit has three out-
puts: z, y1, and y0. If one of the inputs is 1, z is 1 and y1 and y0 represent a 2-bit, binary 
number whose value equals the index of the highest numbered input that is 1. For 
example, if x2 is 1 and x3 is 0, then the outputs are z=1 and y1=1 and y0=0. If all 
inputs are 0, z=0 and y1 and y0 are don’t-cares.
(a) List in decimal form the minterms and don’t-care minterms of each output.(b) List in decimal form the maxterms and don’t-care maxterms of each output.
4.17 The 9’s complement of a decimal digit d (0 to 9) is defined to be 
9−d. A logic circuit 
produces the 9’s complement of an input digit where the input and output digits are rep-resented in BCD. Label the inputs 
A, B, C, and D, and label the outputs W, X, Y and Z.
(a) Determine the minterms and don’t-care minterms for each of the outputs.(b) Determine the maxterms and don’t-care maxterms for each of the outputs.
4.18 Repeat Problem 4.17 for the case where the input and output digits are represented 
using the 4-2-2-1 weighted code. (If only one weight of 2 is required for decimal digits less than 5, select the rightmost 2. In addition, select the codes so that W =A′, 
X=B′, Y=C′, and Z =D′. (There are two possible codes with these restrictions.)
4.19 Each of the following sentences has two possible interpretations depending on 
whether the AND or OR is done first. Write an equation for each interpretation.
(a)  The buzzer will sound if the key is in the ignition switch, and the car door is 
open, or the seat belts are not fastened.
(b)  You will gain weight if you eat too much, or you do not exercise enough, and 
your metabolism rate is too low.
(c)  The speaker will be damaged if the volume is set too high, and loud music is 
played, or the stereo is too powerful.
(d) The roads will be very slippery if it snows, or it rains, and there is oil on the road.
4.20 A bank vault has three locks with a different key for each lock. Each key is owned 
by a different person. To open the door, at least two people must insert their keys into the assigned locks. The signal lines 
A, B, and C are 1 if there is a key inserted 
into lock 1, 2, or 3, respectively. Write an equation for the variable Z which is 1 iff 
the door should open.
4.21 A paper tape reader used as an input device to a computer has five rows of holes as 
shown. A hole punched in the tape indicates a logic 1, and no hole indicates a logic 0. 
As each hole pattern passes under the photocells, the pattern is translated into logic signals on lines 
A, B, C, D, and E . All patterns of holes indicate a valid character with 
two exceptions. A pattern consisting of none of the possible holes punched is not 
118 Unit 4
used because it is impossible to distinguish between this pattern and the unpunched 
space between patterns. An incorrect pattern punched on the tape is erased by punching all five holes in that position. Therefore, a valid character punched on the tape will have at least one hole but will not have all five holes punched.
(a) Write an equation for a variable 
Z which is 1 iff a valid character is being read.
(b)  Write an equation for a variable Y which is 1 iff the hole pattern being read has 
holes punched only in rows C and E.
4.22 A computer interface to a line printer has seven data lines that control the move-
ment of the paper and the print head and determine which char acter to print. The 
data lines are labeled A, B, C, D, E, F, and G, and each represents a binary 0 or 1. 
When the data lines are interpreted as a 7-bit binary number with line A being the 
most significant bit, the data lines can represent the numbers 0 to 12710. The number 
1310 is the command to return the print head to the beginning of a line, the number 
1010 means to advance the paper by one line, and the numbers 3210 to 12710 represent 
printing characters.
(a)  Write an equation for the variable X which is 1 iff the data lines indicate a com-
mand to return the print head to the beginning of the line.
(b)  Write an equation for the variable Y which is 1 iff there is an advance paper 
command on the data lines.
(c)  Write an equation for the variable Z which is 1 iff the data lines indicate a print-
able character. ( Hint: Consider the binary representations of the numbers 0–31 
and 32–127 and write the equation for Z with only two terms.)
4.23 Given F1=Π M(0, 4, 5, 6 ) and F2=Π M(0, 4, 7 ), find the maxterm expansion for F1F2.
State a general rule for finding the maxterm expansion of F1F2 given the maxterm 
expansions of F1 and F2.
Prove your answer by using the general form of the maxterm expansion.
4.24 Given F1=Π M(0, 4, 5, 6 ) and F2=Π M(0, 4, 7 ), find the maxterm expansion for 
F1+F2.
State a general rule for finding the maxterm expansion of F1+F2, given the max-
term expansions of F1 and F2.
Prove your answer by using the general form of the maxterm expansion.
4.25 Four chairs are placed in a row:Photocells
Variables
A
B
C
D
E
A B C D
Applications of Boolean Algebra Minterm and Maxterm Expansions  119
Each chair may be occupied (1) or empty (0). Give the minterm and maxterm expan-
sion for each logic function described.(a) F
(A, B, C, D ) is 1 iff there are no adjacent empty chairs.
(b) G(A, B, C, D ) is 1 iff the chairs on the ends are both empty.
(c) H(A, B, C, D ) is 1 iff at least three chairs are full.
(d)  J(A, B, C, D ) is 1 iff there are more people sitting in the left two chairs than in 
the right two chairs.
4.26 Four chairs ( A, B, C, and D ) are placed in a circle: A next to B, B next to C, C next to 
D, and D  next to A. Each chair may be occupied (1) or empty (0). Give the minterm 
and maxterm expansion for each of the following logic functions:
(a) F(A, B, C, D ) is 1 iff there are no adjacent empty chairs.
(b) G(A, B, C, D ) is 1 iff there are at least three adjacent empty chairs.
(c) H(A, B, C, D ) is 1 iff at least three chairs are full.
(d)  J(A, B, C, D ) is 1 iff there are more people sitting in chairs A and B than chairs 
C and D .
4.27 Given f(a, b, c )=a(b+c′).
(a) Express f as a minterm expansion (use m -notation).
(b) Express f as maxterm expansion (use M-notation).
(c) Express f ′ as a minterm expansion (use m -notation).
(d) Express f ′ as a maxterm expansion (use M-notation).
4.28 Work Problem 4.27 using f(a, b, c , d)=acd+bd′+a′c′d+ab ′cd+a′b′cd ′.
4.29 Find both the minterm expansion and maxterm expansion for the following func-
tions, using algebraic manipulations:
(a) f(A, B, C, D )=AB+A′CD
(b) f(A, B, C, D )=(A+B+D′)(A′+C)(C+D)
4.30 Given F ′(A, B, C, D )=Σ m(0, 1, 2, 6, 7, 13, 15 ).
(a) Find the minterm expansion for F (both decimal and algebraic form).
(b) Find the maxterm expansion for F (both decimal and algebraic form).
4.31 Repeat Problem 4.30 for F ′(A, B, C, D )=Σ m(1, 2, 5, 6, 10, 15 ).
4.32 Work parts (a) through (d) with the given truth table.
A BC F1F2F3F4
00 0 1 1 01
00 1 X00 0
01 0 0 1 X 0
01 1 0 0 1110 0 0 1 1110 1
X01 0
11 0 0 XX X
11 1 1 X1X
120 Unit 4
(a)  Find the simplest expression for F1, and specify the values for the don’t-cares 
that lead to this expression.
(b) Repeat for F2.
(c) Repeat for F3.
(d) Repeat for F4.
4.33  Work Problem 4.5 using the following circuits and truth table. Assume that the input 
combinations of ABC=011 and ABC=110 will never occur.
4.34  Work Problem 4.7 for the following logic functions:
(a) G1(A, B, C ) is 1 iff all the coins landed on the same side (heads or tails).
(b) G2(A, B, C ) is 1 iff the second coin landed on the same side as the first coin.
4.35  A combinational circuit has four inputs (A, B, C, D ) and three outputs (X, Y, Z ). 
XYZ represents a binary number whose value equals the number of 1’s at the input. 
For example if ABCD=1011, XYZ=011.
(a) Find the minterm expansions for X, Y, and Z.
(b) Find the maxterm expansions for Y and Z.
4.36  A combinational circuit has four inputs (A, B, C, D ) and four outputs (W, X, Y, Z ). 
WXYZ represents an excess-3 coded number whose value equals the number of 1’s 
at the input. For example, if ABCD=1101, WXYZ =0110.
(a) Find the minterm expansions for X, Y, and Z.
(b) Find the maxterm expansions for Y and Z.
4.37 A combinational circuit has four inputs (A, B, C, D ), which represent a binary-
coded-decimal digit. The circuit has two groups of four outputs— S, T, U, V, and 
W, X, Y, Z. Each group represents a BCD digit. The output digits represent a deci-
mal number which is five times the input number. For example, if ABCD=0111, 
the outputs are 0011 0101. Assume that invalid BCD digits do not occur as inputs.
(a) Construct the truth table.(b)  Write down the minimum expressions for the outputs by inspection of the truth 
table. (Hint: Try to match output columns in the table with input columns.)
4.38 Work Problem 4.37 where the BCD outputs represent a decimal number that is 1 
more than four times the input number. For example, if 
ABCD=0011, the outputs 
are 0001 0011 .N1N2
A
B
CD
E
FZAB C D EF
00 0 110
00 1 01001 0 00101 1 00010 0 01010 1 00111 0 00111 1 101
Applications of Boolean Algebra Minterm and Maxterm Expansions  121
4.39 Design a circuit which will add a 4-bit binary number to a 5-bit binary number. Use 
five full adders. Assume negative numbers are represented in 2’s complement. (Hint: 
How do you make a 4-bit binary number into a 5-bit binary number, without mak-ing a negative number positive or a positive number negative? Try writing down the representation for 
–3 as a 3-bit 2’s complement number, a 4-bit 2’s complement 
number, and a 5-bit 2’s complement number. Recall that one way to find the 2’s complement of a binary number is to complement all bits to the left of the first 1.)
4.40 A half adder is a circuit that adds two bits to give a sum and a carry. Give the truth 
table for a half adder, and design the circuit using only two gates. Then design a circuit which will find the 2’s complement of a 4-bit binary number. Use four half adders and any additional gates. ( Hint: Recall that one way to find the 2’s comple-
ment of a binary number is to complement all bits, and then add 1.)
4.41 (a)  Write the switching function 
f(x, y)=x+y as a sum of minterms and as a prod-
uct of maxterms.
(b) Consider the Boolean algebra of four elements 50, 1, a, b6 specified by the 
following operation tables and the Boolean function f(x, y)=ax+by where a 
and b are two of the elements in the Boolean algebra. Write f(x, y) in a sum-of- 
minterms form.
(c) Write the Boolean function of part (b) in a product-of-maxterms form.
(d) Give a table of combinations for the Boolean function of part (b). ( Note: The 
table of combinations has 16 rows, not just 4.)
(e) Which four rows of the table of combinations completely specify the function of 
part (b)? Verify your answer.
4.42 (a) If m1 and m2 are minterms of n  variables, prove that m1+m2=m1⊕m2.
(b) Prove that any switching function can be written as the exclusive OR sum 
of  products where each product does not contain a complemented literal. (Hint: Start with the function written as a sum of minterms and use part (a).)
4.43 (a)  Show that the full adder of Figure 4-5 can be implemented using two 2-input 
exclusive OR gates and three 2-input NAND gates. (Hint: Rewrite Equation (4-2) 
in terms of 
X  ⊕  Y.)
(b) Compare the maximum addition time of the ripple-carry adder of Figure 4-3 
using the full adder of part (a) versus the full adder of Figure 4-5 assuming the same gate types are used in both.
4.44 Show that a full subtractor can be implemented using two 2-input exclusive OR 
gates, one inverter, and three 2-input NOR gates. (Hint: Write the borrow out equa-tion in product-of-sums form.)′ +01 ab ·01 ab
01 00 1 ab 00 0 0 0
10 11 1 1 1 1 0 1 ab
ab aa 1a1 a0aa 0
ba bb11 b b0b0b
122 Unit 4
4.45 The full adder of Figure 4-5 is modified by adding two control inputs, E1 and E0, and 
implemented as shown in the figure below.
(a)  For each combination of values for E1 and E0, give the algebraic expression for 
the outputs of the full adder.
(b)  Assume this modified full adder is used in the parallel adder of Figure 4-3. For 
each combination of values for E1 and E0, specify the function (Add, Exclusive 
OR, etc.) performed by the parallel adder.
4.46 Redo Problem 4.45 if gates G1 and G2 are NAND gates rather than AND gates.
4.47 Redo Problem 4.45 if gates G1 and G2 are NOR gates rather than AND gates and 
an inverter is inserted in the ci input of G2.
4.48 Redo Problem 4.45 if gates G1 and G2 are OR gates rather than AND gates and 
an inverter is inserted in the ci input of G2.E1′biE1E0ai
ai
bi
ci
aiE0
biG1
G2
ci
bi
cici+1si
123Karnaugh MapsUNIT
5
Objectives
1. Given a function (completely or incompletely specified) of three to five 
 variables, plot it on a Karnaugh map. The function may be given in minterm, maxterm, or algebraic form.
2. Determine the essential prime implicants of a function from a map.
3. Obtain the minimum sum-of-products or minimum product-of-sums form of a function from the map.
4. Determine all of the prime implicants of a function from a map.
5. Understand the relation between operations performed using the map and the corresponding algebraic operations.
124 Unit 5
Study Guide
In this unit we will study the Karnaugh (pronounced “car-no”) map. Just about any 
type of algebraic manipulation we have done so far can be facilitated by using the map, provided the number of variables is small.
1. Study Section 5.1, Minimum Forms of Switching Functions.
(a) Define a minimum sum of products.
(b) Define a minimum product of sums.
2. Study Section 5.2, Two- and Three-Variable Karnaugh Maps.
(a) Plot the given truth table on the map. Then, loop two pairs of 1’s on the 
map and write the simplified form of 
F.
Now simplify F algebraically and verify that your answer is correct.
(b) F(a, b, c) is plotted below. Find the truth table for F.P Q F
0 0 1
0 1 11 0 01 1 101
0QP
FF =1
0 101
1 1
0 1
100bc
Fa
01
1110
0a b c F
0 0 0
0 0 10 1 00 1 11 0 01 0 11 1 01 1 1
Karnaugh Maps  125
(c) Plot the following functions on the given Karnaugh maps:
F1(R, S, T)=Σ m(0, 1, 5, 6)F2(R, S, T)=Π  M(2, 3, 4, 7)
Why are the two maps the same?
(d) Plot the following function on the given map:
f(x, y, z)=z′ +  x′z +  yz
Do not make a minterm expansion or a truth table before plotting.
(e) For a three-variable map, which squares are “adjacent” to square 2? 
_____________
(f  ) What theorem is used when two terms in adjacent squares are combined?
(g) What law of Boolean algebra justifies using a given 1 on a map in two or 
more loops?01
00
01
11
1001
00
01
11
10
01
00yzx
01
11
10
126 Unit 5
(h) Each of the following solutions is not minimum.
In each case, change the looping on the map so that the minimum solution 
is obtained.
(i) Work Problem 5.3.(j) Find two different minimum sum-of-products expressions for the func-
tion G , which is plotted below.
3. Study Section 5.3, Four-Variable Karnaugh Maps.
(a) Note the locations of the minterms on three- and four-variable maps 
(Figures 5-3(b) and 5-10). Memorize this ordering. This will save you a lot of time when you are plotting Karnaugh maps.
This ordering is valid only for the order of the variables given. If we label 
the maps as shown below, fill in the locations of the minterms:1 1
1
1 1
100bc
Ga
01
11101 101 01
1
1 1
100bc
GG =
G =a
011110
00 01 11 10
00ABCD
01111000 01 11 10
0ABC
11
1
100bc
f = ab ′ + abc g = a′ + aba
01
11
10101 01
1
1 1
100bca
01
11
10 1
Karnaugh Maps  127
(b) Given the following map, write the minterm and maxterm expansions for F 
in decimal form:
(c) Plot the following functions on the given maps:
(1) f (w, x, y, z)=Σ m(0, 1, 2, 5,  7,  8,  9,  10,   13,   14)
(2) f (w, x, y, z)=x′z′ +  y′z+w′xz  +  wyz ′
Your answers to (1) and (2) should be the same.
(d) For a four-variable map, which squares are adjacent to square 14? ________
To square 8? _________
(e) When we combine two adjacent 1’s on a map, this corresponds to applying 
the theorem xy ′ +  xy=x to eliminate the variable in which the two terms 
differ. Thus, looping the two 1’s as indicated on the following map is equiva-
lent to combining the corresponding minterms algebraically:1 100 01 11 10
1 1 1
1 100cdab
01
1110
1F =
F =
00 01 11 10
00yzwx
01
111000 01 11 10
00yzwx
011110
100 01 11 10
1 1
1 100cdab
01
11
10 1a′b′c′d + ab ′c′d = b′c′d
[The term b′c′d can be read directly from the
map because it spans the first and last columns
(b′) and because it is in the second row (c′d).]
128 Unit 5
Loop two other pairs of adjacent 1’s on this map and state the algebraic 
equivalent of looping these terms. Now read the loops directly off the map and check your algebra.
(f  ) When we combine four adjacent 1’s on a map (either four in a line or four 
in a square) this is equivalent to applying 
xy+xy′=x three times:
Loop the other four 1’s on the map and state the algebraic equivalent.
(g) For each of the following maps, loop a minimum number of terms which 
will cover all of the 1’s.
(For each part you should have looped two groups of four 1’s and two 
groups of two 1’s).Write down the minimum sum-of-products expression for 
f1 and f2 from 
these maps.
f1 = __________________________________________________
f2 = __________________________________________________
(h) Why is it not possible to combine three or six minterms together rather 
than just two, four, eight, etc.?a′b′cd + a′b′cd′ + ab′cd + ab′cd′ = a′b′c + ab′c = b′c100 01 11 10
1
1 1 1
100cdab
01
1110
1 1
1 100 01
f1 f211 10
1 1 1
1 100cdab
01
11
10 1100 01 11 10
1
1 1 1 1
100cdab
01
11
10 1
Karnaugh Maps  129
(i) Note the procedure for deriving the minimum product of sums from the 
map. You will probably make fewer mistakes if you write down f  ′ as a sum 
of products first and then complement it, as illustrated by the example in 
Figure 5-14.
 ( j) Work Problems 5.4 and 5.5.
4. Study Section 5.4, Determination of Minimum Expressions Using Essential 
Prime Implicants.
(a) For the map of Figure 5-15, list three implicants of F other than those which 
are labeled.
For the same map, is ac ′d′ a prime implicant of F?  
Why or why not?
(b) For the given map, are any of the circled 
terms prime implicants?
Why or why not?
5. Study Figure 5-18 carefully and then answer the following questions for the 
given map:
(a) How many 1’s are adjacent to m0?
(b) Are all these 1’s covered by a single prime 
implicant?
(c) From your answer to (b), can you determine 
whether B ′C′ is essential?
(d) How many 1’s are adjacent to m9?
(e) Are all of these 1’s covered by a single prime 
implicant?
(f  ) From your answer to (e), is B ′C′ essential?
(g) How many 1’s are adjacent to m7?
(h) Why is A′C essential?
(i) Find two other essential prime implicants and tell which minterm makes 
them essential.100 01 11 10
1 1 1
1 100CDAB
01
11
10 1 1
1
01
4100 01 11 10
8
1
11
9
1
31
7
100CDAB
01
11
10
21
61
10
130 Unit 5
6. (a)  How do you determine if a prime implicant is essential using a Karnaugh map?
(b) For the following map, why is A′B′not essential?
Why is BD ′ essential?
Is A′D′ essential? Why?
Is BC′ essential? Why?
Is B ′CD essential? Why?
Find the minimum sum of products.
(c) Work Programmed Exercise 5.1.
(d) List all 1’s and X’s that are adjacent to 10.1 1 100 01 11 10
1 1 1
1 1
100CDAB
01
11
10 1 1
10 14 11200 01 11 10
8
X1 15 X13 9
3 X7 115 11100CDAB
01
11
102 6 X14 10
Why is A′C′ an essential prime implicant?
List all 1’s and X’s adjacent to 115.
Karnaugh Maps  131
Based on this list, why can you not find an essential prime implicant that 
covers 115?
Does this mean that there is no essential prime implicant that covers 115?
What essential prime implicant covers 111?
Can you find an essential prime implicant that covers 112? Explain.
Find two prime implicants that cover 112.
Give two minimum expressions for F.
(e) Work Problem 5.6.
(f  ) If you have a copy of the LogicAid program available, use the Karnaugh 
map tutorial mode to help you learn to find minimum solutions from  Karnaugh maps. This program will check your work at each step to make sure that you loop the terms in the correct order. It also will check your final answer. Work Problem 5.7 using the Karnaugh map tutor.
7. (a) In Example 4, page 107 , we derived the following function:
Z=
 Σ m(0, 3, 6, 9) +  Σ d(10, 11, 12, 13, 14, 15)
Plot Z on the given map using X’s to represent don’t-care terms.
00 01 11
Z10
00CDAB
01
1110
(b) Show that the minimum sum of products is
Z=A′B′C′D′+B′CD+AD +BCD ′
Which four don’t-care minterms were assigned the value 1 when forming 
your solution?
132 Unit 5
(c) Show that the minimum product of sums for Z is
Z=(B′+C )(B′ +  D′)(A′ +D)(A  +  C+D′)(B +  C′ +  D)
Which one don’t-care term of Z was assigned the value 1 when forming 
your solution?
(d) Work Problem 5.8.
8. Study Section 5.5, Five-Variable Karnaugh Maps.
(a) The figure below shows a three-dimensional five-variable map. Plot the 1’s 
and loops on the corresponding two-dimensional map, and give the mini-
mum sum-of-products expression for the function.
(b) On a five-variable map (Figure 5-21), what are the five minterms adjacent 
to minterm 24?
(c) Work through all of the examples in this section carefully and make sure 
that you understand all of the steps.
(d) Two minimum solutions are given for Figure 5-24. There is a third mini-
mum sum-of-products solution. What is it?
(e) Work Programmed Exercise 5.2.0000
00
01
11
1001 11 10
01 11 10
00
1
0DE
ABC
01
11
10DE
A = 1
F =A = 0BC
11
11
1111
Karnaugh Maps  133
Find the three 1’s and X’s adjacent to 118. Can these all be looped with a 
single loop?
Find the 1’s and X’s adjacent to 124. Loop the essential prime implicant that 
covers 124.
Find the 1’s and X’s adjacent to 13. Loop the essential prime implicant that 
covers 13.
Can you find an essential prime implicant that covers 122? Explain.
Find and loop two more essential prime implicants.Find three ways to cover the remaining 1 on the map and give the corre-sponding minimum solutions.
(g) If you have the LogicAid program available, work Problem 5.9, using the 
Karnaugh map tutor.
9. Study Section 5.6, Other Uses of Karnaugh Maps. Refer to Figure 5-8 and note that a consensus term exists if there are two adjacent, but nonoverlapping prime implicants. Observe how this principle is applied in Figure 5-26.
10. Work Problems 5.10, 5.11, 5.12, and 5.13. When deriving the minimum solution from the map, always write down the essential prime implicants first. If you do not, it is quite likely that you will not get the minimum solution. In addition, make sure you can find all of the prime implicants from the map (see Problem 5.10(b)).
11. Review the objectives.0 4 1200 01 11 10
8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 14XX 1
X 1
X 1
11 XX1
11 1X
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26(f  ) 
134Switching functions can generally be simplified by using the algebraic techniques 
described in Unit 3. However, two problems arise when algebraic procedures are used:
1. The procedures are difficult to apply in a systematic way.
2. It is difficult to tell when you have arrived at a minimum solution.
The Karnaugh map method studied in this unit and the Quine-McCluskey proce-
dure studied in Unit 6 overcome these difficulties by providing systematic methods for simplifying switching functions. The Karnaugh map is an especially useful tool for simplifying and manipulating switching functions of three or four variables, but it can be extended to functions of five or more variables. Generally, you will find the Karnaugh map method is faster and easier to apply than other simplification methods.
5.1 Minimum Forms of Switching Functions
When a function is realized using AND and OR gates, the cost of realizing the func-tion is directly related to the number of gates and gate inputs used. The  Karnaugh 
map techniques developed in this unit lead directly to minimum cost two-level  circuits composed of AND and OR gates. An expression consisting of a sum of product terms corresponds directly to a two-level circuit composed of a group of AND gates feeding a single OR gate (see Figure 2-5). Similarly, a product-of-sums expression corresponds to a two-level circuit composed of OR gates feeding a sin-gle AND gate (see Figure 2-6). Therefore, to find minimum cost two-level AND-OR gate circuits, we must find minimum expressions in sum-of-products or product- of-sums form.
A minimum sum-of-products expression for a function is defined as a sum 
of  product terms which (a) has a minimum number of terms and (b) of all those  expressions which have the same minimum number of terms, has a minimum number of literals. The minimum sum of products corresponds directly to a minimum  two-level 
gate circuit which has (a) a minimum number of gates and (b) a minimum number Karnaugh Maps
Karnaugh Maps  135
Find a minimum sum-of-products expression for
(5-1) a′b′ b′c bc′ abF a′b′c′ a′b′c a′bc′ ab′c abc′ abcF(a, b, c ) mΣ (0, 1, 2, 5, 6, 7)
None of the terms in the above expression can be eliminated by consensus.  However, 
combining terms in a different way leads directly to a minimum sum of products:
(5-2) a′b′ bc′ acF a′b′c′ a′b′c a′bc′ ab′c abc′ abc
If the uniting theorem is applied to all possible pairs of minterms, six two-literal products are obtained: a ′b′,
 a′c′, b′c, bc ′, ac, ab. Then, the consensus theorem can be 
applied to obtain a second minimal solution:
 a′c′+b′c+ab (5-3)
A minimum product-of-sums expression for a function is defined as a product of 
sum terms which (a) has a minimum number of terms, and (b) of all those expres-
sions which have the same number of terms, has a minimum number of literals. Unlike the maxterm expansion, the minimum product-of-sums form of a function is not necessarily unique. Given a maxterm expansion, the minimum product of sums can often be obtained by a procedure similar to that used in the minimum sum-of-products case, except that the uniting theorem 
(X+Y)(X+Y′) =X is used to 
combine terms.of gate inputs. Unlike the minterm expansion for a function, the minimum sum of 
products is not necessarily unique; that is, a given function may have two  different minimum sum-of-products forms, each with the same number of terms and the same number of literals. Given a minterm expansion, the minimum sum-of-products form can often be obtained by the following procedure:
1. Combine terms by using the uniting theorem 
XY′+XY=X. Do this repeat-
edly to eliminate as many literals as possible. A given term may be used more 
than once because X+X=X.
2. Eliminate redundant terms by using the consensus theorem or other theorems.
Unfortunately, the result of this procedure may depend on the order in which terms are combined or eliminated so that the final expression obtained is not necessarily minimum.
Example
136 Unit 5
C′ D) (C′ D)(A B′ D′)
(A B′ D′)
(A B′ D′)((A B′ C′)(A B′ C′) (B C′ D) (B′ C′ D)(A′ B C′ D) (A B′ C D′)(A B′ C′ D′)(A B′ C′ D)(A′ B′ C′ D)(A B C′ D)
(5-4)eliminate by consensus
The uniting theorem XY′+XY=X can be applied to minterms and products where 
the minterms and products are represented in algebraic notation or binary notation. 
The first four-variable example below illustrates this for minterms and the second for products containing three literals. The dash indicates a missing variable.
ab ′cd ′+ab ′cd=ab ′c
1
 0 1 0+  1 0 1 1=101–
ab ′c+abc=ac
1 0 1–+111– =1–1–
Note that minterms only combine if they differ in one variable, and products only combine if they have dashes in the same position (same missing variables) and differ in one other variable. The examples below do not combine.
ab ′cd ′+ab ′c′d
 (will  not combine)
10  10+1001
ab ′c+abd (will  not combine)
1  0  1–+11–1
The Karnaugh maps introduced next arrange the minterms of a function so that it is easy to recognize visually when the simplification theorem applies to two minterms, two products with one missing variable, two products with two missing  variables, etc.
5.2 Two- and Three-Variable Karnaugh Maps
Just like a truth table, the Karnaugh map of a function specifies the value of the func-tion for every combination of values of the independent variables. A two-variable Karnaugh map is shown. The values of one variable are listed across the top of the map, and the values of the other variable are listed on the left side. Each square of the map corresponds to a pair of values for 
A and B  as indicated.Example
Karnaugh Maps  137
Figure 5-1 shows the truth table for a function F and the corresponding  Karnaugh 
map. Note that the value of F for A=B=0 is plotted in the upper left square, and 
the other map entries are plotted in a similar way in Figure 5-1(b). Each 1 on the 
map corresponds to a minterm of F. We can read the minterms from the map just 
like we can read them from the truth table. A 1 in square 00 of Figure 5-1(c) indi-cates that 
A′B′ is a minterm of F. Similarly, a 1 in square 01 indicates that A′B is a 
minterm. Minterms in adjacent squares of the map can be combined since they differ in only one variable. Thus, 
A′B′ and A′B combine to form A′, and this is indicated by 
looping the corresponding 1’s on the map in Figure 5-1(d).
Figure 5-2 shows a three-variable truth table and the corresponding Karnaugh 
map (see Figure 5-27 for an alternative way of labeling maps). The value of one vari-able 
(A) is listed across the top of the map, and the values of the other two variables 
(B, C) are listed along the side of the map. The rows are labeled in the sequence 
00, 01, 11, 10 so that values in adjacent rows differ in only one variable. For each combination of values of the variables, the value of 
F is read from the truth table 
and plotted in the appropriate map square. For example, for the input combination 
ABC=001, the value F=0 is plotted in the square for which A=0 and B C=01. 
For the combination ABC=110, F=1 is plotted in the A=1, BC=10 square.01
0BA
A = 1, B = 0
1A = 1, B = 1A = 0, B = 0
A = 0, B = 1
01
0BA
110
10A′B′ + A ′B = A ′
F = A′
(d)0BA
101
1010
(b)A BF
0 
0 
1 
1 01
11
00
10
(a)0BA
1A′B′
A′B01
10
10
(c)F = A ′B′ + A ′BFIGURE 5-1
FIGURE 5-2
Truth Table and 
Karnaugh Map 
for Three-Variable 
Function
© Cengage Learning 20140 101
0 0
1 0
100
ABC = 001, F = 0
ABC = 110, F = 1BCA
01
1110
1
F
(b)A B C F
0 0 0 0
0 0 1 00 1 0 10 1 1 11 0 0 1
1 0 1 0
1 1 0 1
1 1 1 0
(a)© Cengage Learning 2014
138 Unit 5
Figure 5-3 shows the location of the minterms on a three-variable map. Minterms 
in adjacent squares of the map differ in only one variable and therefore can be com-
bined using the uniting theorem XY′+XY=X. For example, minterm 011 (a′bc) 
is adjacent to the three minterms with which it can be combined—001 ( a′b′c), 010 
(a′bc ′), and 111 (abc). In addition to squares which are physically adjacent, the top 
and bottom rows of the map are defined to be adjacent because the corresponding minterms in these rows differ in only one variable. Thus 000 and 010 are adjacent, and so are 100 and 110.
Given the minterm expansion of a function, it can be plotted on a map by plac-
ing 1’s in the squares which correspond to minterms of the function and 0’s in the remaining squares (the 0’s may be omitted if desired). Figure 5-4 shows the plot of F
(a, b, c)=m1+m3+m5. If F is given as a maxterm expansion, the map is plotted 
by placing 0’s in the squares which correspond to the maxterms and then by filling in the remaining squares with 1’s. Thus, F
(a, b, c)=M0M2M4M6M7 gives the same map 
as Figure 5-4.
Figure 5-5 illustrates how product terms can be plotted on Karnaugh maps. To 
plot the term b , 1’s are entered in the four squares of the map where b=1. The term 
bc ′ is 1 when b=1 and c=0, so 1’s are entered in the two squares in the bc=10 row. 
The term ac ′ is 1 when a=1 and c=0, so 1’s are entered in the a=1 column in the 
rows where c =0.FIGURE 5-3
Location of 
Minterms on a 
Three-Variable 
Karnaugh Map
© Cengage Learning 20140 4
1 5
3 7
200bca
01
11
10 6
(b) Decimal notation000 10001 01
001 101
011 111
01000bca
01
11
10 110
(a) Binary notation100 is
adjacentto 110
FIGURE 5-4
Karnaugh Map of 
F(a, b, c) =
Σ m(1,  3, 5) =
Π M(0, 2, 4, 6, 7)
© Cengage Learning 20140
00
401
1
11
5
1
30
7
000bca
01
11
10
20
6
Karnaugh Maps  139
If a function is given in algebraic form, it is unnecessary to expand it to minterm 
form before plotting it on a map. If the algebraic expression is converted to sum-of-
products form, then each product term can be plotted directly as a group of 1’s on the map. For example, given that
f (a, b, c)=abc ′+b′c+a′
we would plot the map as follows:
Figure 5-6 illustrates how a simplified expression for a function can be derived 
using a Karnaugh map. The function to be simplified is first plotted on a Karnaugh map in Figure 5-6(a). Terms in adjacent squares on the map differ in only one vari-able and can be combined using the uniting theorem 
XY′+XY=X. Thus a′b′c 
and a′bc combine to form a′c, and a′b′c and ab ′c combine to form b′c, as shown 
in Figure 5-6(b). A loop around a group of minterms indicates that these terms have been combined. The looped terms can be read directly off the map. Thus, for Figure 5-6(b), term T
1 is in the a =0 (a′) column, and it spans the rows where c=1, 
so T1=a′c. Note that b has been eliminated because the two minterms in T1 differ 
in the variable b . Similarly, the term T2 is in the bc =01 row so T2=b′c, and a  has 
been eliminated because T2 spans the a =0 and a =1 columns. Thus, the minimum 
sum-of-products form for F is a ′c+b′c.FIGURE 5-5 
Karnaugh Maps for 
Product Terms
© Cengage Learning 2014
bb = 1 in
these rowsa = 1 in
this colum n
c = 0 in
these rows
1 1
100bca
01
11
10 1
bc′100bca
01
11
10 1101 01 01
ac′00bca
01
11
10 1
101
1 1
1
100bca
01
1110
11.   The term abc′ is 1 when a = 1 and bc = 10, so
      we place a 1 in the square which corresponds
      to the a = 1 column and the bc = 10 row of the
      map.
2.   The term b′c is 1 when bc = 01, so we place 1’s
      in both squares of the bc = 01 row of the map.
3.   The term a′ is 1 when a = 0, so we place 1’s in
      all the squares of the a = 0 column of the map.      (Note: Since there already is a 1 in the abc =      001 square, we do not have to place a second
      1 there because x + x = x.)
abc ′
140 Unit 5
FIGURE 5-8
Karnaugh Maps 
that Illustrate the 
Consensus Theorem
© Cengage Learning 201401
1
1 100yzx
01
11
10 1x′z
xy
xy + x′z + yz = xy + x′zyz (consensus term)01
1
1 100yzx
01
11
10 1The map for the complement of F (Figure 5-7) is formed by replacing 0’s with 
1’s and 1’s with 0’s on the map of F. To simplify F′, note that the terms in the top 
row combine to form b ′c′, and the terms in the bottom row combine to form bc ′. 
Because b′c′ and bc ′ differ in only one variable, the top and bottom rows can then 
be combined to form a group of four 1’s, thus eliminating two variables and leav-
ing T1=c′. The remaining 1 combines, as shown, to form T2=ab, so the minimum 
sum- of-products form for F′ is c ′+ab.
The Karnaugh map can also illustrate the basic theorems of Boolean algebra. 
Figure 5-8 illustrates the consensus theorem, XY+X′Z+YZ=XY+X′Z. Note 
that the consensus term (YZ) is redundant because its 1’s are covered by the other 
two terms.FIGURE 5-6
Simplification of 
a Three-Variable 
Function
© Cengage Learning 201401
1 1
100bca
01
11
100
F = Σ m(1, 3, 5) F = a′c + b′c
(a) Plot of minterms (b) Simplified form of F1
1 1
100bca
01
11
10T1
=a′b′c + a′bc
= a′cT2
= a′b′c + ab ′c
= b′c
FIGURE 5-7
Complement 
of Map in 
Figure 5-6(a)
© Cengage Learning 20141 101
0 0
0 1
100bca
01
11
10 1T1 = b′c′ + bc ′ = c′T2 = ab
Karnaugh Maps  141
If a function has two or more minimum sum-of-products forms, all of these forms 
can be determined from a map. Figure 5-9 shows the two minimum solutions for 
F= Σ m(0, 1, 2, 5, 6, 7).
5.3 Four-Variable Karnaugh Maps
Figure 5-10 shows the location of minterms on a four-variable map. Each minterm is located adjacent to the four terms with which it can combine. For example, m
5 (0101 ) 
could combine with m1 (0001 ), m4 (0100 ), m7 (0111 ), or m13 (1101 ) because it differs 
in only one variable from each of the other minterms. The definition of adjacent squares must be extended so that not only are top and bottom rows adjacent as in the three-variable map, but the first and last columns are also adjacent. This requires numbering the columns in the sequence 00, 01, 11, 10 so that minterms 0 and 8, 1 and 9, etc., are in adjacent squares.
We will now plot the following four-variable expression on a Karnaugh map 
(Figure 5-11):
f (a, b, c, d)=acd  +  a′b +  d′
The first term is 1 when a=c=d=1, so we place 1’s in the two squares which are in 
the a=1 column and cd=11 row. The term a′b is 1 when ab=01, so we place four 
1’s in the ab =01 column. Finally, d ′ is 1 when d =0, so we place eight 1’s in the two 
rows for which d =0. (Duplicate 1’s are not plotted because 1 +1=1.)FIGURE 5-9
Function with Two 
Minimum Forms
© Cengage Learning 201410
F = a′b′ + bc ′ + ac1
1 1
1
100bca
01
1110
110
F = a′c′ + b′c + ab1
1 1
1
100bca
011110
1
FIGURE 5-10
Location 
of Minterms on 
Four-Variable 
Karnaugh Map
© Cengage Learning 20140 4 12 800 01 11 10
1 5 13 9
3 7 15 11
200CDAB
01
11
10 6 14 10
142 Unit 5
Next, we will simplify the functions f1 and f2 given in Figure 5-12. Because the 
functions are specified in minterm form, we can determine the locations of the 1’s on 
the map by referring to Figure 5-10. After plotting the maps, we can then combine adjacent groups of 1’s. Minterms can be combined in groups of two, four, or eight to eliminate one, two, or three variables, respectively. In Figure 5-12(a), the pair of 1’s in the ab =00 column and also in the d=1 rows represents a′b′d. The group of four 
1’s in the b =1 columns and c=
0 rows represents bc ′.
In Figure 5-12(b), note that the four corner 1’s span the b=0 columns and d =0 
rows and, therefore, can be combined to form the term b′d′. The group of eight 1’s 
covers both rows where c=1 and, therefore, represents the term c. The pair of 1’s 
which is looped on the map represents the term a′bd because it is in the ab=01 
column and spans the d =1 rows.
The Karnaugh map method is easily extended to functions with don’t-care terms. 
The required minterms are indicated by 1’s on the map, and the don’t-care minterms are indicated by X’s. When choosing terms to form the minimum sum of products, all FIGURE 5-11 
Plot of 
acd+a′b+d′
© Cengage Learning 20141 1 1 100 01 11 10
1
1 1 1
100cdab
01
11
10 1 1 1a′b
acdd′
1 100 01
f1= Σ m(1, 3, 4, 5, 10, 12, 13)
= bc ′ + a′b′d + ab ′cd ′f2= Σ m(0, 2, 3, 5, 6, 7, 8, 10, 11, 14, 15)
= c + b′d′ + a′bd                               
(a) (b)11 10
1 1 1
1100cdab
01
11
101 100 01 11 10
Four corner terms
combine to give b′d′
1
1 1 1 1
100cdab
01
11
10 1 1 1a′b′d cbc ′
ab ′cd ′a′bdFIGURE 5-12
Simplification 
of Four-Variable 
Functions
© Cengage Learning 2014
Karnaugh Maps  143
the 1’s must be covered, but the X’s are only used if they will simplify the resulting 
expression. In Figure 5-13, the only don’t-care term used in forming the simplified expression is 13.
The use of Karnaugh maps to find a minimum sum-of-products form for a func-
tion has been illustrated in Figures 5-1, 5-6, and 5-12. A minimum product of sums can also be obtained from the map. Because the 0’s of 
f are 1’s of f   ′, the minimum 
sum of products for f   ′ can be determined by looping the 0’s on a map of f. The 
complement of the minimum sum of products for f   ′ is then the minimum product of 
sums for f. The following example illustrates this procedure for
f  =x′z′+wyz+w′y′z′+x′y
First, the 1’s of f are plotted in Figure 5-14. Then, from the 0’s,
f  ′=y′z+wxz ′+w′xy
and the minimum product of sums for f is
f  =(y+z′)(w′+x′+z)(w+x′+y′)FIGURE 5-13
Simplification of 
an Incompletely 
Specified Function
© Cengage Learning 2014X00 01 11 10
1 1 X 1
1 100cdab
01
1110
X
f = Σ m(1, 3, 5, 7, 9) + Σ d(6, 12, 13)
 = a′d + c′d
FIGURE 5-14
© Cengage Learning 2014
1 1 0 100 01 11 10
0 0 0 0
1 0 1 1
100yzwx
011110
0 0 1
144 Unit 5
5.4 Determination of Minimum Expressions 
Using Essential Prime Implicants
Any single 1 or any group of 1’s which can be combined together on a map of the 
function F represents a product term which is called an implicant of F (see Section 6.1 
for a formal definition of implicant and prime implicant). Several implicants of F are 
indicated in Figure 5-15. A product term implicant is called a prime implicant if it 
cannot be combined with another term to eliminate a variable. In Figure 5-15, a′b′c, 
a′cd ′, and ac ′ are prime implicants because they cannot be combined with other 
terms to eliminate a variable. On the other hand, a′b′c′d′ is not a prime implicant 
because it can be combined with a ′b′cd ′ or ab ′c′d′. Neither abc ′, nor ab ′c′is a prime 
implicant because these terms can be combined together to form ac ′.
All of the prime implicants of a function can be obtained from a Karnaugh map. 
A single 1 on a map represents a prime implicant if it is not adjacent to any other 1’s. Two adjacent 1’s on a map form a prime implicant if they are not  contained in a group of four 1’s; four adjacent 1’s form a prime implicant if they are not contained in a group of eight 1’s, etc.
The minimum sum-of-products expression for a function consists of some (but 
not necessarily all) of the prime implicants of a function. In other words, a sum-of-products expression containing a term which is not a prime implicant cannot be mini-mum. This is true because if a nonprime term were present, the expression could be simplified by combining the nonprime term with additional minterms. In order to find the minimum sum of products from a map, we must find a minimum number of prime implicants which cover all of the 1’s on the map. The function plotted in Figure 5-16 has six prime implicants. Three of these prime implicants cover all of the 1’s on the map, and the minimum solution is the sum of these three prime implicants. The shaded loops represent prime implicants which are not part of the minimum solution.
When writing down a list of all of the prime implicants from the map, note that 
there are often prime implicants which are not included in the minimum sum of products. Even though all of the 1’s in a term have already been covered by prime FIGURE 5-15
© Cengage Learning 2014
1 1 100 01 11 10
1 1
1
100cdab
01
11
10 1a′b′c′d′
a′b′cac ′
ab ′c′
abc ′
a′cd ′
Karnaugh Maps  145
implicants, that term may still be a prime implicant provided that it is not included in 
a larger group of 1’s. For example, in Figure 5-16, a′c′d is a prime implicant because 
it cannot be combined with other 1’s to eliminate another variable. However, abd is not a prime implicant because it can be combined with two other 1’s to form ab. The 
term b′cd is also a prime implicant even though both of its 1’s are already covered 
by other prime implicants. In the process of finding prime implicants, don’t-cares are treated just like 1’s. However, a prime implicant composed entirely of don’t-cares can never be part of the minimum solution.
Because all of the prime implicants of a function are generally not needed in 
forming the minimum sum of products, a systematic procedure for selecting prime implicants is needed. If prime implicants are selected from the map in the wrong order, a nonminimum solution may result. For example, in Figure 5-17 , if 
CD is cho-
sen first, then BD, B ′C, and AC are needed to cover the remaining 1’s, and the solu-
tion contains four terms. However, if the prime implicants indicated in Figure 5-17(b) are chosen first, all 1’s are covered and 
CD is not needed.
In Section 6.2, prime implicant charts are defined. They can be used systemati-
cally to find (all) minimum solutions. The procedure described below can be used to find minimum solutions for functions that are not too complicated.
Note that some of the minterms on the map of Figure 5-17(a) can be covered by 
only a single prime implicant, but other minterms can be covered by two different prime implicants. For example, m
2 is covered only by B′C, but m3 is covered by both FIGURE 5-16
Determination of 
All Prime Implicants
© Cengage Learning 20141 100 01 11 10
Minimum solution: F = a′b′d + bc′ + ac
All prime implicants: a′b′d, bc′, ac, a′c′d, ab, b′cd1 1 1
1 1 100cdab
01
11
10 1 1a′c′d
b′cd
FIGURE 5-17
© Cengage Learning 201400 01 11 10
11
1 1 1 1
100CD
m2 m14
f = CD + BD + B′C + AC f = BD + B′C + AC
(a) (b)m5
CDAB
0111
10
100 01 11 10
1 1
1 1 1 1
100CDAB
01
11
10 1 1 1
146 Unit 5
B′C and CD. If a minterm is covered by only one prime implicant, that prime impli-
cant is said to be essential, and it must be included in the minimum sum of products. 
Thus, B′C is an essential prime implicant because m2 is not covered by any other 
prime implicant. However, CD is not essential because each of the 1’s in CD can be 
covered by another prime implicant. The only prime implicant which covers m5 is BD , 
so BD is essential. Similarly, AC is essential because no other prime implicant covers 
m14. In this example, if we choose all of the essential prime implicants, all of the 1’s on 
the map are covered and the nonessential prime implicant CD is not needed.
In general, in order to find a minimum sum of products from a map, we should first 
loop all of the essential prime implicants. One way of finding essential prime implicants on a map is simply to look at each 1 on the map that has not already been covered, and check to see how many prime implicants cover that 1. If there is only one prime implicant which covers the 1, that prime implicant is essential. If there are two or more prime implicants which cover the 1, we cannot say whether these prime implicants are essential or not without checking the other minterms. For simple problems, we can locate the essential prime implicants in this way by inspection of each 1 on the map. For example, in Figure 5-16, m
4 is covered only by the prime implicant bc ′, and m10 is 
covered only by the prime implicant ac. All other 1’s on the map are covered by two 
prime implicants; therefore, the only essential prime implicants are bc ′ and ac .
For more complicated maps, and especially for maps with five or more variables, 
we need a more systematic approach for finding the essential prime implicants. When checking a minterm to see if it is covered by only one prime implicant, we must look at all squares adjacent to that minterm. If the given minterm and all of the 1’s adja-cent to it are covered by a single term, then that term is an essential prime implicant.
1 
If all of the 1’s adjacent to a given minterm are not covered by a single term, then there are two or more prime implicants which cover that minterm, and we cannot say whether these prime implicants are essential or not without checking the other minterms. Figure 5-18 illustrates this principle.
1This statement is proved in Appendix D.FIGURE 5-18
© Cengage Learning 2014
0 41 200 01 11 10
Note: 1’s shaded in blue are coveredby only one prime implicant. Allother 1’s are covered by at least twoprime implicants. 8
15 13 9
3 7 15 1100CD
A′C′
ACD
A′B′D ′AB
01
11
10
26 141
1111
11 1
10
Karnaugh Maps  147
The adjacent 1’s for minterm m0 (l0) are 11, 12, and l4. Because no single term cov-
ers these four 1’s, no essential prime implicant is yet apparent. The adjacent 1’s for 
11 are 10 and 15, so the term which covers these three 1’s (A′C′) is an essential prime 
implicant. Because the only 1 adjacent to 12 is 10, A′B′D′ is also essential. Because 
the 1’s adjacent to 17 (15 and  115) are not covered by a single term, neither A′BD nor 
BCD is essential at this point. However, because the only 1 adjacent to 111 is 115, 
ACD is essential. To complete the minimum solution, one of the nonessential prime 
implicants is needed. Either A′BD or B CD may be selected. The final  solution is
A′C′+A′B′D′+ACD +%   orA′BD
BCD-
If a don’t-care minterm is present on the map, we do not have to check it to 
see if it is covered by one or more prime implicants. However, when checking a 1 
for adjacent 1’s, we treat the adjacent don’t-cares as if they were 1’s because don’t-cares may be combined with 1’s in the process of forming prime implicants. The following procedure can then be used to obtain a minimum sum of products from a Karnaugh map:
1. Choose a minterm (a 1) which has not yet been covered.
2. Find all 1’s and X’s adjacent to that minterm. (Check the n adjacent squares on 
an n-variable map.)
3. If a single term covers the minterm and all of the adjacent 1’s and X’s, then that 
term is an essential prime implicant, so select that term. (Note that don’t-care terms are treated like 1’s in steps 2 and 3 but not in step 1.)
4. Repeat steps 1, 2, and 3 until all essential prime implicants have been chosen.
5. Find a minimum set of prime implicants which cover the remaining 1’s on the map. (If there is more than one such set, choose a set with a minimum number of literals.)
Figure 5-19 gives a flowchart for this procedure. The following example 
(Figure 5-20) illustrates the procedure. Starting with 1
4, we see that the adjacent 1’s 
and X’s (X0, 15, and 16) are not covered by a single term, so no essential prime impli-
cant is apparent. However, 16 and its adjacent 1’s and X’s (14 and X7) are covered 
by A′B, so A′B is an essential prime implicant. Next, looking at 113, we see that its 
adjacent 1’s and X’s (15, 19, and X15) are not covered by a single term, so no essential 
prime implicant is apparent. Similarly, an examination of the terms  adjacent to 18 
and 19 reveals no essential prime implicants. However, 110 has only 18 adjacent to it, 
so AB′D′ is an essential prime implicant because it covers both 110 and 18. Having 
first selected the essential prime implicants, we now choose AC ′D because it covers 
both of the remaining 1’s on the map.
Judicious selection of the order in which the minterms are selected (step 1) 
reduces the amount of work required in applying this procedure. As will be seen in the next section, this procedure is especially helpful in obtaining minimum solutions for five- and six-variable problems.
There are two equivalent methods of obtaining minimum product-of-sum 
expressions for a function 
f. As mentioned above, one method is to find minimum 
a sum-of-products expression for f   ′, and then complement f   ′ to obtain a minimum 
148 Unit 5
FIGURE 5-20
© Cengage Learning 2014
X0 14 1800 01 11 10
Shaded 1’s are covered by
only one prime implicant.15 113 19
X7 X1500CDAB
01
1110
16 110FIGURE 5-19
Flowchart for 
Determining a 
Minimum Sum of 
Products Using a 
Karnaugh Map
© Cengage Learning 2014
Find a minimum set of prime
implicants which cover the
remaining 1’s on the map.That term is an essential
prime implicant. Loop it.Find all adjacent
1’s and X’s.Choose a 1 which has
not been covered.
All
uncovered 1’s
checked?
STOPYESAre the chosen
1 and its adjacent 1’s
and X’s covered by a
single term?
YESNO
NO
Note: All essential prime
implicants have beendetermined at this point.
Karnaugh Maps  149
product-of-sums expression for f. Alternatively, we can perform the dual of the pro-
cedure for finding minimum sum of products. Let S be a sum term. If every input 
combination for which S =0 f is also 0, then S can be a term in a product-of-sums 
expression for F. We will call such a sum term an implicate of f. Implicate S is a prime 
implicate if it cannot be combined with any other implicate to eliminate a literal from 
S. All implicates in a minimum product-of-sums expression for f must be prime 
implicates. The prime implicates of f can be found by looping the largest groups of 
adjacent zeros on the Karnaugh map for f. If a prime implicate is the only prime 
implicate covering a maxterm (zero) of f, then it is an essential prime implicate and 
must be included in any minimum product-of-sums expression for f.
5.5 Five-Variable Karnaugh Maps
A five-variable map can be constructed in three dimensions by placing one  four-variable map on top of a second one. Terms in the bottom layer are numbered 0 through 15 and corresponding terms in the top layer are numbered 16 through 31, so that terms in the bottom layer contain 
A′ and those in the top layer contain A. To rep-
resent the map in two dimensions, we will divide each square in a four-variable map by a diagonal line and place terms in the bottom layer below the line and terms in the top layer above the line (Figure 5-21). Terms in the top or bottom layer combine just like terms on a four-variable map. In addition, two terms in the same square which are separated by a diagonal line differ in only one variable and can be combined. However, some terms which appear to be physically adjacent are not. For  example, terms 0 and 20 are not adjacent because they appear in a different column and a 
FIGURE 5-21
A Five-Variable 
Karnaugh Map
© Cengage Learning 2014
0 4 1200 01 11 10
These eight terms combine to give BD′(B from
last two columns and D′ from top two rows; A is
eliminated because four terms are in the top layerand four in the bottom).8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141 1 1
1 1
11
1111 1
1 1
11
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26These four terms (two from top layer and two
from bottom) combine to yield CDE(C from the
middle two columns and DE from the row).
These two terms in the top layer combine to give AB′DE′.These terms do not combine because they are
in different layers and different columns
(they differ in two variables).
150 Unit 5
 different layer. Each term can be adjacent to exactly five other terms, four in the 
same layer and one in the other layer (Figure 5-22). An alternate representation for five-variable maps is to draw the two layers side-by-side, as in Figure 5-28, but most individuals find adjacencies more difficult to see when this form is used.
When checking for adjacencies, each term should be checked against the five 
possible adjacent squares. (In general, the number of adjacent squares is equal to the number of variables.) Two examples of five-variable minimization using maps follow. Figure 5-23 is a map of
F
(A, B, C, D, E)=Σ m(0, 1, 4, 5, 13, 15, 20, 21, 22, 23, 24, 26, 28, 30, 31)
FIGURE 5-23
© Cengage Learning 2014
P1000 01 11 10
Shaded 1’s are used to
select essential prime
implicants.00
1
0DE
ABC
01
11
10111
1
1111111
11 1
124
P4
P3 P2FIGURE 5-22
© Cengage Learning 201400 01 11 10
00DEBC
01
11
1011
111
11
0A
Karnaugh Maps  151
Prime implicant P1 is chosen first because all of the 1’s adjacent to minterm 0 
are covered by P1. Prime implicant P2 is chosen next because all of the 1’s adjacent 
to minterm 24 are covered by P2. All of the remaining 1’s on the map can be cov-
ered by at least two different prime implicants, so we proceed by trial and error. 
After a few tries, it becomes apparent that the remaining 1’s can be covered by three prime implicants. If we choose prime implicants P
3 and P4 next, the remain-
ing two 1’s can be covered by two different groups of four. The resulting minimum solution is
F=A′B′D′+ABE ′+ACD +A′BCE +%    or AB′ C
B′CD ′-
    P1  P2 P3   P4     
Figure 5-24 is a map of
F(A, B, C, D, E)=Σ m(0, 1, 3, 8, 9, 14, 15, 16, 17, 19, 25, 27, 31)
All 1’s adjacent to m16 are covered by P1, so choose P1 first. All 1’s adjacent to 
m3 are covered by P2, so P2 is chosen next. All 1’s adjacent to m8 are covered by P3, 
so P3 is chosen. Because m14 is only adjacent to m15, P4 is also essential. There are no 
more essential prime implicants, and the remaining 1’s can be covered by two terms, 
P5 and (1 -9-17-25) or (17-19-25-27). The final solution is
F=B′C′D′+B′C′E+A′C′D′ +A′BCD +ABDE +%    orC′D′E
AC ′E-
    P1 P2    P3      P4     P5    
FIGURE 5-24
© Cengage Learning 2014
P50 4 1200 01 11 10
8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141
11 1
111 1
1 111
1
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26P3P1
P2
P4
152 Unit 5
FIGURE 5-25
© Cengage Learning 2014
↑5.6 Other Uses of Karnaugh Maps
Many operations that can be performed using a truth table or algebraically can be 
done using a Karnaugh map. A map conveys the same information as a truth table—it is just arranged in a different format. If we plot an expression for 
F on a map, we 
can read off the minterm and maxterm expansions for F and for F ′. From the map of 
Figure 5-14, the minterm expansion of f is
f=Σ m(0, 2, 3, 4, 8, 10, 11, 15)
and because each 0 corresponds to a maxterm, the maxterm expansion of f is
f=Π  M(1, 5, 6, 7, 9, 12, 13, 14)
We can prove that two functions are equal by plotting them on maps and showing that they have the same Karnaugh map. We can perform the AND operation (or the OR operation) on two functions by ANDing (or ORing) the 1’s and 0’s which appear in corresponding positions on their maps. This procedure is valid because it is equivalent to doing the same operations on the truth tables for the functions.
A Karnaugh map can facilitate factoring an expression. Inspection of the 
map reveals terms which have one or more variables in common. For the map of Figure 5-25, the two terms in the first column have 
A′B′ in common; the two terms in 
the lower right corner have AC in common.
When simplifying a function algebraically, the Karnaugh map can be used as a 
guide in determining what steps to take. For example, consider the function
F=ABCD +B′CDE +A′B′+BCE′
From the map (Figure 5-26), we see that in order to get the minimum solution, we must add the term 
ACDE. We can do this using the consensus theorem:
F=ABCD +B′CDE +A′B′+BCE′ +ACD E100 01 11 10
1
1 100CDAB
F = A′B′(C′ + D) + AC(B + D′)01
11
10 1 1
Karnaugh Maps  153
As can be seen from the map, this expression now contains two redundant terms, 
ABCD and B ′CDE. These can be eliminated using the consensus theorem, which 
gives the minimum solution:
F=A′B+BCE′ +ACD E
5.7 Other Forms of Karnaugh Maps
Instead of labeling the sides of a Karnaugh map with 0’s and 1’s, some people prefer 
to use the labeling shown in Figure 5-27 . For the half of the map labeled A, A=1; 
and for the other half, A=0. The other variables have a similar interpretation. A map 
labeled this way is sometimes referred to as a Veitch diagram. It is particularly use-ful for plotting functions given in algebraic form rather than in minterm or maxterm form. However, when utilizing Karnaugh maps to solve sequential circuit problems (Units 12 through 16), the use of 0’s and 1’s to label the maps is more convenient.FIGURE 5-26
© Cengage Learning 2014
0 4 1200 01 11 10
Add this term. .
Then these two terms can be eliminated.8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141
11
1111
11
11
111
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26
FIGURE 5-27
Veitch Diagrams
© Cengage Learning 2014
B C
BC DA A
154 Unit 5
00 01 11 10
00
01
11
10FIGURE 5-28
Other Forms of 
Five-Variable 
Karnaugh Maps
© Cengage Learning 2014Two alternative forms for five-variable maps are used. One form simply consists 
of two four-variable maps side-by-side as in Figure 5-28(a). A modification of this 
uses a mirror image map as in Figure 5-28(b). In this map, first and eighth columns are “adjacent” as are second and seventh columns, third and sixth columns, and fourth and fifth columns. The same function is plotted on both these maps.
F=D′E′+B′C′D′+BCE +A′BC′E′+ACD
E
Programmed Exercise 5.1
Cover the answers to this exercise with a sheet of paper and slide it down as you check your answers. Write your answers in the space provided before looking at the correct answer.
Problem Determine the minimum sum of products and minimum product of 
sums for
f=b′c′d′+bcd+acd ′+a′b′c+a′bc ′d
First, plot the map for f.1 1 1 100 01
A = 0
(a) (b)11 10
1 1
100DEBC
01
11
10 11 1 1 100 01
A = 111 10
1 1
1 100DEBC
01
11
101 1 1 1
1 1
1
11 1 1 1
1 1
1 1B
D
C CEA
Karnaugh Maps  155
Answer:
1 100 01 11 10
1
1 1 1
100cdab
01
11
10 1 1
1 100 01 11 10
1
1 1 1
100cdab
011110
1 1
Loop the remaining 1’s using a minimum number of loops.
The two possible minimum sum-of-products forms for f are
f = ___________________________________ and
f = ___________________________________
Answer:
1 100 01 11 10
1
1 1 1
100cdab
01
1110
1 1f = b′d′ + a′bd + abc +a′cd
or
a′b′c(a) The minterms adjacent to m0 on the preceding map are _________ and _________.
(b) Find an essential prime implicant containing m0 and loop it.
(c) The minterms adjacent to m3 are _________ and _________.
(d) Is there an essential prime implicant which contains m3?
(e) Find the remaining essential prime implicant(s) and loop it (them).
Answers:
(a) m2 and m8 (b)
(c) m2 and m7 (e)
(d) No
156 Unit 5
1 100 01 11 10
1 1 1
100
Essential because of m1
Essential because of m11
Essential because of m6cdab
f′01
11
10 100 01
f′11 10
0001
11
10Next, we will find the minimum product of sums for f. Start by plotting the map for f  ′.
Loop all essential prime implicants of f   ′ and indicate which minterm makes each 
one essential.
Answer:
Loop the remaining 1’s and write the minimum sum of products for f  ′.
f  ′= __________________________________
The minimum product of sums for f is therefore
f = __________________________________
Final Answer: f  ′ =b′c′d+a′bd′+ab ′d+abc ′
f  =(b+c+d′)(a+b′+d)(a ′+b+d′)(a ′+b′+c)
Programmed Exercise 5.2
Problem: Determine a minimum sum-of-products expression for
f (a,  b,  c,  d,  e)=(a′+c+d)(a ′+b+e) (a+c′+e′) (c+d+e′)
                     (b+c+d′+e) (a′+b′+c+e′)
Karnaugh Maps  157
The first step in the solution is to plot a map for f. Because f is given in product-
of-sums form, it is easier to first plot the map for f  ′ and then complement the map. 
Write f  ′ as a sum of products:
f  ′ = _________________________________________
Now plot the map for f  ′. (Note that there are three terms in the upper layer, one 
term in the lower layer, and two terms which span the two layers.)
Next, convert your map for f ′ to a map for f.
00 01 11 10
00
1
0de
abc
f′01
11
1000 01 11 10
00
1
0de
abc
f01
11
10
00 01
f′11 10
00
1
0de
abc
01
11
1011 1
1
1111
10 4 1200 01
f11 10
8 
1 5 13 9
3 7 15 1100
1
0de
abc
01
11
10
2 6 141
1
1 1
11
11111111
1 111
11
111
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26Answer:
158 Unit 5
00 01 11 10
00
1
0de
abc
01
11
101
11
111
11111
1 1
111
1The next step is to determine the essential prime implicants of f.
(a) Why is a′d′e′ an essential prime implicant?
(b) Which minterms are adjacent to m3? ___________ To m19? ___________
(c) Is there an essential prime implicant which covers m3 and m19?
(d) Is there an essential prime implicant which covers m21?
(e) Loop the essential prime implicants which you have found. Then, find two more 
essential prime implicants and loop them.
Answers:
(a) It covers m0 and both adjacent minterms.
(b) m19 and m11; m3 and m23
(c) No
(d) Yes
(e) 
(a) Why is there no essential prime implicant which covers m11?
(b) Why is there no essential prime implicant which covers m28?
Because there are no more essential prime implicants, loop a minimum number of 
terms which cover the remaining 1’s.
Answers:
(a) All adjacent 1’s of m11(m3,  m10) cannot be covered by one grouping.
(b) All adjacent 1’s of m28(m12,  m30,  m29) cannot be covered by one grouping.
Karnaugh Maps  159
00 01 11 10
Note: There are five other
possible ways to loop the
four remaining 1’s.00
1
0de
abc
01
11
101
1
11 111
111111
111
1
Write down two different minimum sum-of-products expressions for f.
f = ___________________________________
f = ___________________________________
Answer:
f=a′d′e′+ace+a′ce′+bde ′+|  orabc
bce ′¶+|b′c′de+a′bc ′db′c′de + a′c′de
ab ′de +a′c′de¶
Problems
5.3 Find the minimum sum of products for each function using a Karnaugh map.
(a)  f1(a,  b,  c) =  m0 +  m2 +m5 +m6 (b)  f2(d,  e,  f  ) =  Σ m(0, 1, 2, 4)
(c)  f3(r,  s,  t) =  rt ′ +  r′s′ +r′s (d)  f4(x,  y,  z)=M0·M5
5.4 (a)   Plot the following function on a Karnaugh map. (Do not expand to minterm 
form before plotting.)
F(A, B, C, D)=BD ′+B′CD+ABC +ABC ′D+B′D′
(b) Find the minimum sum of products.
(c) Find the minimum product of sums.
160 Unit 5
5.5 A switching circuit has two control inputs (C1 and  C2), two data inputs (X1 and  X2), 
and one output (Z). The circuit performs one of the logic operations AND, OR, EQU 
(equivalence), or XOR (exclusive OR) on the two data inputs. The function performed 
depends on the control inputs:
(a) Derive a truth table for Z.
(b) Use a Karnaugh map to find a minimum AND-OR gate circuit to realize Z.
5.6 Find the minimum sum-of-products expression for each function. Underline the 
essential prime implicants in your answer and tell which minterm makes each one essential.
(a) 
f(a,  b,  c,  d)=Σ m(0,  1,  3,  5,  6,  7,  11,   12,   14)
(b) f(a,  b,  c,  d)=Π   M(1,  9,  11,   12,   14)
(c) f(a,  b,  c,  d)=Π   M(5,  7,  13,   14,   15)·Π  D(1, 2, 3, 9)
5.7 Find the minimum sum-of-products expression for each function.
(a) f(a, b, c, d)=Σ m(0, 2, 3, 4, 7, 8, 14)
(b) f(a, b, c, d)=Σ m(1, 2, 4, 15)+Σ d(0, 3, 14)
(c) f(a, b, c, d)=Π   M(1, 2, 3, 4, 9, 15)
(d) f(a, b, c, d)=Π   M(0, 2, 4, 6, 8)·Π  D(1, 12, 9, 15)
5.8 Find the minimum sum of products and the minimum product of sums for each 
function:
(a) f(a, b, c, d)=Π   M(0, 1, 6, 8, 11,  12)·Π  D(3, 7, 14,  15)
(b) f(a, b, c, d) =  Σ m(1, 3, 4, 11) +  Σ d(2, 7, 8, 12,  14,  15)
5.9 Find the minimum sum of products and the minimum product of sums for each 
function:
(a) F(A, B, C, D, E)=Σ m(0, 1, 2, 6, 7, 9, 10, 15, 16, 18, 20, 21, 27, 30)
                                 +Σ d(3, 4, 11, 12, 19)
(b) F(A, B, C, D, E)=Π  M(0, 3, 6, 9, 11, 19, 20, 24, 25, 26, 27, 28, 29, 30)
                                  ·Π  D(1, 2, 12, 13)
5.10 F(a, b, c, d, e)=Σ m(0, 3, 4, 5, 6, 7, 8, 12, 13, 14, 16, 21, 23, 24, 29, 31)
(a) Find the essential prime implicants using a Karnaugh map, and indicate why 
each one of the chosen prime implicants is essential (there are four essential prime implicants).
(b) Find all of the prime implicants by using the Karnaugh map. (There are 
nine in all.)C1C2Function Performed 
by Circuit
00 O R
0 1 XOR
1 0 AND
1 1 EQU
Karnaugh Maps  161
5.11 Find a minimum product-of-sums solution for f. Underline the essential prime 
implicates.
f(a, b, c, d, e)=Σ m(2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 27, 28, 29, 31)+Σ d(1, 30)
5.12 Given F =AB ′D′+A′B+A′C+CD.
(a) Use a Karnaugh map to find the maxterm expression for F (express your answer 
in both decimal and algebric notation).
(b) Use a Karnaugh map to find the minimum sum-of-products form for F ′.
(c) Find the minimum product of sums for F.
5.13 Find the minimum sum of products for the given expression. Then, make minterm 
5 a don’t-care term and verify that the minimum sum of products is unchanged. 
Now, start again with the original expression and find each minterm which could  individually  be made a don’t-care without changing the minimum sum of 
products.
F
(A, B, C, D)=A′C′+B′C+ACD ′+BC′D
5.14 Find the minimum sum-of-products expressions for each of these functions.(a)  
f1(A, B, C)=m1+m2+m5+m7 (b)  f2(d, e, f  )=Σ m(1, 5, 6, 7)
(c)  f3(r, s, t)=rs′+r′s′+st ′ (d)  f4(a, b, c)=m0+m2+m3+m7
(e)  f5(n, p, q)=Σ m(1, 3, 4, 5) (f  )  f6(x, y, z)=M1M7
5.15 Find the minimum product-of-sums expression for each of the functions in 
Problem 5.14.
5.16 Find the minimum sum of products for each of these functions.(a)  
f1(A, B, C)=m1+m3+m4+m6 (b)  f2(d, e, f )=Σ m(1, 4, 5, 7)
(c)  f3(r, s, t)=r ′t ′+rs′+rs (d)  f1(a, b, c)=m3+m4+m6+m7
(e)  f2(n, p, q)=Σ m(2, 3, 5, 7) (f  )  f4(x, y, z)=M3M6
5.17 (a)  Plot the following function on a Karnaugh map. (Do not expand to minterm 
form before plotting.)
F(A, B, C, D)=A′B′+CD ′+ABC +A′B′CD ′+ABCD ′
(b) Find the minimum sum of products.
(c) Find the minimum product of sums.
5.18 Work Problem 5.17 for the following:
f(A, B, C, D)=A′B′+A′B′C′+A′BD ′+AC ′D+A′BD+AB ′CD ′
162 Unit 5
C1C2Function Performed 
by Circuit
00 X1X2
01 X1 ⊕ X2
10 X ′1+X2
11 X1≡X25.19 A switching circuit has two control inputs (C1 and  C2), two data inputs (X1  and  X2), 
and one output (Z). The circuit performs logic operations on the two data inputs, as 
shown in this table:
(a) Derive a truth table for Z.
(b) Use a Karnaugh map to find a minimum OR-AND gate circuit to realize Z.
5.20 Use Karnaugh maps to find all possible minimum sum-of-products expressions for 
each function.
(a) F(a, b, c)=Π  M(3, 4)
(b) g(d, e, f  )=Σ m(1, 4, 6)+Σ d(0, 2, 7)
(c) F(p, q, r)=(p+q′+r)(p′+q+r′)
(d) F(s, t, u)=Σ m(1, 2, 3)+Σ d(0, 5, 7)
(e) f(a, b, c)=Π  M(2, 3, 4)
(f  ) G(D, E, F )=Σ m(1, 6)+Σ d(0, 3, 5)
5.21 Simplify the following expression first by using a map and then by using Boolean 
algebra. Use the map as a guide to determine which theorems to apply to which 
terms for the algebraic simplification.
F=a′b′c′+a′c′d+bcd+abc+ab ′
5.22 Find all prime implicants and all minimum sum-of-products expressions for each of 
the following functions.
(a) f(A, B, C, D)=Σ m(4, 11, 12, 13, 14)+Σ d(5, 6, 7, 8, 9, 10)
(b) f(A, B, C, D)=Σ m(3, 11, 12, 13, 14)+Σ d(5, 6, 7, 8, 9, 10)
(c) f(A, B, C, D)=Σ m(1, 2, 4, 13, 14)+Σ d(5, 6, 7, 8, 9, 10)
(d) f(A, B, C, D)=Σ m(4, 15)+Σ d(5, 6, 7, 8, 9, 10)
(e) f(A, B, C, D)=Σ m(3, 4, 11, 15)+Σ d(5, 6, 7, 8, 9, 10)
(f  ) f(A, B, C, D)=Σ m(4)+Σ d(5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
(g) f(A, B, C, D)=Σ m(4, 15)+Σ d(0, 1, 2, 5, 6, 7, 8, 9, 10)
5.23 For each function in Problem 5.22, find all minimum product-of-sums expressions.
5.24 Find the minimum sum-of-products expression for
(a) Σ m(0, 2, 3, 5, 6, 7, 11, 12, 13)
(b) Σ m(2, 4, 8)+Σ d(0, 3, 7)
(c) Σ m(1, 5, 6, 7, 13)+Σ d(4, 8)
(d) f(w, x, y, z)=Σ m(0, 3, 5, 7, 8, 9, 10, 12, 13)+Σ d(1, 6, 11, 14)
(e) Π M(0, 1, 2, 5, 7, 9, 11)·Π D(4, 10, 13)
Karnaugh Maps  163
5.25 Work Problem 5.24 for the following:
(a) f (a, b, c, d)=Σ m(1, 3, 4, 5, 7, 9, 13, 15)
(b) f (a, b, c, d)=Π   M(0, 3, 5, 8, 11)
(c) f (a, b, c, d)=Σ m(0, 2, 6, 9, 13, 14)+Σ d(3, 8, 10)
(d) f (a, b, c, d)=Π   M(0, 2, 6, 7, 9, 12, 13)·Π  D(1, 3, 5)
5.26 Find the minimum product of sums for the following. Underline the essential prime 
implicates in your answer.
(a) Π  M(0, 2, 4, 5, 6, 9, 14)·Π  D(10, 11)
(b) Σ m(1, 3, 8, 9, 15)+Σ d(6, 7, 12)
5.27 Find a minimum sum-of-products and a minimum product-of-sums expression for 
each function:
(a) f (A, B, C, D)=Π   M(0, 2, 10, 11, 12, 14, 15)·Π  D(5, 7)
(b) f (w, x, y, z)=Σ m(0, 3, 5, 7, 8, 9, 10, 12, 13)+Σ d(1, 6, 11, 14)
5.28 A logic circuit realizes the function F (a, b, c, d)=a′b′+a′cd+ac ′d+ab ′d′. Assum-
ing that a =c never occurs when b =d=1, find a simplified expression for F.
5.29 Given F =AB ′D′+A′B+A′C+CD.
(a) Use a Karnaugh map to find the maxterm expression for F (express your answer 
in both decimal and algebric notation).
(b) Use a Karnaugh map to find the minimum sum-of-products form for F ′.
(c) Find the minimum product of sums for F.
5.30 Assuming that the inputs ABCD =0101,   BCD =1001,   ABCD =1011 never occur, 
find a simplified expression for
F=A′BC′D+A′B′D+A′CD+ABD +ABC
5.31 Find all of the prime implicants for each of the functions plotted on page 157 .
5.32 Find all of the prime implicants for each of the plotted functions:
00 01 11 10
00
1
0de
abc
F01
11
101
1
11
100 01 11 10
00
1
0de
abc
G01
11
101
111
11 11 111
1111
11 11
11 1
164 Unit 5
5.33 Given that f (a, b, c, d, e)=Σ m(6, 7, 9, 11, 12, 13, 16, 17, 18, 20, 21, 23, 25, 28), using 
a Karnaugh map,
(a) Find the essential prime implicants (three).
(b) Find the minimum sum of products (7 terms).
(c) Find all of the prime implicants (twelve).
5.34 A logic circuit realizing the function f has four inputs a, b, c, d. The three inputs a, b, 
and c are the binary representation of the digits 0 through 7 with a being the most 
significant bit. The input d is an odd-parity bit; that is, the value of d is such that 
a, b, c, and d always contains an odd number of 1’s. (For example, the digit 1 is rep-
resented by abc=001 and d =0, and the digit 3 is represented by abcd =0111.) The 
function f has value 1 if the input digit is a prime number. (A number is prime if it is 
divisible only by itself and 1; 1 is considered to be prime, and 0 is not.)
(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f.
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f  ′.
(e) Find all minimum product of sums for f.
5.35 The decimal digits 0 though 9 are represented using five bits A, B, C, D, and E . The 
bits A, B, C, and D  are the BCD representation of the decimal digit, and bit E is a 
parity bit that makes the five bits have odd parity. The function F (A, B, C, D, E ) has 
value 1 if the decimal digit represented by A, B, C, D, and E  is divisible by either 3 
or 4. (Zero is divisible by 3 and 4.)
(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f. (Prime implicants containing only don’t-cares 
need not be included.)
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f  ′.
(e) Find all minimum product of sums for f.
5.36 Rework Problem 5.35 assuming the decimal digits are represented in excess-3 rather 
than BCD.
5.37 The function F (A, B, C, D, E)=Σ m(1, 7, 8, 13, 16, 19)+Σ d(0, 3, 5, 6, 9, 10, 12, 15,
17, 18, 20, 23, 24, 27, 29, 30).
(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f. (Prime implicants containing only don’t-cares 
need not be included.)
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f  ′.
(e) Find all minimum product of sums for f.
Karnaugh Maps  165
5.38 F(a, b, c, d, e)=Σ m(0, 1, 4, 5, 9, 10, 11, 12, 14, 18, 20, 21, 22, 25, 26, 28)
(a) Find the essential prime implicants using a Karnaugh map, and indicate why 
each one of the chosen prime implicants is essential (there are four essential 
prime implicants).
(b) Find all of the prime implicants by using the Karnaugh map (there are 13 in all).
5.39 Find the minimum sum-of-products expression for F. Underline the essential prime 
implicants in this expression.
(a) f(a, b, c, d, e)=Σ m(0, 1, 3, 4, 6, 7, 8, 10, 11, 15, 16, 18, 19, 24, 25, 28, 29, 31)
                           +Σ d(5, 9, 30)
(b) f(a, b, c, d, e)=Σ m(1, 3, 5, 8, 9, 15, 16, 20, 21, 23, 27, 28, 31)
5.40 Work Problem 5.39 with
F(A, B, C, D, E)=Π   M(2, 3, 4, 8, 9, 10, 14, 15, 16, 18, 19, 20, 23, 24, 30, 31)
5.41 Find the minimum sum-of-products expression for F. Underline the essential prime 
implicants in your expression.
F(A, B, C, D, E)=Σ m(0, 2, 3, 5, 8, 11, 13, 20, 25, 26, 30)+Σ d(6, 7, 9, 24)
5.42 F(V, W, X, Y, Z)=Π   M(0, 3, 5, 6, 7, 8, 11, 13, 14, 15, 18, 20, 22, 24)·Π  D(1, 2, 16, 17)
(a) Find a minimum sum-of-products expression for F. Underline the essential 
prime implicants.
(b) Find a minimum product-of-sums expression for F. Underline the essential 
prime implicates.
5.43 Find the minimum product of sums for(a) F
(a, b, c, d, e)=Σ m(1, 2, 3, 4, 5, 6, 25, 26, 27, 28, 29, 30, 31)
(b) F (a, b, c, d, e)=Σ m(1, 5, 12, 13, 14, 16, 17, 21, 23, 24, 30, 31)+Σ d(0, 2, 3, 4)
5.44 Find a minimum product-of-sums expression for each of the following functions:
(a) F(v, w, x, y, z)=Σ m(4, 5, 8, 9, 12, 13, 18, 20, 21, 22, 25, 28, 30, 31)
(b) F(a, b, c, d, e)=Π   M(2, 4, 5, 6, 8, 10, 12, 13, 16, 17, 18, 22, 23, 24)
·Π  D(0, 11, 30, 31)
5.45 Find the minimum sum of products for each function. Then, make the specified 
minterm a don’t-care and verify that the minimum sum of products is unchanged. Now, start again with the original expression and find each minterm which could   individually be made a don’t-care, without changing the minimum sum of products.
(a) F
(A, B, C, D)=A′C′+A′B′+ACD ′+BC′D, minterm  2
(b) F(A, B, C, D)=A′BD+AC ′D+AB ′+BCD +A′C′D, minterm  7
166 Unit 5
5.46 F(V, W, X, Y, Z)=Π   M(0, 3, 6, 9, 11, 19, 20, 24, 25, 26, 27, 28, 29, 30)·Π  D(1, 2, 12,  13)
(a) Find two minimum sum-of-products expressions for F.
(b) Underline the essential prime implicants in your answer and tell why each one 
is essential.
5.47 Four of the minterms of the completely specified function f(a, b, c, d) are m0, m1, m4, 
and m5.
(a) Specify additional minterms for f so that f has eight prime implicants with two 
literals and no other prime implicants.
(b) For each prime implicant, give its algebraic representation and specify whether 
it is an essential prime implicant.
(c) Determine all minimum sum-of-products expressions for f.
5.48 Four of the minterms of the completely specified function f(a, b, c, d) are m0, m1, m4, 
and m5.
(a) Specify additional minterms for f so that f has one prime implicant with one 
literal, six prime implicants with two literals, and no other prime implicants.
(b) For each prime implicant, give its algebraic representation and specify whether 
it is an essential prime implicant.
(c) Determine all minimum sum-of-products expressions for f.
5.49 Four of the minterms of the completely specified function f(a, b, c, d) are m0, m1, m4, 
and m5.
(a) Specify additional minterms for f so that f has two prime implicants with one 
literal, two prime implicants with two literals, and no other prime implicants.
(b) For each prime implicant, give its algebraic representation and specify whether 
it is an essential prime implicant.
(c) Determine all minimum sum-of-products expressions for f.
5.50 Four of the minterms of an incompletely specified function f(a, b, c, d) are m0, m1, m4, 
and m5.
(a) Specify additional minterms and don’t-cares for f so that f has five prime impli-
cants with two literals and no other prime implicants and, in addition, f has one 
prime implicate with one literal and two prime implicates with two literals.
(b) For each prime implicant, give its algebraic representation and specify whether 
it is an essential prime implicant.
(c) Determine all minimum sum-of-products expressions for f.
(d) For each prime implicate, give its algebraic representation and specify whether 
it is an essential prime implicate.
(e) Determine all minimum product-of-sums expressions for f.
167Quine-McCluskey MethodUNIT
6
Objectives
1. Find the prime implicants of a function by using the Quine-McCluskey method. 
Explain the reasons for the procedures used.
2. Define prime implicant and essential prime implicant.
3. Given the prime implicants, find the essential prime implicants and a minimum sum-of-products expression for a function, using a prime implicant chart and using Petrick’s method.
4. Minimize an incompletely specified function, using the Quine-McCluskey method.
5. Find a minimum sum-of-products expression for a function, using the method of map-entered variables.
168 Unit 6
Study Guide
1. Review Section 5.1, Minimum Forms of Switching Functions.
2. Read the introduction to this unit and, then, study Section 6.1. Determination of 
Prime Implicants.
(a) Using variables A, B, C, D , and E , give the algebraic equivalent of
10110   +10010    =10−10
10−10 +10−11 =10−1 −
(b) Why will the following pairs of terms not combine?
01101   +00111
10−10 +001−0
(c) When using the Quine-McCluskey method for finding prime implicants, 
why is it necessary to compare terms only from adjacent groups?
(d) How can you determine if two minterms from adjacent groups will combine 
by looking at their decimal representations?
(e) When combining terms, why is it permissible to use a term which has 
already been checked off?
(f  ) In forming Column II of Table 6-1, note that terms 10 and 14 were com-
bined to form 10, 14 even though both 10 and 14 had already been checked 
off. If this had not been done, which term in Column II could not be elimi-nated (checked off)?
(g) In forming Column III of Table 6-1, note that minterms 0, 1, 8, and 9 were 
combined in two different ways to form –00–. This is equivalent to looping the minterms in two different ways on the Karnaugh map, as shown.
(0, 1) + (8, 9) (0, 8) + (1, 9) (0, 1, 8, 9)==1 100 01 11 10
1 100cdab
01
11
101 100 01 11 10
1 100cdab
01
11101 100 01 11 10
1 100cdab
01
1110
Quine-McCluskey Method  169
(h) Using a map, find all of the prime implicants of Equation (6-2) and com-
pare your answer with Equation (6-3).
(i) The prime implicants of f(a, b, c , d)=Σ m(4, 5, 6, 7, 12, 13, 14, 15 ) are to 
be found using the Quine-McCluskey method. Column III is given; find 
Column IV and check off the appropriate terms in Column III.00 01 11 10
00
01
11
10
Column III Column IV
(4, 5, 6, 7)  01  - -
(4, 5, 12, 13) –10–
(4, 6, 12, 14) –1–0
(5, 7, 13, 15) –1–1
(6, 7, 14, 15) –11–
(12, 13, 14, 15)  11  - -00 01 11 10
00
01
11
10
 3. (a) List all seven product term implicants of F (a, b, c )=Σ  m(0, 1, 5, 7 )
Which of these implicants are prime?
Why is a ′c not an implicant?
(b) Define a prime implicant.
(c) Why must every term in a minimum sum-of-products expression be a 
prime implicant?Check your answer using a Karnaugh map.
170 Unit 6
(d) Given that F(A, B, C, D )=Σ m(0, 1, 4, 5, 7, 10, 15 ), which of the following 
terms are not prime implicants and why?
A′B′C′    A′C′        BCD       ABC       AB ′CD′
4. Study Section 6.2, The Prime Implicant Chart.
(a) Define an essential prime implicant.
(b) Find all of the essential prime implicants from the following chart.
abc d 0 4 5 1 01 11 21 31 5
(0, 4) 0 – 0 0 ××
(4, 5, 12, 13) – 1 0 – ×× × ×
(13, 15) 1 1 – 1 ××
(11, 15) 1 – 1 1 ××
(10, 11) 1 0 1 – ××
m4m5m7m13
P1bd ×× ×
P2bc′ ×× ×
P3a′b ×××
P4c′d ××
We will find all minimum solutions using Petrick’s method. Let Pi=1 mean 
the prime implicant in row Pi is included in the solution.
Which minterm is covered iff (P1+P3)=1?_________
Write a sum term which is 1 iff m4 is covered._________Check your answer using a Karnaugh map.
(c) Why must all essential prime implicants of a function be included in the 
minimum sum of products?
(d) Complete the solution of Table 6-5.
(e) Work Programmed Exercise 6.1.
(f  ) Work Problems 6.2 and 6.3.
5. Study Section 6.3, Petrick’s Method (optional).
(a) Consider the following reduced prime implicant chart for a function F:
Quine-McCluskey Method  171
Write a product-of-sum terms which is 1 iff all m4, m5, m7 and m13 are all 
covered:
P= ____________________________________________________________
(b) Reduce P to a minimum sum of products. (Your answer should have four 
terms, each one of the form Pi Pj.)
P= ____________________________________________________________
If P1P2=1, which prime implicants are included in the solution?_________
How many minimum solutions are there?________
Write out each solution in terms of a , b, c , and d .
(1) F= (2) F=
 (3) F= (4) F=
6. Study Section 6.4, Simplification of Incompletely Specified Functions.
(a) Why are don’t-care terms treated like required minterms when finding the 
prime implicants?
(b) Why are the don’t-care terms not listed at the top of the prime implicant 
chart when finding the minimum solution?
(c) Work Problem 6.4.
(d) Work Problem 6.5, and check your solution using a Karnaugh map.
7. If you have LogicAid or a similar computer program available, use it to check your answers to some of the problems in this unit. LogicAid accepts Boolean functions in the form of equations, minterms or maxterms, and truth tables. It finds simplified sum-of-products and product-of-sums expressions for the func-tions using a modified version of the Quine-McCluskey method or Espresso-II. It can also find one or all of the minimum solutions using Petrick’s method.
8. Study Section 6.5, Simplification Using Map-Entered Variables.
(a) For the following map, find MS
0, MS1, and F. Verify that your solution for 
F is minimum by using a four-variable map.
D 1
1D
1X01
00BCA
01
11
10
172 Unit 6
(b) Use the method of map-entered variables to find an expression for F from 
the following map. Treat C and C′  as if they were independent variables. Is 
the result a correct representation of F? Is it minimum?
(c) Work Problem 6.6.
9. In this unit you have learned a “turn-the-crank” type procedure for finding mini-
mum sum-of-products forms for switching functions. In addition to learning how to “turn the crank” and grind out minimum solutions, you should have learned several very important concepts in this unit. In particular, make sure you know:
(a) What a prime implicant is
(b) What an essential prime implicant is
(c) Why the minimum sum-of-products form is a sum of prime implicants
(d) How don’t-cares are handled when using the Quine-McCluskey method 
and the prime implicant chart
10. Reread the objectives of the unit. If you are satisfied that you can meet the objectives, take the readiness test.C
C′ 101
0BA
1
The Karnaugh map method described in Unit 5 is an effective way to simplify switching functions which have a small number of variables. When the number of variables is large or if several functions must be simplified, the use of a digital com-puter is desirable. The Quine-McCluskey method presented in this unit provides a systematic simplification procedure which can be readily programmed for a digital computer.Quine-McCluskey Method
Quine-McCluskey Method  173
The Quine-McCluskey method reduces the minterm expansion (standard sum-
of-products form) of a function to obtain a minimum sum of products. The  procedure 
consists of two main steps:
1. Eliminate as many literals as possible from each term by systematically applying 
the theorem XY+XY ′=X. The resulting terms are called prime implicants.
2. Use a prime implicant chart to select a minimum set of prime implicants which, when ORed together, are equal to the function being simplified and which con-tain a minimum number of literals.
6.1 Determination of Prime Implicants
In order to apply the Quine-McCluskey method to determine a minimum sum- of-
products expression for a function, the function must be given as a sum of minterms. (If the function is not in minterm form, the minterm expansion can be found by using one of the techniques given in Section 5.3.) In the first part of the Quine-McCluskey method, all of the prime implicants of a function are systematical ly formed by combining minterms. The minterms are represented in binary notation and combined using
 
XY+XY ′=X (6-1)
where X represents a product of literals and Y is a single variable. Two minterms will 
combine if they differ in exactly one variable.
In order to find all of the prime implicants, all possible pairs of minterms should 
be compared and combined whenever possible. To reduce the required number of 
comparisons, the binary minterms are sorted into groups according to the number of 1’s in each term. Thus,
 
f(a, b, c , d)=Σ m(0, 1, 2, 5, 6, 7, 8, 9, 10, 14 ) (6-2)
is represented by the following list of minterms:
group  0  0  0000
group  1|1  0001
2  0010
8  1000
group  2&5  0101
6  0110
9  1001
10  1010
group  3e7  0111
14  1110
174 Unit 6
In this list, the term in group 0 has zero 1’s, the terms in group 1 have one 1, those in 
group 2 have two 1’s, and those in group 3 have three 1’s.
Two terms can be combined if they differ in exactly one variable. Comparison 
of terms in nonadjacent groups is unnecessary because such terms will always differ in at least two variables and cannot be combined using 
XY+XY ′=X. Similarly, 
the comparison of terms within a group is unnecessary because two terms with the same number of 1’s must differ in at least two variables. Thus, only terms in adjacent groups must be compared.
First, we will compare the term in group 0 with all of the terms in group 1. Terms 
0000 and 0001 can be combined to eliminate the fourth variable, which yields 000–. 
Similarly, 0 and 2 combine to form 00–0 
(a′b′d′), and 0 and 8 combine to form –000 
(b′c′d′). The resulting terms are listed in Column II of Table 6-1.
Whenever two terms combine, the corresponding decimal numbers differ by a 
power of 2 (1, 2, 4, 8, etc.). This is true because when the binary representations differ in exactly one column and if we subtract these binary representations, we get a 1 only in the column in which the difference exists. A binary number with a 1 in exactly one column is a power of 2.
Column I Column II Column III
group  0   0 0000
1 0001
group  1    2 0010
8 1000
5 0101
6 0110
group 29 1001
   10 1010
group  3   7 0111
14 1110✓ 0, 1 000– ✓ 0, 1, 8, 9 –00–
✓ 0, 2 00–0 ✓ 0, 2, 8, 10 –0–0
✓ 0, 8 –000 ✓ 0, 8, 1, 9 –00 –
✓ 1, 5 0–01 0, 8, 2, 10 –0–0
✓ 1, 9 –001 ✓ 2, 6, 10, 14 - -  10
✓ 2, 6 0–10 ✓ 2, 10, 6, 14 - -  10
✓ 2, 10 –010 ✓
✓ 8, 9 100– ✓
✓8, 10 10–0 ✓
✓5, 7    01–1
6, 7    011–
6, 14 –110 ✓
10, 14 1–10 ✓TABLE 6-1
Determination of 
Prime Implicants
Because the comparison of group 0 with groups 2 and 3 is unnecessary, we pro-
ceed to compare terms in groups 1 and 2. Comparing term 1 with all terms in group 2, 
we find that it combines with 5 and 9 but not with 6 or 10. Similarly, term 2 combines only with 6 and 10, and term 8 only with 9 and 10. The resulting terms are listed in Column II. Each time a term is combined with another term, it is checked off. A term may be used more than once because 
X+X=X. Even though two terms have 
already been combined with other terms, they still must be compared and combined if possible. This is necessary because the resultant term may be needed to form the © Cengage Learning 2014
Quine-McCluskey Method  175
minimum sum solution. At this stage, we may generate redundant terms, but these 
redundant terms will be eliminated later. We finish with Column I by comparing terms in groups 2 and 3. New terms are formed by combining terms 5 and 7 , 6 and 7 , 6 and 14, and 10 and 14.
Note that the terms in Column II have been divided into groups, according to 
the number of 1’s in each term. Again, we apply 
XY+XY ′=X to combine pairs of 
terms in Column II. In order to combine two terms, the terms must have the same variables, and the terms must differ in exactly one of these variables. Thus, it is neces-sary only to compare terms which have dashes (missing variables) in corresponding places and which differ by exactly one in the number of 1’s.
Terms in the first group in Column II need only be compared with terms in 
the second group which have dashes in the same places. Term 000– (0, 1) com-bines only with term 100– (8, 9) to yield –00–. This is algebraically equivalent to a′b′c+ab ′c′=b′c′. The resulting term is listed in Column III along with the desig-
nation 0, 1, 8, 9 to indicate that it was formed by combining minterms 0, 1, 8, and 9. Term (0, 2) combines only with (8, 10), and term (0, 8) combines with both (1, 9) and (2, 10). Again, the terms which have been combined are checked off. Comparing terms from the second and third groups in Column II, we find that (2, 6) combines with (10, 14), and (2, 10) combines with (6, 14).
Note that there are three pairs of duplicate terms in Column III. These duplicate 
terms were formed in each case by combining the same set of four minterms in a different order. After deleting the duplicate terms, we compare terms from the two groups in Column III. Because no further combination is possible, the process termi-nates. In general, we would keep comparing terms and forming new groups of terms and new columns until no more terms could be combined.
The terms which have not been checked off because they cannot be combined 
with other terms are called prime implicants. Because every minterm has been included in at least one of the prime implicants, the function is equal to the sum of its prime implicants. In this example we have
 
f=a′c′d+a′bd+a′bc+     b′c′+      b′d′+      cd ′
   (1, 5)  (5, 7)  (6, 7)   (0, 1, 8, 9 )  (0, 2, 8, 10 )  (2, 6, 10, 14 ) (6-3)
In this expression, each term has a minimum number of literals, but the num-
ber of terms is not minimum. Using the consensus theorem to eliminate redundant 
terms yields
 f=a′bd+b′c′+cd ′ (6-4)
which is the minimum sum-of-products expression for f. Section 6.2 discusses a 
better  method of eliminating redundant prime implicants using a prime impli-
cant chart.
Next, we will define implicant and prime implicant and relate these terms to the 
Quine-McCluskey method.
176 Unit 6
DefinitionDefinition Given a function F of n  variables, a product term P is an implicant of F iff for every 
combination of values of the n variables for which P =1, F is also equal to 1.
In other words, if for some combination of values of the variables, P=1 and F =0, 
then P is not an implicant of F. For example, consider the function
 F(a, b, c )=a′b′c′+ab ′c′+ab ′c+abc=b′c′+ac (6-5)
If a ′b′c′=1, then F =1; if ac =1, then F =1; etc. Hence, the terms a′b′c′, ac, etc., are 
implicants of F. In this example, bc is not an implicant of F because when a=0 and 
b=c=1, bc=1 and F =0. In general, if F is written in sum-of-products form, every 
product term is an implicant. Every minterm of F is also an implicant of F, and so 
is any term formed by combining two or more minterms. For example, in Table 6-1, 
all of the terms listed in any of the columns are implicants of the function given in Equation (6-2).
A prime implicant of a function F is a product term implicant which is no longer an 
implicant if any literal is deleted from it.
In Equation (6-5), the implicant a′b′c′ is not a prime implicant because a′ can be 
eliminated, and the resulting term (b′c′) is still an implicant of F. The implicants b′c′ 
and ac are prime implicants because if we delete a literal from either term, the term 
will no longer be an implicant of F. Each prime implicant of a function has a mini-
mum number of literals in the sense that no more literals can be eliminated from it by combining it with other terms.
The Quine-McCluskey method, as previously illustrated, finds all of the product 
term implicants of a function. The implicants which are nonprime are checked off in the process of combining terms so that the remaining terms are prime implicants.
A minimum sum-of-products expression for a function consists of a sum of some 
(but not necessarily all) of the prime implicants of that function. In other words, a sum-of-products expression which contains a term which is not a prime implicant cannot be minimum. This is true because the nonprime term does not contain a minimum number of literals—it can be combined with additional minterms to form a prime implicant which has fewer literals than the nonprime term. Any nonprime term in a sum-of-products expression can thus be replaced with a prime implicant, which reduces the number of literals and simplifies the expression.
6.2 The Prime Implicant Chart
Given all the prime implicants of a function, the prime implicant chart can be used to select a minimum set of prime implicants. The minterms of the function are listed across the top of the chart, and the prime implicants are listed down the side. 
Quine-McCluskey Method  177
A prime implicant is equal to a sum of minterms, and the prime implicant is said to 
cover these minterms. If a prime implicant covers a given minterm, an X is placed at the intersection of the corresponding row and column. Table 6-2 shows the prime implicant chart derived from Table 6-1. All of the prime implicants (terms which have not been checked off in Table 6-1) are listed on the left.
In the first row, X’s are placed in columns 0, 1, 8, and 9, because prime implicant 
b′c′ was formed from the sum of minterms 0, 1, 8, and 9. Similarly, X’s are placed in 
columns 0, 2, 8, and 10 opposite the prime implicant b′d′ and so forth.
0 1256789 1 0 1 4
(0, 1, 8, 9) b′c′ ×× ×⊗
(0, 2, 8, 10) b′d′ ×× × ×
(2, 6, 10, 14) cd′ ×× × ⊗
(1, 5) a′c′d ××
(5, 7) a′bd ××
(6, 7) a′bc ××TABLE 6-2
Prime Implicant 
Chart
If a minterm is covered by only one prime implicant, then that prime implicant 
is called an essential prime implicant and must be included in the minimum sum of products. Essential prime implicants are easy to find using the prime implicant chart. If a given column contains only one X, then the corresponding row is an essential prime implicant. In Table 6-2, columns 9 and 14 each contain one X, so prime impli-cants b ′c′ and cd ′ are essential.
Each time a prime implicant is selected for inclusion in the minimum sum, the 
corresponding row should be crossed out. After doing this, the columns which cor-respond to all minterms covered by that prime implicant should also be crossed out. Table 6-3 shows the resulting chart when the essential prime implicants and the cor-responding rows and columns of Table 6-2 are crossed out. A minimum set of prime implicants must now be chosen to cover the remaining columns. In this example, a′bd covers the remaining two columns, so it is chosen. The resulting minimum sum 
of products is
f=b′c′+cd ′+a′bd
which is the same as Equation (6-4). Note that even though the term a′bd is included 
in the minimum sum of products, a′ bd is not an essential prime implicant. It is the sum 
of minterms m5 and m7; m5 is also covered by a ′c′d, and m7 is also covered by a ′bc.
0 1 2 5 6 7 8 9 10 14
(0, 1, 8, 9) b′c′ ×× ××
×× ××
×× ××
××
××
××(0, 2, 8, 10) b′d′
(2, 6, 10, 14) cd′
(1, 5) a′c′d
(5, 7) a′bd
(6, 7) a′bcTABLE 6-3© Cengage Learning 2014
© Cengage Learning 2014
178 Unit 6
When selecting prime implicants for a minimum sum, the essential prime impli-
cants are chosen first because all essential prime implicants must be included in 
every minimum sum. After the essential prime implicants have been chosen, the minterms which they cover can be eliminated from the prime implicant chart by crossing out the corresponding columns. If the essential prime implicants do not cover all of the minterms, then additional nonessential prime implicants are needed. In simple cases, the nonessential prime implicants needed to form the minimum solution may be selected by trial and error. For larger prime implicant charts, addi-tional procedures for chart reduction can be employed.
1 (Also, see Problem 6.21.) 
Some functions have two or more minimum sum-of-products expressions, each hav-ing the same number of terms and literals. The next example shows such a function.
1For a discussion of such procedures, see E. J. McCluskey, Logic Design Principles (Prentice-Hall, 1986).012567
➀→(0, 1) a′b′××
××
× ×
× ×
× ×
××(0, 2) a′c′
(1, 5) b′c
➁→(2, 6) bc′
➂→(5, 7) ac
(6, 7) abExample A prime implicant chart which has two or more X’s in every column is called a cyclic 
prime implicant chart. The following function has such a chart:
 F=Σ m(0, 1, 2, 5, 6, 7 ) (6-6)
Derivation of prime implicants:
 0  000✓
1  001✓ 0, 1  00−
0, 2  0−0
1, 5  −01
 2  010✓
5  101✓
 2, 6  −10
5, 7  1−1
6, 7  11−
 6  110✓
7  111✓
 
TABLE 6-4 Table 6-4 shows the resulting prime implicant chart. All columns have two X’s, so 
we will proceed by trial and error. Both (0, 1) and (0, 2) cover column 0, so we will 
try (0, 1). After crossing out row (0, 1) and columns 0 and 1, we examine column 2, which is covered by (0, 2) and (2, 6). The best choice is (2, 6) because it covers two of the remaining columns while (0, 2) covers only one of the remaining columns. After crossing out row (2, 6) and columns 2 and 6, we see that (5, 7) covers the remaining columns and completes the solution. Therefore, one solution is F =a′b′+bc ′+ac.
© Cengage Learning  
2014
Quine-McCluskey Method  179
6.3 Petrick’s Method
Petrick’s method is a technique for determining all minimum sum-of-products solu-
tions from a prime implicant chart. The example shown in Tables 6-4 and 6-5 has two minimum solutions. As the number of variables increases, the number of prime implicants and the complexity of the prime implicant chart may increase significantly. In such cases, a large amount of trial and error may be required to find the minimum solution(s). Petrick’s method is a more systematic way of finding all minimum solu-tions from a prime implicant chart than the method used previously. Before applying Petrick’s method, all essential prime implicants and the minterms they cover should be removed from the chart.
We will illustrate Petrick’s method using Table 6-5. First, we will label the rows 
of the table P
1, P2, P3, etc. We will form a logic function, P, which is true when all of 
the minterms in the chart have been covered. Let P1 be a logic variable which is true 
when the prime implicant in row P1 is included in the solution, P2 be a logic variable 
which is true when the prime implicant in row P2 is included in the solution, etc. 
Because column 0 has X’s in rows P1 and P2, we must choose row P1 or P2 in order to 
cover minterm 0. Therefore, the expression (P1+P2) must be true. In order to cover 
minterm 1, we must choose row P1 or P3; therefore, (P1+P3) must be true. In order 012567
P1 (0, 1) a′b′ ××
× ×
××
× ×
××
××P2 (0, 2) a′c′
P3 (1, 5) b′c
P4 (2 6) bc′
P5 (5, 7) ac
P6 (6, 7) abHowever, we are not guaranteed that this solution is minimum. We must go back 
and solve the problem over again starting with the other prime implicant that covers 
column 0. The resulting table (Table 6-5) is
TABLE 6-5 
Finish the solution and show that F=a′c′+b′c+ab. Because this has the same 
number of terms and same number of literals as the expression for F derived in Table 6-4, there are two minimum sum-of-products solutions to this problem. Com-pare these two minimum solutions for Equation (6-6) with the solutions obtained in Figure 5-9 using Karnaugh maps. Note that each minterm on the map can be covered by two different loops. Similarly, each column of the prime implicant chart (Table 6-4) has two X’s, indicating that each minterm can be covered by two different prime implicants.© Cengage Learning  
2014
180 Unit 6
to cover minterm 2, (P2+P4) must be true. Similarly, in order to cover minterms 5, 
6, and 7 , the expressions (P3+P5), (P4+P6) and (P5+P6) must be true. Because we 
must cover all of the minterms, the following function must be true:
P=(P1+P2)(P1+P3)(P2+P4)(P3+P5)(P4+P6)(P5+P6)=1
The expression for P in effect means that we must choose row P1 or P2, and row P1 
or P3, and row P2 or P4, etc.
The next step is to reduce P to a minimum sum of products. This is easy because 
there are no complements. First, we multiply out, using (X+Y)(X+Z)=X+YZ 
and the ordinary distributive law:
P=(P1+P2P3)(P4+P2P6)(P5+P3P6)
=(P1P4+P1P2P6+P2P3P4+P2P3P6)(P5+P3P6)
=P1P4P5+P1P2P5P6+P2P3P4P5+P2P3P5P6+P1P3P4P6
+ P1P2P3P6+P2P3P4P6+P2P3P6
Next, we use X+XY=X to eliminate redundant terms from P, which yields
P=P1P4P5+P1P2P5P6+P2P3P4P5+P1P3P4P6+P2P3P6
Because P must be true (P=1) in order to cover all of the minterms, we can trans-
late the equation back into words as follows. In order to cover all of the minterms, 
we must choose rows P1 and P4 and P5, or rows P1 and P2 and P5 and P6, or . . .  
or rows P2 and P3 and P6. Although there are five possible solutions, only two of 
these have the minimum number of rows. Thus, the two solutions with the minimum number of prime implicants are obtained by choosing rows P
1, P4, and P5 or rows 
P2, P3, and P6. The first choice leads to F=a′b′+bc ′+ac, and the second choice 
to F =a′c′+b′c+ab, which are the two minimum solutions derived in Section 6.2.
In summary, Petrick’s method is as follows:
1. Reduce the prime implicant chart by eliminating the essential prime implicant rows and the corresponding columns.
2. Label the rows of the reduced prime implicant chart P
1, P2, P3, etc.
3. Form a logic function P which is true when all columns are covered. P consists of 
a product of sum terms, each sum term having the form (Pi0+Pi1+· · · ), where 
Pi0, Pi1 . . .  represent the rows which cover column i.
4. Reduce P to a minimum sum of products by multiplying out and applying 
X+XY=X.
5. Each term in the result represents a solution, that is, a set of rows which covers all of the minterms in the table. To determine the minimum solutions (as defined in Section 5.1), find those terms which contain a minimum number of variables. Each of these terms represents a solution with a minimum number of prime implicants.
6. For each of the terms found in step 5, count the number of literals in each prime implicant and find the total number of literals. Choose the term or terms which correspond to the minimum total number of literals, and write out the corre-sponding sums of prime implicants.
Quine-McCluskey Method  181
The application of Petrick’s method is very tedious for large charts, but it is easy to 
implement on a computer.
6.4 Simplification of Incompletely 
Specified Functions
Given an incompletely specified function, the proper assignment of values to the 
don’t-care terms is necessary in order to obtain a minimum form for the function. In this section, we will show how to modify the Quine-McCluskey method in order to obtain a minimum solution when don’t-care terms are present. In the process of finding the prime implicants, we will treat the don’t-care terms as if they were required minterms. In this way, they can be combined with other minterms to elimi-nate as many literals as possible. If extra prime implicants are generated because of the don’t-cares, this is correct because the extra prime implicants will be elimi-nated in the next step anyway. When forming the prime implicant chart, the don’t-cares are not listed at the top. This way, when the prime implicant chart is solved, all of the required minterms will be covered by one of the selected prime implicants.  However, the don’t-care terms are not included in the final solution unless they have been used in the process of forming one of the selected prime implicants. The following example of simplifying an incompletely specified function should clarify the procedure.
F(A, B, C, D )=Σ m(2, 3, 7, 9, 11, 13) +Σ d(1, 10, 15)
                  (the   terms   following   d  are   don’t-care   terms)
The don’t-care terms are treated like required minterms when finding the prime implicants:
 1 0001 ✓ (1, 3) 00–1 ✓ (1, 3, 9, 11) –0–1
 2 0010 ✓ (1, 9) –001 ✓ (2, 3, 10,11) –01–
 3 0011 ✓ (2, 3) 001– ✓ (3, 7 , 11, 15)  - - 11
 9 1001 ✓ (2, 10) –010 ✓ (9, 11, 13, 15) 1 - - 1
10 1010 ✓ (3, 7) 0–11 ✓
 7 0111 ✓ (3, 11) –011 ✓
11 1011 ✓ (9, 11) 10–1 ✓
13 1101 ✓ (9, 13) 1–01 ✓
 5 1111 ✓ (10, 11) 101– ✓
   (7 , 15) –111 ✓
   (11, 15) 1–11 ✓
   (13, 15) 11–1 ✓
182 Unit 6
The don’t-care columns are omitted when forming the prime implicant chart:
F=B′C+CD+AD2 3 7 9 11 13
(1, 3, 9, 11) × ××
×× ×
×× ×
×× ×*(2, 3, 10, 11)
*(3, 7, 11, 15)
*(9, 11, 13, 15)
*Indicates an essential prime implicant.
FIGURE 6-1
Use of Map-
Entered 
Variables
© Cengage Learning 
2014100 01 11 10
XE XF
1E 1 1
100CDAB
G01
11
10 X100 01 11 10
X X
1 1 1
100CDAB
E = F = 0
MS0 = A′B′ + ACD01
1110
XX00 01 11 10
X 1 X
X 1 X X
X00CDAB
E = 1, F = 0
MS1 = A′D01
1110
XX00 01 11 10
X X 1
X X X
X00CDAB
E = 0, F = 1
MS2 = AD
(a) (b) (c) (d)01
1110
XNote that although the original function was incompletely specified, the final 
simplified expression for F is defined for all combinations of values for A, B, C, 
and D and is therefore completely specified. In the process of simplification, we have 
automatically assigned values to the don’t-cares in the original truth table for F. 
If we replace each term in the final expression for F by its corresponding sum of  
minterms, the result is
F=(m2+m3+m10+m11)+(m3+m7+m11+m15)+(m9+m11+m13+m15)
Because m10 and m15 appear in this expression and m1 does not, this implies that the 
don’t-care terms in the original truth table for F have been assigned as follows:
for   ABCD =0001, F=0; for   1010, F=1; for   1111, F=1
6.5 Simplification Using Map-Entered Variables
Although the Quine-McCluskey method can be used with functions with a fairly 
large number of variables, it is not very efficient for functions that have many vari-ables and relatively few terms. Some of these functions can be simplified by using a modification of the Karnaugh map method. By using map-entered variables, Karnaugh map techniques can be extended to simplify functions with more than four or five variables. Figure 6-1(a) shows a four-variable map with two additional variables entered in the squares in the map. When E appears in a square, this means 
Quine-McCluskey Method  183
that if E=1, the corresponding minterm is present in the function G, and if E=0, 
the minterm is absent. Thus, the map represents the six-variable function
G(A, B, C, D , E, F  )=m0+m2+m3+Em5+Em7+Fm9+m11+m15
                      (+ don’t-care  terms)
where the minterms are minterms of the variables A, B, C, and D . Note that m9 is 
present in G only when F =1.
We will now use a three-variable map to simplify the function:
F(A, B, C, D )=A′B′C+A′BC+A′BC′D+ABCD +(AB ′C )
where the AB′C is a don’t-care term. Because D appears in only two terms, we will 
choose it as a map-entered variable, which leads to Figure 6-2(a). We will simplify F 
by first considering D=0 and then D=1. First set D=0 on the map, and F reduces 
to A′C. Setting D =1 leads to the map of Figure 6-2(b). The two 1’s on the original 
map have already been covered by the term A′C, so they are changed to X’s because 
we do not care whether they are covered again or not. From Figure 6-2(b), when 
D=1. Thus, the expression
F=A′C+D(C+A′B)=A′C+CD+A′BD
gives the correct value of F both when D =0 and when D =1. This is a minimum 
expression for F, as can be verified by plotting the original function on a four-variable 
map; see Figure 6-2(c).
Next, we will discuss a general method of simplifying functions using map-entered 
variables. In general, if a variable Pi is placed in square mj of a map of function F, this 
means that F=1 when Pi=1, and the variables are chosen so that mj=1. Given a 
map with variables P1, P2, . . . entered into some of the squares, the minimum sum-of-
products form of F can be found as follows:
Find a sum-of-products expression for F of the form
F=MS0+P1MS1+P2MS2+· · ·
where
MS0 is the minimum sum obtained by setting P1=P2=· · ·=0.
FIGURE 6-2
Simplification Using 
a Map-Entered 
Variable
© Cengage Learning 2014
(c) (b) (a)00 01 11 10
1X X1
11 100BCDA
01
1110 101
XXX1
100BCA
01
111001
1X
1 D
D00BCA
01
1110
184 Unit 6
MS1  is the minimum sum obtained by setting P1=1, Pj=0 ( j≠1), and replac-
ing all 1’s on the map with don’t-cares.
MS2  is the minimum sum obtained by setting P2=1, Pj=0 ( j≠2) and replac-
ing all 1’s on the map with don’t-cares.
(Corresponding minimum sums can be found in a similar way for any remaining 
map-entered variables.)
The resulting expression for F will always be a correct representation of F. This 
expression will be minimum provided that the values of the map-entered variables can be assigned independently. On the other hand, the expression will not generally be minimum if the variables are not independent (for example, if P
1=P2′).
For the example of Figure 6-1(a), maps for finding MS0, MS1, and MS2 are shown 
in Figures 6-1(b), (c), and (d), where E corresponds to P1 and F corresponds to P2. 
The resulting expression is a minimum sum of products for G:
G=A′B′+ACD +EA ′D+FAD
After some practice, it should be possible to write the minimum expression 
directly from the original map without first plotting individual maps for each of the minimum sums.
6.6 Conclusion
We have discussed four methods for reducing a switching expression to a minimum sum-of-products or a minimum product-of-sums form: algebraic simplification, Karnaugh maps, Quine-McCluskey method, and Petrick’s method. Many other methods of sim-plification are discussed in the literature, but most of these methods are based on vari-ations or extensions of the Karnaugh map or Quine-McCluskey techniques. Karnaugh maps are most useful for functions with three to five variables. The Quine-McCluskey technique can be used with a high-speed digital computer to simplify functions with up to 15 or more variables. Such computer programs are of greatest value when used as part of a computer-aided design (CAD) package that assists with deriving the equations as well as implementing them. Algebraic simplification is still valuable in many cases, especially when different forms of the expressions are required. For problems with a large number of variables and a small number of terms, it may be impossible to use the Karnaugh map, and the Quine-McCluskey method may be very cumbersome. In such cases, algebraic simplification may be the easiest method to use. In situations where a minimum solution is not required or where obtaining a minimum solution requires too much computation to be practical, heuristic procedures may be used to simplify switch-ing functions. One of the more popular heuristic procedures is the Espresso-II method,
2 
which can produce near minimum solutions for a large class of problems.
The minimum sum-of-products and minimum product-of-sums expressions we 
have derived lead directly to two-level circuits that use a minimum number of AND 
2This method is described in R. K. Brayton et al., Logic Minimization Algorithms for VLSI Synthesis 
(Kluwer Academic Publishers, 1984).
Quine-McCluskey Method  185
and OR gates and have a minimum number of gate inputs. As discussed in Unit 7 , 
these circuits are easily transformed into circuits that contain NAND or NOR gates. These minimum expressions may also be useful when designing with some types of array logic, as discussed in Unit 9. However, many situations exist where minimum expressions do not lead to the best design. For practical designs, many other factors must be considered, such as the following:
What is the maximum number of inputs a gate can have?What is the maximum number of outputs a gate can drive?Is the speed with which signals propagate through the circuit fast enough?How can the number of interconnections in the circuit be reduced?Does the design lead to a satisfactory circuit layout on a printed circuit board or 
on a silicon chip?
Until now, we have considered realizing only one switching function at a time. 
Unit 7 describes design techniques and Unit 9 describes components that can be used when several functions must be realized by a single circuit.
Programmed Exercise 6.1
Cover the answers to this exercise with a sheet of paper and slide it down as you check your answers.
Find a minimum sum-of-products expression for the following function:
f(A, B, C, D , E)=Σ m(0, 2, 3, 5, 7, 9, 11, 13, 14, 16, 18, 24, 26, 28, 30 )
Translate each decimal minterm into binary and sort the binary terms into groups according to the number of 1’s in each term.
0 00000 ✓0,2 000-0
2 00010 ✓
16 10000
3 00011
5 001019 01001
18 10010
24 11000
7 00111
11 0101113 01101
14 01110
26 1101028 1110030 11110Answer:
Compare pairs of terms in adjacent groups and combine terms where possible. 
(Check off terms which have been combined.)
186 Unit 6
Answer:
02
(0, 2, 16, 18)0 00000 ✓ 0, 2 000−0 ✓ 0, 2, 16, 18 −00−0
2 00010 ✓ 0, 16 −0000
16 10000 ✓ 2, 3 0001−
3 00011 ✓ 2, 18 −0010
5 00101 ✓16, 18 100−0 ✓
9 01001 ✓16, 24 1−000
18 10010 ✓ 3, 7 00−11
24 11000 ✓ 3, 11 0−011
7 00111 ✓ 5, 7 001−1
11 01101 ✓ 5, 13 0−101
13 01101 ✓ 9, 11 010−1
14 01110 ✓ 9, 13 01−01
26 11010 ✓18, 26 1−010
28 11100 ✓24, 26 110−0
30 11110 ✓24, 28 11−00
14, 30 −1110
26, 30 11−10
28, 30 111−0
Now, compare pairs of terms in adjacent groups in the second column and combine 
terms where possible. (Check off terms which have been combined.) Check your work by noting that each new term can be formed in two ways. (Cross out duplicate terms.)
Answer: (third column)
0, 2, 16, 18 –00–0 (check off (0, 2), (16, 18), (0, 16), and (2, 18))
16, 18, 24, 26 1–0–0 (check off (16, 18), (24, 26), (16, 24), and (18, 26))
24, 26, 28, 30 11 -- 0 (check off (24, 26), (28, 30), (24, 28), and (26, 30))
Can any pair of terms in the third column be combined?
Complete the given prime implicant chart.
Quine-McCluskey Method  187
Answer:Answer: No pair of terms in the third column combine.
023579 1 1 1 3 1 4 1 6 1 8 2 4 2 6 2 8 3 0
(0, 2, 16, 18) ×× ××
(16, 18, 24, 26) ××××
(24, 26, 28, 30) ××××
(2, 3) ××
(3, 7) ××
(3, 11) ××
(5, 7) ××
(5, 13) ××
(9, 11) ××
(9, 13) ××
(14, 30) ××
Determine the essential prime implicants, and cross out the corresponding rows and 
columns.
0 2 3 5 7 9 11 13 14 16 18 24 26 28 30
*(0, 2, 16, 18) ××
××××
×× ×
××
××
××
××××
××××
×××
×
×(16, 18, 24, 26)
*(24, 26, 28, 30)
(2, 3)
(3, 7)
(3, 11)
(5, 7)
(5, 13)
(9, 11)
(9, 13)
*(14, 30)
*Indicates an essential prime implicant.
Note that all remaining columns contain two or more X’s. Choose the first column 
which has two X’s and then select the prime implicant which covers the first X in that column. Then, choose a minimum number of prime implicants which cover the remaining columns in the chart.
188 Unit 6
Answer:
0 2 3 5 7 9 11 13 14 16 18 24 26 28 30
*(0, 2, 16, 18) ××
××××
×× ×
××
××
××
××××
××××
×××
×
×(16, 18, 24, 26)
*(24, 26, 28, 30)
(2, 3)
(3, 7)
(3, 11)
(5, 7)
(5, 13)(9, 11)
(9, 13)
*(14, 30)0 2 3 5 7 9 11 13 14 16 18 24 26 28 30
*(0, 2, 16, 18) ××
××××
×× ×
××
××
× ×
××
××
××
× ×
×××
×
×(16, 18, 24, 26)
*(24, 26, 28, 30)
(2, 3)
(3, 7)
→ (3, 11)
→ (5, 7)
(5, 13)(9, 11)
→ (9, 13)
*(14, 30)
*Indicates an essential prime implicant.
From this chart, write down the chosen prime implicants in 0, 1, and – notation.
Then, write the minimum sum of products in algebraic form.
Answer: –00–0, 11 --0, 0–011, 001–1, 01–01, and –1110
f=B′C′E′+ABE ′+A′C′DE+A′B′CE+A′BD ′E+BCDE′
The prime implicant chart with the essential prime implicants crossed out is repeated 
here.Find a second minimum sum-of-products solution.
Answer: Start by choosing prime implicant (5, 13).
f =  BCDE′  +  B′C′E′ +  ABE ′ +  A′B′DE  +  A′CD ′E +  A′BC′E*Indicates an essential prime implicant.
Quine-McCluskey Method  189
Problems
6.2 For each of the following functions, find all of the prime implicants, using the Quine-
McCluskey method.
(a) f(a, b, c , d)=Σ m(1, 5, 7, 9, 11, 12, 14, 15 )
(b) f(a, b, c , d)=Σ m(0, 1, 3, 5, 6, 7, 8, 10, 14, 15 )
6.3 Using a prime implicant chart, find all minimum sum-of-products solutions for each 
of the functions given in Problem 6.2.
6.4 For this function, find a minimum sum-of-products solution, using the Quine-
McCluskey method.
f(a,  b,  c,  d) =   Σ m(1,  3,  4,  5,  6,  7,  10,   12,   13)  +   Σ d(2,  9,  15)
6.5 Find all prime implicants of the following function and then find all minimum solu-
tions using Petrick’s method:
F(A,  B,  C,  D) =  Σ m(9,  12,   13,   15) +  Σ d(1,  4,  5,  7,  8,  11,   14)
6.6 Using the method of map-entered variables, use four-variable maps to find a mini-
mum sum-of-products expression for
(a)  F(A, B, C, D , E)=Σ m(0, 4, 5, 7, 9 )+Σ d(6, 11 )+E(m1+m15), where the m’s 
represent minterms of the variables A, B, C, and D .
(b) Z(A, B, C, D , E, F , G)=Σ m(0, 3, 13, 15) +Σ d(1, 2, 7, 9, 14)
                      +E(m6+m8)+Fm12+Gm5
6.7 For each of the following functions, find all of the prime implicants using the Quine-
McCluskey method.
(a) f(a,  b,  c,  d) =  Σ m(0,  3,  4,  5,  7,  9,  11,   13)
(b) f(a,  b,  c,  d) =  Σ m(2,  4,  5,  6,  9,  10,   11,   12,   13,   15)
6.8 Using a prime implicant chart, find all minimum sum-of-products solutions for each 
of the functions given in Problem 6.7 .
6.9 For each function, find a minimum sum-of-products solution using the Quine-
McCluskey method.
(a) f(a, b, c, d) =  Σ m(2, 3, 4, 7, 9, 11, 12, 13, 14) +  Σ  d(1, 10, 15)
(b) f(a, b, c, d) =  Σ m(0, 1, 5, 6, 8, 9, 11, 13) +  Σ d(7, 10, 12)
(c) f(a, b, c, d) =  Σ m(3, 4, 6, 7, 8, 9, 11, 13, 14) +  Σ d(2, 5, 15)
6.10 Work Problem 5.24(a) using the Quine-McCluskey method.
6.11 F(A, B, C, D , E) =Σ m(0, 2, 6, 7, 8, 10,  11, 12, 13, 14, 16, 18, 19, 29, 30)
                    +Σ d(4, 9, 21)
190 Unit 6
Find the minimum sum-of-products expression for F, using the Quine-McCluskey 
method. Underline the essential prime implicants in this expression.
6.12 Using the Quine-McCluskey method, find all minimum sum-of-products expres-
sions for
(a) f(A,  B,  C,  D,  E) =  Σ m(0,  1,  2,  3,  4,  8,  9,  10,   11,   19,   21,   22,   23,   27,   28,   29,   30)
(b) f(A,  B,  C,  D,  E) =  Σ m(0,  1,  2,  4,  8,  11,   13,   14,   15,   17,   18,   20,   21,   26,   27,   30,   31)
6.13 Using the Quine-McCluskey method, find all minimum product-of-sums expressions 
for the functions of Problem 6.12.
 6.14 (a)  Using the Quine-McCluskey, method find all prime implicants of f(A,  B,  C,  D)  = 
Σ m(1,  3,  5,  6,  8,  9,  12,   14,   15) +  Σ d(4,  10,   13). Identify all essential prime impli-
cants and find all minimum sum-of-products expressions.
(b) Repeat part (a) for f ′.
 6.15 (a)  Use the Quine-McCluskey method to find all prime implicants of f(a,  b,  c,  d,  e)  = 
 Σ m(1,  2,  4,  5,  6,  7,  9,  12,   13,   15,   17,   20,   22,   25,   28,   30). Find all essential prime 
implicants, and find all minimum sum-of-products expressions.
(b) Repeat part (a) for f ′.
6.16 G(A, B, C, D , E, F  )=Σ m(1, 2, 3, 16, 17, 18, 19, 26, 32, 39, 48, 63)
                       +Σ d(15, 28, 29, 30)
(a) Find all minimum sum-of-products expressions for G.
(b) Circle the essential prime implicants in your answer.
(c)  If there were no don’t-care terms present in the original function, how would 
your answer to part (a) change? (Do this by inspection of the prime implicant 
chart; do not rework the problem.)
6.17 (a)  Use the Quine-McCluskey procedure to find all prime implicants of the 
function G(A, B, C, D , E, F  ) =  Σ m(1, 7, 11, 12, 15, 33, 35,  43, 47, 59, 60 )  +
Σ d(30, 50,   54,   58). Identify all essential prime implicants and find all minimum 
sum-of-products expressions.
(b) Repeat part (a) for G′.
6.18 The following prime implicant table (chart) is for a four-variable function f(A, B, C, D ).
(a) Give the decimal representation for each of the prime implicants.
(b) List the maxterms of f.
(c) List the don’t-cares of f, if any.
(d) Give the algebraic expression for each of the essential prime implicants.
2379 1 1 1 3
–0–1 ×× ×
–01– ×× ×
- - 11 ×× ×
1 - - 1 ×××
Quine-McCluskey Method  191
6.19 Packages arrive at the stockroom and are delivered on carts to offices and laborato-
ries by student employees. The carts and packages are various sizes and shapes. The 
students are paid according to the carts used. There are five carts and the pay for their use is
Cart C1: $2Cart C2: $1Cart C3: $4Cart C4: $2Cart C5: $2On a particular day, seven packages arrive, and they can be delivered using the five carts as follows:C1 can be used for packages P1, P3, and P4.C2 can be used for packages P2, P5, and P6.C3 can be used for packages P1, P2, P5, P6, and P7.C4 can be used for packages P3, P6, and P7.C5 can be used for packages P2 and P4.
The stockroom manager wants the packages delivered at minimum cost. Using mini-
mization techniques described in this unit, present a systematic procedure for find-ing the minimum cost solution.
6.20 Use the Quine-McCluskey procedure to find all prime implicants of the function 
h
(A,  B, C, D , E, F , G) =  Σ m(24, 28, 39, 47, 70, 86, 88, 92, 102, 105, 118 ).
Express the prime implicants algebraically.
6.21 Shown below is the prime implicant chart for a completely specified four-variable 
combinational logic function r (w, x, y, z).
(a) Algebraically express r as a product of maxterms.
(b) Give algebraic expressions for the prime implicants labeled A, C, and D  in the 
table.
(c) Find all minimal sum-of-product expressions for r. You do not have to give alge-
braic expressions; instead just list the prime implicants ( A, B, C, etc.) required 
in the sum(s).
6.22 (a)  In the prime implicant chart of Problem 6.21, column 7 is said to cover column 6 
since column 7 has an X in each row that column 6 does. Similarly, column 11 0456789 1 0 1 1 1 3 1 4 1 5
A××
B ×× × ×
C ×× ××
D ××××
E ×× ××
F ×× ××
G××
H ××××
192 Unit 6
covers column 10 and column 15 covers column 14. Columns 7 , 11, and 15 can 
be removed to obtain a simpler chart having the same solutions as the original. Explain why this is correct.
(b) In Table 6-5 (after removing row P
2 and columns 0 and 2), row P3 covers row  P1. 
Row (prime implicant) P1 can be removed, and the resulting chart will have a 
minimum solution for the original table. Explain why this is correct. Are there any restrictions on the two prime implicants to allow removal of the covered prime implicant?
(c) After deleting row P
1 from Table 6-5, row P3 must be included in a minimal solu-
tion for the chart. Why?
6.23 Find all prime implicants of the following function, and then find all minimum solu-
tions using Petrick’s method:
F(A, B, C, D ) =  Σ m(7, 12, 14, 15 ) +  Σ d(1, 3, 5, 8, 10, 11, 13 )
6.24 Using the method of map-entered variables, use four-variable maps to find a 
minimum sum-of-products expression for
(a) F(A, B, C, D , E) =  Σ m(0,  4, 6, 13, 14 )+Σ d(2, 9) +E(m1 +  m12)
(b) Z(A, B, C, D , E, F , G)=Σ m(2, 5, 6, 9) +Σ d(1, 3, 4, 13, 14)
                       +E(m11+m12)+F(m10)+G(m0)
6.25 (a) Rework Problem 6.6(a), using a five-variable map.
(b) Rework Problem 6.6(a), using the Quine-McCluskey method. Note that you 
must express F in terms of minterms of all five variables; the original four-
variable minterms cannot be used.
6.26 Using map-entered variables, find the minimum sum-of-products expressions for the 
following function:
G  =  C′E′F +  DEF  +  AD ′E′F ′ +  BDE′ F +  AD ′EF  ′
193Multi-Level Gate Circuits 
NAND and NOR GatesUNIT
7
Objectives
1. Design a minimal two-level or multi-level circuit of AND and OR gates to real-
ize a given function. (Consider both circuits with an OR gate at the output and 
circuits with an AND gate at the output.)
2. Design or analyze a two-level gate circuit using any one of the eight basic forms (AND-OR, NAND-NAND, OR-NAND, NOR-OR, OR-AND, NOR-NOR, AND-NOR, and NAND-AND).
3. Design or analyze a multi-level NAND-gate or NOR-gate circuit.
4. Convert circuits of AND and OR gates to circuits of NAND gates or NOR gates, and conversely, by adding or deleting inversion bubbles.
5. Design a minimal two-level, multiple-output AND-OR, OR-AND, NAND-NAND, or NOR-NOR circuit using Karnaugh maps.
194 Unit 7
Study Guide
1. Study Section 7 .1, Multi-Level Gate Circuits.
(a) What are two ways of changing the number of levels in a gate circuit?
(b) By constructing a tree diagram, determine the number of gates, gate inputs, 
and levels of gates required to realize Z1 and Z2:
 Z1=[(A+B)C+DE(F+G)]H  Z2=A+B[C+DE(F+G)]
Check your answers by drawing the corresponding gate circuits.
(c) In order to find a minimum two-level solution, why is it necessary to consider 
both a sum-of-products form and a product-of-sums form for the function?
(d) One realization of Z =ABC (D+E)+FG is
A
CB
D
E
F
GZ
Redraw the circuit so that it uses one less gate and so that the output of an 
AND gate never goes directly to the input of another AND gate.
Multi-Level Gate Circuits NAND and NOR Gates  195
(e) Work Problems 7 .1 and 7 .2. Unless otherwise specified, you may always 
assume that both the variables and their complements are available as cir-
cuit inputs.
2. Study Section 7 .2, NAND and NOR Gates.
(a) For each gate, specify the missing inputs:
0
01
11 0
01
(b) What is meant by functionally complete set of logic gates?
(c) How can you show that a set of logic gates is functionally complete?
(d) Show that the NOR gate itself is functionally complete.
(e) Using NAND gates, draw a circuit for F =(A′(BC)′)′.
(f  ) Using NOR gates, draw a circuit for F =((X+Y)′+(X′+Z)′)′.
3. Study Section 7 .3, Design of Two-Level NAND- and NOR-Gate Circuits.
(a) Draw the circuit corresponding to Equation (7-17).
(b) Derive Equation (7-18).
(c) Make sure that you understand the relation between Equations (7-13) 
through (7-21) and the diagrams of Figure 7-11.
(d) Why is the NOR-NAND form degenerate?
196 Unit 7
(e) What assumption is made about the types of inputs available when the pro-
cedures for designing two-level NAND-NAND and NOR-NOR circuits 
are used?
(f  ) For these procedures the literal inputs to the output gate are comple-
mented but not the literal inputs to the other gates. Explain why. Use an equation to illustrate.
(g) A general OR-AND circuit follows. Transform this to a NOR-NOR circuit 
and prove that your transformation is valid.
ℓ1ℓ2
...... ...
...x1 P1
P2Fx2
y1y2
=a
ff b
ca′
b′
c′
=a
ff b
ca′
b′
c′(h) Work Problem 7 .3.
4. Study Section 7 .4, Design of Multi-Level NAND- and NOR-Gate Circuits.
(a) Verify that the NAND circuit of Figure 7-13 is correct by dividing the cor-
responding circuit of AND and OR gates into two-level subcircuits and transforming each subcircuit.
(b) If you wish to design a two-level circuit using only NOR gates, should you 
start with a minimum sum of products or a minimum product of sums?
(c) Note that direct conversion of a circuit of AND and OR gates to a NAND-
gate circuit requires starting with an OR gate at the output, but the direct conversion to a NOR-gate circuit requires starting with an AND gate at the output. This is easy to remember because a NAND is equivalent to an OR with the inputs inverted:
and a NOR is equivalent to an AND with the inputs inverted:
Multi-Level Gate Circuits NAND and NOR Gates  197
(d) Convert the circuit of Figure 7-1(b) to all NAND gates.
(e) Work Problems 7 .4, 7 .5, 7 .6, and 7 .7 .
5. Study Section 7 .5, Circuit Conversion Using Alternative Gate Symbols.
(a) Determine the logic function realized by each of the following circuits:
GA
BA
BCFC
F = G =
(b) Convert the circuit of Figure 7-13(a) to NAND gates by adding bubbles 
and complementing input variables when necessary. (You should have 
added 12 bubbles. Your result should be similar to Figure 7-13(b), except some of the NAND gates will use the alternative symbol.)
(c) Draw a circuit of AND and OR gates for the following equation:
Z=A[BC+D+E
(F+GH)]
Then convert to NOR gates by adding bubbles and complementing inputs when necessary. (You should have added 10 bubbles and complemented six input variables.)
(d) Work Problem 7 .8.
6. Study Section 7 .6, Design of Two-Level, Multiple-Output Circuits.
(a) In which of the following cases would you replace a term 
xy ′ with xy ′z+xy′z′?
(1) Neither xy ′z or xy ′z′ is used in another function.
(2) Both xy ′z and xy ′z′ are used in other functions.
(3) Term xy ′z is used in another function, but xy ′z′ is not.
(b) In the second example (Figure 7-23), in f2, c could have been replaced by 
bc+b′c because bc and b ′c were available “free” from f1 and f3. Why was 
this replacement not made?
198 Unit 7
(c) In the following example, compute the cost of realizing f1 and f2 separately; 
then compute the cost using the term a′b′c in common between the two 
functions. Use a two-level AND-OR circuit in both cases.
(d) Find expressions which correspond to a two-level, minimum multiple-
output, AND-OR realization of F1, F2, and F3. Why should the term cd not 
be included in F1?
F1=
F2=
F3=
(e) Work Problems 7 .9, 7 .10, and 7 .11.
(f  ) Work Problem 7 .12. ( Hint: Work with the 0’s on the maps and first find a 
minimum solution for f1′, f2′,  and f3′.)
7. Study Section 7 .7 , Multiple-Output NAND- and NOR-Gate Circuits.
(a) Derive expressions for the F1 and F2 outputs of the NOR circuits of 
Figure 7-26(b) by finding the equation for each gate output, and show that 
these expressions reduce to the original expressions for F1 and F2.f1 f211101
00bca
01
11
1011
11101
00bca
01
11
10
F1 F2 F3100 01 11 10
1
111100cdab
01
1110100 01 11 10
1
11100cdab
01
1110 1100 01 11 10
11
11100cdab
01
1110
Multi-Level Gate Circuits NAND and NOR Gates  199
(b) Convert Figure 7-26(a) to 7-26(b) by using the bubble method.
(c) Work Problem 7 .13.
Multi-Level Gate Circuits 
NAND and NOR Gates
In the first part of this unit, you will learn how to design circuits which have more 
than two levels of AND and OR gates. In the second part you will learn techniques for designing with NAND and NOR gates. These techniques generally consist of first designing a circuit of AND and OR gates and then converting it to the desired type of gates. These techniques are easy to apply provided that you start with the proper 
form of circuit.
7.1 Multi-Level Gate Circuits
The maximum number of gates cascaded in series between a circuit input and the output is referred to as the number of levels of gates (not to be confused with voltage 
levels). Thus, a function written in sum-of-products form or in product-of-sums form corresponds directly to a two-level gate circuit. As is usually the case in digital cir-cuits where the gates are driven from flip-flop outputs (as discussed in Unit 11), we will assume that all variables and their complements are available as circuit inputs. For this reason, we will not normally count inverters which are connected directly 
200 Unit 7
to input variables when determining the number of levels in a circuit. In this unit we 
will use the following terminology:
1. AND-OR circuit  means a two-level circuit composed of a level of AND gates 
followed by an OR gate at the output.
2. OR-AND circuit means a two-level circuit composed of a level of OR gates fol-
lowed by an AND gate at the output.
3. OR-AND-OR circuit means a three-level circuit composed of a level of OR gates followed by a level of AND gates followed by an OR gate at the output.
4. Circuit of AND and OR gates implies no particular ordering of the gates; the output gate may be either AND or OR.
The number of levels in an AND-OR circuit can usually be increased by factor-
ing the sum-of-products expression from which it was derived. Similarly, the number of levels in an OR-AND circuit can usually be increased by multiplying out some of the terms in the product-of-sums expression from which it was derived. Logic designers are concerned with the number of levels in a circuit for several reasons. Sometimes factoring (or multiplying out) to increase the number of levels of gates will reduce the required number of gates and gate inputs and, thus, reduce the cost of building the circuit, but in other cases increasing the number of levels will increase the cost. In many applications, the number of gates which can be cascaded is limited by gate delays. When the input of a gate is switched, there is a finite time before the output changes. When several gates are cascaded, the time between an input change and the corresponding change in the circuit output may become excessive and slow down the operation of the digital system.
The number of gates, gate inputs, and levels in a circuit can be determined by 
inspection of the corresponding expression. In the example of Figure 7-1(a), the tree diagram drawn below the expression for 
Z indicates that the corresponding circuit 
will have four levels, six gates, and 13 gate inputs, as verified in Figure 7-1(b). Each 
FIGURE 7-1
Four-Level 
Realization of Z
© Cengage Learning 2014
Level 1Level 2Level 3Level 4A Z = (AB + C) (D + E + FG) + H B
CD E
H
ZFG
22
3 2
2
2
(a) (b)
Multi-Level Gate Circuits NAND and NOR Gates  201
node on the tree diagram represents a gate, and the number of gate inputs is written 
beside each node.
We can change the expression for Z to three levels by partially multiplying it out:
Z=(AB+C)[(D+E)+FG]+H
=AB(D + E)+C(D + E)+ABFG +CFG +H
As shown in Figure 7-2, the resulting circuit requires three levels, six gates, and 19 gate inputs.FIGURE 7-2
Three-Level 
Realization of Z
© Cengage Learning 2014
ZHABDE
CA B F G C F GZ = AB(D + E) + C(D + E) + ABFG + CFG + H
2
3 2
(a) (b)43Level 2Level 3
Level 1 5*
* The same gate can be used for
   both appearances of (D + E).
Problem: Find a circuit of AND and OR gates to realize
f(a, b, c , d)=Σ m(1, 5, 6, 10, 13, 14 )
Consider solutions with two levels of gates and three levels of gates. Try to minimize the number of gates and the total number of gate inputs. Assume that all variables and their complements are available as inputs.
Solution: First, simplify f by using a Karnaugh map (Figure 7-3):Example of 
Multi-Level Design Using AND and OR Gates
FIGURE 7-3
© Cengage Learning  
2014 000000 01 11 10
1110
0000000cdab
01
1110 111 f=a′c′d+bc ′d+bcd ′+acd ′ (7-1)
202 Unit 7
This leads directly to a two-level AND-OR gate circuit (Figure 7-4):
Factoring Equation (7-1) yields
 f=c′d(a′+b)+cd ′(a+b) (7-2)
which leads to the following three-level OR-AND-OR gate circuit (Figure 7-5):
Both of these solutions have an OR gate at the output. A solution with an AND gate 
at the output might have fewer gates or gate inputs. A two-level OR-AND circuit corresponds to a product-of-sums expression for the function. This can be obtained from the 0’s on the Karnaugh map as follows:
 
f′=c′d′+ab ′c′+cd+a′b′c (7-3) 
 f=(c+d)(a′+b+c)(c′+d′)(a+b+c′) (7-4) 
Equation (7-4) leads directly to a two-level OR-AND circuit (Figure 7-6):FIGURE 7-4
© Cengage Learning  
2014a′
c′d
b
c′d
bf
c
d′
a
c
d′Two levels 
Five gates 16 gate inputs
FIGURE 7-5
© Cengage Learning  
2014a′
b
ac′
d f
c
d′
bThree levels 
Five gates 12 gate inputs
FIGURE 7-6
© Cengage Learning  
2014c
d
a′
b
c
c′f
d′
a
b
c′Two levels 
Five gates 14 gate inputs
Multi-Level Gate Circuits NAND and NOR Gates  203
To get a three-level circuit with an AND-gate output, we partially multiply out 
Equation (7-4) using (X+Y)(X+Z)=X+YZ:
 f=[c+d(a′+b)][c′+d′(a+b)] (7-5)
Equation (7-5) would require four levels of gates to realize; however, if we 
multiply out d ′(a+b) and d (a′+b), we get
 f=(c+a′d+bd)(c′+ad ′+bd′) (7-6) 
which leads directly to a three-level AND-OR-AND circuit (Figure 7-7):
For this particular example, the best two-level solution had an AND gate at the 
output (Figure 7-6), and the best three-level solution had an OR gate at the output (Figure 7-5). In general, to be sure of obtaining a minimum solution, one must find both the circuit with the AND-gate output and the one with the OR-gate output.
If an expression for 
f′ has n  levels, the complement of that expression is an 
n-level expression for f. Therefore, to realize f as an n-level circuit with an AND-gate 
output, one procedure is first to find an n-level expression for f′ with an OR opera-
tion at the output level and then complement the expression for f′. In the preceding 
example, factoring Equation (7-3) gives a three-level expression for  f′:
 f′=c′(d′+ab ′)+c(d+a′b′)
=c′(d′+a)(d ′+b′)+c(d+a′)(d+b′) (7-7)
Complementing Equation (7-7) gives Equation (7-6), which corresponds to the three-level AND-OR-AND circuit of Figure 7-7 .FIGURE 7-7
© Cengage Learning  
2014a
d′
b
d′c′
fa′
d
b
dcThree levels 
Seven gates 16 gate inputs
204 Unit 7
7.2 NAND and NOR Gates
Until this point we have designed logic circuits using AND gates, OR gates, and 
inverters. Exclusive-OR and equivalence gates have also been introduced in Unit 3. In this section we will define NAND and NOR gates. Logic designers frequently use NAND and NOR gates because they are generally faster and use fewer components than AND or OR gates. As will be shown later, any logic function can be imple-mented using only NAND gates or only NOR gates.
Figure 7-8(a) shows a three-input NAND gate. The small circle (or “bub-
ble”) at the gate output indicates inversion, so the NAND gate is equivalent to an AND gate followed by an inverter, as shown in Figure 7-8(b). A more appropriate name would be an AND-NOT gate, but we will follow common usage and call it a NAND gate. The gate output is
F=
(ABC )′=A′+B′+C′
The output of the n-input NAND gate in Figure 7-8(c) is
 F=(X1X2 . . . Xn)′=X1′+X2′+· · ·+Xn′ (7-8)
The output of this gate is 1 iff one or more of its inputs are 0.
Figure 7-9(a) shows a three-input NOR gate. The small circle at the gate output 
indicates inversion, so the NOR gate is equivalent to an OR gate followed by an 
inverter. A more appropriate name would be an OR-NOT gate, but we will follow common usage and call it a NOR gate. The gate output is
 F=
(A+B+C)′=A′B′C′ 
The output of an n-input NOR gate, shown in Figure 7-9(c), is F=
(X1+X2+· · ·+Xn)′=X1′X2′ . . . Xn′ (7-9) FIGURE 7-8
NAND Gates
© Cengage Learning 2014X1
X2
XnA
BF
C
(a) Three-input NAND gateA
BFF
C
(b) NAND gate equivalent (c) n-input NAND gate
...
FIGURE 7-9
NOR Gates
© Cengage Learning 2014X1
X2
XnA
BF
C
(a) Three-input NOR gateA
BFF
C
(b) NOR gate equivalent (c) n-input NOR gate
...
Multi-Level Gate Circuits NAND and NOR Gates  205
A set of logic operations is said to be functionally complete if any Boolean 
function can be expressed in terms of this set of operations. The set AND, OR, and 
NOT is obviously functionally complete because any function can be expressed in sum-of-products form, and a sum-of-products expression uses only the AND, OR, and NOT operations. Similarly, a set of logic gates is functionally complete if all switching functions can be realized using this set of gates. Because the set of oper-ations AND, OR, and NOT is functionally complete, any set of logic gates which can realize AND, OR, and NOT is also functionally complete. AND and NOT are a functionally complete set of gates because OR can also be realized using AND and NOT:
FIGURE 7-10
NAND Gate 
Realization of  
NOT, AND, and OR
© Cengage Learning 2014X
A A′
B′ BX′A
B(AB)′
(A′B′)′ = A + BABIf a single gate forms a functionally complete set by itself, then any switching 
function can be realized using only gates of that type. The NAND gate is an exam-
ple of such a gate. Because the NAND gate performs the AND operation followed by an inversion, NOT, AND, and OR can be realized using only NAND gates, as shown in Figure 7-10. Thus, any switching function can be realized using only NAND gates. An easy method for converting an AND-OR circuit to a NAND circuit is discussed in the next section. Similarly, any function can be realized using only NOR gates.
The following procedure can be used to determine if a given set of gates is func-
tionally complete. First, write out a minimum sum-of-products expression for the function realized by each gate. If no complement appears in any of these expressions, then NOT cannot be realized, and the set is not functionally complete. If a comple-ment appears in one of the expressions, then NOT can generally be realized by an appropriate choice of inputs to the corresponding gate. (We will always assume that 0 and 1 are available as gate inputs). Next, attempt to realize AND or OR, keeping in mind that NOT is now available. Once AND or OR has been realized, the other one can always be realized using DeMorgan’s laws if no more direct procedure is appar-ent. For example, if OR and NOT are available, AND can be realized by
 
XY=(X′+Y′)′ (7-10)X
YX′X′Y′(X ′Y′)′ = X + Y
Y′
206 Unit 7
7.3 Design of Two-Level NAND- and  
NOR-Gate Circuits
In this section two-level circuits realizing a function F using various combinations of 
NAND, NOR, AND, and OR gates are obtained by converting the switching algebra 
expression for F into the form matching the desired gate circuit. It is difficult to extend 
this approach to multiple-level circuits because it requires repeated complementa-tion of parts of the expression for 
F. In Sections 7 .4 and 7 .5, an alternative method is 
developed which first realizes F in the desired form using AND and OR gates. The 
circuit with AND and OR gates is converted to one containing NAND or NOR gates by inserting inverters in pairs to convert each AND and OR gate to a NAND or NOR gate. This approach avoids manipulation of the expression for 
F and is less error prone.
A two-level circuit composed of AND and OR gates is easily converted to a cir-
cuit composed of NAND gates or NOR gates. This conversion is carried out by using F=
(F ′)′ and then applying DeMorgan’s laws:
 ( X1+X2+· · ·+Xn)′=X1′X2′ · · · Xn′ (7-11) 
 ( X1X2 · · · Xn)′=X1′+X2′+· · ·+Xn′ (7-12) 
The following example illustrates conversion of a minimum sum-of-products form to several other two-level forms:
 F=A+BC′ +B′CD=[
(A+BC′ +B′CD)′]′ (7-13) 
 =[A′·(BC′)′·(B′CD)′]′ (by 7-11) (7-14) 
 =[A′·(B′+C)·(B+C′+D′)]′ (by 7-12) (7-15)
 =A+(B′+C)′+(B+C′+D′)′ (by 7-12) (7-16)
Equations (7-13), (7-14), (7-15), and (7-16) represent the AND-OR, NAND-NAND, 
OR-NAND, and NOR-OR forms, respectively, as shown in Figure 7-11.
Rewriting Equation (7-16) in the form
 F=5[A+(B′+C)′+(B+C′+D′)′]′6′ (7-17) 
leads to a three-level NOR-NOR-INVERT circuit. However, if we want a two-level circuit containing only NOR gates, we should start with the minimum product-of-sums form for 
F instead of the minimum sum of products. After obtaining the 
minimum product of sums from a Karnaugh map, F can be written in the following 
two-level forms:
 F=(A+B+C)(A+B′+C′)(A+C′+D)
=5[(A+B+C)(A+B′+C′)(A+C′+D)]′6′ (7-18) 
 =[(A+B+C)′+(A+B′+C′)′+(A+C′+D)′]′ (by 7-12) (7-19)
 =(A′B′C′+A′BC+A′CD ′)′ (by 7-11) (7-20)
 = (A′B′C′)′·(A′BC)′·(A′CD ′)′ (by 7-11) (7-21)
Multi-Level Gate Circuits NAND and NOR Gates  207
FIGURE 7-11
Eight Basic Forms 
for Two-Level 
Circuits
© Cengage Learning 2014
F
A
C′
DA
B′
C′A
B
C
OR-
ANDF = (A + B + C )(A + B′ + C′)(A + C′ + D)       (7-18)
F = (A′B′C′ + A′BC + A′CD′)′       (7-20)NAND-
ANDNOR-
NOR
AND-
NORB
C′
AFB′
C
D
B′
C
AFB
C′
D′
B′
C
A′ FB
C′
D′AND-
ORF = A + BC′ + B′CD
F = [A′ ∙ (B′ + C ) ∙ (B + C′ + D′)]′       (7-15)F = A + (B′ + C )′ + (B + C′ + D′)′
(7-16)F = [A′ ∙ (BC′)′ ∙ (B′CD)′]′
(7-14)
F = (A′B′C′)′ ∙ (A′BC )′ ∙ (A′CD′)′
(7-21)F = [(A + B + C )′ + (A + B′ + C′)′
+ (A + C′ + D)′]′     (7-19)NOR-
ORNAND-
NAND
OR-
NAND(7-13)
B
C′
A′ FB′
C
D
F
A
C′
DA
B′
C′A
B
C
F
A′
C
D′A′
B
CA′
B′
C′F
A′
C
D′A′
B
CA′
B′
C′
208 Unit 7
Equations (7-18), (7-19), (7-20), and (7-21) represent the OR-AND, NOR-NOR, 
AND-NOR, and NAND-AND forms, respectively, as shown in Figure 7-11. Two-level AND-NOR (AND-OR-INVERT) circuits are available in integrated-circuit form. Some types of NAND gates can also realize AND-NOR circuits when the  so-called wired OR connection is used.
The other eight possible two-level forms (AND-AND, OR-OR, OR-NOR, 
AND-NAND, NAND-NOR, NOR-NAND, etc.) are degenerate in the sense that they cannot realize all switching functions. Consider, for example, the following NAND-NOR circuit:
FIGURE 7-12
AND-OR to 
NAND-NAND 
Transformation
© Cengage Learning 2014
... ......x1ℓ1ℓ2ℓ′1
ℓ′2
(a) Before transformationP1
P2Fx2
...y1y2
... ......x1
(b) After transformationP′1
P2′Fx2
...y1y2From this example, it is clear that the NAND-NOR form can realize only a product of literals and not a sum of products.
Because NAND and NOR gates are readily available in integrated circuit 
form,  two of the most commonly used circuit forms are the NAND-NAND and the NOR-NOR. Assuming that all variables and their complements are available as inputs, the following method can be used to realize 
F with NAND gates:
Procedure for designing a minimum two-level NAND-NAND circuit:
1. Find a minimum sum-of-products expression for F.
2. Draw the corresponding two-level AND-OR circuit.
3. Replace all gates with NAND gates leaving the gate interconnections unchanged. 
If the output gate has any single literals as inputs, complement these literals.
Figure 7-12 illustrates the transformation of step 3. Verification that this transforma-tion leaves the circuit output unchanged follows. In general, 
F is a sum of literals 
(ℓ1, ℓ2, . . .) and product terms (P1, P2, . . .):
F=ℓ1+ℓ2+· · ·+P1+P2+· · ·
After applying DeMorgan’s law,
F=(ℓ1′ ℓ2′ · · · P1′ P2′ · · ·)′F=[(ab)′+(cd)′+e]′=abcde ′a
b
c
de F
Multi-Level Gate Circuits NAND and NOR Gates  209
ExampleSo the output OR gate is replaced with a NAND gate with inputs, ℓ1′,  ℓ2′, · · ·, 
P1′,  P2′, · · · . Because product terms P1, P2, . . . are each realized with an AND gate, 
P1′,  P2′, . . . are each realized with a NAND gate in the transformed circuit.
Assuming that all variables and their complements are available as inputs, the 
following method can be used to realize F with NOR gates:
Procedure for designing a minimum two-level NOR-NOR circuit:
1. Find a minimum product-of-sums expression for F.
2. Draw the corresponding two-level OR-AND circuit.
3. Replace all gates with NOR gates leaving the gate interconnections unchanged. 
If the output gate has any single literals as inputs, complement these literals.
This procedure is similar to that used for designing NAND-NAND circuits. Note, however, that for the NOR-NOR circuit, the starting point is a minimum product of 
sums rather than a sum of products.
7.4 Design of Multi-Level NAND- and  
NOR-Gate Circuits
The following procedure may be used to design multi-level NAND-gate circuits:
1. Simplify the switching function to be realized.
2. Design a multi-level circuit of AND and OR gates. The output gate must be OR. 
AND-gate outputs cannot be used as AND-gate inputs; OR-gate outputs cannot be used as OR-gate inputs.
3. Number the levels starting with the output gate as level 1. Replace all gates with NAND gates, leaving all interconnections between gates unchanged. Leave the inputs to levels 2,
 4, 6, . . . unchanged. Invert any literals which appear as inputs 
to levels 1,  3, 5, . . . .
The validity of this procedure is easily proven by dividing the multi-level circuit into two-level subcircuits and applying the previous results for two-level circuits to each of the two-level subcircuits. The example of Figure 7-13 illustrates the procedure. Note that if step 2 is performed correctly, each level of the circuit will contain only AND gates or only OR gates.
The procedure for the design of multi-level NOR-gate circuits is exactly the same 
as for NAND-gate circuits except the output gate of the circuit of AND and OR gates must be an AND gate, and all gates are replaced with NOR gates.
F
1=a′[b′+c(d+e′)+f  ′g′]+hi′j+k
Figure 7-13 shows how the AND-OR circuit for F1 is converted to the corresponding 
NAND circuit.
210 Unit 7
7.5 Circuit Conversion Using Alternative 
Gate Symbols
Logic designers who design complex digital systems often find it convenient to use 
more than one representation for a given type of gate. For example, an inverter can be represented by
In the second case, the inversion “bubble” is at the input instead of the output. 
Figure 7-14 shows some alternative representations for AND, OR, NAND, and NOR gates. These equivalent gate symbols are based on DeMorgan’s laws.
These alternative symbols can be used to facilitate the analysis and design of NAND- 
and NOR-gate circuits. Figure 7-15(a) shows a simple NAND-gate circuit. To analyze the circuit, we will replace the NAND gates at the first and third levels with the alterna-tive NAND gate symbol. This eliminates the inversion bubble at the circuit output.FIGURE 7-13
Multi-Level Circuit 
Conversion to 
NAND Gates
© Cengage Learning  
2014Level 5 Level 4 Level 3
(a) AND-OR networkLevel 2 Level 1
d
e′c
f′
g′b′a′
hk F1
i′
j
Level 5 Level 4 Level 3
(b) NAND networkLevel 2 Level 1
d′
ec
f′
g′ba′
hk′ F1
i′
j
A or A′ AA ′
FIGURE 7-14
Alternative Gate 
Symbols
© Cengage Learning  
2014A
BA
AB = (A′ + B′)′
(a) ANDA + B = (A′B′)′
(b) ORBAB A + B A
BA
(AB)′ = A′ + B′
(c) NAND(A + B)′ = A′B′
(d) NORB(AB) ′ (A + B)′
Multi-Level Gate Circuits NAND and NOR Gates  211
In the resulting circuit (Figure 7-15(b)), inverted outputs (those with a bubble) are 
always connected to inverted inputs, and noninverted outputs are connected to non-inverted inputs. Because two inversions in a row cancel each other out, we can easily analyze the circuit without algebraically applying DeMorgan’s laws. Note, for example, that the output of gate 2 is [
(A′+B)C]′, but the term (A′+B)C appears in the output 
function. We can also convert the circuit to an AND-OR circuit by simply removing the double inversions (see Figure 7-15(c)). When a single input variable is connected to an inverted input, we must also complement that variable when we remove the inversion from the gate input. For example, 
A in Figure 7-15(b) becomes A′ in Figure 7-15(c).
The circuit of AND and OR gates shown in Figure 7-16(a) can easily be con-
verted to a NOR-gate circuit because the output gate is an AND-gate, and AND and OR gates alternate throughout the circuit. That is, AND-gate outputs connect only to OR-gate inputs, and OR-gate outputs connect only to AND-gate inputs. To carry out conversion to NOR-gates, we first replace all of the OR and AND gates with NOR gates, as shown in Figure 7-16(b). Because each inverted gate output drives an inverted gate input, the pairs of inversions cancel. However, when an input variable drives an inverted input, we have added a single inversion, so we must complement the variable to compensate. Therefore, we have complemented 
C and G. The result-
ing NOR-gate circuit is equivalent to the original AND-OR circuit.
Even if AND and OR gates do not alternate, we can still convert an AND-OR 
circuit to a NAND or NOR circuit, but it may be necessary to add extra inverters so that each added inversion is cancelled by another inversion. The following proce-dure may be used to convert to a NAND (or NOR) circuit:
1. Convert all AND gates to NAND gates by adding an inversion bubble at the 
output. Convert all OR gates to NAND gates by adding inversion bubbles at the FIGURE 7-15
NAND Gate Circuit 
Conversion
© Cengage Learning 2014A
B′C
DFZ
E12
3
(a) NAND gate network4
A A′ + B[(A′ + B)C ]′
(DE)′B′C
DFZ  = (A′ + B)C  + F ′ + DE
E2
3
(b) Alternate form for NAND gate network
A′
BC
DF′ Z
E2
3
(c) Equivalent AND-OR network1
1
44
212 Unit 7
inputs. (To convert to NOR, add inversion bubbles at all OR-gate outputs and 
all AND-gate inputs.)
2. Whenever an inverted output drives an inverted input, no further action is needed because the two inversions cancel.
3. Whenever a noninverted gate output drives an inverted gate input or vice versa, insert an inverter so that the bubbles will cancel. (Choose an inverter with the bubble at the input or output as required.)FIGURE 7-16
Conversion to 
NOR Gates
© Cengage Learning 2014
Double inversion cancels
Complemented input
cancels inversionA
B′CD
EG
Z
F
(a) Circuit with OR and AND gates
A
B′C′D
EG′ Z
F
(b) Equivalent circuit with NOR gates
FIGURE 7-17
Conversion of 
AND-OR Circuit 
to NAND Gates
© Cengage Learning 2014
A
B′CD′E′FAdded inverter
(c) Completed conversionAdded inverterA
B′CDEFBubbles cancel
(b) First step in NAND conversionA
B′CDEF
(a) AND-OR network
Multi-Level Gate Circuits NAND and NOR Gates  213
4. Whenever a variable drives an inverted input, complement the variable (or add 
an inverter) so the complementation cancels the inversion at the input.
In other words, if we always add bubbles (or inversions) in pairs, the function realized 
by the circuit will be unchanged. To illustrate the procedure we will convert Figure 7-17(a) to NANDs. First, we add bubbles to change all gates to NAND gates (Figure 7-17(b)). In four places (highlighted in blue), we have added only a single inversion. This is corrected in Figure 7-17(c) by adding two inverters and complementing two variables.
Note that when an inverter is added between two gates during the conversion 
procedure, the number of levels in the circuit is increased by 1. This is avoided if each path through the circuit alternately passes through AND and OR gates. Similarly, if the circuit containing AND and OR gates has an output OR (AND) gate and it is converted to a circuit with NOR (NAND) gates, then it is necessary to add an inverter at the output, which also increases the number of levels by 1. Hence, if a NAND (NOR) gate circuit is desired, it is usually best to start with a circuit contain-ing AND and OR gates that has an output OR (AND) gate.
An advantage of multi-level circuits is that gate fan-in can be reduced. As an 
example, consider
 F=D′E+BCE +AB ′+AC ′ 
(7-22)
A two-level AND-OR circuit implementing F requires one 4-input OR, one 3-input 
AND, and three 2-input ANDs. To reduce the fan-in, F can be factored.
 F=A(B′+C′)+E(D′+BC) (7-23)
The resulting four-level circuit using AND and OR gates is shown in Figure 7-18.
Since the output gate is an OR, the circuit can be converted to NAND gates 
without increasing the number of levels; Figure 7-19 is the result. Note that the three-
level OR with inputs B′ and C′ and the four-level AND with inputs B and C both 
become a NAND with inputs B and C; hence, both can be replaced by the same gate.FIGURE 7-18
Limited Fan-In 
Circuit
© Cengage Learning 2014FA
E
D′B′
C′
B
C
FIGURE 7-19
NAND Gate 
Equivalent of 
Figure 7-18
© Cengage Learning 2014B
C
DEA
F
214 Unit 7
Reducing the fan-in for some functions requires inserting inverters. The fan-in 
for F=ABC +D can be reduced to 2 by factoring F as F =(AB)C+D. If this is 
implemented using two-input NAND gates, an inverter is required and the resulting 
circuit has four levels.
7.6 Design of Two-Level, Multiple-Output 
Circuits
Solution of digital design problems often requires the realization of several func-
tions of the same variables. Although each function could be realized separately, the use of some gates in common between two or more functions sometimes leads to a more economical realization. The following example illustrates this:
Design a circuit with four inputs and three outputs which realizes the functions
 F
1(A, B, C, D )=Σ m(11, 12, 13, 14, 15)  
F2(A, B, C, D )=Σ m(3, 7, 11, 12, 13, 15)
F3(A, B, C, D )=Σ m(3, 7, 12, 13, 14, 15)  (7-24) 
First, each function will be realized individually. The Karnaugh maps, functions, 
and resulting circuit are given in Figures 7-20 and 7-21. The cost of this circuit is 9 gates and 21 gate inputs.
An obvious way to simplify this circuit is to use the same gate for 
AB in both 
F1 and F3. This reduces the cost to eight gates and 19 gate inputs. (Another, but less 
obvious, way to simplify the circuit is possible.) Observing that the term ACD is 
necessary for the realization of F1 and A′CD is necessary for F3, if we replace CD 
in F2 by A′CD+ACD , the realization of CD is unnecessary and one gate is saved. 
Figure 7-22 shows the reduced circuit, which requires seven gates and 18 gate inputs. Note that F
2 is realized by the expression ABC′ +A′CD+ACD , which is not a 
minimum sum of products, and two of the terms are not prime implicants of F2. Thus 
in realizing multiple-output circuits, the use of a minimum sum of prime implicants 
FIGURE 7-20
Karnaugh Maps for 
Equations (7-24)
© Cengage Learning 2014
F1 F2 F3100 01 11 10
1
1100CDAB
01
11
10 1100 01 11 10
1
111100CDAB
01
1110100 01 11 10
1
11100CDAB
01
1110 1
Multi-Level Gate Circuits NAND and NOR Gates  215
for each function does not necessarily lead to a minimum cost solution for the circuit 
as a whole.
When designing multiple-output circuits, you should try to minimize the total 
number of gates required. If several solutions require the same number of gates, the one with the minimum number of gate inputs should be chosen. The next example further illustrates the use of common terms to save gates. A four-input, three-output circuit is to be designed to realize
 f1=Σ m(2, 3, 5, 7, 8, 9, 10, 11, 13, 15)
f2=Σ m(2, 3, 5, 6, 7, 10, 11, 14, 15)
f3=Σ m(6, 7, 8, 9, 13, 14, 15)  (7-25)
First, we plot maps for f1, f2, and f3 (Figure 7-23). If each function is minimized sepa-
rately, the result is
 f1=bd+b′c+ab ′
f2=c+a′bd 
 f3=bc+ab ′c′+%abd
  or
ac ′d- 10 gates,
 25 gate inputs 
(7-25(a)) FIGURE 7-22
Multiple-Output 
Realization of 
Equations (7-24)
© Cengage Learning 2014A
B F1
A
C
D F2
A
B
C′
A′
C
D F3FIGURE 7-21
Realization of 
Equations (7-24)
© Cengage Learning 2014A
A
BC
D F1 = AB + ACD
A
C
DB
C′ F2 = ABC′  + CD
A′
A
BC
D F3 = A′ CD + AB
216 Unit 7
By inspecting the maps, we can see that terms a′bd (from f2), abd (from f3), and ab ′c′ 
(from f3) can be used in f1. If bd is replaced with a′bd+abd, then the gate needed to 
realize bd can be eliminated. Because m10 and m11 in f1 are already covered by b′c, ab ′c′ 
(from f3) can be used to cover m8 and m9, and the gate needed to realize ab ′ can be 
eliminated. The minimal solution is therefore
 f1=a′bd+abd +ab ′c′+b′c
f2=c+a′bd eight gates
f3=bc+ab ′c′+abd 22 gate inputs (7-25(b))
(Terms which are used in common between two functions are underlined.)
When designing multiple-output circuits, it is sometimes best not to combine a 1 
with its adjacent 1’s, as illustrated in the example of Figure 7-24.
The solution with the maximum number of common terms is not necessarily 
best, as illustrated in the example of Figure 7-25.
Determination of Essential Prime Implicants  
for Multiple-Output Realization
As a first step in determining a minimum two-level, multiple-output realization, it is 
often desirable to determine essential prime implicants. However, we must be careful because some of the prime implicants essential to an individual function may not be essential to the multiple-output realization. For example, in Figure 7-23, bd is an essen-
tial prime implicant of 
f1 (only prime implicant which covers m5), but it is not essential to 
the multiple-output realization. The reason that bd is not essential is that m5 also appears 
on the f2 map and, hence, might be covered by a term which is shared by f1 and f2. 
We can find prime implicants which are essential to one of the functions and to 
the multiple-output realization by a modification of the procedure used for the single-output case. In particular, when we check each 1 on the map to see if it is covered by only one prime implicant, we will only check those 1’s which do not appear on the other function maps. Thus, in Figure 7-24 we find that c′d is essential to 
f1 for the 
multiple-output realization (because of m1), but abd  is not essential because m15 also abdab′c′
a′bd100 01 11 10
111
1111
100cdab
01
1110 100 01 11 10
1
1111100cdab
01
1110 111100 01 11 10
11
1100cdab
01
1110 11FIGURE 7-23
© Cengage Learning 2014
Multi-Level Gate Circuits NAND and NOR Gates  217
appears on the f2 map. In Figure 7-25, the only minterms of f1 which do not appear on 
the f2 map are m2 and m5. The only prime implicant which covers m2 is a′d′; hence, a′d′
is essential to f1 in the multiple-output realization. Similarly, the only prime implicant 
which covers m5 is a ′bc ′, and a ′bc ′ is essential. On the f2 map, bd′  is essential. Why?
Once the essential prime implicants for f1 and f2 have been looped, selection of 
the remaining terms to form the minimum solution is obvious in this example. The 
techniques for finding essential prime implicants outlined above cannot be applied in a problem such as Figure 7-23, where every minterm of 
f1 also appears on the f2 or f3 map.
A general procedure for finding the minimum multiple output AND-OR circuit 
requires finding the prime implicants of not only each function but, also, of the prod-uct of all functions. If three functions 
f1, f2, and f3 are being realized, then the prime 
implicants of f1, f2, f3, f1 f2, f1 f3, f2 f3, and f1  f2  f3 are required. The optimum solution is 
obtained by selecting the fewest prime implicants from these prime implicants to realize 
f1, f2, and f3. This procedure is not discussed further in this text.
7.7 Multiple-Output NAND- and NOR-Gate 
Circuits
The procedure given in Section 7 .4 for design of single-output, multi-level NAND- 
and NOR-gate circuits also applies to multiple-output circuits. If all of the output gates are OR gates, direct conversion to a NAND-gate circuit is possible. If all FIGURE 7-24
00 01 11 10
1 1 1 1
100cdab
f101
11
101 100 01 11 10
100cdab
f201
1110
1 100 01 11 10
1 1 1 1
100cdab
f1
(a) Best solution (b) Solution requires an extra gate01
11101 100 01 11 10
100cdab
f201
1110
1 1
00 01 11 10
111
11100cdab
f1
(a) Solution with maximum number of
common terms requires 8 gates, 26 inputs01
11101 1
1100 01 11 10
00cdab
f201
1110
1 100 01 11 10
111
11100cdab
f1
(b) Best solution requires 7 gates, 18 inputs
and has no common terms01
11101 100 01 11 10
00cdab
f201
1110
1 11
1FIGURE 7-25© Cengage Learning 2014
© Cengage Learning 2014
218 Unit 7
of the output gates are AND, direct conversion to a NOR-gate circuit is possible. 
Figure 7-26 gives an example of converting a two-output circuit to NOR gates. Note that the inputs to the first and third levels of NOR gates are inverted.
F
1=[(a+b′ )c+d](e′+f  )      F2=[(a+b′ )c+g′](e′+f  )h
Problems
7.1 Using AND and OR gates, find a minimum circuit to realize
f(a,  b,  c,  d)=m4+m6+m7+m8+m9+m10
(a) using two-level logic
(b) using three-level logic (12 gate inputs minimum)
7.2  Realize the following functions using AND and OR gates. Assume that there are no 
restrictions on the number of gates which can be cascaded and minimize the number of gate inputs.
(a) 
AC′D+ADE ′+BE′ +BC ′+A′D′E′
(b) AE+BDE +BCE+BCFG+BDF G+AFG
7.3 Find eight different simplified two-level gate circuits to realize
F(a, b, c , d)=a′bd+ac ′dFIGURE 7-26
Multi-Level Circuit 
Conversion to 
NOR Gates
© Cengage Learning 2014Level 4 Level 3
(a) Network of AND and OR gatesLevel 2 Level 1
a
b′cd
e′
f
g′hF1
F2
(b) NOR networka
b′c′d
e′
f
g′h′F1
F2
Multi-Level Gate Circuits NAND and NOR Gates  219
7.4 Find a minimum three-level NAND-gate circuit to realize
F(A, B, C, D )=Σ m(5, 10, 11, 12, 13 ) (four  gates )
7.5 Realize Z =A′D+A′C+AB ′C′D′ using four NOR gates.
7.6 Realize Z=ABC +AD +C′D′ using only two-input NAND gates. Use as few 
gates as possible.
7.7 Realize Z=AE+BDE +BCE F using only two-input NOR gates. Use as few gates 
as possible.
7.8 (a)  Convert the following circuit to all NAND gates, by adding bubbles and inverters 
where necessary.
(b) Convert to all NOR gates (an inverter at the output is allowed).
A′
B
C
D′E
F
G′Z
7.9 Find a two-level, multiple-output AND-OR gate circuit to realize the following 
functions. Minimize the required number of gates (six gates minimum).
f1=ac+ad+b′d  and  f2=a′b′+a′d′+cd ′
7.10 Find a minimum two-level, multiple-output AND-OR gate circuit to realize these 
functions.
f1(a, b, c , d)=Σ m(3, 4, 6, 9, 11)
f2(a, b, c , d)=Σ m(2, 4, 8, 10, 11, 12)
f3(a, b, c , d)=Σ m(3, 6, 7, 10, 11)       (11 gates minimum)
7.11 Find a minimum two-level OR-AND circuit to simultaneously realize
F1(a, b, c , d)=Σ m(2, 3, 8, 9, 14, 15)
F2(a, b, c , d)=Σ m(0, 1, 5, 8, 9, 14, 15)
(minimum solution has eight gates)
7.12 Find a minimum two-level OR-AND circuit to realize the functions given in 
Equations (7-25) on page 215 (nine gates minimum).
7.13  (a)  Find a minimum two-level NAND-NAND circuit to realize the functions given 
in Equations (7-25) on page 215.
(b) Find a minimum two-level NOR-NOR circuit to realize the functions given in 
Equations (7-25).
220 Unit 7
7.14 Using AND and OR gates, find a minimum circuit to realize
f(a, b, c , d)=M0 M1 M3 M13 M14 M15
(a) using two-level logic
(b) using three-level logic (12 gate inputs minimum)
7.15 Using AND and OR gates, find a minimum two-level circuit to realize
(a) F=a′c+bc ′d+ac ′d
(b) F=(b′+c)(a+b′+d)(a+b+c′+d )
(c) F=a′cd ′+a′bc+ad
(d) F=a′b+ac+bc+bd′
7.16 Realize the following functions using AND and OR gates. Assume that there are no 
restrictions on the number of gates which can be cascaded and minimize the number 
of gate inputs.
(a) ABC′ +ACD +A′BC+A′C′D
(b) ABCE +ABEF +ACD ′+ABEG +ACD E
7.17  A combinational switching circuit has four inputs (A, B, C, D ) and one output (F ). 
F=0 iff three or four of the inputs are 0.
(a) Write the maxterm expansion for F.
(b) Using AND and OR gates, find a minimum three-level circuit to realize F (five 
gates, 12 inputs).
7.18 Find eight different simplified two-level gate circuits to realize
(a) F(w, x, y, z)=(x+y′+z)(x′+y+z)w
(b) F(a, b, c , d)=Σ m(4, 5, 8, 9, 13 )
7.19 Implement f(x, y, z)=Σ m(0, 1, 3, 4, 7 ) as a two-level gate circuit, using a minimum 
number of gates.
(a) Use AND gates and NAND gates.
(b) Use NAND gates only.
7.20 Implement f(a, b, c , d)=Σ m(3, 4, 5, 6, 7, 11, 15 ) as a two-level gate circuit, using a 
minimum number of gates.
(a) Use OR gates and NOR gates.
(b) Use NOR gates only.
7.21 Realize each of the following functions as a minimum two-level NAND-gate circuit 
and as a minimum two-level NOR-gate circuit.
(a) F(A,B,C,D)=BD ′+B′CD+A′BC+A′BC′D+B′D′
(b) f(a, b, c , d)=Π M(0, 1, 7, 9, 10, 13 )·Π D(2, 6, 14, 15 )
(c) f(a, b, c , d)=Σ m(0, 2, 5, 10 )+Σ d(3, 6, 9, 13, 14, 15 )
(d) F(A, B, C, D , E) =Σ m(0, 2, 4, 5, 11, 14, 16, 17, 18, 22, 23, 25, 26, 31)
                                       +Σ d(3, 19, 20, 27, 28 )
Multi-Level Gate Circuits NAND and NOR Gates  221
(e) F(A, B, C, D , E) =Π M(3, 4, 8, 9, 10, 11, 12, 13, 14, 16, 19, 22, 25, 27)
                                         ·Π D(17, 18, 28, 29 )
(f  ) f(a, b, c , d)=Π M(1, 3, 10, 11, 13, 14, 15 )·Π D(4, 6)
(g) f(w, x, y, z)=Σ m(1, 2, 4, 6, 8, 9, 11, 12, 13 )+Σ d(0, 7, 10, 15 )
7.22 A combinational switching circuit has four inputs and one output as shown. F=0 iff 
three or four of the inputs are 1.
(a) Write the maxterm expansion for F.
(b) Using AND and OR gates, find a minimum three-level circuit to realize F 
(5 gates, 12 inputs).
A
B
CDF
fA
B
C
7.25 (a)  Use gate equivalences to convert the circuit of Problem 7 .24 into a five-level cir-
cuit containing only NOR gates and a minimum number of inverters. (Assume 
the inputs are available only in uncomplemented form.)
(b) Derive a minimum POS expression for f.
(c) By manipulating the expression for f, find a four-level circuit containing only six 
NOR gates and inverters.7.23 Implement f(a, b, c , d)=Σ m(3, 4, 5, 6, 7, 11, 15 ) as a two-level gate circuit, using a 
minimum number of gates.
(a) Use AND gates and NAND gates.
(b) Use OR gates and NAND gates.
(c) Use NAND gates only.
7.24 (a)  Use gate equivalences to convert the circuit into a four-level circuit containing 
only NAND gates and a minimum number of inverters. (Assume the inputs are available only in uncomplemented form.)
(b) Derive a minimum SOP expression for 
f.
(c) By manipulating the expression for f, find a three-level circuit containing only 
five NAND gates and inverters.
222 Unit 7
7.26 In the circuit, replace each NOR gate by an AND or OR gate so that the resulting 
circuit contains the fewest inverters possible. Assume the inputs are available in 
both true and complemented form. Do not replace the exclusive-OR gates.
B
C′A′
D′
E′
FGJWH
I′
C
D
fAB7.27 (a)  Convert the circuit shown into a four-level circuit only containing AND and OR 
gates and a minimum number of inverters.
(b) Derive a sum-of-products expression for f.
(c) Find a circuit that realizes f  ′ containing only NOR gates (no internal inverters). 
(Hint: Use gate conversions to convert the NAND gates in the given circuit to NOR gates.)
7.28 
f(a, b, c , d, e )=Σ m(2, 3, 6, 12, 13, 16, 17, 18, 19, 22, 24, 25, 27, 28, 29, 31 )
(a) Find a minimum two-level NOR-gate circuit to realize f.
(b) Find a minimum three-level NOR-gate circuit to realize f.
7.29 Design a minimum three-level NOR-gate circuit to realize
f=a′b′+abd +acd
7.30 Find a minimum four-level NAND- or NOR-gate circuit to realize
(a) Z=abe ′f+c′e′f+d′e′f+gh
(b) Z=(a′+b′+e+f )(c′+a′+b)(d′+a′+b)(g+h)
7.31 Implement abde ′+a′b′+c using four NOR gates.
7.32 Implement x′yz+xvy′w′+xvy′z′ using a three-level NAND-gate circuit.
Multi-Level Gate Circuits NAND and NOR Gates  223
7.33 Design a logic circuit that has a 4-bit binary number as an input and one output. The 
output should be 1 iff the input is a prime number (greater than 1) or zero.
(a) Use a two-level NAND-gate circuit.
(b) Use a two-level NOR-gate circuit.
(c) Use only two-input NAND gates.
7.34 Work Problem 7 .33 for a circuit that has an output 1 iff the input is evenly divisible 
by 3 (0 is divisible by 3).
7.35 Realize the following functions, using only two-input NAND gates. Repeat using 
only two-input NOR gates.
(a) F=A′BC′ +BD+AC+B′CD ′
(b) F=A′CD+AB ′C′D+ABD ′+BC
7.36 (a)  Find a minimum circuit of two-input AND and two-input OR gates to realize 
F(A, B, C, D )=Σ m(0, 1, 2, 3, 4, 5, 7, 9, 11, 13, 14, 15 )
(b) Convert your circuit to two-input NAND gates. Add inverters where necessary.
(c) Repeat (b), except convert to two-input NOR gates.
7.37 Realize Z=A[BC′ +D+E(F′+GH)] using NOR gates. Add inverters if necessary.
7.38 Show that the function of Equation (7-22) can be realized using four 2-input NOR 
gates and one 3-input NOR gate. Assume the inputs are available both comple-
mented and uncomplemented. (No inverters are required.)
7.39 F(A, B, C ) equals 1 if exactly two of A, B, and C are 1.
(a) Find the minimum two-level OR-AND circuit for F.
(b) Find a four-level circuit for F that has six 2-input NOR gates.
(c) Find the minimum two-level AND-OR circuit for F.
(d) Find a three-level circuit for F that has three 2-input NAND gates and two 
2-input XOR gates.
7.40 (a)  Use gate conversions to convert the circuit below into one containing NAND 
and XOR gates.
(b) Find the minimum two-level OR-AND circuit for F.
(c) Find a three-level circuit for F that has five 2-input NAND gates.
B′A′A
B
C F
C′
224 Unit 7
7.41 In which of the following two-level circuit forms can an arbitrary switching function 
be realized? Verify your answers. (Assume the inputs are available in both comple-
mented and uncomplemented form.)
(a) NOR-AND
(b) NOR-OR
(c) NOR-NAND
(d) NOR-XOR
(e) NAND-AND
(f  ) NAND-OR
(g) NAND-NOR
(h) NAND-XOR
7.42 Find a minimum two-level, multiple-output AND-OR gate circuit to realize these 
functions (eight gates minimum).
f1(a, b, c , d  )=Σ m(10, 11, 12, 15) +Σ d(4, 8, 14)
f2(a, b, c , d  )=Σ m(0, 4, 8, 9) +Σ d(1, 10, 12)
f3(a, b, c , d  )=Σ m(4, 11, 13, 14, 15) +Σ d(5, 9, 12)
7.43 Repeat 7 .42 for the following functions (six gates).
f1(a, b, c , d)=Σ m(2, 3, 5, 6, 7, 8, 10)
f2(a, b, c , d)=Σ m(0, 1, 2, 3, 5, 7, 8, 10)
7.44 Repeat 7 .42 for the following functions (eight gates).
f1(x, y, z)=Σ m(2, 3, 4, 5)
f2(x, y, z)=Σ m(1, 3, 5, 6)
f3(x, y, z)=Σ m(1, 2, 4, 5, 6)
7.45 (a)  Find a minimum two-level, multiple-output OR-AND circuit to realize 
f1=b′d +a′b′+c′d and f2=a′d′+bc ′+bd′.
(b) Realize the same functions with a minimum two-level NAND-NAND circuit.
7.46 Repeat Problem 7 .45 for f1=ac ′+b′d+c′d and f2=b′c+a′d+cd ′.
7.47 (a)  Find a minimum two-level, multiple-output NAND-NAND circuit to realize 
f1=Σ m(3, 6, 7, 11, 13, 14, 15 ) and f2=Σ m(3, 4, 6, 11, 12, 13, 14 ).
(b) Repeat for a minimum two-level, NOR-NOR circuit.
7.48 (a)  Find a minimum two-level, multiple-output NAND-NAND circuit to realize 
f1=Σ m(0, 2, 4, 6, 7, 10, 14 ) and f2=Σ m(0, 1, 4, 5, 7, 10, 14 ).
(b) Repeat for a minimum two-level, multiple-output NOR-NOR circuit.
7.49 Draw a multi-level, multiple-output circuit equivalent to Figure 7-26(a) using:
(a) NAND and AND gates
(b) NAND gates only (a direct conversion is not possible)
225Combinational Circuit Design 
and Simulation Using GatesUNIT
8
Objectives
1. Draw a timing diagram for a combinational circuit with gate delays.
2. Define static 0- and 1 -hazards and dynamic hazards. Given a combinational 
 circuit, find all of the static 0- and 1 -hazards. For each hazard, specify the order in which the gate outputs must switch in order for the hazard to actually  produce a false output.
3. Given a switching function, realize it using a two-level circuit which is free of static and dynamic hazards (for single input variable changes).
4. Design a multiple-output NAND or NOR circuit using gates with limited fan-in.
5. Explain the operation of a logic simulator that uses four-valued logic.
6. Test and debug a logic circuit design using a simulator.
226 Unit 8
Study Guide
1. Obtain your design problem assignment from your instructor.
2. Study Section 8.1, Review of Combinational Circuit Design.
3. Generally, it is possible to redesign a circuit which has two AND gates cas-
caded or two OR gates cascaded so that AND and OR gates alternate. If this is not practical, the conversion to a NAND or NOR circuit by the techniques of Section 7 .4 is still possible by introducing a dummy one-input OR (AND) gate between the two AND (OR) gates. When the conversion is carried out, the dummy gate becomes an inverter. Try this technique and convert the following circuit to all NAND gates. Alternatively, you may use the procedures given in Section 7 .5 to do the conversion.
4. Study Section 8.2, Design of Circuits with Limited Gate Fan-In.
(a) If a realization of a switching expression requires too many inputs on one 
or more gates, what should be done?
(b) Assuming that all variables and their complements are available as inputs 
and that both AND and OR gates are available, does realizing the comple-ment of an expression take the same number of gates and gate inputs as realizing the original expression?
(c) When designing multiple-output circuits with limited gate fan-in, why is 
the procedure of Section 7 .6 of little help?
5. (a)  Study Section 8.3, Gate Delays and Timing Diagrams . Complete the 
timing diagram for the given circuit. Assume that the AND gate has a 30-nanosecond
 (ns) propagation delay and the inverter has a 20-ns delay.
ZB′B
0 20 40 60 80 100 120 t(ns)A
A
BB′Zfa
b′
d′
ec
g′
Combinational Circuit Design and Simulation Using Gates  227
(b) Work Problem 8.1.
6. Study Section 8.4, Hazards in Combinational Logic.
(a) Even though all of the gates in a circuit are of the same type, each indi-
vidual gate may have a different propagation delay. For example, for one 
type of TTL NAND gate the manufacturer specifies a minimum propaga-tion delay of 5
 ns and a maximum delay of 30  ns. Sketch the gate outputs 
for the following circuit when the x input changes from 1 to 0, assuming the 
following gate delays:
(a)  gate 1–5   ns (b)  gate 2–20   ns (c)  gate 3–10   ns
(b) Define static 0-hazard, static 1 -hazard, and dynamic hazard.
(c) Using a Karnaugh map, explain why F=a′b+ac has a 1 -hazard for the 
input change abc =011 to 111, but not for 011 to 010. Then explain it with-
out using the map.
(d) Explain why F=(a′+b′)(b+c) has a 0-hazard for the input change 
abc =100   to   110, but not for 100 to 000.
(e) Under what condition does a sum-of-products expression represent a 
hazard-free, two-level AND-OR circuit?
(f  ) Under what condition does a product-of-sums expression represent a 
hazard-free, two-level OR-AND circuit?
(g) If a hazard-free circuit of AND and OR gates is transformed to NAND 
or NOR gates using the procedure given in Unit 7 , why will the results be 
hazard-free?
(h) Work Problems 8.2 and 8.3.Zy2y1y1
y2
50 40 30 20 10 0 t(ns)x
x 1
0Z13
2
228 Unit 8
7. Study Section 8.5, Simulation and Testing of Logic Circuits.
(a) Verify that Table 8-1 is correct. Consider both the case where the unknown 
value, X, is 0 and the case where it is 1.
(b) The following circuit was designed to realize the function
F=[A′+B+C′D][A+B′+(C′+D′)(C+D)]
When a student builds the circuit in lab, he finds that when A=C=0 and 
B=D =1, the output F has the wrong value and that the gate outputs are as shown. 
Determine some possible causes of the incorrect output if G =0 and if G =1
(c) Work Problems 8.4 and 8.5.
8. Study your assigned design problem and prepare a design which meets specifica-
tions. Note that only two-, three-, and four-input NAND gates (or NOR gates as specified) and inverters are available for this project; therefore, factoring some of the equations will be necessary. Try to make an economical design by using common terms; however, do not waste time trying to get an absolute minimum solution. When counting gates, count both NAND (or NOR) gates and inverters, but do not count the inverters needed for the input variables.
9. Check your design carefully before simulating it. Test it on paper by applying 
some input combinations of 0’s and 1’s and tracing the signals through to make sure that the outputs are correct. If you have a CAD program such as LogicAid 
available, enter the truth table for your design into the computer, derive the minimum two-level equations, and compare them with your solution.
10. In designing multi-level, multiple-output circuits of the type used in the design problems in this unit, it is very difficult and time-consuming to find a minimum solution. You are not expected to find the best possible solution to these prob-lems. All of these solutions involve some “tricks,” and it is unlikely that you 
could find them without trying a large number of different ways of factoring your equations. Therefore, if you already have an acceptable solution, do not waste time trying to find the minimum solution. Because integrated circuit gates are quite inexpensive, it is not good engineering practice to spend a large amount of time finding the absolute minimum solution unless a very large number of units of the same type are to be manufactured.
11. Obtain a Unit 8 supplement from your instructor and follow the instructions therein regarding simulating and testing your design.C′
D′
CC A′
B
AF
B′D′
G
01 00
1
0
D1357
6
4
2
229Combinational Circuit Design 
and Simulation Using Gates
8.1 Review of Combinational Circuit Design
The first step in the design of a combinational switching circuit is usually to set up a 
truth table which specifies the output(s) as a function of the input variables. For n input 
variables this table will have 2n rows. If a given combination of values for the input 
variables can never occur at the circuit inputs, the corresponding output values are don’t-cares. The next step is to derive simplified algebraic expressions for the output functions using Karnaugh maps, the Quine-McCluskey method, or a similar proce-dure. In some cases, particularly if the number of variables is large and the number of terms is small, it may be desirable to go directly from the problem statement to alge-braic equations, without writing down a truth table. The resulting equations can then be simplified algebraically. The simplified algebraic expressions are then manipulated into the proper form, depending on the type of gates to be used in realizing the circuit.
The number of levels in a gate circuit is equal to the maximum number of gates 
through which a signal must pass when going between the input and output termi-nals. The minimum sum of products (or product of sums) leads directly to a mini-mum two-level gate circuit. However, in some applications it is desirable to increase the number of levels by factoring (or multiplying out) because this may lead to a reduction in the number of gates or gate inputs.
When a circuit has two or more outputs, common terms in the output functions 
can often be used to reduce the total number of gates or gate inputs. If each function is minimized separately, this does not always lead to a minimum multiple-output circuit. For a two-level circuit, Karnaugh maps of the output functions can be used to find the common terms. All of the terms in the minimum multiple-output circuit will not necessarily be prime implicants of the individual functions. When designing circuits with three or more levels, looking for common terms on the Karnaugh maps may be of little value. In this case, the designer will often minimize the functions separately and, then, use ingenuity to factor the expressions in such a way to create common terms.
Minimum two-level AND-OR, NAND-NAND, OR-NAND, and NOR-OR 
 circuits can be realized using the minimum sum of products as a starting point. Mini-mum two-level OR-AND, NOR-NOR, AND-NOR, and NAND-AND circuits can be realized using the minimum product of sums as a starting point. Design of multi-level, 
230 Unit 8
multiple-output NAND-gate circuits is most easily accomplished by first designing a 
circuit of AND and OR gates. Usually, the best starting point is the minimum sum-of-products expressions for the output functions. These expressions are then factored in various ways until an economical circuit of the desired form can be found. If this circuit has an OR gate at each output and is arranged so that an AND- gate (or OR-gate) output is never connected to the same type of gate, a direct conversion to a NAND-gate circuit is possible. Conversion is accomplished by replacing all of the AND and OR gates with NAND gates and then inverting any literals which appear as inputs to the first, third, fifth, . . . levels (output gates are the first level).
If the AND-OR circuit has an AND-gate (or OR-gate) output connected to the 
same type of gate, then extra inverters must be added in the conversion process (see Section 7 .5, Circuit Conversion Using Alternative Gate Symbols).
Similarly, design of multi-level, multiple-output NOR-gate circuits is most easily 
accomplished by first designing a circuit of AND and OR gates. In this case the best starting point is usually the minimum sum-of-products expressions for the comple-
ments of the output functions. After factoring these expressions to the desired form, 
they are then complemented to get expressions for the output functions, and the cor-responding circuit of AND and OR gates is drawn. If this circuit has an AND gate at each output, and an AND-gate (or OR-gate) output is never connected to the same type of gate, a direct conversion to a NOR-gate circuit is possible. Otherwise, extra inverters must be added in the conversion process.
8.2 Design of Circuits with Limited Gate Fan-In
In practical logic design problems, the maximum number of inputs on each gate (or the fan-in) is limited. Depending on the type of gates used, this limit may be two, three, four, eight, or some other number. If a two-level realization of a circuit requires more gate inputs than allowed, factoring the logic expression to obtain a multi-level realization is necessary.
map of f :
f′ = a′b′c′d + ab ′cd + abc ′ + a′bc + a′cd ′110100 01 11 10
0101
1010
000cdab
01
11
10 011Realize f(a, b, c , d)=Σm(0, 3, 4, 5, 8, 9, 10, 14, 15 ) using three-input NOR gates. Example
Combinational Circuit Design and Simulation Using Gates  231
As can be seen from the preceding expression, a two-level realization requires two 
four-input gates and one five-input gate. The expression for f ′ is factored to reduce 
the maximum number of gate inputs to three and, then, it is complemented:
f ′=b′d(a′c′+ac)+a′c(b+d′)+abc ′
f=[b+d′+(a+c)(a ′+c′)][a+c′+b′d][a′+b′+c]
The resulting NOR-gate circuit is shown in Figure 8-1.
FIGURE 8-1
© Cengage Learning 
2014
a
c
a′b
d′
d′ba′
cb′ fa
c′
c′
FIGURE 8-2
© Cengage Learning 
2014
f1 = Σ m(0, 2, 3, 4, 5) f2 = Σ m(0, 2, 3, 4, 7) f3 = Σ m(1, 2, 6, 7)1
1
100bca
01
11
1011 11
11
100bca
01
11
1001 01 01
1
1
100bca
01
11
10 1The techniques for designing two-level, multiple-output circuits given in 
Section 7 .6 are not very effective for designing multiple-output circuits with more 
than two levels. Even if the two-level expressions had common terms, most of these common terms would be lost when the expressions were factored. Therefore, when designing multiple-output circuits with more than two levels, it is usually best to minimize each function separately. The resulting two-level expressions must then be factored to increase the number of levels. This factoring should be done in such a way as to introduce common terms wherever possible.
Realize the functions given in Figure 8-2, using only two-input NAND gates and inverters. If we minimize each function separately, the result is
f1=b′c′ +  ab ′ +  a′b
f2=b′c′ +  bc  +  a′b
f3=a′b′c +  ab  +  bc ′Example
232 Unit 8
Each function requires a three-input OR gate, so we will factor to reduce the num-
ber of gate inputs:
f1=b′(a +  c′) +  a′b
f2=b(a′ +  c) +  b′c′    or    f2=(b′+c)(b+c′) +  a′b
f3=a′b′c+b(a +  c′)
The second expression for f2 has a term common to f1, so we will choose the second 
expression. We can eliminate the remaining three-input gate from f3 by noting that
a′b′c=a′(b′c)=a′(b+c′)′
Figure 8-3(a) shows the resulting circuit, using common terms a′b and a+c′. Because 
each output gate is an OR, the conversion to NAND gates, as shown in Figure 8-3(b), is straightforward.
8.3 Gate Delays and Timing Diagrams
When the input to a logic gate is changed, the output will not change instantaneously. The transistors or other switching elements within the gate take a finite time to react to a change in input, so that the change in the gate output is delayed with respect to the input change. Figure 8-4 shows possible input and output waveforms for an inverter. If the change in output is delayed by time, ε
  , with respect to the input, we say that this gate 
has a propagation delay of ε . In practice, the propagation delay for a 0 to 1 output change 
may be different than the delay for a 1 to 0 change. Propagation delays for integr ated 
circuit gates may be as short as a few nanoseconds (1 na nosecond = 10−9 second), and 
in many cases these delays can be neglected. However, in the analysis of some types of sequential circuits, even short delays may be important.
Timing diagrams are frequently used in the analysis of sequential circuits. These 
diagrams show various signals in the circuit as a function of time. Several variables are usually plotted with the same time scale so that the times at which these vari-ables change with respect to each other can easily be observed.FIGURE 8-3  Realization of Figure 8-2  
a′
c
b
c′
b′b′
a′
a′
bbf1
f2
f3b′c
c
(b)a
c′
b′
c
bb′
a′
a′
bbf1
f2
f3b′c
c′
(a)© Cengage Learning 2014
Combinational Circuit Design and Simulation Using Gates  233
Figure 8-5 shows the timing diagram for a circuit with two gates. We will assume 
that each gate has a propagation delay of 20 ns (nanoseconds ). This timing diagram 
indicates what happens when gate inputs B and C are held at constant values 1 and 
0, respectively, and input A is changed to 1 at t=40 ns and then changed back to 0 
at t=100 ns. The output of gate G1 changes 20  ns after A changes, and the output of 
gate G2 changes 20  ns after G1 changes.
Figure 8-6 shows a timing diagram for a circuit with an added delay element. The 
input X consists of two pulses, the first of which is 2  microseconds  (2×10−6 second ) 
wide and the second is 3 microseconds wide. The delay element has an output Y 
which is the same as the input except that it is delayed by 1 microsecond. That is, Y 
changes to a 1 value 1 microsecond after the rising edge of the X pulse and returns 
to 0 1 microsecond after the falling edge of the X pulse. The output (Z) of the AND 
gate should be 1 during the time interval in which both X and Y are 1. If we assume 
a small propagation delay in the AND gate (ε), then Z will be as shown in Figure 8-6.FIGURE 8-4
Propagation Delay 
in an Inverter
© Cengage Learning 2014
X′X′
ε1 ε2TimeX
XTime
FIGURE 8-5
Timing Diagram for 
AND-NOR Circuit
© Cengage Learning 2014
0 20 40 60 80 100 120 140 t(ns)G2
G2G1G1A
A
B = 1C = 020 ns
20 ns 20 ns20 ns
FIGURE 8-6 Timing Diagram for Circuit with Delay  
111
0 1 2 3 4 5 6 7 8 9 10000
ZYX
X
Y Z
Time (microseconds)Rising edge Falling edge
2 
1 1s  3 
1 Delayμs
μs
εμsμs
μs© Cengage Learning 2014
234 Unit 8
8.4 Hazards in Combinational Logic
When the input to a combinational circuit changes, unwanted switching transients 
may appear in the output. These transients occur when different paths from input to output have different propagation delays. If, in response to any single input change and for some combination of propagation delays, a circuit output may momentar-ily go to 0 when it should remain a constant 1, we say that the circuit has a static 1 -hazard. Similarly, if the output may momentarily go to 1 when it should remain a 0, we say that the circuit has a static 0-hazard. If, when the output is supposed to change from 0 to 1 (or 1 to 0), the output may change three or more times, we say that the circuit has a dynamic hazard. Figure 8-7 shows possible outputs from a circuit with hazards. In each case the steady-state output of the circuit is correct, but a switching transient appears at the circuit output when the input is changed.
FIGURE 8-7  Types of Hazards  
 © Cengage Learning 2014
011 1 1 1
0 00
(a) Static 1-hazard (c) Dynamic hazards001
01
(b) Static 0-hazard
Figure 8-8(a) illustrates a circuit with a static 1 -hazard. If A =C =1, then 
F=B +B′=1, so the F output should remain a constant 1 when B changes from 
1 to 0. However, as shown in Figure 8-8(b), if each gate has a propagation delay of 10
  ns, E will go to 0 before D goes to 1, resulting in a momentary 0 (a glitch caused 
by the 1 -hazard) appearing at the output F. Note that right after B changes to 0, both 
the inverter input (B) and output (B′) are 0 until the propagation delay has elapsed. 
During this period, both terms in the equation for F are 0, so F momentarily goes to 0.
Note that hazards are properties of the circuit and are independent of the delays 
existing in the circuit. If the circuit is free of hazards, then for any combination of delays that might exist in the circuit and for any single input change, the output will not contain a transient. On the other hand, if a circuit contains a hazard, then there is some combination of delays and some input change for which the circuit output contains a transient. The combination of delays that produces the transient may or may not be likely to occur in an implementation of the circuit; in some cases it is very unlikely that such delays would occur.
Besides depending on the delays existing in a circuit, the occurrence of transients 
depends on how gates respond to input changes. In some cases, if multiple input changes to a gate occur within a short time period, a gate may not respond to the input changes. For example, in Figure 8-8 assume the inverter has a delay of 2 ns rather than 10 ns. Then the D  and E changes reaching the output OR gate are 2 ns 
apart, in which case the OR gate may not generate the 0 glitch. A gate exhibiting 
Combinational Circuit Design and Simulation Using Gates  235
this behavior is said to have an inertial delay. Quite often the inertial delay value is 
assumed to be the same as the propagation delay of the gate; if this is the case, the 
circuit of Figure 8-8 will generate the 0 glitch only for inverter delays greater than 10 ns. In contrast, if a gate always responds to input changes (with a propagation delay), no matter how closely spaced the input changes may be, the gate is said to have an ideal or transport delay. If the OR gate in Figure 8-8 has an ideal delay, then the 0 glitch would be generated for any nonzero value of the inverter delay. (Inertial and transport delay models are discussed more in Unit 10.) Unless otherwise noted, the examples and problems in this unit assume that gates have an ideal delay.
Hazards can be detected using a Karnaugh map (Figure 8-8(a)). As seen on the 
map, no loop covers both minterms 
ABC and AB′C. So if A =C =1 and B  changes, 
both terms can momentarily go to 0, resulting in a glitch in F. We can detect hazards 
in a two-level AND-OR circuit, using the following procedure:
1. Write down the sum-of-products expression for the circuit.
2. Plot each term on the map and loop it.
3. If any two adjacent 1’s are not covered by the same loop, a 1 -hazard exists for 
the transition between the two 1’s. For an n-variable map, this transition occurs 
when one variable changes and the other n −1 variables are held constant.
If we add a loop to the map of Figure 8-8(a) and, then, add the corresponding 
gate to the circuit (Figure 8-9), this eliminates the hazard. The term AC remains 1 
while B is changing, so no glitch can appear in the output. Note that F is no longer a 
minimum sum of products. FIGURE 8-8
Detection of a 
1-Hazard
© Cengage Learning 2014
0 ns 10 ns 20 ns 30 ns
(b) Timing chart(a) Circuit with a static 1-hazard
40 ns 50 ns1-hazard
60 nsFEDBBAD
EF
C F =AB′ +BC  0101
1 0
1
01000BCA
01
11
10
236 Unit 8
Figure 8-10(a) shows a circuit with several 0-hazards. The product-of-sums repre-
sentation for the circuit output is
F=(A+C)(A′+D′)(B′+C′+D)
The Karnaugh map for this function (Figure 8-10(b)) shows four pairs of adjacent 
0’s that are not covered by a common loop as indicated by the arrows. Each of these pairs corresponds to a 0-hazard. For example, when 
A=0, B =1, D =0, and C 
changes from 0 to 1, a spike may appear at the Z output for some combination 
of gate delays. The timing diagram of Figure 8-10(c) illustrates this, assuming gate delays of 3 ns for each inverter and of 5 ns for each AND gate and each OR gate.FIGURE 8-9
Circuit with Hazard 
Removed
© Cengage Learning 2014BA
AFC
F = AB′ + BC + AC0101
1 0
1
01000BCA
01
11
10
FIGURE 8-10
Detection of a 
Static 0-Hazard
© Cengage Learning 2014C
DAW
YZ
B
Xat 5 ns, 0 →1
at 10 ns, 0 →1
at 8 ns, 1 →0
(a) Circuit with a static 0-hazard (b) Karnaugh map for circuit of (a)at 13 ns, 1 →0at 15 ns, 0 →1
at 18 ns, 1 →0
4
0 5 10
(c) Timing diagram illustrating 0-hazard of (a)15 8 13 18 20ZYXWC0000 01 11 10
0000
0000CDAB
01
1110 001
2
3
Combinational Circuit Design and Simulation Using Gates  237
We can eliminate the 0-hazards by looping additional prime implicants that cover 
the adjacent 0’s that are not already covered by a common loop. This requires three 
additional loops as shown in Figure 8-11. The resulting equation is
F=(A+C)(A′+D′)(B′+C′+D)(C+D′)(A+B′+D)(A′+B′+C′)
and the resulting circuit requires seven gates in addition to the inverters.
FIGURE 8-11
Karnaugh Map 
Removing Hazards 
of Figure 8-10
© Cengage Learning 20140000 01 11 10
0000
0000CDAB
01
11
10 00
Hazards in circuits with more than two levels can be determined by deriving 
either a SOP or POS expression for the circuit that represents a two-level circuit 
containing the same hazards as the original circuit. The SOP or POS expression is derived in the normal manner except that the complementation laws are not used, 
i.e., 
xx′=0 and x+x′=1 are not used. Consequently, the resulting SOP (POS) 
expression may contain products (sums) of the form xx′α (x+x′+β). (α is a product 
of literals or it may be null; β is a sum of literals or it may be empty.) The comple-
mentation laws are not used because we are analyzing the circuit behavior resulting from an input change. As that input change propagates through the circuit, at a given point in time a line tending toward the value 
x may not have the value that is the 
complement of a line tending toward the value x′. In the SOP expression, a product 
of the form xx′α represents a pseudo gate that may temporarily have the output 
value 1 as x changes and if α =1.
Given the SOP expression, the circuit is analyzed for static 1 -hazards the same as 
for a two-level AND-OR circuit, i.e., the products are mapped on a Karnaugh map and if two 1’s are adjacent on the map and not included in one of the products, they correspond to a static 1 -hazard. The circuit can have a static 0-hazard or a dynamic hazard only if the SOP expression contains a term of the form 
xx′α. A static 0-hazard 
exists if there are two adjacent 0’s on the Karnaugh map for which α=1 and the 
two input combinations differ just in the value of x. A dynamic hazard exists if there 
is a term of the form xx′α and two conditions are satisfied: (1) There are adjacent 
input combinations on the Karnaugh map differing in the value of x, with α =1 and 
with opposite function values, and (2) for these input combinations the change in x 
propagates over at least three paths through the circuit.
238 Unit 8
As an example consider the circuit of Figure 7-7 . The expression for the circuit 
output is
f=(c′+ad ′+bd′)(c+a′d+bd) 
=cc′+acd ′+bcd ′+a′c′d+aa′dd′+a′bdd′ +bc ′d+abdd′ +bdd′
=cc′+acd ′+bcd ′+a′c′d+aa′dd′+bc ′d+bdd′
The Karnaugh map for this function is shown as the circled 1’s in Figure 7-3. It is 
derived in the normal way ignoring the product terms containing both a variable and 
its complement. The circuit does not contain any static 1 -hazards because each pair of adjacent 1’s are covered by one of the product terms. Potentially, the terms cc′ and 
bdd′  may cause either static 0- or dynamic hazards or both; the first for c changing 
and the second for d changing. (The term aa′dd′ cannot cause either hazard because, 
for example, if a  changes the dd′  part of the product forces it to 0.) With a=
0, b=0, and 
d=0 and c  changing, the circuit output is 0 before and after the change, and because 
the cc′ term can cause the output to temporarily become 1, this transition is a static 
0-hazard. Similarly, a change in c, with a=1, b=0, and d=1, is a static 0-hazard. 
The cc′ term cannot cause a dynamic hazard because there are only two physical 
paths from input c  to the circuit output.
The term bdd′  can cause a static 0- or dynamic hazard only if b=1. From the 
Karnaugh map, it is seen that, with b =1 and d  changing, the circuit output changes 
for any combination of a and c, so the only possibility is that of a dynamic hazard. 
There are four physical paths from d to the circuit output, so a dynamic hazard exists 
if a d change can propagate over at least three of those paths. However, this cannot 
happen because, with c=0, propagation over the upper two paths is blocked at the 
upper OR gate because c ′=1 forces the OR gate output to be 1, and with c=1 
propagation over the lower two paths is blocked at the lower OR gate. The circuit does not contain a dynamic hazard.
Another approach to finding the hazards is as follows: If we factor the original 
expression for the circuit output (without using the complementation laws), we get
f=(c′+a+b)(c′+d′)(c+a′+b)(c+d)
Plotting the 0’s of f from this expression on a Karnaugh map reveals that there are 
0-hazards when a=b=d=0 and c  changes, and also when b=0, a=d=1, and c  
changes. An expression of the form x+x′ does not appear in any sum term of f, and 
this indicates that there are no 1 -hazards or dynamic hazards.
As another example of finding static and dynamic hazards from a SOP expression, 
consider the circuit of Figure 8-12(a). The SOP expression for f is
f=(A′C′+B′C) (C+D)=A′CC′ +A′C′D+B′C
The Karnaugh map for f in Figure 8-12(b) shows that f=1 for the input com-
binations (A, B, C, D )=(0, 0, 0, 1 ) and (0, 0, 1, 1 ) and neither product of f covers 
these two minterms; hence, these two input combinations imply a static 1 -hazard for C changing. The product 
A′CC ′ in f indicates the possibility of a static 0-hazard and a 
dynamic hazard for A=0 and C changing. The Karnaugh map shows that when f=0, 
Combinational Circuit Design and Simulation Using Gates  239
the two input combinations (0, 1, 0, 0 ) and (0, 1, 1, 0 ) meet these conditions and, hence, 
they imply a static 0-hazard. The Karnaugh map shows two pairs of input combina-
tions with f changing for A=0 and C changing—namely, (0, 0, 0, 0 ), (0, 0, 1, 0 ), and 
(0, 1, 0, 1 ), (0, 1, 1, 1 ). In order for these to be dynamic hazards, the C change must 
propagate over three or more paths to the output. The circuit shows that propagation over the three paths requires B=
0 and D =0 as well as A=0; thus, a dynamic hazard 
only occurs for (0, 0, 0, 0 ) and (0, 0, 1, 0 ). For (0, 1, 0, 1 ) and (0, 1, 1, 1 ), the C change 
only propagates over one path, and f can only change once.
To design a circuit which is free of static and dynamic hazards, the following pro-
cedure may be used:
1. Find a sum-of-products expression ( F t) for the output in which every pair of 
adjacent 1’s is covered by a 1 -term. (The sum of all prime implicants will always 
satisfy this condition.) A two-level AND-OR circuit based on this Ft will be free 
of 1 -, 0-, and dynamic hazards.
2. If a different form of the circuit is desired, manipulate Ft to the desired form by 
simple factoring, DeMorgan’s laws, etc. Treat each xi and x′i as independent vari-
ables to prevent introduction of hazards.
Alternatively, you can start with a product-of-sums expression in which every pair of adjacent 0’s is covered by a 0-term, and follow the dual procedure to design a hazard-free two-level OR-AND circuit.
It should be emphasized that the discussion of hazards and the possibility of 
resulting glitches in this section has assumed that only a single input can change at a time and that no other input will change until the circuit has stabilized. If more than one input can change at one time, then nearly all circuits will contain hazards, and they cannot be eliminated by modifying the circuit implementation. The circuit cor-responding to the Karnaugh map of Figure 8-11 illustrates this. Consider the input change 
(A, B, C, D)=(0, 1, 0, 1) to (0, 1, 1, 0) with both C and D  changing. The out-
put is 0 before the change and will be 0 after the circuit has stabilized; however, if the 
C change propagates through the circuit before the D change, then the circuit will 
output a transient 1. Effectively, the input combination to the circuit can temporarily become 
(A, B, C, D )=(0, 1, 1, 1 ), and the circuit output will temporarily become 1 
no matter how it is implemented.FIGURE 8-12
Hazard Example
© Cengage Learning 2014
111000
00
000
00
1
(b)1011010000A B
C Df
01 11 10
1
1
DBCfA
(a)
240 Unit 8
Glitches are of most importance in asynchronous sequential circuits. The latches 
and flip-flops discussed in Unit 11 are the most important examples of asynchronous 
sequential circuits. Although more than one input can change at the same time for some of these circuits, restrictions are placed on the changes so that it is necessary to analyze the circuits for hazards only when a single input changes. Consequently, the discussion in this section is relevant to this important class of circuits.
8.5 Simulation and Testing of Logic Circuits
An important part of the logic design process is verifying that the final design is correct and debugging the design if necessary. Logic circuits may be tested either by actually building them or by simulating them on a computer. Simulation is gener-ally easier, faster, and more economical. As logic circuits become more and more complex, it is very important to simulate a design before actually building it. This is particularly true when the design is built in integrated circuit form, because fabri-cating an integrated circuit may take a long time and correcting errors may be very expensive. Simulation is done for several reasons, including (1) verification that the design is logically correct, (2) verification that the timing of the logic signals is cor-rect, and (3) simulation of faulty components in the circuit as an aid to finding tests for the circuit.
To use a computer program for simulating logic circuits, you must first specify 
the circuit components and connections; then, specify the circuit inputs; and, finally, observe the circuit outputs. The circuit description may be input into a simulator in the form of a list of connections between the gates and other logic elements in the circuit, or the description may be in the form of a logic diagram drawn on a computer screen. Most modern logic simulators use the latter approach. A typical simulator which runs on a personal computer uses switches or input boxes to specify the inputs and probes to read the logic outputs. Alternatively, the inputs and outputs may be specified as sequences of 0’s and 1’s or in the form of timing diagrams.
A simple simulator for combinational logic works as follows:
1. The circuit inputs are applied to the first set of gates in the circuit, and the out-puts of those gates are calculated.
2. The outputs of the gates which changed in the previous step are fed into the next level of gate inputs. If the input to any gate has changed, then the output of that gate is calculated.
3. Step 2 is repeated until no more changes in gate inputs occur. The circuit is then in a steady-state condition, and the outputs may be read.
4. Steps 1 through 3 are repeated every time a circuit input changes.
The two logic values, 0 and 1, are not sufficient for simulating logic circuits. At 
times, the value of a gate input or output may be unknown, and we will represent this unknown value by 
X. At other times we may have no logic signal at an input, as 
in the case of an open circuit when an input is not connected to any output. We use 
Combinational Circuit Design and Simulation Using Gates  241
the logic value Z to represent an open circuit, or high impedance (hi-Z) connection. 
The discussion that follows assumes we are using a four-valued logic simulator with 
logic values 0, 1, X (unknown), and Z (hi-Z).
Figure 8-13(a) shows a typical simulation screen on a personal computer. The 
switches are set to 0 or 1 for each input. The probes indicate the value of each gate output. In Figure 8-13(b), one gate has no connection to one of its inputs. Because that gate has a 1 input and a hi- Z input, we do not know what the hardware will do, 
and the gate output is unknown. This is indicated by an 
X in the probe.
111
00
(a) Simulation screen showing switches0
1
0
11110
1
0Probe
X11
00
(b) Simulation screen with missing gate input0
1
0
11
ZX0FIGURE 8-13
TABLE 8-1
AND and OR 
Functions for  
Four-Valued 
Simulation ·01XZ
0 0000
10 1 X X
X 0XXXZ 0XXX+ 01XZ
00 1 X X
1 1111
XX1X XZX 1 X XTable 8-1 shows AND and OR functions for four-valued logic simulation. These 
functions are defined in a manner similar to the way real gates work. For an AND 
gate, if one of the inputs is 0, the output is always 0 regardless of the other input. If one input is 1 and the other input is 
X (we do not know what the other input is), 
then the output is X (we do not know what the output is). If one input is 1 and the 
other input is Z (it has no logic signal), then the output is X (we do not know what 
the hardware will do). For an OR gate, if one of the inputs is 1, the output is 1 regard-less of the other input. If one input is 0 and the other input is 
X or Z, the output 
is unknown. For gates with more than two inputs, the operations may be applied several times.
A combinational logic circuit with a small number of inputs may easily be tested 
with a simulator or in lab by checking the circuit outputs for all possible combina-tions of the input values. When the number of inputs is large, it is usually possible to find a relatively small set of input test patterns which will test for all possible faulty gates in the circuit.
1
1Methods for test pattern generation are described in Alexander Miczo, Digital Logic Testing and Simula-
tion, 2nd ed. (John Wiley & Sons, 2003).© Cengage Learning 2014
© Cengage Learning 2014
242 Unit 8
If a circuit output is wrong for some set of input values, this may be due to several 
possible causes:
1. Incorrect design
2. Gates connected wrong
3. Wrong input signals to the circuit
If the circuit is built in lab, other possible causes include
4. Defective gates
5. Defective connecting wires
Fortunately, if the output of a combinational logic circuit is wrong, it is very easy 
to locate the problem systematically by starting at the output and working back 
through the circuit until the trouble is located. For example, if the output gate has the wrong output and its inputs are correct, this indicates that the gate is defective. On the other hand, if one of the inputs is wrong, then either the gate is connected wrong, the gate driving this input has the wrong output, or the input connection is defective.
The function F=AB
(C′D+CD ′) +A′B′(C+D) is realized by the circuit of 
Figure 8-14:Example
FIGURE 8-14
Logic Circuit with 
Incorrect Output
© Cengage Learning  
2014C′
D
CAF B
A′
B′
DC
D′10
1
11
0
105
623
7
4
A student builds the circuit in a lab and finds that when A=B=C=D=1, the 
output F has the wrong value, and that the gate outputs are as shown in Figure 8-14. 
The reason for the incorrect value of F can be determined as follows:
1. The output of gate 7 (F ) is wrong, but this wrong output is consistent with the inputs 
to gate 7 , that is, 1 +0=1. Therefore, one of the inputs to gate 7 must be wrong.
2. In order for gate 7 to have the correct output (F=0), both inputs must be 0. 
Therefore, the output of gate 5 is wrong. However, the output of gate 5 is con-
sistent with its inputs because 1 ·1·1=1. Therefore, one of the inputs to gate 
5 must be wrong.
3. Either the output of gate 3 is wrong, or the A or B  input to gate 5 is wrong. 
Because C ′D+CD ′=0, the output of gate 3 is wrong.
4. The output of gate 3 is not consistent with the outputs of gates 1 and 2 because 0+0≠1. Therefore, either one of the inputs to gate 3 is connected wrong, gate 
3 is defective, or one of the input connections to gate 3 is defective.
This example illustrates how to troubleshoot a logic circuit by starting at the output gate and working back until the wrong connection or defective gate is located.
Combinational Circuit Design and Simulation Using Gates  243
Problems
8.1 Complete the timing diagram for the given circuit. Assume that both gates have a 
propagation delay of 5  ns.
8.2 Consider the following logic function.
F(A, B, C, D )=Σ  m(0, 4, 5, 10, 11, 13, 14, 15 )
(a) Find two different minimum circuits which implement F using AND and OR 
gates. Identify two hazards in each circuit.
(b) Find an AND-OR circuit for F which has no hazards.
(c) Find an OR-AND circuit for F which has no hazards.
8.3  For the following circuit:
(a) Assume that the inverters have a delay of 1  ns and the other gates have a delay 
of 2  ns. Initially A=0 and B =C=D=1, and C changes to 0 at time =2 ns. 
Draw a timing diagram and identify the transient that occurs.
(b) Modify the circuit to eliminate the hazard.
8.4 Using four-valued logic, find A, B, C, D, E, F , G, and H .ZVYXW
W
X
YV
Z
05 10 15 20 25 30 35 40t(ns)
B E
FC
A
DG
1
(no connection)AC
DE
FG
HB
244 Unit 8
8.5 The circuit below was designed to implement the logic equation  F=AB ′D +
BC′D′ +BCD , but it is not working properly. The input wires to gates 1, 2, and 3 are 
so tightly packed, it would take you a while to trace them all back to see whether 
the inputs are correct. It would be nice to only have to trace whichever one is incor-rectly wired. When 
A=B=0 and C=D=1, the inputs and outputs of gate 4 are 
as shown. Is gate 4 working properly? If so, which of the other gates either is con-nected incorrectly or is malfunctioning?
1
1
1
0FA
B
C
D12 4
3Mess
of
Wires
8.7 A two-level, NOR-NOR circuit implements the function 
f(a, b, c, d)=(a+d′)(b′+c+d)(a′+c′+d′)(b′+c′+d).
(a) Find all hazards in the circuit.
(b) Redesign the circuit as a two-level, NOR-NOR circuit free of all hazards and 
using a minimum number of gates.
8.8 F(A, B, C, D )=Σ m(0, 2, 3, 5, 6, 7, 8, 9, 13, 15 )
(a) Find three different minimum AND-OR circuits that implement F. Identify two 
hazards in each circuit. Then find an AND-OR circuit for F that has no hazards.
(b) There are two minimum OR-AND circuits for F ; each has one hazard. Identify 
the hazard in each circuit, and then find an OR-AND circuit for F that has no 
hazards.A
D
C
BE
F
GH8.6 (a)  Assume the inverters have a delay of 1  ns and the other gates have a delay of 2  ns. 
Initially A=B=C=0 and D=1; C changes to 1 at time 2  ns. Draw a timing dia-
gram showing the glitch corresponding to the hazard.
(b) Modify the circuit so that it is hazard free. (Leave the circuit as a two-level, 
OR- AND circuit.)
Combinational Circuit Design and Simulation Using Gates  245
8.9 Consider the following three-level NOR circuit:
(a) Find all hazards in this circuit.
(b) Redesign the circuit as a three-level NOR circuit that is free of all hazards.
A
B
C
Df
ZVYXW
W
X
YV
Z
05 10 15 20 25 30 35 40t(ns)W
X
YV
Z10 ns
5 ns
15V
Z
0 5 10 20 25 30 35 40 t (ns)YXW
4550 558.10 Draw the timing diagram for V and Z for the circuit. Assume that the AND gate has 
a delay of 10  ns and the OR gate has a delay of 5  ns.
8.11 Consider the three-level circuit corresponding to the expression f(A, B, C, D )=  
 (A+B)(B′C′+BD ′).
(a) Find all hazards in this circuit.
(b) Redesign the circuit as a three-level NOR circuit that is free of all hazards.
8.12 Complete the timing diagram for the given circuit. Assume that both gates have a 
propagation delay of 5  ns.
246 Unit 8
8.13 Implement the logic function from Figure 8.10(b) as a minimum sum of products. 
Find the static hazards and tell what minterms they are between. Implement the 
same logic function as a sum of products without any hazards.
8.14 Using four-valued logic, find A, B, C, D , E, F , G, and H .
1
0F
0A
B
C0Mess
of
Wires1
2 4
3(no connection)
(no connection)0AC
D
EF
H
GB
8.15 The following circuit was designed to implement the logic equation F=(A+B′+C′)
(A′+B+C′)(A′+B′+C), but it is not working properly. The input wires to gates 
1, 2, and 3 are so tightly packed, it would take you a while to trace them all back to 
see whether the inputs are correct. It would be nice to only have to trace whichever one is incorrectly wired. When 
A=B=C=1, the inputs and outputs of gate 4 are 
as shown. Is gate 4 working properly? If so, which of the other gates either is con-nected incorrectly or is malfunctioning?
8.16 Consider the following logic function.
F(A, B, C, D)=Σ m(0, 2, 5, 6, 7, 8, 9, 12, 13, 15 )
(a) Find two different minimum AND-OR circuits which implement F . Identify two 
hazards in each circuit. Then find an AND-OR circuit for F that has no hazards.
(b) The minimum OR-AND circuit for F has one hazard. Identify it, and then find 
an OR-AND circuit for F that has no hazards.
Design Problems
Seven-Segment Indicator
Several of the problems involve the design of a circuit to drive a seven-segment indi-cator (see Figure 8-15). The seven-segment indicator can be used to display any one of the decimal digits 0 through 9. For example, “1” is displayed by lighting  segments 
Combinational Circuit Design and Simulation Using Gates  247
2 and 3, “2” by lighting segments 1, 2, 7 , 5, and 4, and “8” by lighting all seven seg-
ments. A segment is lighted when a logic 1 is applied to the corresponding input on the display module.
8.A Design an 8-4-2-1 BCD code converter to drive a seven-segment indicator. The four inputs to the converter circuit (
A, B, C, and D  in Figure 8-15) represent an 8-4-2-1 
binary-coded-decimal digit. Assume that only input combinations representing the digits 0 through 9 can occur as inputs, so that the combinations 1010 through 1111 are don’t-cares. Design your circuit using only two-, three-, and four-input NAND gates and inverters. Try to minimize the number of gates required. The variables 
A, B, C, and D  will be available from toggle switches.
Use (not ) for 6. Use (not ) for 9.
Any solution that uses 18 or fewer gates and inverters (not counting the four invert-ers for the inputs) is acceptable.
8.B  Design an excess-3 code converter to drive a seven-segment indicator. The four inputs to the converter circuit (
A, B, C, and D  in Figure 8-15) represent an excess-3 
coded decimal digit. Assume that only input combinations representing the dig-its 0 through 9 can occur as inputs, so that the six unused combinations are don’t-cares. Design your circuit using only two-, three-, and four-input NAND gates and inverters. Try to minimize the number of gates and inverters required. The variables 
A, B, C, and D  will be available from toggle switches.
Use (not ) for 6. Use (not ) for 9.
Any solution with 16 or fewer gates and inverters (not counting the four inverters for the inputs) is acceptable.
8.C  Design a circuit which will yield the product of two binary numbers, n
2 and m2, 
where 002≤n2≤ 112 and 0002≤m2≤ 1012. For example, if n2=102 and m2=0012, 
then the product is n2×m2=102×0012=00102. Let the variables A and B repre-
sent the first and second digits of n2, respectively (i.e., in this example A=1 and 
B=0). Let the variables C, D, and E represent the first, second, and third digits of FIGURE 8-15
Circuit Driving 
Seven-Segment 
Module
© Cengage Learning 2014A
B
C
DCircuit
to be
Designed1Seven-Segment Indicator
2
3
4
5
6
7X1
X2
X3
X4
X5
X6
X71
2
3
4567 Inputs From
Toggle
Switches
248 Unit 8
m2,  respectively (in this example C=0, D =0, and E =1). Also let the variables 
W, X, Y, and Z represent the first, second, third, and fourth digits of the product. (In 
this example W=0, X=0, Y=1, and Z=0.) Assume that m2>1012 never occurs 
as a circuit input.
CA
BW
X
Y
ZD
ECircuit
to be
DesignedProduct of
n2×m2
m2 Inputn2 Input
Design the circuit using only two-, three-, and four-input NOR gates and invert-
ers. Try to minimize the total number of gates and inverters required. The variables 
A, B, C, D , and E  will be available from toggle switches . Any solution that uses 15 or 
fewer gates and inverters (not counting the five inverters for the inputs) is  acceptable.
8.D Work Design Problem 8.C using two-, three-, and four-input NAND gates and 
inverters instead of NOR gates and inverters . Any solution that uses 14 gates and 
inverters or less (not counting the five inverters for the inputs) is acceptable.
8.E Design a circuit which multiplies two 2-bit binary numbers and displays the answer in decimal on a seven-segment indicator. In Figure 8-15, 
A and B  are two bits of 
a binary number N1, and C and D  are two bits of a binary number N2. The prod-
uct (N1×N2) is to be displayed in decimal by lighting appropriate segments of the 
seven-segment indicator. For example, if A=1, B=0, C=1, and D =0, the num-
ber “4” is displayed by lighting segments 2, 3, 6, and 7 .
Use (not ) for 6. Use (not ) for 9.
Design your circuit using only two-, three-, and four-input NAND gates and invert-ers. Try to minimize the number of gates required. The variables 
A, B, C, and D  
will be available from toggle switches . Any solution that uses 18 or fewer gates and 
inverters (not counting the four inverters for the inputs) is acceptable.
8.F Design a Gray code converter to drive a seven-segment indicator. The four inputs to the converter circuit (
A, B, C, and D  in Figure 8-15) represent a decimal digit coded 
using the Gray code of Table 1 -2. Assume that only input combinations representing the digits 0 through 9 can occur as inputs , so that the six unused combinations are 
don’t-care terms . De sign your circuit using only two-, three-, and four-input NAND 
gates and inverters . Try to minimize the numbers of gates and inverters required. The 
variables 
A, B, C, and D  will be available from toggle switches .
Use (not ) for 6. Use (not ) for 9.
Any solution with 20 or fewer gates and inverters (not counting the four inverters 
for the inputs) is acceptable.
Combinational Circuit Design and Simulation Using Gates  249
8.G Design a circuit that will add either 1 or 2 to a 4-bit binary number N. Let the inputs 
N3, N2, N1, N0 represent N. The input K is a control signal. The circuit should have 
outputs M3, M2, M1, M0, which represent the 4-bit binary number M. When K=0, 
M =N+1. When K=1, M =N+2. Assume that the inputs for which M   >11112 
will never occur.
Design the circuit using only two-, three-, and four-input NAND gates and inverters. 
Try to minimize the total number of gates and inverters required. The input vari-ables K, N
3, N2, N1, and N0 will be available from toggle switches. Any solution that 
uses 13 or fewer gates and inverters (not counting the five inverters for the inputs) is acceptable.
8.H Work Problem 8.A, except use 4-2-1 -8 code instead of 8-4-2-1 code. For example, in 4-2-1 -8 code, 9 is represented by 0011. Also change the representations of digits 6 and 9 to the opposite form given in Problem 8.A. Any solution with 20 or fewer gates and inverters (not counting the four inverters for the inputs) is acceptable.
8.I Work Problem 8.B, except use excess-2 code instead of excess-3 code. (In excess- 2 code, 0 is represented by 0010, 1 by 0011, 2 by 0100, etc.). Any solution with 17 or fewer gates and inverters (not counting the four inverters for the inputs) is  acceptable.
8.J Design a circuit which will multiply a 3-bit binary number 
CDE by 2, 3, or 5, depend-
ing on the value of a 2-bit code AB (00, 01, or 10), to produce a 4-bit result WXYZ . If 
the result has a value greater than or equal to 15, WXYZ should be 1111 to indicate 
an overflow. Assume that the code AB=11 will never occur. Design your circuit 
using only two-, three-, and four-input NOR gates and inverters. Try to minimize the number of gates required. The inputs 
A, B, C, D , and E  will be available from toggle 
switches. Any solution which uses 19 or fewer gates and inverters (not counting the five inverters for the inputs) is acceptable.
8.K Design a circuit which will divide a 5-bit binary number by 3 to produce a 4-bit binary quotient. Assume that the input number is in the range 0 through 27 and that numbers in the range 28 through 31 will never occur as inputs. Design your circuit using only two-, three-, and four-input NAND gates and inverters. Try to minimize the number of gates required. The inputs 
A, B, C, D , and E  will be available from 
toggle switches. Any solution which uses 22 or fewer gates and inverters (not count-ing the five inverters for the inputs) is acceptable.
8.L Design an excess-3 code converter to drive a seven-segment indicator. The four inputs 
(A, B, C, D ) to the converter circuit represent an excess-3 digit. Input combi-
nations representing the numbers 0 through 9 should be displayed as decimal digits. The input combinations 0000, 0001, and 0010 should be interpreted as an error, and an “E” should be displayed. Assume that the input combinations 1101, 1110, and 1111 will never occur. Design your circuit using only two-, three-, and four-input NOR gates and inverters. Any solution with 18 or fewer gates and inverters (not counting the four inverters for the inputs) is acceptable.
250 Unit 8
Use (not ) for 6. Use (not ) for 9.
8.M Design a circuit which displays the letters A through J on a seven-segment indicator. 
The circuit has four inputs W, X, Y, Z which represent the last 4 bits of the ASCII 
code for the letter to be displayed. For example, if WXYZ =0001, “A” will be dis-
played. The letters should be displayed in the following form:
Design your circuit using only two-, three-, and four-input NOR gates and inverters. Any solution with 22 or fewer gates and inverters (not counting the four inverters for the inputs) is acceptable.
8.N A simple security system for two doors consists of a card reader and a keypad.
To Door 1
To Door 2To AlarmLogic
Circuit
Keypad
Card Reader
CA
B
D
EX
YZ
A person may open a particular door if he or she has a card containing the corre-
sponding code and enters an authorized keypad code for that card. The outputs from the card reader are as follows:
To unlock a door, a person must hold down the proper keys on the keypad and, then, 
insert the card in the reader. The authorized keypad codes for door 1 are 101 and 110, and the authorized keypad codes for door 2 are 101 and 011. If the card has an invalid code or if the wrong keypad code is entered, the alarm will ring when the card is inserted. If the correct keypad code is entered, the corresponding door will be unlocked when the card is inserted.
Design the logic circuit for this simple security system. Your circuit’s inputs will consist 
of a card code 
AB, and a keypad code CDE. The circuit will have three outputs XYZ 
(if X or Y =1, door 1 or 2 will be opened; if Z =1, the alarm will sound). Design your 
circuit using only two-, three-, and four-input NOR gates and inverters. Any solution A B
No card inserted 0 0
Valid code for door 1 0 1Valid code for door 2 1 1Invalid card code 1 0
Combinational Circuit Design and Simulation Using Gates  251
with 19 or fewer gates and inverters (not counting the five inverters for the inputs) is 
acceptable. Use toggle switches for inputs A, B, C, D, and E  when you test your circuit.
8.O Work Design Problem 8.A using two-, three-, and four-input NOR gates and invert-ers instead of NAND gates and inverters. Any solution that uses 19 gates and invert-
ers or fewer (not counting the four inverters for the inputs) is acceptable.
8.P Work Design Problem 8.F using two-, three-, and four-input NOR gates and inverters instead of NAND gates and inverters. Any solution that uses 21 gates and  inverters or fewer (not counting the four inverters for the inputs) is acceptable.
8.Q Work Design Problem 8.H using two-, three-, and four-input NOR gates and  inverters instead of NAND gates and inverters. Any solution that uses 17 gates and inverters or fewer (not counting the four inverters for the inputs) is acceptable.
8.R Work Design Problem 8.I using two-, three-, and four-input NOR gates and  inverters 
instead of NAND gates and inverters. Any solution that uses 16 gates and inverters or fewer (not counting the four inverters for the inputs) is acceptable.
8.S Design a “disk spinning” animation circuit for a CD player. The input to the circuit will be a 3-bit binary number 
A1A2A3 provided by another circuit. It will count from 
0 to 7 in binary, and then it will repeat. (You will learn to design such counters in Unit 12.) The animation will appear on the top four lights of the LED display of Figure 8-15, i.e., on 
X1, X2, X7, and X6, going clockwise. The animation should consist 
of a blank spot on a disk spinning around once, beginning with X1. Then, the entire 
disk should blink on and off twice. The pattern is shown.
Design your circuit using only two-, three-, and four-input NOR gates and inverters. Try to minimize the number of gates required. Any solution which uses 11 or fewer gates (not counting the four inverters for the inputs) is acceptable.
252Multiplexers, Decoders, and 
Programmable Logic DevicesUNIT
9
Objectives
1. Explain the function of a multiplexer. Implement a multiplexer using gates.
2. Explain the operation of three-state buffers. Determine the resulting output 
when three-state buffer outputs are connected together. Use three-state buffers to multiplex signals onto a bus.
3. Explain the operation of a decoder and encoder. Use a decoder with added gates to implement a set of logic functions. Implement a decoder or priority encoder using gates.
4. Explain the operation of a read-only memory (ROM). Use a ROM to imple-ment a set of logic functions.
5. Explain the operation of a programmable logic array (PLA). Use a PLA to implement a set of logic functions. Given a PLA table or an internal connection diagram for a PLA, determine the logic functions realized.
6. Explain the operation of a programmable array logic device (PAL). Determine the programming pattern required to realize a set of logic functions with a PAL.
7. Explain the operation of a complex programmable logic device (CPLD) and a field-programmable gate array (FPGA).
8. Use Shannon’s expansion theorem to decompose a switching function.
Multiplexers, Decoders, and Programmable Logic Devices  253
Study Guide
1. Read Section 9.1, Introduction.
2. Study Section 9.2, Multiplexers.
(a) Draw a logic circuit for a 2-to-1 multiplexer (MUX) using gates.
(b) Write the equation for a 4-to-1 MUX with control inputs A and C.
Z= ___________________________________________
(c) By tracing signals on Figure 9-3, determine what will happen to Z if A=1, 
B=0 and C changes from 0 to 1.
(d) Use three 2-to-1 MUXes to make a 4-to-1 MUX with control inputs A 
and B. Draw the circuit. ( Hint: One MUX should have I0 and I1 inputs, and 
another should have I2 and I3 inputs.)
(e) Observe that if A=0, A ⊕ B=B, and that if A=1, A ⊕ B=B′. Using 
this observation, construct an exclusive-OR gate using a 2-to-1 multiplexer 
and one inverter.
(f  ) Work Problems 9.1 and 9.2.
(g) This section introduces bus notation. The bus symbol A4
 
represents a group of four wires:
A3 ______________
A2 ______________
A1 ______________
A0 ______________
254 Unit 9
Draw the bus symbol for
B2______________
B1______________
B0______________
(h) Represent the circuit of Figure 4-3 by one 4-bit full adder with two bus 
inputs, one bus output, and terminals for carry input C0 and output C4. 
Note that the carries C3, C2, and C1 will not appear on your circuit diagram 
because they are signals internal to the 4-bit adder.
3. Study Section 9.3, Three-State Buffers.
(a) Determine the output of each three-state buffer:
(b) Determine the inputs for each three-state buffer (use X  if an input is a 
don’t-care).
(c) Determine the output for each circuit. Use X to represent an unknown 
output.
(d) The symbol C
AB22 represents 2 three-state buffers with a common 
control input:0 Z 1 1
1
1
0
01
1
1
01
0
1
00
1
0
01
10
11
00
11
Multiplexers, Decoders, and Programmable Logic Devices  255
Using bus notation, draw an equivalent circuit for:
(e) For the following circuit, determine the 4-bit output (P) if M=0. 
______________ Repeat for M =1. ______________
(f  ) Specify the AND-gate inputs so that the given circuit is equivalent to the 
4-to-1 MUX in Figure 9-2. ( Z in the following figure represents an output 
terminal, not high impedance.)4 4
4 4P0101
1100M
I0
ZI1
I2
I3C
A1 B1
B0 A0
G
E2 F2
F1 E1
F0 E0
256 Unit 9
(g) Work Problem 9.3.
4. Study Section 9.4, Decoders and Encoders.
(a) The 7442 4-to-10 line decoder (Figure 9-18) can be used as a 3-to-8 line 
decoder. To do this, which three lines should be used as inputs?
________________________
The remaining input line should be set equal to ______________.
(b) Complete the following table for a 4-to-2 priority encoder:
What will a ,b, and c  be if y0 y1 y2 y3 is 0101?
(c) Work Problem 9.4, 9.5, and 9.6.
5. Study Section 9.5, Read-Only Memories.
(a) The following diagram shows the pattern of 0’s and 1’s stored in a ROM 
with eight words and four bits per word. What will be the values of F1, F2, F3, 
and F4 if A=0 and B =C=1?
Give the minterm expansions for F1 and F2:
F1=
F2=
(b) When asked to specify the size of a ROM, give the number of words and 
the number of bits per word.What size ROM is required to realize four functions of 5 variables?
What size ROM is required to realize eight functions of 10 variables?y0y1y2y3 abc
0
1
0
1
1
1
01
0001DecoderA
B
C 1011010100010100
0101
F
1
F2F3
F4
Multiplexers, Decoders, and Programmable Logic Devices  257
(c) When specifying the size of a ROM, assume that you are specifying a stand-
ard size ROM with 2n words. What size ROM is required to convert 8-4-2-1 
BCD code to 2-out-of-5 code? (See Table 1 -2, page 22.)
What size ROM would be required to realize the decoder given in 
Figure 9-18?
(d) Draw an internal connection diagram for a ROM which would perform the 
same function as the circuit of Figure 7-22. (Indicate the presence of switch-ing elements by dots at the intersection of the word lines and output lines.)
(e) Explain the difference between a mask-programmable ROM and an EEP-
ROM. Which would you use for a new design which had not yet been debugged?
(f  ) Work Problem 9.7 .
6. Study Section 9.6, Programmable Logic Devices.
(a) When you are asked to specify the size of a PLA, give the number of inputs, 
the number of product terms, and the number of outputs.What size PLA would be required to realize Equations (7-24) if no simpli-fication of the minterm expansions were performed?
(b) If the realization of Equations (7-24) shown in Figure 7-22 were converted 
to a PLA realization, what size PLA would be required?
(c) Specify the contents of the PLA of question (b) in tabular form. Your table 
should have four rows. (You will only need seven 1’s on the right side of your table. If you get eight 1’s, you are probably doing more work than is necessary.)
(d) Draw an internal connection diagram for the PLA of (b). (Use X’s to indi-
cate the presence of switching elements in the AND and OR arrays.)
258 Unit 9
(e) Given the following PLA table, plot maps for Z1,Z2, and Z3.
(The Z1 map should have six 1’s, Z2 should have five, and Z3 should have four.)
(f  ) For a truth table, any combination of input values will select exactly one 
row. Is this statement true for a PLA table?
For any combination of input values, the output values from a PLA can 
be determined by inspection of the PLA table. Consider Table 9-1, which represents a PLA with three inputs and four outputs. If the inputs are 
ABC=110, which three rows in the table are selected?
In a given output column, what is the output if some of the selected rows are 1’s and some are 0’s? (Remember that the output bits for the selected rows are ORed together.)
When 
ABC=110, what are the values of F0F1F2F3 at the PLA output?
When ABC=010, which rows are selected and what are the values of 
F0F1F2F3 at the PLA output?
(g) Which interconnection points in Figure 9-32(a) must be set in order to real-
ize the function shown in Figure 9-32(b)?
(h) What size of PAL could be used to realize the 8-to-1 MUX of Figure 9-3? 
The quad MUX of Figure 9-7? Give the number of inputs, the number of 
OR gates, and the maximum number of inputs to an OR gate.
(i) Work Problems 9.8, 9.9, and 9.10.
7. Study Section 9.7 , Complex Programmable Logic Devices.Work Problem 9.11.
8. Study Section 9.8, Field-Programmable Gate Arrays.
(a) For the CLB of Figure 9-37 , write a logic equation for 
H in terms of F, G, 
and H1.ABC Z1Z2Z3
−00 110
01− 1 10
10− 1 00111 0 110−1 1 01000 0 01
Z1 Z2 Z301
00BCA
01
111001
00
01
111001
00
01
1110
Multiplexers, Decoders, and Programmable Logic Devices  259
(b) How many 4-variable function generators are required to implement a 
four-input OR gate? A 4-variable function with 13 minterms?
(c) Expand the function of Equation (9-9) about the variable c instead of a. 
Expand it algebraically and, then, expand it by using the Karnaugh map of 
Figure 9-39. (Hint: How should you split the map into two halves?)
(d) Draw a diagram showing how to implement Equation (9-12) using four 
function generators and a 4-to-1 MUX.
(e) In the worst case, how many 4-variable function generators are required to 
realize a 7-variable function (assume the necessary MUXes are available).
(f  ) Show how to realize K =abcde fg using only two 4-variable function gen-
erators. (Hint: Use the output of one function generator as an input to the other.)
(g) Work Problems 9.12 and 9.13.
9. When you are satisfied that you can meet all of the objectives, take the readi-ness test.
260Multiplexers, Decoders, and 
Programmable Logic Devices
9.1 Introduction
Until this point we have mainly been concerned with basic principles of logic design. 
We have illustrated these principles using gates as our basic building blocks. In this unit we introduce the use of more complex integrated circuits (ICs) in logic design. Integrated circuits may be classified as small-scale integration (SSI), medium-scale integration (MSI), large-scale integration (LSI), or very-large-scale integration (VLSI), depending on the number of gates in each integrated circuit package and the type of function performed. SSI functions include NAND, NOR, AND, and OR gates, inverters, and flip-flops. SSI integrated circuit packages typically contain one to four gates, six inverters, or one or two flip-flops. MSI integrated circuits, such as adders, multiplexers, decoders, registers, and counters, perform more complex func-tions. Such integrated circuits typically contain the equivalent of 12 to 100 gates in one package. More complex functions such as memories and microprocessors are classified as LSI or VLSI integrated circuits. An LSI integrated circuit generally con-tains 100 to a few thousand gates in a single package, and a VLSI integrated circuit contains several thousand gates or more.
It is generally uneconomical to design digital systems using only SSI and MSI 
integrated circuits. By using LSI and VLSI functions, the required number of inte-grated circuit packages is greatly reduced. The cost of mounting and wiring the inte-grated circuits as well as the cost of designing and maintaining the digital system may be significantly lower when LSI and VLSI functions are used.
This unit introduces the use of multiplexers, decoders, encoders, and three-state 
buffers in logic design. Then read-only memories (ROMs) are described and used to implement multiple-output combinational logic circuits. Finally, other types of programmable logic devices (PLDs), including programmable logic arrays (PLAs), programmable array logic devices (PALs), complex programmable logic devices (CPLDs), and field- programmable gate arrays (FPGAs) are introduced and used in combinational logic design.
Multiplexers, Decoders, and Programmable Logic Devices  261
9.2 Multiplexers
A multiplexer (or data selector, abbreviated as MUX) has a group of data inputs and a 
group of control inputs. The control inputs are used to select one of the data inputs and connect it to the output terminal. Figure 9-1 shows a 2-to-1 multiplexer and its switch analog. When the control input 
A is 0, the switch is in the upper position and the MUX 
output is Z=I0; when A is 1, the switch is in the lower position and the MUX output is 
Z=I1. In other words, a MUX acts like a switch that selects one of the data inputs ( I0 
or I1) and transmits it to the output. The logic equation for the 2-to-1 MUX is therefore:
Z=A′I0+AI1
Figure 9-2 shows diagrams for a 4-to-1 multiplexer, 8-to-1 multiplexer, and 2n-to-1 
multiplexer. The 4-to-1 MUX acts like a four-position switch that transmits one of the four inputs to the output. Two control inputs (
A and B ) are needed to select 
one of the four inputs. If the control inputs are AB=00, the output is I0; similarly, 
the control inputs 01, 10, and 11 give outputs of I1, I2, and I3, respectively. The 4-to-1 
multiplexer is described by the equation
 Z=A′B′I0+A′BI1+AB′I2+ABI3 (9-1)
Similarly, the 8-to-1 MUX selects one of eight data inputs using three control inputs. 
It is described by the equation
 Z=A′B′C′I0+A′B′CI1+A′BC′I2+A′BCI3
      +AB′C′I4+AB′CI5+ABC ′I6+ABCI7 (9-2)FIGURE 9-2
Multiplexers
© Cengage Learning 20144-to-1
MUXData
inputs
Control
inputsI0
I1
I2
I3
ABZ2n-to-1
MUX
n control
inputs2n data
linesZ
8-to-1MUXI
0
I1
I2
I3
I4
I5
I6
I7
ABCZ
......FIGURE 9-1
2-to-1 Multiplexer 
and Switch Analog
© Cengage Learning 20142-to-1MUXI
0
I1
AZI0
I1
AZ
262 Unit 9
When the control inputs are ABC=011, the output is I3, and the other outputs 
are selected in a similar manner. Figure 9-3 shows an internal logic diagram for the 
8-to-1 MUX. In general, a multiplexer with n control inputs can be used to select any 
one of 2n data inputs. The general equation for the output of a MUX with n control 
inputs and 2n data inputs is
Z =a2n−1
k=0mkIk
where mk is a minterm of the n control variables and Ik is the corresponding data 
input.
Of course, there are several other implementations of the 8-to-1 MUX. Each 
of the gates in Figure 9-3 can be replaced by NAND gates to obtain a NAND gate implementation. If a NOR gate implementation is wanted, the equation for 
Z can be 
written as a product of sums:
 Z=(A+B+C+I0)(A+B+C′+I1)(A+B′+C+I2)
        ( A+B′+C′+I3)(A′+B+C+I4)(A′+B+C′+I5)
        ( A′+B′+C+I6)(A′+B′+C′+I7)  (9-3)
Implementations with more than two levels of gates can be obtained by factoring 
the equation for Z. For example, if a multiple-level NAND-gate implementation is 
desired, Equation (9-2) can be factored. One factorization is
  Z=A′B′(C′I0+CI1)+A′B(C′I2+CI3)+AB′(C′I4+CI5)
      +AB(C′I6+CI7) (9-4)FIGURE 9-3
Logic Diagram for 
8-to-1 MUX
© Cengage Learning 2014a′b′c′I0a′b′cI1a′bc′I2a′b
ZcI3ab′c′I4ab′cI5abc ′I6abcI7
Multiplexers, Decoders, and Programmable Logic Devices  263
The corresponding NAND-gate circuit is shown in Figure 9-4. Note that the data 
inputs are connected to four 2-to-1 MUXs with C as the select line, and the outputs 
of these 2-to-1 MUXs are connected to a 4-to-1 MUX with A and B as the select 
lines. Figure 9-5 shows this in block diagram form.
FIGURE 9-5
Component MUXs 
of Figure 9-4
© Cengage Learning 201402-to-11
S0S10
1
2
34-to-10
2-to-11
02-to-11I0
I1
I2
I3
I4
I5
I6
I702-to-11Z
CB AS
S
S
SFIGURE 9-4
A Multi-Level 
Implementation of 
an 8-to-1 MUX
© Cengage Learning 2014I0
I1
I2
I3
I4
I5
I6
I7
C′CA′
B′
A′
B
AZ
B′
A
B
264 Unit 9
Multiplexers are frequently used in digital system design to select the data which 
is to be processed or stored. Figure 9-6 shows how a quadruple 2-to-1 MUX is used 
to select one of two 4-bit data words. If the control is A=0, the values of x0, x1, x2, 
and x3 will appear at the z0, z1, z2, and z3 outputs; if A=1, the values of y0, y1, y2, and 
y3 will appear at the outputs.
Several logic signals that perform a common function may be grouped together 
to form a bus. For example, the sum outputs of a 4-bit binary adder can be grouped together to form a 4-bit bus. Instead of drawing the individual wires that make up a bus, we often represent a bus by a single heavy line. The quad MUX of Figure 9-6 is redrawn in Figure 9-7 , using bus inputs 
X and Y, and bus output Z. The X bus repre-
sents the four signals x0, x1, x2, and x3, and similarly for the Y and Z buses. When A=0, 
the signals on bus X appear on bus Z; otherwise, the signals on bus Y appear. A diago-
nal slash through a bus with a number beside it specifies the number of bits in the bus.
The preceding multiplexers do not invert the data inputs as they are routed to 
the output. Some multiplexers do invert the inputs, e.g., if the OR gate in Figure 9-3 is replaced by a NOR gate, then the 8-to-1 MUX inverts the selected input. To dis-tinguish between these two types of multiplexers, we will say that the multiplexers without the inversion have active high outputs, and the multiplexers with the inver-sion have active low outputs.
Another type of multiplexer has an additional input called an enable. The 8-to-1 
MUX in Figure 9-3 can be modified to include an enable by changing the AND gates to five-input gates. The enable signal E is connected to the fifth input of each 
of the AND gates. Then, if E=
0, Z=0 independent of the gate inputs Ii and the 
select inputs a, b, and c. However, if E=1, then the MUX functions as an ordinary 
8-to-1 multiplexer. The terminology used for the MUX output, i.e., active high and active low, can be used for the enable as well. As described above, the enable is active high; E must be 1 for the MUX to function as a multiplexer. If an inverter is FIGURE 9-7
Quad Multiplexer 
with Bus Inputs and 
Output
© Cengage Learning 20142-to-14
44
XZ
YAFIGURE 9-6
Quad Multiplexer 
Used to Select Data
© Cengage Learning 2014 2-to-1
x0z0
y02-to-1
x1z1
y12-to-1
x2z2
y2A (MUX control)
2-to-1
x3z3
y3
Multiplexers, Decoders, and Programmable Logic Devices  265
inserted between E  and the AND gates, E must be 0 for the MUX to function as a 
multiplexer; the enable is active low.
Four combinations of multiplexers with an enable are possible. The output can 
be active high or active low, whereas the enable can be active high or active low. In 
a block diagram for the MUX, an active low line is indicated by inserting a bubble on the line to indicate the inclusion of an inversion. Figure 9-8 shows these combina-tions for a 4-to-1 MUX.
In addition to acting as a data selector, a MUX can implement more general logic 
functions. In Figure 9-9 a 4-to-1 MUX is used to implement the function
Z=C′D′(A′+B′)+C′D(A′)+CD′(AB′+A′B)+CD′(0)
=A′C′+A′BD′+AB′D′
Given a switching function, a MUX implementation can be obtained using Shan-non’s expansion of the function. (See the Subsection Decomposition of Switching 
Functions in Section 9.8.) In general, the complexity of the implementation will depend upon which function inputs are used as the MUX select inputs, so it is neces-sary to try different combinations to obtain the simplest solution.
9.3 Three-State Buffers
A gate output can only be connected to a limited number of other device inputs without degrading the performance of a digital system. A simple buffer may be used to increase the driving capability of a gate output. Figure 9-10 shows a buffer con-nected between a gate output and several gate inputs. Because no bubble is present FIGURE 9-8
Active-High, 
Active-Low Enable 
and Output 
Combinations
© Cengage Learning 2014ZS0S10
1
2
34-to-1I0
I1
I2
I3E
(c) (a) (b) (d)ZS0S101
2
34-to-1 I0
I1
I2
I3E
Z
S0S10
1
2
34-to-1I0
I1
I2
I3E
ZS0S10
1
2
34-to-1I0
I1
I2
I3E
FIGURE 9-9
Four-Variable 
Function 
Implemented with 
a 4-to-1 MUX
© Cengage Learning 2014ZS0S10
1
2
34-to-1A
B
CDA′
A
B0
266 Unit 9
at the buffer output, this is a noninverting buffer, and the logic values of the buffer 
input and output are the same, that is, F =C.
Normally, a logic circuit will not operate correctly if the outputs of two or more 
gates or other logic devices are directly connected to each other. For example, if one gate has a 0 output (a low voltage) and another has a 1 output (a high voltage), when the gate outputs are connected together the resulting output voltage may be some intermediate value that does not clearly represent either a 0 or a 1. In some cases, damage to the gates may result if the outputs are connected together.
Use of three-state logic permits the outputs of two or more gates or other logic 
devices to be connected together. Figure 9-11 shows a three-state buffer and its logi-cal equivalent. When the enable input B  is 1, the output 
C equals A; when B  is 0, 
the output C acts like an open circuit. In other words, when B is 0, the output C is 
effectively disconnected from the buffer output so that no current can flow. This is often referred to as a Hi-Z (high-impedance) state of the output because the circuit offers a very high resistance or impedance to the flow of current. Three-state buffers are also called tri-state buffers.
Figure 9-12 shows the truth tables for four types of three-state buffers. In 
Figures 9-12(a) and (b), the enable input 
B is not inverted, so the buffer output is 
enabled when B=1 and disabled when B =0. That is, the buffer operates normally 
when B=1, and the buffer output is effectively an open circuit when B =0. We use 
the symbol Z  to represent this high-impedance state. In Figure 9-12(b), the buffer 
output is inverted so that C=A′ when the buffer is enabled. The buffers in 9-12(c) 
and (d) operate the same as in (a) and (b) except that the enable input is inverted, so the buffer is enabled when B =
0.
In Figure 9-13, the outputs of two three-state buffers are tied together. When 
B=0, the top buffer is enabled, so that D=A; when B=1, the lower buffer is ena-
bled, so that D=C. Therefore, D=B′A+BC. This is logically equivalent to using 
a 2-to-1 multiplexer to select the A input when B =0 and the C input when B =1.FIGURE 9-10
Gate Circuit with 
Added Buffer
© Cengage Learning 2014
...A
BCF
FIGURE 9-11
Three-State Buffer
© Cengage Learning 2014ACB
A CB
Multiplexers, Decoders, and Programmable Logic Devices  267
When we connect two three-state buffer outputs together, as shown in 
Figure 9-14, if one of the buffers is disabled (output = Z), the combined output F is 
the same as the other buffer output. If both buffers are disabled, the output is Z. If 
both buffers are enabled, a conflict can occur. If A=0 and C=1, we do not know 
what the hardware will do, so the F output is unknown ( X). If one of the buffer 
inputs is unknown, the F output will also be unknown. The table in Figure 9-14 
summarizes the operation of the circuit. S1 and S2 represent the outputs the two 
buffers would have if they were not connected together. When a bus is driven by 
three-state buffers, we call it a three-state bus. The signals on this bus can have values of 0, 1, Z , and perhaps X .
A multiplexer may be used to select one of several sources to drive a device input. 
For example, if an adder input must come from four different sources, a 4-to-1 MUX may be used to select one of the four sources. An alternative is to set up a three-state bus, using three-state buffers to select one of the sources (see Figure 9-15). In this FIGURE 9-12
Four Kinds of 
Three-State Buffers
© Cengage Learning 2014
(a) (b) (c) (d)BA C B A C BA C BA C
00 Z 0 0 Z 00 0 00 1
01 Z 0 1 Z 01 1 01 010 0 1 0 1 10 Z 10 Z11 1 1 1 0 11 Z 11 ZACB
ACB
ACB
ACB
FIGURE 9-14
Circuit with Two 
Three-State Buffers
© Cengage Learning 2014X01 Z
XX X X X
0X 0 X 01X X 1 1ZX 0 1 ZS2
S1
AB
S1
S2D
CFFIGURE 9-13
Data Selection 
Using Three-State 
Buffers
© Cengage Learning 20142-to-1
MUX0
1A
C
BDA
CBD
268 Unit 9
circuit, each buffer symbol actually represents four three-state buffers that have a 
common enable signal.
Integrated circuits are often designed using bi-directional pins for input and out-
put. Bi-directional means that the same pin can be used as an input pin and as an output pin, but not both at the same time. To accomplish this, the circuit output is connected to the pin through a three-state buffer, as shown in Figure 9-16. When the buffer is enabled, the pin is driven with the output signal. When the buffer is disa-bled, an external source can drive the input pin.
9.4 Decoders and Encoders
The decoder is another commonly used type of integrated circuit. Figure 9-17 shows the diagram and truth table for a 3-to-8 line decoder. This decoder generates all of the minterms of the three input variables. Exactly one of the output lines will be 1 for each combination of the values of the input variables.
FIGURE 9-17
A 3-to-8 Line 
Decoder
© Cengage Learning 2014y0 = a′b′c′
y1 = a′b′c
y2 = a′bc′
y3 = a′bc
y4 = ab′c′
y5 = ab′c
y6 = abc′
y7 = abc3-to-8
line
decodera
b
cabc y0y1y2y3y4y5y6y7
0 0 0 10000000
0 0 1 010000000 1 0 001000000 1 1 000100001 0 0 000010001 0 1 000001001 1 0 000000101 1 1 00000001FIGURE 9-16
Integrated Circuit 
with Bi-Directional 
Input-Output Pin
© Cengage Learning 2014Integrated
Logic
CircuitOutputEN
Bi-Directional
Input-Output PinInputFIGURE 9-15
4-Bit Adder with 
Four Sources for 
One Operand
© Cengage Learning 2014EnA
4
AEnB
4
BEnC
4
CEnD4-bit
adder
4444
DE
Sum
Cout
Multiplexers, Decoders, and Programmable Logic Devices  269
Figure 9-18 illustrates a 4-to-10 decoder. This decoder has inverted outputs (indi-
cated by the small circles). For each combination of the values of the inputs, exactly 
one of the output lines will be 0. When a binary-coded-decimal digit is used as an input to this decoder, one of the output lines will go low to indicate which of the 10 decimal digits is present.
FIGURE 9-18
A 4-to-10 Line 
Decoder
© Cengage Learning 2014
9 8 7 6 5 4 3 2 1 0D C B A
Outputs
7442
(b) Block diagram(a) Logic diagram
ABCDInputs
m′  9m′8m′7m′6m′5m′4m′3m′2m′1m′0BCD Input Decimal Output
ABCD 0123456789
0000 0111111111
0001 10111111110010 11011111110011 11101111110100 11110111110101 11111011110110 11111101110111 11111110111000 11111111011001 11111111101010 11111111111011 11111111111100 11111111111101 11111111111110 1111111111
1111 1111111111
(c) Truth Table
270 Unit 9
In general, an n -to-2n line decoder generates all 2n minterms (or maxterms) of 
the n  input variables. The outputs are defined by the equations
 yi=mi=Mi′,                i =0 to 2n−1          (noninverted outputs ) (9-5)
or
 yi=mi′=Mi,                i =0 to 2n−1           (inverted outputs ) (9-6)
where mi is a minterm of the n  input variables and Mi is a maxterm.
Because an n -input decoder generates all of the minterms of n variables, n - variable 
functions can be realized by ORing together selected minterm outputs from a decoder. 
If the decoder outputs are inverted, then NAND gates can be used to generate the functions, as illustrated in the following example. Realize
f1(a, b, c , d)=m1+m2+m4 and f2(a, b, c , d)=m4+m7+m9
using the decoder of Figure 9-18. Since a NAND gate ORs inverted signals, f1 and f2 
can be generated using NAND gates, as shown in Figure 9-19.
An encoder performs the inverse function of a decoder. Figure 9-20 shows an 
8-to-3 priority encoder with inputs y0 through y7. If input yi is 1 and the other inputs 
are 0, then the abc  outputs represent a binary number equal to i. For example, if 
FIGURE 9-19
Realization of a 
Multiple-Output 
Circuit Using a 
Decoder
© Cengage Learning 2014m4′
m7′
m9′ f2f1m2′m1′0
12344-to-10
Line
Decodera
b
c
d56789
FIGURE 9-20
An 8-to-3 Priority 
Encoder
© Cengage Learning 2014y0y1y2y3y4y5y6y7 abc d
00000000 0 0 0 0
10000000 0 0 0 1
X1000000 0 0 1 1X X100000 0 1 0 1X XX10000 0 1 1 1XXXX1 0 0 0 100 1XXXXX1 0 0 101 1XXXXXX10 1 1 0 1XXXXXXX1 1 1 1 18-to-3
Priority
Encodera
b
c
dy0
y1
y2
y3
y4
y5
y6
y7
Multiplexers, Decoders, and Programmable Logic Devices  271
y3=1, then abc=011. If more than one input can be 1 at the same time, the output 
can be defined using a priority scheme. The truth table in Figure 9-20 uses the fol-
lowing scheme: If more than one input is 1, the highest numbered input determines the output. For example, if inputs 
y1, y4, and y5 are 1, the output is abc =101. The 
X’s in the table are don’t-cares; for example, if y5 is 1, we do not care what inputs y0 
through y4 are. Output d  is 1 if any input is 1, otherwise, d is 0. This signal is needed 
to distinguish the case of all 0 inputs from the case where only y0 is 1.
9.5 Read-Only Memories
A read-only memory (ROM) consists of an array of semiconductor devices that are interconnected to store an array of binary data. Once binary data is stored in the ROM, it can be read out whenever desired, but the data that is stored cannot be changed under normal operating conditions. Figure 9-21(a) shows a ROM which has three input lines and four output lines. Figure 9-21(b) shows a typical truth table which relates the ROM inputs and outputs. For each combination of input values on the three input lines, the corresponding pattern of 0’s and 1’s appears on the ROM output lines. For example, if the combination 
ABC=010 is applied to the input lines, the pattern F0F1F2F3=0111 
appears on the output lines. Each of the output patterns that is stored in the ROM is called a word . Because the ROM has three input lines, we have 2
3=eight different 
combinations of input values. Each input combination serves as an address which can 
select one of the eight words stored in the memory. Because there are four output lines, each word is four bits long, and the size of this ROM is 8 words ×
4 bits.
A ROM which has n  input lines and m  output lines (Figure 9-22) contains an array 
of 2n words, and each word is m bits long. The input lines serve as an address to select 
one of the 2n words. When an input combination is applied to the ROM, the pattern 
of 0’s and 1’s which is stored in the corresponding word in the memory appears at the output lines. For the example in Figure 9-22, if 00 . . . 11 is applied to the input (address lines) of the ROM, the word 110 . . . 010 will be selected and transferred to the output lines. A 2
n×m ROM can realize m functions of n variables because it 
can store a truth table with 2n rows and m  columns. Typical sizes for commercially 
 available ROMs range from 32 words ×4 bits to 512K words ×8 bits, or larger.
FIGURE 9-21
An 8-Word  
×4-Bit ROM
© Cengage Learning 2014
272 Unit 9
A ROM basically consists of a decoder and a memory array, as shown in Figure 9-23. 
When a pattern of n 0’s and 1’s is applied to the decoder inputs, exactly one of the 2n 
decoder outputs is 1. This decoder output line selects one of the words in the memory 
array, and the bit pattern stored in this word is transferred to the memory output lines.
Figure 9-24 illustrates one possible internal structure of the 8-word ×  4-bit ROM 
shown in Figure 9-21. The decoder generates the eight minterms of the three input variables. The memory array forms the four output functions by ORing together selected minterms. A switching element is placed at the intersection of a word line  
and an output line if the corresponding minterm is to be included in the output func-tion; otherwise, the switching element is omitted (or not connected). If a switching element connects an output line to a word line which is 1, the output line will be 1. Otherwise, the pull-down resistors at the top of Figure 9-24 cause the output line to be 0. So the switching elements which are connected in this way in the memory array effectively form an OR gate for each of the output functions. For example, m
0, m1, m4, 
and m6 are ORed together to form F0. Figure 9-25 shows the equivalent OR gate.
In general, those minterms which are connected to output line F by switching 
elements are ORed together to form the output Fi. Thus, the ROM in Figure 9-24 
generates the following functions:
  F0=Σ m(0, 1, 4, 6) =A′B′+AC′
F1=Σ m(2, 3, 4, 6, 7) =B+AC′
F2=Σ m(0, 1, 2, 6) =A′B′+BC′
F3=Σ m(2, 3, 5, 6, 7) =AC+B (9-7)FIGURE 9-22
Read-Only Memory 
with n Inputs and 
m Outputs
© Cengage Learning 2014nInput mOutput
Variables Variables
00 · · · 00 100 · · · 110
00 · · · 01 010 · · · 11100 · · · 10 101 · · · 10100 · · · 11 110 · · · 010
11 · · · 00 001 · · · 011
11 · · · 01 110 · · · 11011 · · · 10 011 · · · 00011 · · · 11 111 · · · 101
···
···Typical DataArray Storedin ROM(2
nwords of
mbits each)ROM
2n Words
× m Bits
m Output Linesn Input
Lines
......
FIGURE 9-23
Basic ROM 
Structure
© Cengage Learning 2014Decodern Input
LinesMemory Array
2n Words × m BitsROM
m Output Lines......
...
Multiplexers, Decoders, and Programmable Logic Devices  273
The contents of a ROM are usually specified by a truth table. The truth table of 
Figure 9-21(b) specifies the ROM in Figure 9-24. Note that a 1 or 0 in the output part 
of the truth table corresponds to the presence or absence of a switching element in the memory array of the ROM.
Multiple-output combinational circuits can easily be realized using ROMs. As 
an example, we will realize a code converter that converts a 4-bit binary number to a hexadecimal digit and outputs the 7-bit ASCII code. Figure 9-26 shows the truth table and logic circuit for the converter. Because 
A5=A4, and A6=A4′ the ROM 
needs only five outputs. Because there are four address lines, the ROM size is 16 words by 5 bits. Columns 
A4 A3 A2 A1 A0 of the truth table are stored in the ROM. 
Figure 9-27 shows an internal diagram of the ROM. The switching elements at the intersections of the rows and columns of the memory array are indicated using X’s. 
An X indicates that the switching element is present and connected, and no X indi-
cates that the corresponding element is absent or not connected.
Three common types of ROMs are mask-programmable ROMs, programmable 
ROMs (PROMs), and electrically erasable programmable ROMs (EEPROMs). At the time of manufacture, the data array is permanently stored in a mask-programmable ROM. This is accomplished by selectively including or omitting the switching elements at the row- column intersections of the memory array. This requires  preparation of a FIGURE 9-25
Equivalent OR Gate 
for F0
© Cengage Learning 2014m0m1m4m6F0FIGURE 9-24
An 8-Word × 4-Bit 
ROM
© Cengage Learning 2014
Word
Lines
F0m7 = ABCm6 = ABC′m5 = AB′Cm4 = AB′C′m3 = A′BCm2 = A′BC′m1 = A′B′C
F1 F2 F3m0 = A′B′C′
3-to-8
Decoder
Switching
Element
Output
LinesA
B
C
274 Unit 9
special mask, which is used during fabrication of the integrated circuit. Preparation 
of this mask is expensive, so the use of mask-programmable ROMs is economically 
feasible only if a large quantity (typically several thousand or more) is required with the same data array. If a small quantity of ROMs is required with a given data array, EEPROMs may be used.
Modification of the data stored in a ROM is often necessary during the devel-
opmental phases of a digital system, so EEPROMs are used instead of mask- programmable ROMs. EEPROMs use a special charge-storage mechanism to enable or disable the switching elements in the memory array. A PROM programmer is used to provide appropriate voltage pulses to store electronic charges in the mem-ory array locations. Data stored in this manner is generally permanent until erased. FIGURE 9-27
ROM Realization of 
Code Converter
© Cengage Learning 2014
4-to-16
Decoder
ROM OutputsROM
Inputs
ZYXW
A4m15m14m13m12m11m10m9m8m7m6m5m4m3m2m1m0
A3A2A1A0FIGURE 9-26
Hexadecimal-
to-ASCII Code 
Converter
© Cengage Learning 2014Input Hex ASCII Code for Hex Digit
WXYZ Digit A6A5A4A3A2A1A0
0 0 0 0 0 0110000
0 0 0 1 1 01100010 0 1 0 2 01100100 0 1 1 3 01100110 1 0 0 4 01101000 1 0 1 5 01101010 1 1 0 6 01101100 1 1 1 7 01101111 0 0 0 8 01110001 0 0 1 9 01110011 0 1 0 A 10000011 0 1 1 B 10000101 1 0 0 C 10000111 1 0 1 D 10001001 1 1 0 E 10001011 1 1 1 F 1000110ROMA6
A5
A4
A3
A2
A1ZYXW
A0
Multiplexers, Decoders, and Programmable Logic Devices  275
After erasure, a new set of data can be stored in the EEPROM. An EEPROM can 
be erased and reprogrammed only a limited number of times, typically 100 to 1000 times. Flash memories are similar to EEPROMs, except that they use a different charge-storage mechanism. They usually have built-in programming and erase capa-bility so that data can be written to the flash memory while it is in place in a circuit without the need for a separate programmer.
9.6 Programmable Logic Devices
A programmable logic device (or PLD) is a general name for a digital integrated circuit capable of being programmed to provide a variety of different logic functions. In this section we will discuss several types of combinational PLDs, and later we will discuss sequential PLDs. Simple combinational PLDs are capable of realizing from 2 to 10 functions of 4 to 16 variables with a single integrated circuit. More complex PLDs may contain thousands of gates and flip-flops. Thus, a single PLD can replace a large number of integrated circuits, and this leads to lower cost designs. When a digital system is designed using a PLD, changes in the design can easily be made by changing the programming of the PLD without having to change the wiring in the system.
Programmable Logic Arrays
A programmable logic array (PLA) performs the same basic function as a ROM. A PLA with n inputs and m outputs (Figure 9-28) can realize m functions of n vari-
ables. The internal organization of the PLA is different from that of the ROM. The decoder is replaced with an AND array which realizes selected product terms of the input variables. The OR array ORs together the product terms needed to form the output functions, so a PLA implements a sum-of-products expression, while a ROM directly implements a truth table.
Figure 9-29 shows a PLA which realizes the same functions as the ROM 
of Figure 9-24. Product terms are formed in the AND array by connecting switch-ing elements at appropriate points in the array. For example, to form 
A′B′, 
switching  elements are used to connect the first word line with the A′ and B′ lines. 
FIGURE 9-28
Programmable 
Logic Array 
Structure
© Cengage Learning 2014AND
Arrayn Input
Lines
k Word
LinesOR
ArrayPLA
m Output Lines......
...
276 Unit 9
 Switching elements are connected in the OR array to select the product terms 
needed for the output functions. For example, because F0=A′B′+AC′, switching 
elements are used to connect the A′B′ and AC′ lines to the F0 line. The connec-
tions in the AND and OR arrays of this PLA make it equivalent to the AND-OR array of Figure 9-30.
The contents of a PLA can be specified by a PLA table. Table 9-1 specifies the 
PLA in Figure 9-29. The input side of the table specifies the product terms. The sym-bols 0, l, and – indicate whether a variable is complemented, not complemented, or F3F2 F1
OutputsF0A′B′A′ABC
B′ C′
AC′
B
BC′
AC+VInputs
+V
+V+V+V
FIGURE 9-30
AND-OR Array 
Equivalent to 
Figure 9-29
© Cengage Learning 2014A
A′B′B
AC′
B
BC′
AC
F0 F1 F2 F3C
AND ArrayOR ArrayFIGURE 9-29
PLA with Three 
Inputs, Five Product 
Terms, and Four 
Outputs © Cengage Learning 2014
Multiplexers, Decoders, and Programmable Logic Devices  277
not present in the corresponding product term. The output side of the table specifies 
which product terms appear in each output function. A 1 or 0 indicates whether a given product term is present or not present in the corresponding output function. Thus, the first row of Table 9-1 indicates that the term 
A′B′ is present in output func-
tions F0 and F2, and the second row indicates that AC′ is present in F0 and F1.
Next, we will realize Equation (7-25) using a PLA. Using the minimum 
 multiple-output solution given in Equation (7-25b), we can construct a PLA table, Figure 9-31(a), with one row for each distinct product term. Figure 9-31(b) shows the corresponding PLA structure, which has four inputs, six product terms, and three outputs. A dot at the intersection of a word line and an input or output line indicates the presence of a switching element in the array.TABLE 9-1
PLA Table for 
Figure 9-29
© Cengage Learning 2014Product 
TermInputs 
A B COutputs  
F0 F1 F2 F3
A′B′  0 0 − 1  0  1  0 F0=A′B′+AC′
AC′  1 − 0 1  1  0  0 F1=AC′+B
B  − 1 − 0  1  0  1 F2=A′B′+BC′
BC′  − 1 0 0  0  1  0 F3=B+AC
AC  1 − 1 0  0  0  1
FIGURE 9-31
PLA Realization of 
Equation (7-25b)
© Cengage Learning 2014
a b c d
F1a′bd
abd
ab′c′
b′c
c
bc
F2F3Inputs
Outputs
(b) PLA structureWord
Linesabcd f1f2f3
01–1 11011–1 101100– 101–01– 100––1– 010–11– 001
(a) PLA table
278 Unit 9
A PLA table is significantly different than a truth table for a ROM. In a truth 
table each row represents a minterm; therefore, exactly one row will be selected by 
each combination of input values. The 0’s and 1’s of the output portion of the selected row determine the corresponding output values. On the other hand, each row in a PLA table represents a general product term. Therefore, zero, one, or more rows may be selected by each combination of input values. To determine the value of 
fi for a 
given input combination, the values of fi in the selected rows of the PLA table must 
be ORed together. The following examples refer to the PLA table of Figure 9-31(a). If abcd =0001, no rows are selected, and all 
f’s are 0. If abcd =1001, only the third 
row is selected, and f1 f2 f3=101. If abcd =0111, the first, fifth, and sixth rows are 
selected. Therefore, f1=1+0+0=1, f2=1+1+0=1, and f3=0+0+1=1.
Both mask-programmable and field-programmable PLAs are available. The 
mask-programmable type is programmed at the time of manufacture in a manner similar to mask-programmable ROMs. The field-programmable logic array (FPLA) has programmable interconnection points that use electronic charges to store a pat-tern in the AND and OR arrays. An FPLA with 16 inputs, 48 product terms, and eight outputs can be programmed to implement eight functions of 16 variables, pro-vided that the total number of product terms does not exceed 48.
When the number of input variables is small, a PROM may be more economi-
cal to use than a PLA. However, when the number of input variables is large, PLAs often provide a more economical solution than PROMs. For example, to realize eight functions of 24 variables would require a PROM with over 16 million 8-bit words. Because PROMs of this size are not readily available, the functions would have to be decomposed so that they could be realized using a number of smaller PROMs. The same eight functions of 24 variables could easily be realized using a single PLA, provided that the total number of product terms is small. If more terms are required, the outputs of several PLAs can be ORed together.
Programmable Array Logic
The PAL (programmable array logic) is a special case of the programmable logic array in which the AND array is programmable and the OR array is fixed. The basic structure of the PAL is the same as the PLA shown in Figure 9-28. Because only the AND array is programmable, the PAL is less expensive than the more general PLA, and the PAL is easier to program. For this reason, logic designers frequently use PALs to replace individual logic gates when several logic functions must be realized.
Figure 9-32(a) represents a segment of an unprogrammed PAL. The symbol
Noninverted Output
Inverted Output
represents an input buffer which is logically equivalent to
Multiplexers, Decoders, and Programmable Logic Devices  279
A buffer is used because each PAL input must drive many AND gate inputs. When 
the PAL is programmed, some of the interconnection points are programmed to make the desired connections to the AND gate inputs. Connections to the AND gate inputs in a PAL are represented by X ’s as shown:
FIGURE 9-32
PAL Segment
© Cengage Learning 2014I1
I2F1
Output
(a) UnprogrammedF4
F5
F8
I1
I1 I2′ + I1′ I2
I2
(b) ProgrammedAC
B
CA B C A B CBA
As an example, we will use the PAL segment of Figure 9-32(a) to realize the func-
tion I1I2′+I1′I2. The X’s in Figure 9-32(b) indicate that I1 and I2′ lines are  connected 
to the first AND gate, and the I′1′ and I2 lines are connected to the other gate.
When designing with PALs, we must simplify our logic equations and try to fit 
them into one (or more) of the available PALs. Unlike the more general PLA, the AND terms cannot be shared among two or more OR gates; therefore, each func-tion to be realized can be simplified by itself without regard to common terms. For a given type of PAL, the number of AND terms that feed each output OR gate is fixed and limited. If the number of AND terms in a simplified function is too large, we may be forced to choose a PAL with more gate inputs and fewer outputs.
280 Unit 9
As an example of programming a PAL, we will implement a full adder. The logic 
equations for the full adder are
Sum =X′Y′Cin+X′YC′in+XY′C′in+XYCin
 Cout=XCin+YCin+XY
Figure 9-33 shows a section of a PAL where each OR gate is driven by four AND 
gates. The X’s on the diagram show the connections that are programmed into the 
PAL to implement the full adder equations. For example, the first row of X’s imple-
ments the product term X′Y′Cin.
FIGURE 9-33
Implementation 
of a Full Adder  
Using a PAL
© Cengage Learning 2014X
Cin
Sum
CoutY
9.7 Complex Programmable Logic Devices
As integrated circuit technology continues to improve, more and more gates can be placed on a single chip. This has allowed the development of complex programmable logic devices (CPLDs). Instead of a single PAL or PLA on a chip, many PALs or PLAs can be placed on a single CPLD chip and interconnected. When storage ele-ments such as flip-flops are also included on the same IC, a small digital system can be implemented with a single CPLD.
Figure 9-34 shows the basic architecture of a Xilinx XCR3064XL CPLD. This 
CPLD has four function blocks, and each block has 16 associated macrocells (MC1, MC2, . . .). Each function block is a programmable AND-OR array that is configured as a PLA. Each macrocell contains a flip-flop and multiplexers that route signals from the function block to the input-output (I/O) block or to the interconnect array (IA). The IA selects signals from the macrocell outputs or I/O blocks and connects them back to function block inputs. Thus, a signal generated in one function block can be used as an input to any other function block. The I/O blocks provide an inter-face between the bi-directional I/O pins on the IC and the interior of the CPLD.
Multiplexers, Decoders, and Programmable Logic Devices  281
Figure 9-35 shows how a signal generated in the PLA is routed to an I/O pin 
through a macrocell. Any of the 36 outputs from the IA (or their complements) can 
be connected to any inputs of the 48 AND gates. Each OR gate can accept up to 48 product term inputs from the AND array. The macrocell logic in this diagram is a sim-plified version of the actual logic. The first MUX (1) can be programmed to select the OR-gate output or its complement. Details of the flip-flop operation will be discussed in Unit 11. The MUX (2) at the output of the macrocell can be programmed to select either the combinational output 
(G) or the flip-flop output (Q). This output goes to 
the interconnect array and to the output cell. The output cell includes a three-state buffer (3) to drive the I/O pin. The buffer enable input can be programmed from several sources. When the I/O pin is used as an input, the buffer must be disabled.
Sophisticated CAD software is available for fitting logic circuits into a PLD and 
for programming the interconnections within the PLD. The input to this software can be in several forms such as a logic circuit diagram, a set of logic equations, or code written in a hardware description language (HDL). Unit 10 discusses the use of an HDL. The CAD software processes the input, determines the logic equations to be implemented, fits these equations into the PLD, determines the required inter-connections within the PLD, and generates a bit pattern for programming the PLD.FIGURE 9-34 Architecture of Xilinx XCR3064XL CPLD (Figure based on figures and text owned by Xilinx, Inc., 
Courtesy of Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
16 16
16 16MC1
MC2
MC16FUNCTION
BLOCK
Interconnect
Array
(IA)FUNCTION
BLOCKI/OI/O PinsI/O...MC1
MC2
MC16
......
...36 36
16 16
16 16MC1
MC2
MC16FUNCTION
BLOCKFUNCTION
BLOCKI/O I/O...MC1
MC2
MC16
... ...
...36 36
FIGURE 9-35
CPLD Function 
Block and Macrocell 
(A Simplified 
Version of 
XCR3064XL)
© Cengage Learning 2014One of 16 OR Gates
Part of PLA Simplified Macrocell Output Cell48 AND Gates36 Inputs from IA
...
...
... ...
...123
I/O PinTo IA To IA
D
CE
CKQProgrammable
Select
Flip-FlopProgrammable
EnableGF
282 Unit 9
9.8 Field-Programmable Gate Arrays
In this section we introduce the use of field-programmable gate arrays (FPGAs) in 
combinational logic design. An FPGA is an IC that contains an array of identical logic cells with programmable interconnections. The user can program the functions realized by each logic cell and the connections between the cells. Figure 9-36 shows the layout of part of a typical FPGA. The interior of the FPGA consists of an array of logic cells, also called configurable logic blocks (CLBs). The array of CLBs is sur-rounded by a ring of input-output interface blocks. These I/O blocks connect the CLB signals to IC pins. The space between the CLBs is used to route connections between the CLB outputs and inputs.
Figure 9-37 shows a simplified version of a CLB. This CLB contains two func-
tion generators, two flip-flops, and various multiplexers for routing signals within the CLB. Each function generator has four inputs and can implement any function of up to four variables. The function generators are implemented as lookup tables (LUTs). A four-input LUT is essentially a reprogrammable ROM with 16 1 -bit words. This ROM stores the truth table for the function being generated. The 
H multiplexer 
selects either F or G depending on the value of H1. The CLB has two combinational 
outputs ( X and Y) and two flip-flop outputs ( XQ and YQ). The X and Y outputs and 
FIGURE 9-36
Layout of a Typical 
FPGA
© Cengage Learning 2014
Interconnect AreaConfigurable Logic Block I/O Block
Multiplexers, Decoders, and Programmable Logic Devices  283
the flip-flop inputs are selected by programmable multiplexers. The select inputs to 
these MUXes are programmed when the FPGA is configured. For example, the X 
output can come from the F function generator, and the Y output from the H multi-
plexer. Operation of the CLB flip-flops will be described in Unit 11.
Figure 9-38 shows one way to implement a function generator with inputs 
a, b, c , d. The numbers in the squares represent the bits stored in the LUT. These 
bits enable particular minterms. Because the function being implemented is stored as a truth table, a function with only one minterm or with as many as 15 minterms requires a single function generator. The functions
F=abc
and
F=a′b′c′d+a′b′cd+a′bc′d+a′bcd′+ab′c′d+ab′cd′+abc′d′+abc
d
each require a single function generator.
Decomposition of Switching Functions
In order to implement a switching function of more than four variables using 4- variable function generators, the function must be decomposed into subfunctions where each subfunction requires only four variables. One method of decomposition FIGURE 9-37
Simplified 
Configurable  
Logic Block (CLB)
© Cengage Learning 2014 HLUT
GG4 YQ
XQY
XG3
G2DSR
Q
CK
CE
G1
H1
LUT
= Programmable MUXFF4
F3
F2
F1DSR
Q
CK
CE
FIGURE 9-38
Implementation 
of a Lookup Table 
(LUT)
© Cengage Learning 2014
...
...0
b′a′
c′
d′
1
b′a′
c′
dF
1
ba
c
dabcd F
0000 0
0001 1
1111 1
······
284 Unit 9
is based on Shannon’s expansion theorem. We will first illustrate this theorem by 
expanding a function of the variables a , b, c , and d about the variable a :
 f(a, b, c , d)=a′ f(0, b, c , d)+a f(1, b, c , d)=a′ f0+a f1 (9-8)
The 3-variable function f0=f(0, b, c , d) is formed by replacing a with 0 in f(a, b, c , d), 
and f1=f(1, b, c , d) is formed by replacing a with 1 in f(a, b, c , d). To verify that 
Equation (9-8) is correct, first set a to 0 on both sides, and then set a to 1 on both 
sides. An example of applying Equation (9-8) is as follows:
 f(a, b, c , d)=c′d′+a′b′c+bcd+ac′
=a′(c′d′+b′c+bcd)+a(c′d′+bcd+c′)
=a′(c′d′ +b′c+cd)+a(c′+bd)=a′f0+a f1 (9-9)
Note that before simplification, the terms c′d′ and bcd appear in both f0 and f1 
because neither term contains a ′ or a .
Expansion can also be accomplished using a truth table or a Karnaugh map. 
Figure 9-39 shows the map for Equation (9-9). The left half of the map where a=0 
is in effect a 3-variable map for f0(b, c, d). Looping terms on the left half gives 
f0=c′d′+b′c+cd, which is the same as the previous result. Similarly the right half 
where a=1 is a 3-variable map for f1(b, c, d), and looping terms on the right half 
gives f1=c′+bd. The expressions for f0 and f1 obtained from the map are the same 
as those obtained algebraically in Equation (9-9).
The general form of Shannon’s expansion theorem for expanding an n-variable 
function about the variable xi is
f(x1, x2, . . . , xi–1, xi, xi+1, . . . , xn)
   =xi′ f(x1, x2, . . . , xi–1, 0, xi+1, . . . , xn)+xi f(x1, x2, . . . , xi–1, 1, xi+1, . . . , xn)
   =xi′ f0+xi f1                                                                                (9-10)
FIGURE 9-39
Function Expansion 
Using a Karnaugh 
Map
© Cengage Learning 2014
FF0 F1a = 0 a = 1
111100 01 11 10
11
111
100cdab
01
1110111100 01 11 10
11
111100cdab
01
1110where f0 is the (n−1)-variable function obtained by setting xi to 0 in the original 
function and f1 is the (n−1)-variable function obtained by setting xi to 1 in the 
Multiplexers, Decoders, and Programmable Logic Devices  285
original function. The theorem is easily proved for switching algebra by first setting  xi 
to 0 in Equation (9-10), and, then, setting xi to 1. Because both sides of the equation 
are equal for xi=0 and for xi=1, the theorem is true for switching algebra.
Applying the expansion theorem to a 5-variable function gives
 f(a, b, c , d, e )=a′ f(0, b, c , d, e )+a f(1, b, c , d, e )=a′ f0+a f1 (9-11)
This shows that any 5-variable function can be realized using two 4-variable function 
generators and a 2-to-1 MUX (Figure 9-40(a)). This implies that any 5-variable func-tion can be implemented using a CLB of the type shown in Figure 9-37 .
To realize a 6-variable function using 4-variable function generators, we apply 
the expansion theorem twice:
G(a, b, c , d, e , f
 )=a′G(0, b, c , d, e , f  )+a G(1, b, c , d, e , f  )=a′G0+a G1
G0=b′G(0, 0, c, d, e , f  )+b G(0, 1, c, d, e , f  )=b′G00+b G01
G1=b′G(1, 0, c, d, e , f  )+b G(1, 1, c, d, e , f  )=b′G10+bG11
Because G00,G01,G10, and G11 are all 4-variable functions, we can realize any  
6-variable function using four 4-variable function generators and three 2-to-1 MUXes, as shown in Figure 9-40(b). Thus, we can realize any 6-variable function using two CLBs of the type shown in Figure 9-35. Alternatively, we can write
 G
(a, b, c , d, e , f  )=a′b′G00+a′b G01+ab′G10+ab G11 (9-12)
and realize G using four function generators and a 4-to-1 MUX. In general, we can 
realize any n-variable function (n>4) using 2n−4 4-variable function generators 
and one 2n−4-to-1 MUX. This is a worst-case situation because many functions of  
n- variables can be realized with fewer function generators.
FIGURE 9-40
Realization of 
5- and 6-Variable 
Functions 
with Function 
Generators
© Cengage Learning 2014b
bc
d G00
G0
G1GG01
G10
G11e
f
c
d
e
f
c
d
e
f
c
d
e
fFG
FG
a ab
c F0
F1Fd
eFG
0
1 b
c
d
eFG
(a) 5-variable function (b) 6-variable functionFG
FG
286 Unit 9
Problems
9.1 (a)  Show how two 2-to-1 multiplexers (with no added gates) could be connected to 
form a 3-to-1 MUX. Input selection should be as follows:
If AB=00, select I0
If AB=01, select I1
If AB=1− (B  is a don’t-care), select I2
(b) Show how two 4-to-1 and one 2-to-1 multiplexers could be connected to form an 
8-to-1 MUX with three control inputs.
(c) Show how four 2-to-1 and one 4-to-1 multiplexers could be connected to form 
an 8-to-1 MUX with three control inputs.
9.2 Design a circuit which will either subtract X from Y or Y from X, depending on the 
value of A. If A=1, the output should be X−Y, and if A=0, the output should be 
Y−X. Use a 4-bit subtracter and two 4-bit 2-to-1 multiplexers (with bus inputs and 
outputs as in Figure 9-7).
9.3 Repeat 9.2 using a 4-bit subtracter, four 4-bit three-state buffers (with bus inputs and outputs), and one inverter.
9.4 Realize a full adder using a 3-to-8 line decoder (as in Figure 9-17) and
(a) two OR gates.
(b) two NOR gates.
9.5 Derive the logic equations for a 4-to-2 priority encoder. Refer to your table in the Study Guide, Part 4(b).
9.6 Design a circuit equivalent to Figure 9-15 using a 4-to-1 MUX (with bus inputs as in Figure 9-7). Use a 4-to-2 line priority encoder to generate the control signals.
9.7 An adder for Gray-coded-decimal digits (see Table 1 -2) is to be designed using a ROM. The adder should add two Gray-coded digits and give the Gray-coded sum and a carry. For example, 1011 +1010 =0010 with a carry of 1
 (7+6=13). Draw 
a block diagram showing the required ROM inputs and outputs. What size ROM is required? Indicate how the truth table for the ROM would be specified by giving some typical rows.
9.8 The following PLA will be used to implement the following equations:
X=AB′D+A′C′ + BC +C′D′
Y=A′C′ + AC +C′D′
Z=CD+A′C′ + AB ′D
Multiplexers, Decoders, and Programmable Logic Devices  287
(a) Indicate the connections that will be made to program the PLA to implement 
these equations.
(b) Specify the truth table for a ROM which realizes these same equations.
9.9 Show how to implement a full subtracter using a PAL. See Figure 9-33.
9.10 (a)  If the ROM in the hexadecimal to ASCII code converter of Figure 9-26 is 
replaced with a PAL, give the internal connection diagram.
(b) If the same ROM is replaced with a PLA, give the PLA table.
9.11 (a)  Sometimes the programmable MUX (1) in Figure 9-35 helps us to save AND 
gates. Consider the case in which F=c′d′+bc′+a′c. If programmable MUX (1) 
is not set to invert F (i.e., G=F), how many AND gates are needed? If the MUX 
is set to invert F (i.e., G=F′), how many AND gates are needed?
(b) Repeat (a) for F =a′b′+c′d′.
9.12 (a)  Implement a 3-variable function generator using a PAL with inputs a, b, c , and 
1 (use the input inverter to get 0 also). Give the internal connection diagram. 
Leave the connections to 0 and 1 disconnected, so that any 3-variable function can be implemented by connecting only 0 and 1.
(b) Now connect 0 and 1 so that the function generator implements the sum func-
tion for a full adder. See Figure 9-38.
9.13 Expand the following function about the variable b .
F=ab′cde′+bc′d′e+a′cd′e+ac′de′ 
9.14 (a)  Implement the following function using only 2-to-1 MUXes:  R=ab′h′
 + bch ′ + eg′h+fgh. 
(b) Repeat using only tri-state buffers.
9.15 Show how to make a 4-to-1 MUX, using an 8-to-1 MUX.
9.16 Implement a 32-to-1 multiplexer using two 16-to-1 multiplexers and a 2-to-1  multiplexer in two ways: (a) Connect the most significant select line to the 2-to-1 multiplexer, and (b) connect the least significant select line to the 2-to-1 multiplexer.A
XYZB C D
288 Unit 9
9.17 2-to-1 multiplexers with an active high output and active high enable are to be used 
in the following implementations:
(a) Show how to implement a 4-to-1 multiplexer with an active high output and no 
enable using two of the 2-to-1 MUXes and a minimum number of additional gates.
(b) Repeat part (a) for a 4-to-1 multiplexer with an active low output.
(c) Repeat part (b) assuming the output of the 2-to-1 MUX is 1 (rather than 0) 
when the enable is 0.
9.18 Realize a BCD to excess-3 code converter using a 4-to-10 decoder with active low outputs and a minimum number of gates.
9.19 Use a 4-to-1 multiplexer and a minimum number of external gates to realize the function F
(w, x, y, z)=Σ m(3, 4, 5, 7, 10, 14 )+Σ d(1, 6, 15 ).
The inputs are only available uncomplemented.
9.20 Realize the function f(a, b, c , d, e )=Σ m(6, 7, 9, 11, 12, 13, 16, 17, 18, 20, 21, 23, 25, 28 ) 
using a 16-to-1 MUX with control inputs b, c, d, and e . Each data input should be 
0, 1, a , or a ′. (Hint: Start with a minterm expansion of F and combine minterms to 
eliminate a  and a ′ where possible.)
9.21 Implement a full adder
(a) using two 8-to-1 MUXes. Connect X,Y, and Cin to the control inputs of the 
MUXes and connect 1 or 0 to each data input.
(b) using two 4-to-1 MUXes and one inverter. Connect X and Y to the control 
inputs of the MUXes, and connect 1’s, 0’s, Cin, or C ′in to each data input.
(c) again using two 4-to-1 MUXes, but this time connect Cin and Y to the control 
inputs of the MUXes, and connect 1’s, 0’s, X, or X′ to each data input. Note that 
in this fashion, any N-variable logic function may be implemented using a 2(N−1)- 
to-1 MUX.
9.22 Repeat Problem 9.21 for a full subtracter, except use Bin instead of Cin.
9.23 Make a circuit which gives the absolute value of a 4-bit binary number. Use four full adders, four multiplexers, and four inverters. Assume negative numbers are repre-
sented in 2’s complement. Recall that one way to find the 2’s complement of a binary number is to invert all of the bits and then add 1.
9.24 Show how to make a 4-to-1 MUX using four three-state buffers and a decoder.
9.25 Show how to make an 8-to-1 MUX using two 4-to-1 MUXes, two three-state buffers, and one inverter.
9.26 Realize a full subtracter using a 3-to-8 line decoder with inverting outputs and
(a) two NAND gates
(b) two AND gates
Multiplexers, Decoders, and Programmable Logic Devices  289
9.27 Show how to make the 8-to-3 priority encoder of Figure 9-20 using two 4-to-2 prior-
ity encoders and any additional necessary gates.
9.28 Design an adder for excess-3 decimal digits (see Table 1 -2) using a ROM. Add two excess-3 digits and give the excess-3 sum and a carry. For example, 1010 +1001 =0110 
with a carry of 1
 (7+6=13). Draw a block diagram showing the required ROM 
inputs and outputs. What size ROM is required? Indicate how the truth table for the ROM would be specified by giving some typical rows.
9.29 A circuit has four inputs R
STU and four outputs VWYZ. RSTU represents a binary-
coded-decimal digit. VW represents the quotient and YZ the remainder when RSTU 
is divided by 3 ( VW and YZ represent 2-bit binary numbers). Assume that invalid 
inputs do not occur. Realize the circuit using
(a) a ROM
(b) a minimum two-level NAND-gate circuit
(c) a PLA (specify the PLA table)
9.30 Repeat Problem 9.29 if the inputs RSTU represent a decimal digit in Gray code (see 
Table 1 -2).
9.31 (a)  Find a minimum two-level NOR-gate circuit to realize F1 and F2. Use as many 
common gates as possible.F
1(a, b, c , d)=Σ m(1, 2, 4, 5, 6, 8, 10, 12, 14 )
F2(a, b, c , d)=Σ m(2, 4, 6, 8, 10, 11, 12, 14, 15 )
(b) Realize F1 and F2 using a PLA. Give the PLA table and internal connection 
diagram for the PLA.
9.32 Braille is a system which allows a blind person to read alphanumerics by feeling a pattern of raised dots. Design a circuit that converts BCD to Braille. The table shows the correspondence between BCD and Braille.
(a) Use a multiple-output NAND-gate circuit.

290 Unit 9
(b) Use a PLA. Give the PLA table.
(c) Specify the connection pattern for the PLA.
9.33 (a)    Implement your solution to Problem 7 .10 using a PLA. Specify the PLA table 
and draw the internal connection diagram for the PLA using dots to indicate the 
presence of switching elements.
(b) Repeat (a) for Problem 7 .44.
(c) Repeat (a) for Problem 7 .47 .
9.34 Show how to make an 8-to-1 MUX using a PAL. Assume that PAL has 14 inputs and six outputs and assume that each output OR gate may have up to four AND terms as inputs, as in Figure 9-33. ( Hint: Wire some outputs of the PAL around 
to the inputs, external to the PAL. Some PALs allow this inside the PAL to save inputs.)
9.35 Work Problem 9.34 but make the 8-to-3 priority encoder of Figure 9-20 instead of 
a MUX.
9.36 The function F=CD′E+CDE +A′D′E+A′B′DE′+BCD  is to be implemented 
in an FPGA which uses 3-variable lookup tables.
(a) Expand 
F about the variables A and B .
(b) Expand F about the variables B  and C.
(c) Expand F about the variables A and C.
(d) Any 5-variable function can be implemented using four 3-variable lookup tables 
and a 4-to-1 MUX, but this time we are lucky. Use your preceding answers to implement 
F using only three 3-variable lookup tables and a 4-to-1 MUX. Give 
the truth tables for the lookup tables.
9.37 Work Problem 9.36 for F =B′D′E′+AB′C+C′DE′+A′BC′D.
9.38 Implement a 4-to-1 MUX using a CLB of the type shown in Figure 9-37 . Specify the function realized by each function generator.
9.39 Realize the function 
f(A, B, C, D)=A′C′+AB′D′+ACD +A′BD.
(a) Use a single 8-to-1 multiplexer with an active low enable and an active high 
output. Use A, C, and D  as the select inputs where A is the most significant and 
D is the least significant.
(b) Repeat part (a) assuming the multiplexer enable is active high and output is 
active low.
(c) Use a single 4-to-1 multiplexer with an active low enable and an active high 
output and a minimum of additional gates. Show the function expansion both algebraically and on a Karnaugh map.
9.40 Repeat Problem 9.39 for the function 
f(A, B, C, D, E)=A′C′E′+A′B′D′E′+ACDE ′+A′BDE′ .
Multiplexers, Decoders, and Programmable Logic Devices  291
9.41 F(a, b, c, d)=a′+ac′d′+b′cd′+ad.
(a) Using Shannon’s expansion theorem, expand F about the variable d .
(b) Use the expansion in part (a) to realize the function using two 3-variable LUTs 
and a 2-to-1 MUX. Specify the LUT inputs.
(c) Give the truth table for each LUT.
9.42 Repeat 9.41 for F (a, b, c, d)=cd′+ad′+a′b′cd+bc′.
9.43 Repeat 9.41 for F (a, b, c, d)=bd+bc′+ac′d+a′d′.
9.44 The module M below is a demultiplexer (i.e., it routes the input w to one of the four 
outputs depending on the value of the select lines s and t; thus, an output is 0 or equal 
to input w depending on the value of s and t). The outputs of module M can be ORed 
to realize functions of the inputs.
(a) Show how to realize the function f(a, b, c )=ab′+b′c′ using one module M and 
one OR-gate. (Assume that the inputs are available in both true and comple-
ment form.)
(b) Using just one module M and one OR gate, is it possible to realize any arbitrary 
three-variable function? (Again assume inputs are available in both true and complement form.) Justify your answer.
(c) Can the function of part (a) be realized with one module M and one NOR gate? 
Verify your answer.
(d) If the outputs of module M are active-low, to what type of gate should the out-
puts connect to realize nontrivial functions? ( Note: The outputs not selected are 
logic 1 and the selected output is w ′.)
9.45 The circuit below has a 4-input priority encoder connected to a 2-to-4 decoder with enable. The truth table for the priority encoder is given. (The 
I3 input is highest pri-
ority.) All signals are active high. What functions of A, B, C, and D  are realized by 
Z3, Z2, Z1, and Z0?sty3=w if st =11
y2=w if st=10w My1=w if st =01
y0=w if st=00
(a) (b)Priority
EncoderY1
Y0
GA
B2-to-4
DecoderZ3
Z2
Z1
Z0S0S1I3
I2
I1
I0C
DEI3I2I1I0GY1Y0
0000 000
0001 100001– 10101–– 1101––– 111
292 Unit 9
9.46 The circuit below has a 2-to-4 decoder with active high outputs connected to a 4-to-1 
MUX with an active low output.
(a) Derive a minimum SOP or a minimum POS expression for the output, 
f(A, B, C, D ).
(b) Repeat part (a) assuming the decoder outputs are active low.
9.47 The Max Selector below has two 4-bit, unsigned inputs, A and B . Its output Z =A if 
A≥B and Z=B if A<B.
(a) Design the Max Selector in the form shown. The Mi are identical, and a single 
line connects them with information flowing from right to left. Do one design assuming c
0=0 and one assuming c0=1.
(b) What is the relationship between the design of part (a) and adder or subtractor 
circuits?C
DBA S1Y0
Y1
Y2
Y3I0
I1f
S1S0I2
I32-to-4
Decoder4-to-1MUX
S
0
AB
44 4
ZMax
Selector
c0c4 c3 c2 c1a3b3 a2b2 a1b1 a0b0
2-to-1MUXAB
4 4
4
ZM3 M2 M1 M0 S
Multiplexers, Decoders, and Programmable Logic Devices  293
(c) Consider an alternative design of the Max Selector where the information flow 
is from left to right as shown. Can the Max Selector be designed in this form? 
If yes, complete the design. If no, explain why not and explain what change 
would be required (with information only flowing from left to right between the 
modules).
9.48 (a)    Show that the full adder of Figure 4-5 can be implemented using two 2-input 
exclusive-OR gates and a 2-to-1 multiplexer. ( Hint: Rewrite Equation (4-21) in 
terms of X ⊕ Y.)
(b) Assume the ripple-carry adder of Figure 4-3 and the full adder of part (a) are 
implemented using CMOS logic. Which adder would have the smallest max-imum addition time? Explain. (You need to be familiar with the material in Appendix A to answer this question.)
9.49 Repeat Problem 9.48 for the full subtractor of Table 4-6.c4c3 c2 c1 c0a3b3 a2b2 a1b1 a0b0
2-to-1
MuxAB
4 4
4
ZS M3 M2 M1 M0
294Introduction to VHDLUNIT
10
Objectives
1. Represent gates and combinational logic by concurrent VHDL statements.
2. Given a set of concurrent VHDL statements, draw the corresponding 
 combinational logic circuit.
3. Write a VHDL module for a combinational circuit
a. by using concurrent VHDL statements to represent logic equations
b. by interconnecting VHDL components
4. Compile and simulate a VHDL module.
5. Use the basic VHDL operators and understand their order of precedence.
6. Use the VHDL types: bit, bit_vector, Boolean, and integer. Define and use an array_type.
7. Use IEEE Standard Logic. Use std_logic_vectors, together with overloaded operators, to perform arithmetic operations.
Introduction to VHDL  295
(d) Write a VHDL statement to implement A=B ⊕ C without using the xor 
or xnor operator. Do not include gate delays.
(e) Work Problems 10.1 and 10.2.
2. Study Section 10.2, VHDL Models for Multiplexers.
(a) Implement the following VHDL conditional assignment statement, using a 
2-to-1 MUX:
F <= A when C = ‘1’ else B;
(b) Write a VHDL conditional assignment statement that represents the 4-to-1 
MUX of Figure 9-2. Assume I0=1, I1=0, and I2=I3=C.
(c) Write a VHDL selected signal assignment for the same circuit as in (b).
3. Study Section 10.3, VHDL Modules, and Section 10.4, Signals and Constants.
(a) Write an entity for the module MOD1. A, B, C, D ,  and   E are all of type bit.M
1M
0 5 10 15 20 25t (ns)Study Guide
1. Study Section 10.1, VHDL Description of Combinational Circuits.
(a) Draw a circuit that corresponds to the following VHDL statements:
C <= not A ;     D  <= C and B;
(b) If A changes at time 5  ns, at what time do each of the following concurrent 
statements execute? At what times are C and D updated?
C <= A;
D <= A;
(c) Write a VHDL statement that corresponds to the following circuit. The inverter 
has a delay of 5 ns. Draw the waveform for M assuming that M is initially 0.
A
B
CD
EVHDL
Module
MOD1
296 Unit 10
(b) Write the architecture for MOD1 if D =ABC and E =D′.
(c) What changes must be made in the code of Figure 10-12 to implement a 
5-bit adder?
(d) Given the concurrent VHDL statements
R <= A after 5 ns; -- statement 1
S <= R after 10 ns; -- statement 2
If A changes at time 3 ns, at what time will statement 1 be executed?
At what time will R be updated?At what time will statement 2 be executed?At what time will S be updated?
Answers: 3 ns, 
8 ns, 8 ns, and 18 ns
(e) Write a statement that defines a bit_vector constant C1 equal to 10101011.
(f  ) The circuit of Figure 8-5 is implemented as a module without gate delays 
as follows.(In the figure, B is set to 1 and 
C is set to 0, but here, assume they are inputs.)
entity ﬁg8_5 is  port (A, B, C: in bit; G2: out bit);end ﬁg8_5;architecture circuit of ﬁg8_5 isbegin  G2 <= not(C or (A and B));
end circuit;
Each gate in Figure 8-5 has a delay of 20 ns. Modify the module to include gate delays. (Hint: You will need a signal declaration to introduce G1 as an 
internal signal.)
(g) Work Problems 10.3 and 10.4.
4. Study Section 10.5, Arrays.
(a) Write VHDL statements that define a ROM that is 16 words of 8 bits each. 
Leave the values stored in the ROM unspecified.
(b) Work Problem 10.5.
Introduction to VHDL  297
5. Study Section 10.6, VHDL Operators.
(a) For each of the following statements, eliminate one set of parentheses with-
out changing the order of operation.
(i) not ((A & B) xor “10”)
(ii) (not (A & B) xor “10”)
(b) If A (0  to   7) = “11011011”, what will be the result of executing the follow-
ing concurrent statement?
B <= A(6 to 7)&A(0 to 5);
What problem will occur when the following concurrent statement is  executed?
A <= A(6 to 7)&A(0 to 5);
(Hint: A concurrent statement executes every time the right-hand side changes.)
(c) Work Problem 10.6(a).
6. Study Section 10.7 , Packages and Libraries.
 Give the entity and architecture that describes a three-input AND gate with 
2-ns delay. Assume that all signals are of type bit.
7. Study Section 10.8, IEEE Standard Logic.
(a) Suppose A, B, C, D, E, and F are of type std_logic. If the following concur-
rent statements are executed, what are the values of A, B, C, D, E, and F?
A <= ‘1’; A <= ‘Z’;
B <= ‘0’; B <= A;
C <= ‘0’;D <= A when C = ‘0’ else ‘Z’;
D <= C when C = ‘1’ else ‘Z’;
E <= ‘0’ when A = ‘1’ else C;
E <= A when C = ‘0’ else ‘1’;
F <= ‘1’ when A = ‘1’ and C = ‘1’ else ‘Z’;
F <= ‘0’ when A = ‘0’ and C = ‘0’ else ‘Z’;
(b) Given the concurrent statements
F <= ‘0’;F <= ‘1’ after 2 ns;
What will happen if F is of type bit? What if F is of type std_logic?
(c) Suppose in Figure 10-19 that A is 1011, B is 0111, and Cin is 1. What is 
Addout? Sum? Cout?
298 Unit 10
(d) If A is a 6-bit std_logic_vector and B is a 4-bit std_logic_vector, write con-
current VHDL statements that will add A and B to result in a 6-bit sum 
and a carry.
(e) Draw a circuit that implements the following VHDL code:
signal A, B, C, D: std_logic_vector(1 to 3);signal E, F , G: std_logic;-----------------------------------------------------D <= A when E = ‘1’ else “ZZZ”;
D <= B when F = ‘1’ else “ZZZ”;
D <= C when G = ‘1’ else “ZZZ”;
(f  ) Work Problems 10.6(b), 10.7 , and 10.8.
8. Before you take the test on Unit 10, pick up a lab assignment sheet and work the assigned lab problems. Turn in your VHDL code and simulation results.
Introduction to VHDL
As integrated circuit technology has improved to allow more and more components on a chip, digital systems have continued to grow in complexity. As digital systems have become more complex, detailed design of the systems at the gate and flip-flop level has become very tedious and time consuming. For this reason, the use of hard-ware description languages in the digital design process continues to grow in impor-tance. A hardware description language allows a digital system to be designed and debugged at a higher level before implementation at the gate and flip-flop level. The use of computer-aided design tools to do this conversion is becoming more wide-spread. This is analogous to writing software programs in a high-level language such as C and then using a compiler to convert the programs to machine language. The two most popular hardware description languages are VHDL and Verilog.
Introduction to VHDL  299
VHDL is a hardware description language that is used to describe the behav-
ior  and structure of digital systems. The acronym VHDL stands for VHSIC 
Hardware Description Language, and VHSIC in turn stands for Very High Speed Integrated Circuit. However, VHDL is a general-purpose hardware description language which can be used to describe and simulate the operation of a wide variety of digital systems, ranging in complexity from a few gates to an intercon-nection of many complex integrated circuits. VHDL was originally developed to allow  a uniform method for specifying digital systems. The VHDL language became an IEEE standard in 1987 , and it is widely used in industry. IEEE pub-lished a revised VHDL standard in 1993, and the examples in this text conform to that standard.
VHDL can describe a digital system at several different levels—behavioral, 
data flow, and structural. For example, a binary adder could be described at the behavioral level in terms of its function of adding two binary numbers, without giving any implementation details. The same adder could be described at the data flow level by giving the logic equations for the adder. Finally, the adder could be described at the structural level by specifying the interconnections of the gates which make up the adder.
VHDL leads naturally to a top-down design methodology in which the system 
is first specified at a high level and tested using a simulator. After the system is debugged at this level, the design can gradually be refined, eventually leading to a structural description which is closely related to the actual hardware implementa-tion. VHDL was designed to be technology independent. If a design is described in VHDL and implemented in today’s technology, the same VHDL description could be used as a starting point for a design in some future technology.
In this chapter, we introduce VHDL and illustrate how we can describe simple 
combinational circuits using VHDL. We will use VHDL in later units to design sequential circuits and more complex digital systems. In Unit 17 , we introduce the use of CAD software tools for automatic synthesis from VHDL descriptions. These synthesis tools will derive a hardware implementation from the VHDL code.
10.1 VHDL Description of Combinational  
Circuits
We begin by describing a simple gate circuit using VHDL. A VHDL signal is used 
to describe a signal in a physical system. (Section 10.4 contains a summary of signals, constants, and types. The VHDL language also includes variables similar to variables in programming languages, but to obtain synthesizable code for hardware, signals should be used to represent hardware signals. VHDL variables are not used in this text.) The gate circuit of Figure 10-1 has five signals: A, B, C, D, and E. The symbol “<=” is the signal assignment operator which indicates that the value computed on 
300 Unit 10
the right-hand side is assigned to the signal on the left side. A behavioral description 
of the circuit in Figure 10-1 is
E <= D or (A and B);
Parentheses are used to specify the order of operator execution.
The two assignment statements in Figure 10-1 give a dataflow description of 
the circuit where it is assumed that each gate has a 5-ns propagation delay. When 
the statements in Figure 10-1 are simulated, the first statement will be evalu-ated any  time A or B changes, and the second statement will be evaluated any time C or  D changes.  Suppose that initially A =1, and B =
C=D=E=0. If B 
changes to 1 at time 0, C will change to 1 at time = 5 ns. Then, E will change to 1 at 
time = 10 ns.
The circuit of Figure 10-1 can also be described using structural VHDL code. 
To do so requires that a two-input AND-gate component and a two-input OR-gate component be declared and defined. Components may be declared and defined either in a library or within the architecture part of the VHDL code. (VHDL archi-tectures are discussed in Section 10.3, and packages and libraries are discussed in Section 10.7 .) Instantiation statements are used to specify how components are con-nected. Each copy of a component requires a separate instantiation statement to specify how it is connected to other components and to the port inputs and outputs. An instantiation statement is a concurrent statement that executes anytime one of the input signals in its port map changes. The circuit of Figure 10-1 is described by instantiating the AND gate and the OR gate as follows:
Gate1: AND2 port map (A, B, C);
Gate2: OR2 port map (C, D, E);
The port map for Gate1 connects A and B to the AND-gate inputs, and it con-nects  D to the AND-gate output. Since an instantiation statement is concurrent, whenever A or B changes, these changes go to the Gate1 inputs, and then the com-ponent computes a new value of C. Similarly, the second statement passes changes in C or D to the Gate2 inputs, and then the component computes a new value of E. This is exactly how the real hardware works. (The order in which the instantiation statements appear is irrelevant.) Instantiating a component is different than calling a function in a computer program. A function returns a new value whenever it is called, but an instantiated component computes a new output value whenever its input changes.
VHDL signal assignment statements, such as the ones in Figure 10-1, are exam-
ples of concurrent statements. The VHDL simulator monitors the right side of each concurrent statement, and any time a signal changes, the expression on the right side is immediately re-evaluated. The new value is assigned to the signal on the left side FIGURE 10-1
Gate Circuit
© Cengage Learning 2014C <= A and B after 5 ns;
E <= C or D after 5 ns;A
BDC
E
Introduction to VHDL  301
FIGURE 10-2
Inverter with 
Feedback
© Cengage Learning 2014CLK
CLK
10 20 30 40 60 50CLK <= not CLK after 10 ns;after an appropriate delay. This is exactly the way the hardware works. Any time a 
gate input changes, the gate output is recomputed by the hardware, and the output changes after the gate delay.
When we initially describe a circuit, we may not be concerned about propagation 
delays. If we write
C <= A and B;
E <= C or D;
this implies that the propagation delays are 
0 ns. In this case, the simulator will 
assume an infinitesimal delay referred to as Δ (delta). Assume that initially A =1 
and B =C=D=E=0. If B is changed to 1 at time = 1 ns, then C will change at 
time 1 +Δ and E will change at time 1 +2Δ.
Unlike a sequential program, the order of the above concurrent statements is 
unimportant. If we write
E <= C or D;C <= A and B;
the simulation results would be exactly the same as before.
In general, a signal assignment statement has the form
signal_name <= expression [after delay];
The expression is evaluated when the statement is executed, and the signal on the 
left side is scheduled to change after delay. The square brackets indicate that after delay is optional; they are not part of the statement. If after delay is omitted, then the signal is scheduled to be updated after a delta delay. Note that the time at which the statement executes and the time at which the signal is updated are not the same.
Even if a VHDL program has no explicit loops, concurrent statements may exe-
cute repeatedly as if they were in a loop. Figure 10-2 shows an inverter with the output connected back to the input. If the output is ‘0’, then this ‘0’ feeds back to the input and the inverter output changes to ‘1’ after the inverter delay, assumed to be 10 ns. Then, the ‘1’ feeds back to the input, and the output changes to ‘0’ after the inverter delay. The signal CLK will continue to oscillate between ‘0’ and ‘1’, as shown in the waveform. The corresponding concurrent VHDL statement will produce the same result. If CLK is initialized to ‘0’, the statement executes and CLK changes to ‘1’ after 10 ns. Because CLK has changed, the statement executes again, and CLK will change back to ‘0’ after another 10 ns. This process will continue indefinitely.
302 Unit 10
The statement in Figure 10-2 generates a clock waveform with a half period of 
10 ns. On the other hand, the concurrent statement
CLK <= not CLK;
will cause a run-time error during simulation. Because there is 0 delay, the value of 
CLK will change at times 0+Δ, 0+2Δ, 0+3Δ, etc. Because Δ is an infinitesimal 
time, time will never advance to 1  ns.
In general, VHDL is not case sensitive, that is, capital and lower case letters are 
treated the same by the compiler and the simulator. Thus, the statements
 Clk <= NOT clk After 10 NS;
and CLK <= not CLK after 10 ns;
would be treated exactly the same. Signal names and other VHDL identifiers may contain letters, numbers, and the underscore character (_). An identifier must start with a letter, and it cannot end with an underscore. Thus, C123 and ab_23 are legal identifiers, but 1ABC and ABC_ are not. Every VHDL statement must be termi-nated with a semicolon. Spaces, tabs, and carriage returns are treated in the same way. This means that a VHDL statement can be continued over several lines, or sev-eral statements can be placed on one line. In a line of VHDL code, anything follow-ing a double dash (--) is treated as a comment. Words such as and, or, and after are 
reserved words (or keywords) which have a special meaning to the VHDL compiler. In this text, we will put all reserved words in boldface type.
Figure 10-3 shows three gates that have the signal A as a common input and 
the corresponding VHDL code. The three concurrent statements execute simultane-ously whenever A changes, just as the three gates start processing the signal change at the same time. However, if the gates have different delays, the gate outputs can change at different times. If the gates have delays of 2 ns, 1 ns, and 3 ns, respectively, and A changes at time 5 ns, then the gate outputs D, E, and F can change at times 7 ns, 6 ns, and 
8 ns, respectively. The VHDL statements work in the same way. Even 
though the statements execute simultaneously, the signals D, E, and F are updated at times 7 ns, 6 ns, and 
8 ns. However, if no delays were specified, then D, E, and F 
would all be updated at time 5 +Δ.
In these examples, every signal is of type bit, which means it can have a value of 
‘0’ or ‘1’. (Bit values in VHDL are enclosed in single quotes to distinguish them from integer values.) In digital design, we often need to perform the same operation on a group of signals. A one-dimensional array of bit signals is referred to as a bit-vector. If a 4-bit vector named B has an index range 0 through 3, then the four elements of the bit-vector are designated B(0), B(1), B(2), and B(3). The statement 
B <= “0110” 
assigns ‘0’ to B(0), ‘1’ to B(1), ‘1’ to B(2), and ‘0’ to B(3).
FIGURE 10-3
Three Gates with a 
Common Input and 
Different Delays
© Cengage Learning 2014B
CAD
E
F-- when A changes, these concurrent
-- statements all execute at the same time
D <= A and B after 2 ns;
E <= not A after 1 ns;F <= A or C after 3 ns;
Introduction to VHDL  303
FIGURE 10-4
Array of AND  
Gates
© Cengage Learning 2014A(3)
B(3)C(3)
A(2)
B(2)C(2)
A(1)
B(1)C(1)
A(0)
B(0)C(0)-- the hard way
C(3) <= A(3) and B(3);
C(2) <= A(2) and B(2);C(1) <= A(1) and B(1);C(0) <= A(0) and B(0);
-- the easy way
C <= A and B;
Figure 10-4 shows an array of four AND gates. The inputs are represented by bit-
vectors A and B, and the outputs by bit-vector C. Although we can write four VHDL 
statements to represent the four gates, it is much more efficient to write a single VHDL statement that performs the and operation on the bit-vectors A and B. When applied to bit-vectors, the and operator performs the and operation on correspond-
ing pairs of elements.
The preceding signal assignment statements containing “ after delay” create 
what is called an inertial delay model. Consider a device with an inertial delay 
of D time units. If an input change to the device will cause its output to change, then the output changes D time units later. However, this is not what happens if the device receives two input changes within a period of D time units and both input changes should cause the output to change. In this case the device output does not change in response to either input change. As an example, consider the signal assignment
C <= A and B after 10 ns;
Assume A and B are initially 1, and A changes to 0 at 15 ns, to 1 at 30 ns, and to 0 at 35 ns. Then C changes to 1 at 10 ns and to 0 at 25 ns, but C does not change in response to the A changes at 30 ns and 35 ns because these two changes occurred less than 10 ns apart. A device with an inertial delay of D time units filters out output changes that would occur in less than or equal to D time units.
VHDL can also model devices with an ideal ( transport) delay. Output changes 
caused by input changes to a device exhibiting an ideal (transport) delay of D time units are delayed by D time units, and the output changes occur even if they occur within D time units. The VHDL signal assignment statement that models ideal (transport) delay is
signal_name <= transport expression after delay
As an example, consider the signal assignment
C <= transport A and B after 10 ns;
Assume A and B are initially 1 and A changes to 0 at 15 ns, to 1 at 30 ns, and to 0 at 35 ns. Then C changes to 1 at 10 ns, to 0 at 25 ns, to 1 at 
40 ns, and to 0 at 45 ns. Note 
that the last two changes are separated by just 5 ns.
304 Unit 10
10.2 VHDL Models for Multiplexers
Figure 10-5 shows a 2-to-1 multiplexer (MUX) with two data inputs and one control 
input. The MUX output is F =A′·I0+A·I1. The corresponding VHDL statement is
F <= (not A and I0) or (A and I1);
Alternatively, we can represent the MUX by a conditional signal assignment state-ment, as shown in Figure 10-5. This statement executes whenever A, I0, or I1 changes. The MUX output is I0 when 
A=‘0’, and else it is I1. In the conditional statement, 
I0,  I1, and F can either be bits or bit-vectors.
The general form of a conditional signal assignment statement is
signal_name <= expression1 when condition1
 else expression2 when condition2
 [ else expressionN];
This concurrent statement is executed whenever a change occurs in a signal used in one of the expressions or conditions. If condition1 is true, signal_name is set equal to the value of expression1, or else if condition2 is true, signal_name is set equal to the value of expression2, etc. The line in square brackets is optional. Figure 10-6 shows how two cascaded MUXes can be represented by a conditional signal assignment statement. The output MUX selects A when E =‘1’; or else it selects the output of 
the first MUX, which is B when D =‘1’, or else it is C.
Figure 10-7 shows a 4-to-1 MUX with four data inputs and two control inputs, A 
and B. The control inputs select which one of the data inputs is transmitted to the output. The logic equation for the 4-to-1 MUX is
F=A′B′Ι
0+A′BI1+AB ′I2+ABI3
Thus, one way to model the MUX is with the VHDL statement
F <= (not A and not B and I0) or (not A and B and I1) or
 (A and not B and I2) or (A and B and I3);FIGURE 10-5
2-to-1 Multiplexer
© Cengage Learning 2014
AFI0
I10
1-- conditional signal assignment statement
F <= I0 when A = '0' else I1;
FIGURE 10-6
Cascaded 2-to-1 
MUXes
© Cengage Learning 2014
DC
B0
1
EF
A01 F <= A when E = '1'
else B when D = '1'
else C;
Introduction to VHDL  305
Another way to model the 4-to-1 MUX is to use a conditional assignment statement:
F <= I0 when A&B = “00”
else I1 when A&B = “01”
else I2 when A&B = “10”
else I3;
The expression A&B means A concatenated with B, that is, the two bits A and B 
are merged together to form a 2-bit vector. This bit vector is tested, and the appro-priate MUX input is selected. For example, if 
A=‘1’ and B =‘0’, A&B =“10” 
and I2 is selected. Instead of concatenating A and B, we could use a more complex condition:
F <= I0 when A = ‘0’ and B = ‘0’
else I1 when A = ‘0’ and B = ‘1’
else I2 when A = ‘1’ and B = ‘0’
else I3;
A third way to model the MUX is to use a selected signal assignment state-
ment, as shown in Figure 10-7 . A&B cannot be used in this type of statement, so we first set Sel equal to A&B. The value of Sel then selects the MUX input that is assigned to F.
The general form of a selected signal assignment statement is
with expression_s select
  signal_s <= expression1 [after delay-time] when choice1,
       expression2 [after delay-time] when choice2,       .  .  .         [expression_n [after delay-time] when others];
This concurrent statement executes whenever a signal changes in any of the expressions. First, expression_s is evaluated. If it equals choice1, signal_s is set equal to expression1; if it equals choice2, signal_s is set equal to expression2; etc. If all possible choices for the value of expression_s are given, the last line should be omit-ted; otherwise, the last line is required. When it is present, if expression_s is not equal to any of the enumerated choices, signal_s is set equal to expression_n. The signal_s is updated after the specified delay-time, or after 
Δ if the “ after delay-time” 
is omitted.FIGURE 10-7
4-to-1 Multiplexer
© Cengage Learning 2014
ABI0
I1
I2
I3F MUXsel <= A&B;
-- selected signal assignment statementwith sel select   F <= I0 when "00",        I1 when "01",        I2 when "10",        I3 when "11";
306 Unit 10
10.3 VHDL Modules
To write a complete VHDL module, we must declare all of the input and output 
signals using an entity declaration, and then specify the internal operation of the module using an architecture declaration. As an example, consider Figure 10-8. The 
entity declaration gives the name “two_gates” to the module. The port declaration specifies the inputs and outputs to the module. A, B, and D are input signals of type bit, and E is an output signal of type bit. The architecture is named “gates”. The signal C is declared within the architecture because it is an internal signal. The two concurrent  statements that describe the gates are placed between the keywords begin and end.
When we describe a system in VHDL, we must specify an entity and an archi-
tecture at the top level, and also specify an entity and architecture for each of the component modules that are part of the system (see Figure 10-9). Each entity decla-ration includes a list of interface signals that can be used to connect to other modules or to the outside world. We will use entity declarations of the form:
entity entity-name is   [port(interface-signal-declaration);]
end [entity] [entity-name];
The items enclosed in square brackets are optional. The interface-signal-declaration normally has the following form:
list-of-interface-signals: mode type [: = initial-value]{; list-of-interface-signals: mode type [: = initial-value]};FIGURE 10-8
VHDL Module with 
Two Gates
© Cengage Learning 2014entity two_gates is
     port (A,B,D: in bit; E: out bit);end two_gates;architecture gates of two_gates is     signal C: bit;begin     C <= A and B; -- concurrent     E <= C or D; -- statementsend gates;A
B
DC
E
FIGURE 10-9
VHDL Program 
Structure
© Cengage Learning 2014...Entity
Architecture
Module 1Entity
Architecture
Module 2Entity
Architecture
Entity
Architecture
Module N
Introduction to VHDL  307
The curly brackets indicate zero or more repetitions of the enclosed clause. Input 
signals are of mode in, output signals are of mode out, and bi-directional signals (see 
Figure 9-16) are of mode inout.
So far, we have only used type bit and bit_vector; other types are described in 
Section 10.4. The optional initial-value is used to initialize the signals on the associ-ated list; otherwise, the default initial value is used for the specified type. For exam-ple, the port declaration
port(A, B: in integer : = 2; C, D: out bit);
indicates that A and B are input signals of type integer that are initially set to 2, and C and D are output signals of type bit that are initialized by default to ‘0’.
Associated with each entity is one or more architecture declarations of the 
form
architecture architecture-name of entity-name is  [declarations]begin  architecture bodyend [architecture] [architecture-name];
In the declarations section, we can declare signals and components that are used within the architecture. The architecture body contains statements that describe the operation of the module.
Next, we will write the entity and architecture for a full adder module (refer to 
Section 4.7 for a description of a full adder). The entity specifies the inputs and out-puts of the adder module, as shown in Figure 10-10. The port declaration specifies that X, Y and Cin are input signals of type bit, and that Cout and Sum are output signals of type bit.
The operation of the full adder is specified by an architecture declaration:
In this example, the architecture name (Equations) is arbitrary, but the entity name (FullAdder) must match the name used in the associated entity declaration. FIGURE 10-10
Entity Declaration 
for a Full Adder 
Module
© Cengage Learning 2014X
Y
CinCout
SumFull
Adderentity FullAdder is
     port (X,Y,Cin: in bit;  -- Inputs  Cout, Sum: out bit);  -- Outputsend FullAdder;
architecture Equations of FullAdder is
begin    -- concurrent assignment statements
Sum <= X xor Y xor Cin after 10 ns;
Cout <= (X and Y) or (X and Cin) or (Y and Cin) after 10 ns;
end Equations;
308 Unit 10
The VHDL assignment statements for Sum and Cout represent the logic equations 
for the full adder. Several other architectural descriptions such as a truth table or an interconnection of gates could have been used instead. In the Cout equation, paren-theses are required around (X and Y) because VHDL does not specify an order of 
precedence for the logic operators.
Four-Bit Full Adder
Next, we will show how to use the FullAdder module defined above as a com-ponent in a system which consists of four full adders connected to form a 4-bit binary adder (see Figure 10-11). We first declare the 4-bit adder as an entity (see Figure 10-12). Because the inputs and the sum output are four bits wide, we declare them as bit_vectors which are dimensioned 3 downto 0. (We could have used a range 
1 to 4 instead.)
Next, we specify the FullAdder as a component within the architecture of Adder4 
(Figure 10-12). The component specification is very similar to the entity declaration for the full adder, and the input and output port signals correspond to those declared for the full adder. Following the component statement, we declare a 3-bit internal carry signal C.
In the body of the architecture, we create several instances of the FullAdder 
component. (In CAD jargon, we instantiate four copies of the FullAdder.) Each copy of FullAdder has a name (such as FA0) and a port map. The signal names following the port map correspond one-to-one with the signals in the component port. Thus, A(0), B(0), and Ci correspond to the inputs X, Y, and Cin, respectively. C(1) and S(0) correspond to the Cout and Sum outputs. Note that the order of the signals in the port map must be the same as the order of the signals in the port of the component declaration.
In preparation for simulation, we can place the entity and architecture for the 
FullAdder and for Adder4 together in one file and compile. Alternatively, we could compile the FullAdder separately and place the resulting code in a library which is linked in when we compile Adder4.
All of the simulation examples in this text use the ModelSim simulator from 
Model Tech. Most other VHDL simulators use similar command files and can FIGURE 10-11
4-Bit Binary Adder
© Cengage Learning 2014
Full
AdderCo
A3B3S3
Full
AdderC3
A2B2S2
Full
AdderC2
A1B1S1
Full
AdderC1
A0B0S0
Ci
Introduction to VHDL  309
produce output in a similar format. We will use the following simulator commands 
to test Adder4:
We have chosen to run the simulation for 50 ns because this is more than enough 
time for the carry to propagate through all of the full adders. The simulation results for the above command list are:
ns delta a b co c ci s
0 +0 0000 0000 0 000 0 0000
0 +1 1111 0001 0 000 1 0000
10 +0 1111 0001 0 001 1 1111
20 +0 1111 0001 0 011 1 1101
30 +0 1111 0001 0 111 1 1001
40 +0 1111 0001 1 111 1 0001
50 +0 0101 1110 1 111 0 0001
60 +0 0101 1110 1 110 0 0101
70 +0 0101 1110 1 100 0 0111
80 +0 0101 1110 1 100 0 0011FIGURE 10-12
Structural 
Description of 4-Bit 
Adder
© Cengage Learning 2014entity Adder4 is
port (A, B: inbit_vector(3 downto 0); Ci: inbit; -- Inputs
S:outbit_vector(3 downto 0); Co: outbit); -- Outputs
endAdder4;
architecture Structure ofAdder4 is
component FullAdder
port (X, Y , Cin: inbit; -- Inputs
Cout, Sum: outbit); -- Outputs
end component ;
signal C: bit_vector(3 downto 1);
begin -- instantiate four copies of the FullAdder
FA0: FullAdder port map (A(0), B(0), Ci, C(1), S(0));
FA1: FullAdder port map (A(1), B(1), C(1), C(2), S(1));
FA2: FullAdder port map (A(2), B(2), C(2), C(3), S(2));
FA3: FullAdder port map (A(3), B(3), C(3), Co, S(3));
end Structure;
add list A B Co C Ci S -- put these signals on the output list
force A 1111 -- set the A inputs to 1111
force B 0001 -- set the B inputs to 0001
force Ci 1 -- set Ci to 1
run 5 0 ns -- run the simulation for 5 0 ns
force Ci 0
force A 0101force B 1110run 5
0 ns
310 Unit 10
The listing shows how the carry propagates one position every 10 ns. The full 
adder inputs change at time = Δ:
The sum and carry are computed by each FA and appear at the FA outputs 10 ns later:
Because the inputs to FA1 have changed, the outputs change 10 ns later:
The final simulation results are:
1111 + 0001 + 1 = 0001 with a carry of 1 (at time = 40 ns) and
0101 + 1110 + 0 = 0011 with a carry of 1 (at time = 80 ns)
The simulation stops at 80 ns because no further changes occur after that time. For 
more details on how the simulator handles Δ delays, refer to Section 10.9.
In this section we have shown how to construct a VHDL module using an entity-
architecture pair. The 4-bit adder module demonstrates the use of VHDL components to write structural VHDL code. Components used within the architecture are declared at the beginning of the architecture, using a component declaration of the form
component component-name  port (list-of-interface-signals-and-their-types);
end component;FA3
100Time = 10
001
11
FA2
101
FA1
101
FA0
111
FA3
100Time = 20
011
11
FA2
101
FA1
100
FA0
111FA3
100Time = Δ
000
10
FA2
100
FA1
100
FA0
110
Introduction to VHDL  311
The port clause used in the component declaration has the same form as the port 
clause used in an entity declaration. The connections to each component used in a circuit are specified by using a component instantiation statement of the form
label: component-name port map (list-of-actual-signals);
The list of actual signals must correspond one-to-one to the list of interface signals specified in the component declaration.
10.4 Signals and Constants
Input and output signals for a module are declared in a port. Signals internal to a module are declared at the start of an architecture, before begin, and can be used only within that architecture. Port signals have an associated mode (usually in or out), but internal signals do not. A signal used within an architecture must be declared either in a port or in the declaration section of an architecture, but it cannot be declared in both places. A signal declaration has the form
signal list_of_signal_names: type_name [constraint] [:= initial_value];
The constraint can be an index range like (0 to 5) or (4 downto 1), or it can be a range 
of values such as range 0 to 7 . Examples:
signal A, B, C: bit_vector(3 downto 0):= “1111”;
A, B, and C are 4-bit vectors dimensioned 3 downto 0 and initialized to 1111.
signal E, F: integer range 0 to 15;
E and F are integers in the range 0 to 15, initialized by default to 0. The compiler or simulator will flag an error if we attempt to assign a value outside the specified range to E or F.
Constants declared at the start of an architecture can be used anywhere within 
that architecture. A constant declaration is similar to a signal declaration:
constant constant_name: type_name [constraint] [:= constant_value];
A constant named limit of type integer with a value of 17 can be defined as
constant limit : integer := 17;
A constant named delay1 of type time with the value of 5 ns can be defined as
constant delay1 : time := 5 ns;
This constant could then be used in an assignment statement
A <= B after delay1;
Once the value of a constant is defined in a declaration statement, unlike a signal, the value cannot be changed by using an assignment statement.
Signals and constants can have any one of the predefined VHDL types, or they 
can have a user-defined type. Some of the predefined types are
312 Unit 10
Note that the integer range for VHDL is symmetrical even though the range for a 
32-bit 2’s complement integer is −231 to+(231 − 1).
A common user-defined type is the enumeration type in which all of the values 
are enumerated. For example, the declarations
type state_type is (S0, S1, S2, S3, S4, S5);signal state : state_type := S1;
define a signal called state which can have any one of the values S0, S1, S2, S3, S4, or S5 and which is initialized to S1. If no initialization is given, the default initialization is the left most element in the enumeration list, S0 in this example. If we declare the signal state as shown, the following assignment statement sets state to S3:
state <= S3;
VHDL is a strongly typed language so signals of different types generally cannot be mixed in the same assignment statement, and no automatic type conversion is per-formed. Thus the statement 
A <= B or C is only valid if A, B, and C all have the same 
type or closely related types.
10.5 Arrays
In order to use an array in VHDL, we must first declare an array type, and then declare an array object. For example, the following declaration defines a one-dimensional array type named SHORT_WORD:
type SHORT_WORD is array (15 downto 0) of bit;
An array of this type has an integer index with a range from 15 downto 0, and each element of the array is of type bit.
Next, we will declare array objects of type SHORT_WORD:
signal DATA_WORD: SHORT_WORD;
signal ALT_WORD: SHORT_WORD := “0101010101010101”;constant ONE_WORD: SHORT_WORD := (others => ‘1’);Definition bit ‘0’ or ‘1’
boolean FALSE or TRUE
integer an integer in the range −(231−1) to + (231−1)
(some implementations support a wider range)
positive an integer in the range 1 to 231−1 (positive integers)
natural an integer in the range 0 to 231−1 (positive integers and zero)
real floating-point number in the range −1.0E38 to + 1.0E38
character any legal VHDL character including upper- and lower case letters, 
digits, and special characters; each printable character must be 
enclosed in single quotes, e.g., ‘d’, ‘7’, ‘+’
time an integer with units fs, ps, ns, us, ms, sec, min, or hr
Introduction to VHDL  313
DATA_WORD is a signal array of 16 bits, indexed 15 downto 0, which is initial-
ized (by default) to all ‘0’ bits. ALT_WORD is a signal array of 16 bits which is ini-
tialized to alternating 0’s and 1’s. ONE_WORD is a constant array of 16 bits; all bits are set to ‘1’ by others => ‘1’
). Because none of the bits have been set individually,1 in 
this case others applies to all of the bits.
We can reference individual elements of the array by specifying an index value. 
For example, ALT_WORD(0) accesses the far right bit of ALT_WORD. We can also specify a portion of the array by specifying an index range: ALT_WORD(5  downto 0) 
accesses the low order six bits of ALT_WORD, which have an initial value of 010101.
The array type and array object declarations illustrated above have the general 
forms:
type array_type_name is array index_range of element_type;signal array_name: array_type_name [ := initial_values ];
In this declaration, signal may be replaced with constant.
Multidimensional array types may also be defined with two or more dimensions. 
The following example defines a two-dimensional array signal which is a matrix of integers with four rows and three columns:
type matrix4x3 is array (1 to 4, 1 to 3) of integer;signal matrixA: matrix4x3 := ((1,2,3),(4,5,6),(7,8,9),(10,11,12));
The signal matrixA, will be initialized to
 1 2 3
 4 5 6
 7 8 9
10 11 12¥
The array element matrixA(3,2) references the element in the third row and second col-
umn, which has a value of 8. The statement 
B <= matrixA (2,3) assigns a value of 6 to B.
When an array type is declared, the dimensions of the array may be left unde-
fined. This is referred to as an unconstrained array type. For example,
type intvec is array (natural range <>) of integer;
declares intvec as an array type which defines a one-dimensional array of integers with an unconstrained index range of natural numbers. The default type for array indices is integer, but another type may be specified. Because the index range is not specified in the unconstrained array type, the range must be specified when the array object is declared. For example,
signal intvec5: intvec(1 to 5) := (3,2,6,8,1);
defines a signal array named intvec5 with an index range of 1 to 5, which is initialized to 3, 2, 6, 8, 1. The following declaration defines matrix as a two-dimensional array with unconstrained row and column index ranges:
type matrix is array (natural range <>, natural range <>) of integer;
1See Reference [1, p. 86] for information on how to set individual bits.
314 Unit 10
Predefined unconstrained array types in VHDL include bit_vector and string, which 
are defined as follows:
type bit_vector is array (natural range <>) of bit;type string is array (positive range <>) of character;
The characters in a string literal must be enclosed in double quotes. For example, 
“This is a string.” is a string literal. The following example declares a constant string1 
of type string:
constant string1: string(1 to 29) := “This string is 29 characters.”
A bit_vector literal may be written either as a list of bits separated by commas 
or as a string. For example, (‘1’,‘0’,‘1’,‘1’,‘0’) and “10110” are equivalent forms. The 
following declares a constant A which is a bit_vector with a range 0 to 5.
constant A : bit_vector(0 to 5) := “101011”;
A truth table can be implemented using a ROM (read-only memory) as illustrated 
in Figure 9-21. If we represent the ROM outputs by a bit_vector, F(0 to 3), we can rep-
resent the truth table that is stored in the ROM by an array of bit_vectors. The VHDL 
code for this ROM is given in Figure 10-13. The port declaration (line 4) defines the inputs and outputs for the ROM. The type declaration (line 7) defines an array with 8 rows where each row is 4 bits wide. Line 8 declares ROM1 to be an array of this type with binary data stored in each row. Line 9 declares an integer called index. This index will be used to select one of the 8 rows in the ROM1 array. In line 11, this index is formed by concatenating the three input bits to form a 3-bit vector, and this vector is converted to an integer. The data is read from the ROM1 array in line 13. For example, if A =‘1’, B =‘0’, and 
C=‘1’, index =5, and “0001” is r ead from the ROM. Lines 1 
and 2 allow us to use the vec2int function, which is defined in a library named BITLIB.
FIGURE 10-13 VHDL Description of a ROM
1 library BITLIB;
2 use BITLIB.bit_pack. all;
3 entity ROM9_17 is 
4 port (A, B, C: inbit; F: outbit_vector(0 to3));
5 end entity;
6 architecture ROM ofROM9_17 is
7 type ROM8X4 is array (0 to7) ofbit_vector(0 to3);
8 constant ROM1: ROM8X4 : (“1010”, “1010”, “0111”, “0101”, “1100”, “0001”, “1111”, “0101”);
9 signal index: Integer range 0 to7;
10 begin
11 index vec2int(A&B&C); -- A&B&C Is a 3-bit vector
12 -- vec2int is a function that converts this vector to an integer13 F
ROM1 (index);
14 -- this statement reads the output from the ROM
15 end ROM;
© Cengage Learning 2014
Introduction to VHDL  315
10.6 VHDL Operators
Predefined VHDL operators can be grouped into seven classes:
1. binary logical operators: and or nand nor xor xnor
2. relational operators: = /=   <   <=    >  >=
3. shift operators: sll srl sla sra rol ror
4. adding operators: +− & (concatenation)
5. unary sign operators: + −
6. multiplying operators: * / mod rem
7. miscellaneous operators: not abs **
When parentheses are not used, operators in class 7 have highest precedence and are 
applied first, followed by class 6, then class 5, etc. Class 1 operators have lowest prece-dence and are applied last. Operators in the same class have the same precedence and are applied from left to right in an expression. The precedence order can be changed by using parentheses. In the following expression, A, B, C, and D are bit_vectors:
not A or B and not C & D
In this expression, not is performed first, then & (concatenation), then or, and finally 
and. The equivalent expression using parentheses is
((not A) or B) and ((not C) &D)
The binary logical operators (class 1) as well as not can be applied to bits, booleans, 
bit_vectors, and boolean_vectors. The class 1 operators require two operands of the same type and size, and the result is of that type and size.
Relational operators (class 2) are used to compare two expressions and return a value 
of FALSE or TRUE. The two expressions must be of the same type and size. Equal
(=) 
and not  equal (/=) apply to any type, but the application of the other relational oper-
ators is more restricted. Note that “ =” is always a relational operator, but “ <=” also 
serves as an assignment operator. Example: If A =5, B =4, and C=3 the expression
(A >= B) and (B <= C) evaluates to FALSE.
Figure 10-14 shows a comparator for two integers with a restricted range. C must 
be of type Boolean since the condition A <= B evaluates to TRUE or FALSE. If 
we implement the comparator in hardware, each integer would be represented by a 
4-bit signal because the range is restricted to 0 to 15. C, D, and E would each be one bit (0 for FALSE or 1 for TRUE).
FIGURE 10-14
Comparator for 
Integers
© Cengage Learning 2014signal A,B: integer range 0 to 15;
signal C, D, E: Boolean;---------------------------------C <= A <= B;D <= A = B;E <= A > B;A
BC
D
EComparator
>
=<=
316 Unit 10
The shift operators are used to shift or rotate a bit_vector. In the following exam-
ples, A is an 8-bit vector equal to “10010101”:
A sll 2 is “01010100” (shift left logical, filled with ‘0’)
A srl 3 is “00010010” (shift right logical, filled with ‘0’)
A sla 3 is “10101111” (shift left arithmetic, filled with rightmost bit)
A sra 2 is “11100101” (shift right arithmetic, filled with leftmost bit)
A rol  3 is “10101100” (rotate left)
A ror  5 is “10101100” (rotate right)
We will not utilize these shift operators because some software used for synthesis 
uses different shift operators. Instead, we will do shifting using the concatenation operator. For example, if A in the above listing is dimensioned 7 downto 0, we can implement shift right arithmetic two places as follows:
A(7)&A(7)&A(7 downto 2) = ‘1’&’1’&“100101” = “11100101”
This makes two copies of the sign bit followed by the left 6 bits of A, which gives the same result as A sra 2.
The 
+ and − operators can be applied to integer or real numeric operands. The 
& operator can be used to concatenate two vectors (or an element and a vector, or two elements) to form a longer vector. For example, “010” & ‘1’ is “0101” and “ABC” & “DEF” is “ABCDEF.”
The * and / operators perform multiplication and division on integer or floating-
point operands. The rem  and mod operators calculate the remainder and  modulus 
for integer operands. (We will not use rem and mod; for further discussion of these operators see Reference [1].) The ** operator raises an integer or floating-point number to an integer power, and abs  finds the absolute value of a numeric 
operand.
10.7 Packages and Libraries
Packages and libraries provide a convenient way of referencing frequently used functions and components. A package consists of a package declaration and an optional package body. The package declaration contains a set of declarations which may be shared by several design units. For example, it may contain type, signal, component, function, and procedure declarations. The package body usually con-tains component descriptions and the function and procedure bodies. The pack-age and its associated compiled VHDL models may be placed in a library, so they can be accessed as required by different VHDL designs. A package declaration has the form:
package package-name is  package declarationsend [package][package-name];
Introduction to VHDL  317
A package body has the form
package body package-name is  package body declarationsend [package body][package name];
We have developed a package called bit_pack which is used in a number of 
examples in this book. This package contains commonly used components and func-
tions which use signals of type bit and bit_vector. A complete listing of this package and associated component models is included on the CD-ROM that accompanies this text. Most of the components in this package have a default delay of 10 ns, but this delay can be changed by the use of generics. For an explanation of generics, refer to one of the VHDL references. We have compiled this package and the component models and placed the result in a library called BITLIB.
One of the components in the library is a two-input NOR gate named Nor2, 
which has default delay of 10 ns. The package declaration for bit_pack includes the component declaration
component Nor2  port (A1, A2: in bit; Z: out bit);
end component;
The NOR gate is modeled using a concurrent statement. The entity-architecture pair for this component is
-- two-input NOR gateentity Nor2 is  port (A1, A2: in bit; Z: out bit);
end Nor2;
architecture concur of Nor2 is
begin  Z <= not(A1 or A2) after 10 ns;
end concur;
To access components and functions within a package requires a library state-
ment and a use statement. The statement
library BITLIB;
allows your design to access the BITLIB. The statement
use BITLIB.bit_pack.all;
allows your design to use the entire bit_pack package. A statement of the form
use BITLIB.bit_pack.Nor2;
may be used if you want to use a specific component (in this case Nor2) or function 
in the package.
When components from a library package are used, component declarations are 
not needed. Figure 10-15 shows a NOR-NOR circuit and the corresponding struc-tural VHDL code. This code instantiates three copies of the Nor2 gate component from the package bit_pack and connects the gate inputs and outputs.
318 Unit 10
10.8 IEEE Standard Logic
Use of two-valued logic (bits and bit vectors) is generally not adequate for simula-
tion of digital systems. In addition to ‘0’ and ‘1’, values of ‘Z’ (high-impedance or no connection) and ‘X’ (unknown) are frequently used in digital system simulation. The IEEE Standard 1164 defines a std_logic type that actually has nine values (‘U’, ‘X’, ‘0’, ‘1’, ‘Z’, ‘W’, ‘L’, ‘H’, and ‘–’). We will only be concerned with the first five values in this text. ‘U’ stands for uninitialized. When a logic circuit is first turned on and before it is reset, the signals will be uninitialized. If these signals are represented by std_logic, they will have a value of ‘U’ until they are changed. Just as a group of bits is represented by a bit_vector, a group of std_logic signals is represented by a std_logic_vector.
Figure 10-16 shows how a tri-state buffer can be represented by a concurrent 
statement. When the buffer is enabled 
(B=‘1’), the output is A, or else it is high 
impedance (‘Z’). A and C could be std_logic_vectors instead of std_logic bits.
Figure 10-17 shows two tri-state buffers with their outputs connected together 
by a tri-state bus. If buffer 1 has an output of ‘1’ and buffer 2 has a hi-Z output, the bus value is ‘1’. When both buffers are enabled, if buffer 1 drives ‘0’ onto the bus and buffer 2 drives ‘1’ onto the bus, the result is a bus conflict. In this case, the bus value is unknown, which we represent by an ‘X’.
In the VHDL code, A, C, and F are std_logic_vectors and F represents the tri-
state bus. The signal F is driven from two different sources. If the two concurrent FIGURE 10-15
NOR-NOR Circuit 
and Structural 
VHDL Code 
Using Library 
Components
© Cengage Learning 2014library BITLIB;
use BITLIB.bit_pack.all;entity nor_nor is     port (A,B,C,D: in bit; G: out bit);end nor_nor;architecture structural of nor_nor issignal E,F,BN,CN: bit;  -- internal signalsbegin     BN <= not B;  CN <= not C;     G1: Nor2 port map (A, BN, E);     G2: Nor2 port map (CN, D, F);     G3: Nor2 port map (E, F, G);end structural;A
B′
C′E
G
F DG1
G2G3
FIGURE 10-16
Tri-State Buffer
© Cengage Learning 2014 ACB
signal A,B,C: std_logic;
-------------------------------C <= A when B = '1' else 'Z';
 FIGURE 10-17
Tri-State Buffers 
Driving a Bus
© Cengage Learning 2014AB
signal A,C,F: std_logic_vector(3 downto 0);signal B,D: std_logic;--------------------------------------------- concurrent statementsF <= A when B = '1' else "ZZZZ";F <= C when D = '1' else "ZZZZ"; 1
CD F
2
Introduction to VHDL  319
statements assign different values to F, VHDL automatically calls a resolution func-
tion to determine the resulting value. This is similar to the way the hardware works—
if the two buffers have different output values, the hardware resolves the values and comes up with an appropriate value on the bus. VHDL uses the table of Figure 10-18 to resolve the bus value when two different std_logic signals, S1 and S2, drive the bus. (Only signal values ‘U’, ‘X’, ‘0’, ‘1’, and ‘Z’ are considered here.) This table is similar to Figure 9-14, which is used for four-valued logic simulation, except for the addition of a row and a column corresponding to ‘U’. When an uninitialized signal is connected to any other signal, VHDL considers that the result is uninitialized.
If A, B, and F are bits (or bit_vectors) and we write the concurrent statements
F <= A; F <= not B;
the compiler will flag an error because no resolution function exists for signals of 
type bit. If A, B, and F are std_logic bits or vectors, the compiler will generate a call to the resolution function and not report an error. If F is assigned conflicting values during simulation, then F will be set to ‘X’ (unknown).
In order to use signals of type std_logic and std_logic_vector in a VHDL module, 
the following declarations must be placed before the entity declaration:
library ieee;use ieee.std_logic_1164.all;
The IEEE std_logic_1164 package defines std_logic and related types, logic opera-tions on these types, and functions for working with these types.
The original IEEE standards for VHDL do not define arithmetic operations on bit_
vectors or on std_logic vectors. Based on these standards, we cannot add, subtract, multi-ply, or divide bit_vectors or std_logic_vectors without first converting them to other types. For example, if A and B are bit_vectors, the expression 
A+B is not allowed.  However, 
VHDL libraries and packages are available that define arithmetic and comparison oper-ations on std_logic_vectors. The operators defined in these packages are referred to as overloaded operators. This means that the compiler will  automatically use the proper definition of the operator depending on its context. For example, when evaluating the expression 
A+B, if A and B are integers, the compiler will use the  integer arithmetic 
routine to do the addition. On the other hand, if A and B are of type std_logic_vector, the compiler will use the addition routine for standard logic vectors. In order to use overloaded operators, the appropriate library and use statements must be included in the VHDL code so that the compiler can locate the definitions of these operators.
In this text, we will use the std_logic_unsigned package, originally developed by 
Synopsys and now widely available. This package treats std_logic_vectors as unsigned FIGURE 10-18
Resolution Function 
for Two Signals
© Cengage Learning 2014S2
S1 UX0 1 Z
UU U U UU
XU X X X X
0U X 0 X 01U X X 1 1ZU X 0 1 Z
320 Unit 10
numbers. The std_logic_unsigned package defines arithmetic operators (+, −, * ) and 
comparison operators (<, <=, =, / =, >, >= ) that operate on std_logic_vectors. For +, 
−, and comparison operators, if the two operands are of different length, the shorter 
operand is filled on the left end with zeros.
These operations can also be applied when the left operand is a std_logic_vector 
and the right operand is an integer. The arithmetic operations return a std_logic_vector, 
and the comparison operations return a Boolean. For example, if A is “10011”, A+7 
returns a value of “11010”, and A >= 5 returns TRUE. In these examples, + and >= 
are overloaded operators, and the compiler automatically calls the appropriate routine to add an integer to a std_logic_vector or to compare an integer with a std_logic_vector.
If A and B are 4-bit std_logic vectors, 
A+B gives their sum as a 4-bit vector, and 
any carry is lost. If the carry is needed, then A must be extended to five-bits before addition. This is accomplished by concatenating a ‘0’ in front of A. Then ‘0’ & 
A+B 
gives a 5-bit sum that can be split into a carry and a 4-bit sum.
Figure 10-19 shows a binary adder and its VHDL representation using the 
std_ logic_ unsigned package. Addout is a 5-bit sum that is split into Sum and Cout. For example, if A =“1011”, B =“1001”, and 
Cin=‘1’, Addout evaluates to “10101”, 
which is then split into a sum “0101” with a carry out of ‘1’.
Figure 10-20 shows how to implement the bi-directional input-output pin and tri-
state buffer of Figure 9-16 using IEEE std_logic. The I/O pin declared in the port is 
 FIGURE 10-19
VHDL Code for 
Binary Adder
© Cengage Learning 2014
4-Bit Adder Cout Cin
ABSumlibrary IEEE;
use IEEE.std_logic_1164.all;use IEEE.std_logic_unsigned.all;--------------------------------------------signal A,B,Sum: std_logic_vector(3 downto 0);signal Addout: std_logic_vector(4 downto 0);signal Cin,Cout: std_logic;------------------------------------Addout <= '0'&A + B + Cin;Sum <= Addout(3 downto 0);Cout <= Addout(4);
FIGURE 10-20
VHDL Code for 
Bi-Directional 
I/O Pin
© Cengage Learning 2014entity IC_pin is
port(IO_pin: inout std_logic);
end entity;
architecture bi_dir ofIC_pin is
component IC
port(input: instd_logic; output: outstd_logic);
end component ;
signal input, output, en: std_logic;
begin -- connections to bi-directional I/O pin
IO_pin output when en ‘1’ else ‘Z’;
input IO_pin;
IC1: IC port map (input, output);
end bi_dir;
Introduction to VHDL  321
of mode inout. The concurrent statements in the architecture connect the IC output 
to the pin via a tri-state buffer and also connect the pin to the IC input.
10.9 Compilation and Simulation of VHDL Code
After describing a digital system in VHDL, simulation of the VHDL code is impor-
tant for two reasons. First, we need to verify the VHDL code correctly implements the intended design, and second, we need to verify that the design meets its speci-fications. Before the VHDL model of a digital system can be simulated, the VHDL code must first be compiled (see Figure 10-21). The VHDL compiler, also called an analyzer, first checks the VHDL source code to see that it conforms to the syntax and semantic rules of VHDL. If there is a syntax error such as a missing semicolon or a semantic error such as trying to add two signals of incompatible types, the com-piler will output an error message. The compiler also checks to see that references to libraries are correct. If the VHDL code conforms to all of the rules, the compiler generates intermediate code which can be used by a simulator or by a synthesizer.
In preparation for simulation, the VHDL intermediate code must be converted 
to a form which can be used by the simulator. This step is referred to as elaboration. 
During elaboration, ports are created for each instance of a component, memory storage is allocated for the required signals, the interconnections among the port signals are specified, and a mechanism is established for executing the VHDL state-ments in the proper sequence. The resulting data structure represents the digital sys-tem being simulated. After an initialization phase, the simulator enters the execution phase. The simulator accepts simulation commands which control the simulation of the digital system and specify the desired simulator output.
Understanding the role of the delta 
(Δ) time delays is important when interpreting 
output from a VHDL simulator. Although the delta delays do not show up on wave-form outputs from the simulator, they show up on listing outputs. The simulator uses delta delays to make sure that signals are processed in the proper sequence. Basically, the simulator works as follows: Whenever a component input changes, the output is scheduled to change after the specified delay or after 
Δ if no delay is specified. When all 
input changes have been processed, the simulated time is advanced to the next time at which an output change is specified. When time is advanced by a finite amount (1
 ns for 
example), the Δ counter is reset, and simulation resumes. Real time does not advance 
again until all Δ delays associated with the current simulation time have been processed.
FIGURE 10-21
Compilation, 
Simulation, and 
Synthesis of VHDL 
Code
© Cengage Learning 2014Compiler Simulator
Synthesizer Implementer HardwareSimulator
OutputVHDL
CodeVHDL
LibrariesSimulator
Commands
Intermediate
Code
322 Unit 10
The following example illustrates how the simulator works for the circuit of 
Figure 10-22. Suppose that A changes at time = 3 ns. Statement 1 executes, and B is 
scheduled to change at time 3 +Δ. Then time advances to 3 +Δ, and statement 2 
executes. C is scheduled to change at time 3 +2Δ. Time advances to 3 +2Δ, and state-
ment 3 executes. D is then scheduled to change at 8 ns. You may think the change 
should occur at (3+2Δ+ 5) ns. However, when time advances a finite amount (as 
opposed to Δ, which is infinitesimal), the Δ counter is reset. For this reason, when 
events are scheduled a finite time in the future, the Δ’s are ignored. Because no further 
changes are scheduled after 8 ns, the simulator goes into an idle mode and waits for 
another input change. The table gives the simulator output listing.
After the VHDL code for a digital system has been simulated to verify that it 
works correctly, the VHDL code can be synthesized to produce a list of required components and their interconnections. The synthesizer output can then be used to implement the digital system using specific hardware such as a CPLD or FPGA. The CAD software used for implementation generates the necessary information to program the CPLD or FPGA hardware. The synthesis and implementation of digital logic from VHDL code is discussed in more detail in Unit 17 .
In this chapter, we have covered the basics of VHDL. We have shown how to use 
VHDL to model combinational logic and how to construct a VHDL module using an entity-architecture pair. Because VHDL is a hardware description language, it differs from an ordinary programming language in several ways. Most importantly, VHDL statements execute concurrently because they must model real hardware in which the components are all in operation at the same time.
Problems
10.1 Write VHDL statements that represent the following circuit:(a) Write a statement for each gate.(b) Write one statement for the whole circuit.FIGURE 10-22
Simulation of 
VHDL Code
© Cengage Learning 20141     B <= not A;
2     C <= not B;3     D <= not C after 5 ns;D
C B A
A′
B
CF
N
GI
D
E′ns delta A B C D
0 +00 1 0 1
3 +01 1 0 1
3 +1 1001
3 +21 0 1 1
8 +01 0 1 0
Introduction to VHDL  323
10.2 Draw the circuit represented by the following VHDL statements:
F <= E and I;
I <= G or H;G <= A and B;
H <= not C and D;
10.3 (a) Implement the following VHDL conditional statement using two 2-to-1 MUXes:
F <= A when D = ‘1’ else B when E = ‘1’ else C;
(b) Implement the same statement using gates.
10.4 Write the VHDL code for Figure 9-6 using a conditional signal assignment state-ment. Use bit_vectors for X, Y, and Z.
10.5 Write a VHDL module that implements a full adder using an array of bit_vectors to represent the truth table.
10.6 (a) Given that A =“00101101” and B =“10011”, determine the value of F:
F <= not B & “0111” or A & ‘1’ and ‘1’& A;
(b) Given A =“11000”, B =“10011”, and 
C=“0111”, evaluate the following 
expression:not A + C * 2 > B / 4 & “00”
10.7 Write a VHDL module that finds the average value of four 16-bit unsigned numbers that are represented by std_logic_vectors. Division by four is best accomplished by shifting. Round off your answer to the nearest integer.
10.8 Write VHDL code for the system shown in Figure 9-15. Use four concurrent state-ments to compute the signal on the tri-state bus.
10.9 (a) Draw the circuit represented by the following VHDL statements:
T1 <= not A and not B and I0;
T2 <= not A and B and I1;
T3 <= A and not B and I2;
T4 <= A and B and I3;
F <= T1 or T2 or T3 or T4;
(b) Draw a MUX that implements F. Then write a selected signal assignment 
statement that describes the MUX.
10.10 Assume that the following are concurrent VHDL statements:
(a) L <= P nand Q after 10 ns;
(b) M <= L nor N after 5 ns;
(c) R <= not M;
Initially at time t =
0 ns, P =1, Q =1, and N =0. If Q becomes 0 at time t =4 ns,
(1) At what time will statement (a) execute?(2) At what time will L be updated?
324 Unit 10
(3) At what time will statement (c) execute?
(4) At what time will R be updated?
10.11 (a)  Write a single concurrent VHDL statement to represent the following circuit. 
Do not use parentheses in the statement.
A
B
DCG
HE F
(b) Write individual statements to represent the circuit of part (a). Assume that all 
NAND gates have a delay of 10 ns, all NOR gates have a delay of 15 ns, and inverters have a delay of 5 ns.
10.12 Draw a circuit that implements the following VHDL code.
V <= T and U;
U <= not R or S and P or not Q or S;T <= not P or Q or R;
10.13 Suppose L, M, and N are of type std_logic. If the following are concurrent state-ments, what are the values of L, M, and N? You can use the resolution function given in Figure 10-18.
L <= ‘1’; L <= ‘0’;
M <= ‘1’ when L = ‘0’ else ‘Z’ when L = ‘1’ else ‘0’;
N <= M when L = ‘0’ else not M;
N <= ‘Z’;
10.14 (a) Given that D =“011001” and E =‘110”, determine the value of F.
F <= not E & “011” or “000100” and not D;
(b) Given A =“101” and B =“011”, evaluate the following expression:
not (A & B) < (not B & A and not A & A)
10.15 Write VHDL code to implement the following logic functions using a 16 words × 
3 bits ROM.
W=A′B′C+C′D+ACD ′
X=A′C′+B′D
Y=BD ′+B′C′D
10.16 The diagram shows an 8-bit-wide data bus that transfers data between a micropro-cessor and memory. Data on this bus is determined by the control signals mRead and mWrite. When mRead =‘1’, the data on the memory’s internal bus ‘membus’ 
is output to the data bus. When mWrite =‘1’, the data on the processor’s internal 
Introduction to VHDL  325
bus ‘probus’ is output to the data bus. When both control signals are ‘0’, the data bus 
must be in a high-impedance state.
I0
I3I2I1A′
B
B′
0
CDF
A
B
F
C
DProcessorData Bus
8-BitMemory
(a) Write VHDL statements to represent the data bus.
(b) Normally mRead =mWrite =‘1’ does not occur. But if it occurs, what value will 
the data bus take?
10.17 (a)  Write a selected signal assignment statement to represent the 4-to-1 MUX 
shown below. Assume that there is an inherent delay in the MUX that causes the change in output to occur 15 ns after a change in input.
(b) Repeat (a) using a conditional signal assignment statement.
10.18 (a) Write a complete VHDL module for a two-input NAND gate with 4-ns delay.
(b) Write a complete VHDL module for the following circuit that uses the NAND 
gate module of part (a) as a component.
10.19 In the following circuit, all gates, including the inverter, have an inertial delay of 10 ns.
(a) Write VHDL code that gives a dataflow description of the circuit. All delays 
should be inertial delays.
(b) Using the Direct VHDL simulator simulate the circuit. (Use a View Interval of 
100 ns.) Initially set A =1, B =1 and 
C=1, then run the simulator for 40 ns. 
Change B to 0, and run the simulator for 40 ns. Record the waveform.
(c) Change the VHDL code of part (a) so that the inverter has a delay of 5 ns.
(d) Repeat part (b).
(e) Change the VHDL code of part (c) so that the output OR gate has a transport 
delay rather than an inertial delay.
(f  ) Repeat part (b).
(g) Explain any differences between the waveforms for parts (b), (d), and (f).
326 Unit 10
10.20 In the following circuit, all gates, including the inverter, have an inertial delay of 
10 ns except for gate 3, which has delay 40 ns.
(a) Write VHDL code that gives a dataflow description of the circuit. All delays 
should be inertial delays.
(b) Using the Direct VHDL simulator simulate the circuit. (Use a View Interval of 
150 ns.) Initially set A =1, B =1, C=1 and D =0, then run the simulator for 
60 ns. Change B to 0, and run the simulator for 60 ns. Record the waveform.
(c) Change the VHDL code of part (a) so that the inverter has a delay of 5 ns.
(d) Repeat part (b).
(e) Change the VHDL code of part (c) so that gates 4 and 5 have a transport delay 
rather than an inertial delay.
(f  ) Repeat part (b).
(g) Explain any differences between the waveforms for parts (b), (d), and (f).
10.21 Write VHDL code that gives a behavioral description of a circuit that converts the representation of decimal digits in BCD to the representation using the 2-4-2-1 weighted code, as follows:A
B
C
Df 5
341
2A
B
Cf
Digit 2421 code
0 0000
1 0001
2 0010
3 0011
4 0100
5 1011
6 1100
7 1101
8 1110
9 1111
Introduction to VHDL  327
For the six input combinations that do not represent valid BCD digits, the circuit 
output should be “XXXX”. Make the inputs and outputs of type std_logic.
(a) Write the code using the when else assignment statement.
(b) Use the VHDL simulator to verify the code of part (a) for the inputs x=0011, 
0100, 1001, and 1010.
(c) Write the code using the with select when assignment statement.
(d) Use the VHDL simulator to verify the code of part (c) for the inputs x=0100, 
0101, 1001, and 1010.
10.22 Write VHDL code that gives a behavioral description of a circuit that converts the representation of decimal digits in the weighted code with weights 8, 4, −2 and −1 to 
the representation using the excess-3 code.
(a) Write the code using the when else assignment statement.
(b) Use the VHDL simulator to verify the code of part (a) for the inputs 
x=0011, 
0100, 1001, and 1010.
(c) Write the code using the with select when assignment statement.
(d) Use the VHDL simulator to verify the code of part (c) for the inputs x=0100, 
0101, 1001, and 1010.
Design Problems
10.A (a)  Design a 4-to-1 MUX using only three 2-to-1 MUXes. Write an entity- architecture 
pair to implement a 2-to-1 MUX. Then write an entity-architecture pair to imple-ment a 4-to-1 MUX using three instances of your 2-to-1 MUX.
(Hint: The equation for a 4-to-1 MUX can be rewritten as
F=A′
(I0B′+I1B)+A(I2B′ +  I3B).)
Use the following port definitions:For the 2-to-1 MUX:
port (i0, i1: in bit; sel: in bit; z: out bit);
For the 4-to-1 MUX:
port (i0, i1, i2, i3: in bit; a, b: in bit; f: out bit);
(b) Simulate your code and test it using the following inputs:
I0=I2=1, I1 =I3=0,
  AB=00,   01,   11,   10
10.B (a)  Show how a BCD to Gray code converter can be designed using a 16 words × 
4 bits ROM. Then write an entity-architecture pair to implement the converter using the ROM. For your code to function correctly, you will need to add the following two lines of code to the top of your program.
library BITLIB;use BITLIB.bit_pack.all;
Use the port definition specified below for the ROM:
port (bcd: in bit_vector (3 downto 0);
gray: out bit_vector (3 downto 0));
328 Unit 10
(b) Simulate your code and test it using the following inputs:
BCD = 0010, 0101, 1001
10.C (a)  A half adder is a circuit that can add two bits at a time to produce a sum and a 
carry. Design a half adder using only two gates. Write an entity-architecture pair 
to implement the half adder. Now write an entity-architecture pair to implement a full adder using two instances of your half adder and an OR gate. Use the port definitions specified below:For the half adder: port (a, b: in bit; s, c: out bit);For the full adder: port (a, b, cin: in bit; sum, cout: out bit);
(b) Simulate your code and test it using the following inputs:
a b cin = 0 0 1, 0 1 1, 1 1 1, 1 1 0, 1 0 0
10.D (a)  Using a 3-to-8 decoder and two four-input OR gates, design a circuit that has 
three inputs and a 2-bit output. The output of the circuit represents (in binary form) the number of 1’s present in the input. For example, when the input is ABC = 101, the output will be Count = 10. Write an entity-architecture pair to 
implement a 3-to-8 decoder. Then write an entity-architecture pair for your cir-cuit, using the decoder as a component. Use the port definitions specified below.For the 3-to-8 decoder:
port (a, b, c: in bit;
    y0, y1, y2, y3, y4, y5, y6, y7: out bit);
For the main circuit: port (a, b, c: in bit; count: out bit_vector (1 downto 0));
(b) Simulate your code and test it using the following inputs:
a b c = 0 0 0, 0 1 0, 1 1 0, 1 1 1, 0 1 1
10.E (a)  Show how a BCD to seven-segment LED code converter can be designed, using 
a 16 words × 7 bits ROM. Then write an entity-architecture pair to implement the converter using the ROM. Use the vec2int function in BITLIB for this prob-lem. Use the port definition specified below for the ROM:
port (bcd: in bit_vector (3 downto 0);
    seven: out bit_vector (6 downto 0));
(b) Simulate your code and test it using the following inputs:
BCD = 0000, 0001, 1000, 1001
10.F (a)  Using a 3-to-8 decoder, two three-input OR gates, and one two-input OR gate, 
design a circuit that has three inputs and a 1 -bit output. The output of the circuit is 1 when the input 3-bit number is less than 3 or is greater than 4. Write an entity-architecture pair to implement a 3-to-8 decoder. Then write an entity-architecture pair for your circuit using the decoder as a component. Use the port definitions specified below.For the 3-to-8 decoder:
port (a, b, c: in bit;
    y0, y1, y2, y3, y4, y5, y6, y7: out bit);
For the main circuit:
port (a, b, c: in bit; output : out bit);
Introduction to VHDL  329
(b) Simulate your code and test it using the following inputs:
a b c = 0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 1 1
10.G (a)  Write the VHDL code for a full subtracter, using logic equations. Assume that 
the full subtracter has a 5-ns delay.
(b) Write the VHDL code for a 4-bit subtracter using the module defined in (a) as 
a component.
(c) Simulate your code and test it using the following inputs:
1100 – 0101, 0110 – 1011
10.H (a)  The diagram shows an 8-bit shifter that shifts its input one place to the left. Write 
a VHDL module for the shifter.
(b) Write a VHDL module that multiplies an 8-bit input (C) by 1012 to give a 11 -bit 
product (D). This can be accomplished by shifting C two places to the left and 
adding the result to C. Use two of the modules written in (a) as components and an overloaded operator for addition.
(c) Simulate your code and test it using the following inputs:
10100101 11111111
10.I (a)  Design a 4-to-2 priority encoder using gates (see Unit 9, Study Guide, Part 4(b)). 
Write a VHDL module for your encoder. Use the port declarationPort (y : in std_logic_vector(0 to  3);
     a1,b1,c1: out std_logic);
(b) Design an 8-to-3 priority encoder (Figure 9-20), using two instances of the 4-to-2 
priority encoder you designed, two 2-to-1 multiplexers, and one OR gate. Write a VHDL module for the 8-to-3 encoder. Use the port declarationPort (y : in std_logic_vector(0 to  7);
     a,b,c,d : out std_logic);
 (Hint: In building the 8-to-3 encoder, use one 4-to-2 encoder for the four most 
significant bits, and the other for the four least significant bits. Outputs b and c of the 8-to-3 encoder should come from the multiplexers.)
(c) Simulate your code and test it using the following inputs:
00000000, 10000000, 11000000, ---, 11111111
10.J (a)  Write a VHDL module for a 4-bit adder, with a carry-in and carry-out, using an 
overloaded addition operator and std_logic_vector inputs and outputs.B (7 down to 0)
A (7 down to 0)Lout Rin
330 Unit 10
(b) Design an 8-bit subtracter with a borrow-out, using two of the 4-bit adders you 
designed in (a), along with any necessary gates or inverters. Write a VHDL 
module for the subtracter.
(c) Simulate your code and test it using the following inputs:
11011011 – 01110110, 01110110 – 11011011
10.K (a)  Write a VHDL module for a tri-state buffer, with 6-bit data inputs and outputs 
and one control input.
(b) Design a 4-to-1 multiplexer with 6-bit data inputs and outputs and two control 
inputs. Use four tri-state buffers from part (a) and a 2-to-4 decoder.
(c) Simulate your code and test it for the following data inputs:
000111, 101010, 111000, 010101
10.L (a)  Write a VHDL module for a ROM with four inputs and three outputs. The 3-bit 
output should be a binary number equal to the number of 1’s in the ROM input.
(b) Write a VHDL module for a circuit that counts the number of 1’s in a 12-bit num-
ber. Use three of the modules from (a) along with overloaded addition operators.
(c) Simulate your code and test it for the following data inputs:
111111111111, 010110101101, 100001011100
10.M (a)  Write a VHDL module for a full subtracter using a ROM to implement the truth 
table.
(b) Write a VHDL module for a 3-bit subtracter using the module defined in 
part (a). Your module should have a borrow-in and a borrow-out.
(c) Simulate your code and test it for the following data:
110 − 010 with a borrow input of 1011 − 101 with a borrow input of 0
10.N (a)  Design a 4-to-2 priority encoder with an enable input, using gates. (See Unit 9, 
Study Guide Part 4(b)). When enable is 0, all outputs are 0. Write a VHDL mod-ule for the encoder. Use the following port declaration:
Port ( y : in std_logic_vector(0 to 3);  enable : in std_logic; a1,b1,c1 : out std_logic);
(b) Design an 8-to-3 priority encoder (Figure 9-20) with an enable input, using two 
of the 4-to-2 priority encoders you designed in (a), three OR gates, an AND gate, and one inverter. Then write a VHDL module for this encoder. Use the port declaration:
Port ( y : in std_logic_vector(0 to 7);  main_enable : in std_logic; a,b,c,d : out std_logic);
(Hint: In building the 8-to-3 encoder, use one 4-to-2 encoder for the four most significant bits, and another for the four least significant bits. Also, outputs b and c of the 8-to-3 encoder should come from OR gates. The enable input to the encoder for the least significant bits depends on the main_enable signal and the c1 output from the encoder for the most significant bits.)
(c) Simulate your code and test it using the following inputs:
00000000, 10000000, 11000000, ---, 11111111
331Latches and Flip-FlopsUNIT
11
Objectives
In this unit you will study one of the basic building blocks used in sequential 
circuits—the flip-flop. Some of the basic analysis techniques used for sequential circuits are introduced here. In particular, you will learn how to construct timing diagrams which show how each signal in the circuit varies as a function of time. Specific objectives are:
1. Explain in words the operation of S-R and gated D latches.
2. Explain in words the operation of D, D-CE, S-R, J-K, and T flip-flops.
3. Make a table and derive the characteristic (next-state) equation for such latches 
and flip-flops. State any necessary restrictions on the input signals.
4. Draw a timing diagram relating the input and output of such latches and  flip-flops.
5. Show how latches and flip-flops can be constructed using gates. Analyze the operation of a flip-flop that is constructed of gates and latches.
332 Unit 11
Study Guide
1. Review Section 8.3, Gate Delays and Timing Diagrams. Then study Section 11.1, 
Introduction.
(a) In the circuit shown, suppose that at some instant of time the inputs to both 
inverters are 0. Is this a stable condition of the circuit?
0 0
Assuming that the output of the left inverter changes before the output of the right inverter, what stable state will the circuit reach? (Indicate 0’s and 1’s on the inverters’ inputs and outputs.)
(b) Work Problem 11.1.
2. Study Section 11.2, Set-Reset Latch.
(a) Build an S-R latch in SimUaid, using NOR gates as in Figure 11 -3. Place 
switches on the inputs and probes on the outputs. Experiment with it. Describe in words the behavior of your S-R latch.
(b) For Figure 11 -4(b), what values would 
P and Q assume if S=R=1?
(c) What restriction is necessary on S and R so that the two outputs of the S-R 
latch are complements?
(d) State in words the meaning of the equation Q+=S+R′Q.
(e) Starting with Q=0 and S=R=1 in Figure 11 -10(a), change S to 0 and 
trace signals through the latch until steady-state is reached. Then, change  
S to 1 and R  to 0 and trace again.
(f  ) Work Problems 11.2 and 11.3.
3. Study Section 11.3, Gated Latches.
(a) Build a gated D  latch in SimUaid. See Figure 11 -14. (Construct the S-R 
latch as in Study Guide Section 2(a).) Place switches on the inputs and probes on the outputs. Experiment with it. Describe in words the behavior of your gated D latch.
(b) State in words the meaning of the equation Q
+=G′Q+GD.
Latches and Flip-Flops  333
(c) Given a gated D latch with the following inputs, sketch the waveform for Q.
(d) Work Problem 11.4.
4. Study Section 11.4, Edge-Triggered D Flip-Flop.
(a) Experiment with a D flip-flop in SimUaid. Use the D flip-flop on the parts 
menu. Place switches on the inputs and probes on the outputs. Describe in 
words the behavior of your D flip-flop.
(b) Given a rising-edge-triggered D flip-flop with the following inputs, sketch 
the waveform for Q .
(c) Work Programmed Exercise 11.35.
(d) A D flip-flop with a falling-edge trigger is behaving erratically. It has a setup 
time of 2 ns and a hold time of 2 ns. The figure shows the inputs to the flip-flop over a typical clock cycle. Why might the flip-flop be behaving erratically?
(e) Suppose that for the circuit of Figure 11 -21, new semiconductor technol-
ogy has allowed us to improve the delays and setup times. The propagation delay of the new inverter is 1.5 ns, and the propagation delay and setup times of the new flip-flop are 3.5 ns and 2 ns, respectively. What is the short-est clock period for the circuit of Figure 11 -21(a) which will not violate the timing constraints?
(f  ) Work Problem 11.5.
5. Study Section 11.5, S-R Flip-Flop.
(a) Describe in words the behavior of an S-R flip-flop.D
G
Q
D
QClock
Clock
D
1 ns
334 Unit 11
(b) Trace signals through the circuit of Figure 11 -23(a) and verify the timing 
diagram of Figure 11 -23(b).
(c) What is the difference between a master-slave flip-flop and an edge-triggered 
flip-flop? Assume that Q changes on the rising clock edge in both cases.
(d) Work Problem 11.6.
6. Study Section 11.6, J-K Flip-Flop.
(a) Experiment with a J-K flip-flop in SimUaid. Use the J-K flip-flop in the parts 
menu. Place switches on the inputs and probes on the outputs. Describe in 
words the behavior of your J-K flip-flop.
(b) Derive the next-state equation for the J-K flip-flop.
(c) Examine Figures 11 -23(a) and 11 -25. Construct a J-K flip-flop, using a 
master-slave S-R flip-flop and two AND gates. (Do not draw the interior of the S-R flip-flop. Just use the symbol in Figure 11 -22.)
(d) Work Problem 11.7 .
7. Study Section 11.7 , T Flip-Flop.
(a) Construct a T flip-flop in SimUaid from a D flip-flop as in Figure 11 -28(b). 
Place switches on the inputs and probes on the outputs. Experiment with it. Describe in words the behavior of the T flip-flop.
(b) Complete the following timing diagram (assume that Q =0 initially):
8. Study Section 11.8, Flip-Flops with Additional Inputs.
(a) To set the flip-flop of Figure 11 -29 to Q=1 without using the clock, 
the ClrN input should be set to ___________ and the PreN input to ___________. To reset this flip-flop to 
Q=0 without using the clock, the Clock
QT
1 2 3 4
Latches and Flip-Flops  335
___________ input should be set to ___________ and the ___________ 
input to ___________.
(b) Complete the following timing diagram for a rising-edge-triggered D 
 flip-flop with ClrN and PreN inputs. Assume Q  begins at 0.
(c) In Figure 11 -31(a), what would happen if En changed from 1 to 0 while 
CLK = 1?What if En changed when CLK = 0?In order to have 
Q change synchronization with the clock, what restriction 
must be placed on the time at which En can change?
Why does this restriction not apply to Figures 11 -31(b) and (c)?
(d) Make a table similar to Figure 11 -29(b) that describes the operation of a D 
flip-flop with a falling-edge clock input, a clock enable input, and an asyn-
chronous active-low clear input (ClrN), but no preset input.
(e) Work Problems 11.8 and 11.9.
9. Study Section 11.10, Summary.
(a) Given one of the flip-flops in this chapter or a similar flip-flop, you should 
be able to derive the characteristic equation which gives the next state of the flip-flop in terms of the present state and inputs. You should understand the meaning of each of the characteristic equations given in Section 11.10.
(b) An S-R flip-flop can be converted to a T flip-flop by adding gates at the 
S 
and R inputs. The S and R  inputs must be chosen so that the flip-flop will 
change state whenever T =1 and the clock is pulsed. In order to determine 
the S and R  inputs, ask yourself the question, “Under what conditions must QPreNClrNDClock
336 Unit 11
the flip-flop be set to 1, and under what conditions must it be reset?” The 
flip-flop must be set to 1 if Q =0 and T =1.
Therefore, S = ___________. In a similar manner, determine the equation 
for R  and draw the circuit which converts an S-R flip-flop to a T flip-flop.
(c) Work Problem 11.10.
10. When you are satisfied that you can meet the objectives of this unit, take the readiness test.
Latches and Flip-Flops
11.1 Introduction
Sequential switching circuits have the property that the output depends not only on the present input but also on the past sequence of inputs. In effect, these circuits must be able to “remember” something about the past history of the inputs in order to produce the present output. Latches and flip-flops are commonly used memory devices in sequential circuits. Basically, latches and flip-flops are memory devices which can assume one of two stable output states and which have one or more inputs that can cause the output state to change. Several common types of latches and flip-flops are described in this unit.
In Units 12 through 16, we will discuss the analysis and design of synchronous 
digital systems. In such systems, it is common practice to synchronize the operation of all flip-flops by a common clock or pulse generator. Each of the flip-flops has a clock input, and the flip-flops can only change state in response to a clock pulse. The use of a clock to synchronize the operation of several flip-flops is illustrated in Units 12 and 13. A memory element that has no clock input is often called a latch, and we will follow this practice. We will then reserve the term flip-flop to describe a memory device that changes its output in response to a clock input and not in response to a data input.
Latches and Flip-Flops  337
The switching circuits that we have studied so far have not had feedback con-
nections. By feedback we mean that the output of one of the gates is connected 
back into the input of another gate in the circuit so as to form a closed loop. In order to construct a switching circuit that has memory, such as a latch or flip-flop, we must introduce feedback into the circuit. For example, in the NOR-gate circuit of Figure 11 -3(a), the output of the second NOR gate is fed back into the input of the first NOR gate. Sequential circuits must contain feedback, but not all circuits with feedback are sequential. There are a few circuits containing feedback that are combinational.
In simple cases, we can analyze circuits with feedback by tracing signals through 
the circuit. For example, consider the circuit in Figure 11 -1(a). If at some instant of time the inverter input is 0, this 0 will propagate through the inverter and cause the output to become 1 after the inverter delay. This 1 is fed back into the input, so after the propagation delay, the inverter output will become 0. When this 0 feeds back into the input, the output will again switch to l, and so forth. The inverter output will continue to oscillate back and forth between 0 and 1, as shown in Figure 11 -1(b), and it will never reach a stable condition. An oscillator can be created using any odd number of inverters. The oscillator waveform has a high and a low time that is the sum of the propagation times of the inverters. For example, with n inverters and with 
all having the same delay, the oscillator waveform high time is 
(n+1)/2 times the 
high-to-low inverter propagation delay plus (n−1)/2 times the low-to-high inverter 
propagation delay.
Next, consider a feedback loop which has two inverters in it, as shown in 
Figure 11 -2(a). In this case, the circuit has two stable conditions, often referred to as stable states. If the input to the first inverter is 0, its output will be 1. Then, the input to the second inverter will be 1, and its output will be 0. This 0 will feed back into the first inverter, but because this input is already 0, no changes will occur. The circuit is then in a stable state. As shown in Figure 11 -2(b), a second stable state of the circuit occurs when the input to the first inverter is 1 and the input to the second inverter is 0. The simple loop of two inverters lacks any external means of initializing the state to one of the stable states. The set-reset latches in the next section have inputs for this initialization.X
X
tFeedback
(a) Inverter with feedback (b) Oscillation at inverter outputFIGURE 11-1
1 00 1
(a)0 11 0
(b)FIGURE 11-2
© Cengage Learning 2014© Cengage Learning 2014
338 Unit 11
11.2 Set-Reset Latch
We can construct a simple latch by introducing feedback into a NOR-gate circuit, 
as seen in Figure 11 -3(a). As indicated, if the inputs are S=R=0, the circuit can 
assume a stable state with Q=0 and P=1. Note that this is a stable condition of the 
circuit because P =1 feeds into the second gate forcing the output to be Q=0, and 
Q=0 feeds into the first gate allowing its output to be 1. Now if we change S to 1, 
P will become 0. This is an unstable condition or state of the circuit because both the 
inputs and output of the second gate are 0; therefore Q will change to 1, leading to 
the stable state shown in Figure 11 -3(b).
If S is changed back to 0, the circuit will not change state because Q =1 feeds 
back into the first gate, causing P to remain 0, as shown in Figure 11 -4(a). Note that 
the inputs are again S=R=0, but the outputs are different than those with which 
we started. Thus, the circuit has two different stable states for a given set of inputs. If we now change R  to 1, 
Q will become 0 and P will then change back to 1, as seen in 
Figure 11 -4(b). If we then change R back to 0, the circuit remains in this state and we 
are back where we started.
This circuit is said to have memory because its output depends not only on the 
present inputs, but also on the past sequence of inputs. If we restrict the inputs so that R=
S=1 is not allowed, the stable states of the outputs P and Q are always 
complements, that is, P =Q′. To emphasize the symmetry between the operation of 
the two gates, the circuit is often drawn in cross-coupled form (see Figure 11 -5(a)). 
As shown in Figures 11 -3(b) and 11 -4(b), an input S=1 sets the output to Q=1, and 
an input R =1 resets the output to Q=0. When used with the restriction that R and 
S cannot be 1 simultaneously, the circuit is commonly referred to as a set-reset (S-R) 
latch and given the symbol shown in Figure 11 -5(b). Note that although Q comes 
out of the NOR gate with the R input, the standard S-R latch symbol has Q directly 
above the S input.SP
1
(a)Q
00R0SP
0
(b)Q
11R0FIGURE 11-3
SP
0
(a)Q
10R0SP
1
(b)Q
00R1FIGURE 11-4
© Cengage Learning 2014© Cengage Learning 2014
Latches and Flip-Flops  339
If S=R=1, the latch will not operate properly, as shown in Figure 11 -6. The 
notation 1 → 0 means that the input is originally 1 and then changes to 0. Note that 
when S and R are both l, P and Q are both 0. Therefore, P is not equal to Q′, and this 
violates a basic rule of latch operation that requires the latch outputs to be comple-
ments. Furthermore, if S and R are simultaneously changed back to 0, P and Q may 
both change to 1. If S=R=0 and P=Q=1, then after the 1’s propagate through 
the gates, P and Q will become 0 again, and the latch may continue to oscillate if the 
gate delays are equal.
Figure 11 -7 shows a timing diagram for the S-R latch. Note that when S changes 
to 1 at time t1, Q changes to 1 a short time ( ε) later. ( ε represents the response time 
or delay time of the latch.) At time t2, when S changes back to 0, Q does not change. 
At time t3, R changes to 1, and Q changes back to 0 a short time ( ε) later. The dura-
tion of the S (or R) input pulse must normally be at least as great as ε in order for a 
change in the state of Q to occur. If S=1 for a time less than ε , the gate output will 
not change and the latch will not change state.
Theoretically, the two-inverter circuit of Figure 11 -2 and the set-reset of 
Figure 11 -3 can exist in a third stable state. This is the situation where the voltage level at the output of the two inverters or gates is approximately halfway between FIGURE 11-7
Timing Diagram 
for S-R Latch
© Cengage Learning 2014RS
Q
t1
t1 + εt2 t3 t4 t
t3 + ε00 1
ε εFIGURE 11-5
S-R Latch
© Cengage Learning 2014Q
RQ′
RQ
S SQ′
L
(a) (b)
FIGURE 11-6
Improper S-R Latch 
Operation
© Cengage Learning 2014S
RP   0 →1→0→1
Q   0 →1→0→11→0
1→0
340 Unit 11
the voltage levels for a logic 0 and a logic 1. This state is referred to as a metastable 
state. It is metastable because any noise existing in the circuit will cause the circuit 
to transition to one of the truly stable states. However, certain events can cause the latch to enter the metastable state for a short time. The simultaneous change in 
S and 
R from 1 to 0 in the set-reset latch can cause the latch to enter the metastable state. 
Also, starting with Q=0 and applying a pulse on S with a length on the borderline 
between being too short to cause Q to change and just long enough to cause Q to 
change may cause the circuit to enter the metastable state.
Even though a circuit in the metastable state will quickly enter a stable state, 
events causing the circuit to enter the metastable state must be avoided. First, the stable state entered from the metastable state is unpredictable. Second, any gates or latches with an input that is in the metastable state will respond unpredictably; the gate or latch may respond as if the input is a logic 0 or it may respond as if the input is a logic 1. Metastable behavior is discussed further in the next sections.
When discussing latches and flip-flops, we use the term present state to denote 
the state of the 
Q output of the latch or flip-flop at the time any input signal changes, 
and the term next state to denote the state of the Q output after the latch or flip-flop 
has reacted to the input change and stabilized. If we let Q(t) represent the present 
state and Q (t+ε) represent the next state, an equation for Q(t+ε) can be obtained 
from the circuit by conceptually breaking the feedback loop at Q and considering 
Q(t) as an input and Q (t+ε) as the output. Then for the S-R latch of Figure 11 -3
 Q(t+ε)=R(t)′[S(t)+Q(t)]=R(t)′S(t)+R(t)′Q(t) (11 -1)
and the equation for output P is
 P(t)=S(t)′Q(t)′ (11 -2)
Normally we write the next-state equation without including time explicitly, using Q 
to represent the present state of the latch and Q+ to represent the next state:
 Q+=R′S+R′Q (11 -3)
 P=S′Q′ (11 -4)
These equations are mapped in the next-state and output tables of Table 11 -1. The stable states of the latch are circled. Note that for all stable states, P=Q′ except 
when 
S=R=1. As discussed previously, this is one of the reasons why S=R=1 is 
disallowed as an input combination to the S-R latch. Making S=R=1 a don’t-care 
combination allows simplifying the next-state equation, as shown in Figure 11 -8(a). After plotting Equation (11 -3) on the map and changing two entries to don’t-cares, the next-state equation simplifies to
 Q
+=S+R′Q    (SR=0) (11 -5)
TABLE 11-1 
S-R Latch Next  
State and OutputPresent 
State
QNext State Q+Present Output P
SR SR SR SR SR SR SR SR
00 01 11 10 00 01 11 10
00 0 0 1 1 1 0 0
11 0 0 1 0 0 0 0© Cengage Learning 2014
Latches and Flip-Flops  341
In words, this equation tells us that the next state of the latch will be 1 either if it 
is set to 1 with an S input, or if the present state is 1 and the latch is not reset. The 
condition SR=0 implies that S and R cannot both be 1 at the same time. An equa-
tion that expresses the next state of a latch in terms of its present state and inputs will be referred to as a next-state equation, or characteristic equation. Note that the 
characteristic equation is not necessarily the same as the next-state equation derived from the circuit. They both give the functional behavior of the latch (or FF). How-ever, the characteristic equation is a minimal equation and it takes into account any disallowed input combinations. The next-state equation derived from the circuit is not necessarily minimal and it does not take into account any disallowed input com-binations. Compare Equations (11 -3) and (11 -5).
Another approach for deriving the characteristic equation for an S-R latch is based 
on constructing a truth table for the next state of Q  We previously discussed the latch 
operation by tracing signals through the gates, and the truth table in Figure 11 -8(b) is based on this discussion. Plotting Q
+ on a Karnaugh map gives the same result as 
Figure 11 -8(a).
The S-R latch is often used as a component in more complex latches and flip-
flops and in asynchronous systems. Another useful application of the S-R latch is for debouncing switches. When a mechanical switch is opened or closed, the switch con-tacts tend to vibrate or bounce open and closed several times before settling down to their final position. This produces a noisy transition, and this noise can interfere with the proper operation of a logic circuit. The input to the switch in Figure 11 -9 is connected to a logic 1 ( +V). The pull-down resistors connected to contacts a and b 
FIGURE 11-9
Switch Debouncing 
with an S-R Latch
© Cengage Learning 2014S
a+V
1b
RQS
R
Q
Switch
at aSwitch
at bBounce
at aBounce
at bSwitch between
a and bFIGURE 11-8
Derivation of Q+ 
for an S-R Latch
© Cengage Learning 20140101
11
0
XX
000RQ
(a) Q++
 mapS
01
1110SRQ Q
000 0
001 1010 0011 0100 1101 1110 –111 –Inputs not
allowed
}
(b) Truth table
342 Unit 11
assure that when the switch is between a and b  the latch inputs S and R  will always 
be at a logic 0, and the latch output will not change state. The timing diagram shows 
what happens when the switch is flipped from a to b. As the switch leaves a, bounces 
occur at the R input; when the switch reaches b, bounces occur at the S input. After 
the switch reaches b , the first time S becomes 1, after a short delay the latch switches 
to the Q=1 state and remains there. Thus Q is free of all bounces even though 
the switch contacts bounce. This debouncing scheme requires a double throw switch 
that switches between two contacts; it will not work with a single throw switch that 
switches between one contact and open.
An alternative form of the S-R latch uses NAND gates, as shown in Figure 11 -10. 
We will refer to this circuit as an S-R latch, and the table describes its operation. We 
have labeled the inputs to this latch S and R  because S=0 will set Q to 1 and R=0 
will reset Q to 0. If S and R are 0 at the same time, both the Q and Q′ outputs are 
forced to 1. Therefore, for the proper operation of this latch, the condition S=R=0 
is not allowed.
11.3 Gated Latches
Gated latches have an additional input called the gate or enable input. When the gate input is inactive, which may be the high or low value, the state of the latch can-not change. When the gate input is active, the latch is controlled by the other inputs and operates as indicated in the preceding section. A NAND-gate version of a gated S-R latch is shown in Figure 11 -11.FIGURE 11-10
S-R Latch
© Cengage Learning 2014S
RQ
Q′S
R
) b ( ) a (S
L
RQ
Q′QQ
110 0
111 1100 0101 0010 1011 1000 –001 –R
S
}
(c)Inputs not
allowed
FIGURE 11-11
NAND-Gate Gated 
S-R Latch
© Cengage Learning 2014S
Q
PG
R
Latches and Flip-Flops  343
The next-state equation is
Q+=SG+Q(R′+G′)
and the equation for the P output is
P=Q′+RG
The next-state and output tables are shown in Table 11 -2. When G=0, the circuit is 
always in a stable state; when G=1, S=1 sets the latch and R=1 resets the latch. 
Note that P =Q′ whenever the latch is in a stable state except for the input com-
bination G=S=R=1; consequently, as for the basic latch, the S=R=1 input 
combination is disallowed.
Another reason for disallowing the S=R=1 input combination is illustrated by 
considering a change in G from 1 to 0 with S=R=1. When G changes, both inputs 
to the basic S-R latch change from 0 to 1, as shown in Figure 11 -12. This causes both 
gates in the basic S-R latch to attempt to change from 1 to 0; a race condition exists and the propagation delays of the gates determine whether the latch stabilizes with Q=0 or Q =1. This was illustrated in Figure 11 -6 for the simple NOR-gate latch.
It is also instructive to examine this problem from a different viewpoint. If the 
equation for Q
+ is plotted on a Karnaugh map (Figure 11 -13), it is evident that Q+ 
has a static 1 -hazard for the input combinations G=1, S=1, R =1, Q =1 and TABLE 11-2  
Next-State and 
Output of Gated 
S-R Latch
FIGURE 11-12
Race Condition in 
the Gated S-R Latch
© Cengage Learning 2014S
Q
PG
R10101
011?
1?
1Next State Q+
Present 
State 
QG = 0 G = 1
SR SR SR SR SR SR SR SR
00 01 11 10 00 01 11 10
0 000000111 11111011
Present Output P
Present 
State  
QG = 0 G = 1
SR SR SR SR SR SR SR SR00 01 11 10 00 01 11 10
0 111111111 00000110© Cengage Learning 2014
344 Unit 11
G=0, S=1, R =1, Q =1. Consequently, when G changes from 1 to 0 between 
these two input combinations, it is possible for Q to change from 1 to 0 and, because 
of the feedback, to cause Q to remain at Q=0. This is simply a different interpreta-
tion of the race condition described above. Of course, the static 1 -hazard exists for G 
changing from 0 to 1 and, again, Q may change to 0, but in this case Q is forced back 
to 1 by the S=R=1 input values. So, for this change, the hazard may cause a glitch 
in Q, but it cannot cause the latch to stabilize with Q=0.
There is another restriction regarding gated S-R latches. The S and R  inputs must 
not be changing or contain glitches while G=1. For example, assume Q=0 when G 
changes from 0 to 1 and S=0 and R =0. If S and R  remain at 0 until G returns to 0, 
then Q remains at 0. However, if S contains a 1 glitch, maybe due to a static 1 -hazard 
in its circuit, then Q may be forced to a 1 and will remain there after G becomes 0. 
A similar problem occurs if S does not change from 1 to 0 until after G changes to 1. 
This is referred to as the 1’s catching problem. A NOR-gate version of the gated S-R 
latch has a 0’s catching problem.
Another gated latch is the gated D latch. It can be obtained from a gated S-R 
latch by connecting S to D and R to D′. Figure 11 -14(a) shows this construction 
using a basic S-R latch, two AND gates and an inverter; the NAND-gate, gated S-R latch in Figure 11 -11 can be converted to a gated D latch with the addition of an inverter. As indicated in Figure 11 -14(b), Q of the gated D latch remains 
unchanged while 
G is inactive, G=0 in this case, and Q becomes equal to the D 
after some delay when G is active. The delay is due to the propagation delay of the 
gates. This latch is also referred to as a transparent latch since Q becomes equal to 
D while G is active. Figure 11 -15 shows the state table and characteristic equation 
for the gated D  latch.FIGURE 11-13
Karnaugh Map 
for Q+
© Cengage Learning 2014SR
GQ 00 01 11 10
00
0111
100
1
010
1
0001
110
1
11
Q+
FIGURE 11-14
Gated D Latch
© Cengage Learning 2014
Q
(a) (b)D
GS
L
RQ
Q′DG 01 0
Latches and Flip-Flops  345
Most digital systems use a clock signal to synchronize the change in outputs of 
the system’s flip-flops to an edge of the clock signal, either the positive (0 to 1) or the 
negative (1 to 0) edge of the clock. It is tempting to think that gated latches could be used as flip-flops where the clock signal is connected to the gate inputs of the latches. However, this is not a practical approach. The following example illustrates the dif-ficulty. In the circuit of Figure 11 -16, it seems that when the Clk is 1 the next value of Q should be Q′ when the input 
x=1 and should be Q when x=0. However, when 
Clk = 1 and x=1, D=Q′ causes Q  to change and, if Clk remains 1, the change in 
Q will feed back and cause Q to change again. If Clk remains at 1, Q will oscillate. 
Consequently, the circuit will only operate as intended if Clk remains at 1 for a short time; it has to 1 just long enough to allow Q to change but short enough to prevent 
the change from feeding back and causing a second change. With a single latch, it may be possible to control the clock high time so the latch operates as intended, but in a system with several latches, the variation in gate delays would make it impos-sible to provide the correct clock width to all latches.
To avoid this timing problem, more complicated flip-flops restrict the flip-flop 
outputs to only change on an edge of the clock, and the outputs cannot change at other times even if the inputs change. If the inputs to the flip-flop only need to be stable for a short period of time around the clock edge, then we refer to the flip-flop as edge-triggered. (See the discussion of setup and hold times in the next sec-tion.) The term master-slave flip-flop refers to a particular implementation that uses 
two gated latches in such a way that the flip-flop outputs only change on a clock edge. However, master-slave flip-flops are not necessarily edge-triggered flip-flops because they may require the flip-flop inputs to be stable at times during the clock period other than just around the clock edge. The S-R, J-K, and T master-slave flip-flops in later sections are examples. The master-slave D flip-flop of the next section is an exception; it uses the master-slave implementation and it is also edge triggered.FIGURE 11-15
Symbol and Truth 
Table for Gated 
Latch
© Cengage Learning 2014D
L
GQ
Q′
Q+ = G′Q + GD001000 01 11 10
11100QGD
1GDQ Q
000 0
001 1010 0011 1100 0101 0110 1111 1
FIGURE 11-16
Unreliable Gated D 
Latch Circuit
© Cengage Learning 2014Gated
D Latch
ClkD
GxQ
346 Unit 11
11.4 Edge-Triggered D Flip-Flop
A D flip-flop (Figure 11 -17) has two inputs, D  (data) and Ck (clock). The small 
arrowhead on the flip-flop symbol identifies the clock input. Unlike the D  latch, the 
flip-flop output changes only in response to the clock, not to a change in D. If the 
output can change in response to a 0 to 1 transition on the clock input, we say that 
the flip-flop is triggered on the rising edge (or positive edge) of the clock. If the out-
put can change in response to a 1 to 0 transition on the clock input, we say that the flip-flop is triggered on the falling edge (or negative edge) of the clock. An inversion 
bubble on the clock input indicates a falling-edge trigger (Figure 11 -17(b)), and no 
bubble indicates a rising-edge trigger (Figure 11 -17(a)). The term active edge refers to 
the clock edge (rising or falling) that triggers the flip-flop state change.
The state of a D flip-flop after the active clock edge ( Q
+) is equal to the input 
(D) before the active edge. For example, if D=1 before the clock pulse, Q=1 
after the active edge, regardless of the previous value of Q. Therefore, the char-
acteristic equation is Q+=D. If D changes at most once following each clock 
pulse, the output of the flip-flop is the same as the D  input, except that the output 
changes are delayed until after the active edge of the clock pulse, as illustrated in Figure 11 -18.
A rising-edge-triggered D flip-flop can be constructed from two gated D latches 
and an inverter, as shown in Figure 11 -19(a). The timing diagram is shown in Figure 11 -19(b). When CLK = 0, G
1=1, and the first latch is transparent so that the P 
output follows the D input. Because G2=0, the second latch holds the current value 
of Q. When CLK changes to 1, G1 changes to 0, and the current value of D is stored FIGURE 11-17
D Flip-Flops
© Cengage Learning 2014Q′ Q
CkDFF
(a) Rising-edge triggerQ′ Q
DFF
(b) Falling-edge triggerCkDQ Q
00 0
01 010 111 1
(c) Truth tableQ+D
FIGURE 11-18
Timing for  
D Flip-Flop  
(Falling-Edge 
Trigger)
© Cengage Learning 2014QCk
1010110
11 00D
Latches and Flip-Flops  347
in the first latch. Because G2=1, the value of P flows through the second latch to 
the Q output. When CLK changes back to 0, the second latch takes on the value of 
P and holds it and, then, the first latch starts following the D input again. If the first 
latch starts following the D input before the second latch takes on the value of P, the 
flip-flop will not function properly. Therefore, the circuit designers must pay careful 
attention to timing issues when designing edge-triggered flip-flops. With this circuit, output state changes occur only following the rising edge of the clock. The value of D at the time of the rising edge of the clock determines the value of 
Q, and any extra 
changes in D that occur between rising clock edges have no effect on Q.
Because a flip-flop changes state only on the active edge of the clock, the propa-
gation delay of a flip-flop is the time between the active edge of the clock and the resulting change in the output. However, there are also timing issues associated with the D input. To function properly, the D input to an edge-triggered flip-flop must 
be held at a constant value for a period of time before and after the active edge of the clock. If D changes at the same time as the active edge, the behavior is unpre-dictable. The amount of time that D must be stable before the active edge is called 
the setup time (t
su), and the amount of time that D must hold the same value after 
the active edge is the hold time ( th). The times at which D is allowed to change dur-
ing the clock cycle are shaded in the timing diagram of Figure 11 -20. The propagation FIGURE 11-19
D Flip-Flop (Rising-
Edge Trigger)
© Cengage Learning 2014DPQ D1
L
(a) Construction from two gated D latchesG1Q1D2
L
G2Q2
CLK
(b) Timing analysisQPDG1CLK = G2
FIGURE 11-20
Setup and Hold 
Times for an  
Edge-Triggered D 
Flip-Flop
© Cengage Learning 2014
QD
CLKtsuth
tp tp
348 Unit 11
delay (tp) from the time the clock changes until the Q output changes is also indi-
cated. For Figure 11 -19(a), the setup time allows a change in D to propagate through 
the first latch before the rising edge of Clock. The hold time is required so that D gets 
stored in the first latch before D changes.
Using these timing parameters, we can determine the minimum clock period 
for a circuit which will not violate the timing constraints. Consider the circuit of 
Figure 11 -21(a). Suppose the inverter has a propagation delay of 2 ns, and suppose the flip-flop has a propagation delay of 5 ns and a setup time of 3 ns. (The hold time does not affect this calculation.) Suppose, as in Figure 11 -21(b), that the clock period is 
9 ns, i.e., 9 ns is the time between successive active edges (rising edges for 
this  figure). Then, 5 ns after a clock edge, the flip-flop output will change, and 2 ns after that, the output of the inverter will change. Therefore, the input to the flip-flop will change 7 ns after the rising edge, which is 2 ns before the next rising edge. But the setup time of the flip-flop requires that the input be stable 3 ns before the rising edge; therefore, the flip-flop may not take on the correct value.
Suppose instead that the clock period were 15 ns, as in Figure 11 -21(c). Again, 
the input to the flip-flop will change 7 ns after the rising edge. However, because the clock is slower, this is 
8 ns before the next rising edge. Therefore, the flip-flop will 
work properly. Note in Figure 11 -21(c) that there is 5 ns of extra time between the time the D input is correct and the time when it must be correct for the setup time to 
be satisfied. Therefore, we can use a shorter clock period, and have less extra time, or no extra time. Figure 11 -21(d) shows that 10 ns is the minimum clock period which will work for this circuit.
FIGURE 11-21
Determination of 
Minimum Clock 
Period
© Cengage Learning 2014
DQCLK
DQ
CLK
(a) Simple flip-flop circuit (b) Setup time not satisfied
(c) Setup time satisfied (d) Minimum clock periodSetup
time 3 ns
Flip-flop
delay 5 ns
Inverter
delay 2 ns
DQCLKSetup
time 3 ns
Extra time
5 ns Flip-flop
delay 5 ns
Inverter
delay 2 ns DQCLKSetup
time 3 ns
Flip-flop
delay 5 ns
Inverter
delay 2 ns
Latches and Flip-Flops  349
11.5 S-R Flip-Flop
An S-R flip-flop (Figure 11 -22) is similar to an S-R latch in that S=1 sets the Q 
output to 1, and R=1 resets the Q output to 0. The essential difference is that the 
flip-flop has a clock input, and the Q  output can change only after an active clock 
edge. The truth table and characteristic equation for the flip-flop are the same as for 
the latch, but the interpretation of Q+ is different. For the latch, Q+ is the value of Q 
after the propagation delay through the latch, while for the flip-flop, Q+ is the value 
that Q  assumes after the active clock edge.
Figure 11 -23(a) shows an S-R flip-flop constructed from two S-R latches and 
gates. This flip-flop changes state after the rising edge of the clock. The circuit is often referred to as a master-slave flip-flop. When CLK = 0, the 
S and R  inputs set 
the outputs of the master latch to the appropriate value while the slave latch holds the previous value of Q. When the clock changes from 0 to 1, the value of 
P is held 
in the master latch and this value is transferred to the slave latch. The master latch holds the value of 
P while CLK = 1, and, hence, Q does not change. When the clock 
changes from 1 to 0, the Q  value is latched in the slave, and the master can process 
FIGURE 11-22
S-R Flip-Flop
© Cengage Learning 2014SQ
RQ ′CkOperation summary:
S R 0 No state change
S 1,R 0 Set Qto 1 (after active Ck edge)
S 0,R 1 Reset Qto 0 (after active Ck edge)
S R 1 Not allowed
FIGURE 11-23
S-R Flip-Flop 
Implementation 
and Timing
© Cengage Learning 2014
(a) Implementation with two latches
(b) Timing analysisS
RS1
Master
R1P
P′S2
Slave
R2Q
Q′Q
CLK
Q′
Q
t1 t2 t3 t4 t5PRSCLK′CLK
350 Unit 11
new inputs. Figure 11 -23(b) shows the timing diagram. Initially, S=1 and Q changes 
to 1 at t1. Then R=1 and Q changes to 0 at t3.
At first glance, this flip-flop appears to operate just like an edge-triggered flip-
flop, but there is a subtle difference. For a rising-edge-triggered flip-flop the value of 
the inputs is sensed at the rising edge of the clock, and the inputs can change while the clock is low. For the master-slave flip-flop, if the inputs change while the clock is low, the flip-flop output may be incorrect. For example, in Figure 11 -23(b) at t
4, S=1 
and R=0, so P changes to 1. Then S changes to 0 at t5, but P does not change, so at t5, 
Q changes to 1 after the rising edge of CLK. However, at t5, S=R=0, so the state of 
Q should not change. We can solve this problem if we only allow the S and R inputs 
to change while the clock is high.
11.6 J-K Flip-Flop
The J-K flip-flop (Figure 11 -24) is an extended version of the S-R flip-flop. The J-K flip-flop has three inputs— J, K, and the clock (CK). The 
J input corresponds to S, 
and K corresponds to R. That is, if J=1 and K=0, the flip-flop output is set to 
Q=1 after the active clock edge; and if K=1 and J=0, the flip-flop output is reset 
to Q=0 after the active edge. Unlike the S-R flip-flop, a 1 input may be applied 
simultaneously to J and K, in which case the flip-flop changes state after the active 
clock edge. When J=K=1, the active edge will cause Q  to change from 0 to 1, or 
FIGURE 11-24
J-K Flip-Flop  
(Q Changes on 
the Rising  
Edge)
© Cengage Learning 2014Q′
′′Q
J KFF
CK
(a) J-K flip-flop
(c) J-K flip-flop timingQKJClock
t1tp tp tp
t2 t3(b) Truth table and characteristic equationJKQ Q
00 0 0
00 1 101 0 001 1 010 0 110 1 111 0 111 1 0
Q+JQ KQ
Latches and Flip-Flops  351
from 1 to 0. The next-state table and characteristic equation for the J-K flip-flop are 
given in Figure 11 -24(b).
Figure 11 -24(c) shows the timing for a J-K flip-flop. This flip-flop changes state a 
short time ( tp) after the rising edge of the clock pulse, provided that J and K have 
appropriate values. If J=1 and K=0 when Clock = 0, Q will be set to 1 following 
the rising edge. If K =1 and J=0 when Clock = 0, Q will be set to 0 after the rising 
edge. Similarly, if J=K=1, Q will change state after the rising edge. Referring to 
Figure 11 -24(c), because Q=0, J=1, and K =0 before the first rising clock edge, 
Q changes to 1 at t1. Because Q=1, J=0, and K=1 before the second rising clock 
edge, Q changes to 0 at t2. Because Q =0, J=1, and K=1 before the third rising 
clock edge, Q  changes to 1 at t3.
One way to realize the J-K flip-flop is with two S-R latches connected in a master-
slave arrangement, as shown in Figure 11 -25. This is the same circuit as for the S-R master-slave flip-flop, except 
S and R have been replaced with J and K, and the Q 
and Q′ outputs are feeding back into the input gates. Because S =J·Q′·CLK′  and 
R=K·Q·CLK′ , only one of S and R inputs to the first latch can be 1 at any given 
time. If Q =0 and J=1, then S=1 and R=0, regardless of the value of K. If Q =1 
and K =1, then S=0 and R =1, regardless of the value of J.
11.7 T Flip-Flop
The T flip-flop, also called the toggle flip-flop, is frequently used in building counters. Most CPLDs and FPGAs can be programmed to implement T flip-flops. The T flip-flop in Figure 11 -26(a) has a 
T input and a clock input. When T =1 the flip-flop changes 
state after the active edge of the clock. When T=0, no state change occurs. The next-
state table and characteristic equation for the T flip-flop are given in Figure 11 -26(b). The characteristic equation states that the next state of the flip-flop ( Q
+) will be 1 iff 
the present state ( Q) is 1 and T =0 or the present state is 0 and T =1.FIGURE 11-25
Master-Slave  
J-K Flip-Flop  
(Q Changes on 
Rising Edge)
© Cengage Learning 2014J
KS1
Master
R1P
P′S2
Slave
R2Q
Q′Q
CLK
Q′
FIGURE 11-26
T Flip-Flop
© Cengage Learning 2014Q′
CkTFF
(a)TQ Q
00 001 110 111 0
Q+TQ  TQ T ⊕ Q
(b)Q
′′
352 Unit 11
Figure 11 -27 shows a timing diagram for the T flip-flop. At times t2 and t4 the T 
input is 1 and the flip-flop state ( Q) changes a short time ( tp) after the falling edge of 
the clock pulse. At times t1 and t3 the T input is 0, and the clock edge does not cause 
a change of state.
One way to implement a T flip-flop is to connect the J and K inputs of a J-K 
flip-flop together, as shown in Figure 11 -28(a). Substituting T for J and K in the J-K 
characteristic equation gives
Q+=JQ ′+K′Q=TQ′ +T′Q
which is the characteristic equation for the T flip-flop. Another way to realize a T 
flip-flop is with a D flip-flop and an exclusive-OR gate (Figure 11 -28(b)). The D input 
is Q ⊕ T, so Q+=Q ⊕ T=TQ′ +T′Q, which is the characteristic equation for the 
T flip-flop.
11.8 Flip-Flops with Additional Inputs
Flip-flops often have additional inputs which can be used to set the flip-flops to an initial state independent of the clock. Figure 11 -29 shows a D flip-flop with clear and preset inputs. The small circles (inversion symbols) on these inputs indicate that a logic 0 (rather than a 1) is required to clear or set the flip-flop. This type of input is often referred to as active-low because a low voltage or logic 0 will activate the clear 
or preset function. We will use the notation ClrN or PreN to indicate active-low clear FIGURE 11-27
Timing Diagram for 
T Flip-Flop (Falling-
Edge Trigger)
© Cengage Learning 2014Q
t2 t1 t3 t4T
tp tpCk
FIGURE 11-28
Implementation 
of T Flip-Flops
© Cengage Learning 2014Q′
TQ
Ck
ClockJ
(a) Conversion of J-K to TKQ′
ClockQ
D
T
(b) Conversion of D to TCk
Latches and Flip-Flops  353
and preset inputs. Thus, a logic 0 applied to ClrN will reset the flip-flop to Q=0, and 
a 0 applied to PreN will set the flip-flop to Q=1. These inputs override the clock and 
D inputs. That is, a 0 applied to the ClrN will reset the flip-flop regardless of the val-
ues of D  and the clock. Under normal operating conditions, a 0 should not be applied 
simultaneously to ClrN and PreN. When ClrN and PreN are both held at logic 1, the 
D and clock inputs operate in the normal manner. ClrN and PreN are often referred 
to as asynchronous clear and preset inputs because their operation does not depend 
on the clock. The table in Figure 11 -29(b) summarizes the flip-flop operation. In the table, ↑ indicates a rising clock edge, and X is a don’t-care. The last row of the table 
indicates that if Ck is held at 0, held at 1, or has a falling edge, 
Q does not change. 
The clear and preset inputs can also be synchronous, i.e., the clear and set operations occur on the active edge of the clock. Often a synchronous clear or preset will over-ride the other synchronous inputs, e.g., a D flip-flop with a synchronous clear input will clear on the active edge of the clock when the clear input is active independent of the value on D.
Figure 11 -30 illustrates the operation of the clear and preset inputs. At t
1, ClrN =  0 
holds the Q output at 0, so the rising edge of the clock is ignored. At t2 and t3, normal 
state changes occur because ClrN and PreN are both 1. Then, Q is set to 1 by PreN = 0, 
but Q is cleared at t4 by the rising edge of the clock because D =0 at that time.
In synchronous digital systems, the flip-flops are usually driven by a common 
clock so that all state changes occur at the same time in response to the same clock edge. When designing such systems, we frequently encounter situations where we want some flip-flops to hold existing data even though the data input to the flip-flops may be changing. One way to do this is to gate the clock, as shown in Figure 11 -31(a). When En = 0, the clock input to the flip-flop is 0, and Q  does not change. This method FIGURE 11-29
D Flip-Flop with 
Clear and Preset
© Cengage Learning 2014QQ
CkClrN PreN
D
(a)Ck DPreN ClrN Q
x x 0 0 (not allowed)
xx 01 1xx 10 0
01 10
11 1 1
0,1,↓↑↑
x1 1 Q(no change)
(b)′
Q
t1 t2 t3 t4PreNClrNDCLKFIGURE 11-30
Timing Diagram 
for D Flip-Flop 
with Asynchronous 
Clear and Preset
© Cengage Learning 2014
354 Unit 11
has two potential problems. First, gate delays may cause the clock to arrive at some 
flip-flops at different times than at other flip-flops, resulting in a loss of synchroniza-tion. Second, if En changes at the wrong time, the flip-flop may trigger due to the change in En instead of due to the change in the clock, again resulting in loss of synchronization. Rather than gating the clock, a better way is to use a flip-flop with a clock enable (CE). Such flip-flops are commonly used in CPLDs and FPGAs.
Figure 11 -31(b) shows a D flip-flop with a clock enable, which we will call a D-CE 
flip-flop. When CE = 0, the clock is disabled and no state change occurs, so Q
+=Q. 
When CE = 1, the flip-flop acts like a normal D flip-flop, so Q+=D. Therefore, the 
characteristic equation is Q+=Q·CE′ +D·CE. The D-CE flip-flop is easily imple-
mented using a D flip-flop and a multiplexer (Figure 11 -31(c)). For this circuit, the MUX output is
Q
+=D=Q·CE′ +Din·CE
Because there is no gate in the clock line, this cannot cause a synchronization problem.
11.9 Asynchronous Sequential Circuits
The signals on the feedback loops in a sequential circuit define the state of the cir-cuit. In asynchronous sequential circuits the state of the circuit can change whenever 
any input changes. The latches discussed in this chapter are asynchronous sequential circuits. In addition, even though the output of a master-slave or edge-triggered flip-flop only changes on an edge of the clock input, the internal circuitry of the flip-flop is an asynchronous circuit. In order for asynchronous circuits to operate in a well-defined manner, they must satisfy several restrictions. Asynchronous circuits are not discussed in detail in this text,
1 but the examples in this section illustrate some of 
these restrictions necessary for correct asynchronous circuit operation.
Consider the circuit in Figure 11 -32(a). It has two feedback loops and, hence, four 
states. To analyze the circuit, break the feedback loops at the outputs of gates 4 and 5. Label the gate outputs P
+ and Q+. The next-state equations are
P+=x′P+xQ
Q+=x′P′+xQ
1 For more details, see M. Morris Mano and Ciletti, Michael D., Digital Design (4th Ed) , (Pearson Prentice 
Hall, 2007).FIGURE 11-31
D Flip-Flop with 
Clock Enable
© Cengage Learning 2014DQ
Q′ Q ′ CkCLK
(a) Gating the clock (b) D-CE symbol (c) ImplementationEnDQ
CEDDinQ
Ck Ck CLKCE0
1
Q′ Q′
Latches and Flip-Flops  355
Note that both equations contain static 1 -hazards. P+ contains a static 1 -hazard for 
xPQ = 111 ↔ 011 .
Figure 11 -32(b) shows the circuit’s next-state table with the stable states circled.
Consider starting the circuit in total stable state xPQ=111 and changing x  to 0. The 
table indicates that the next state is PQ =10 (i.e., P does not change and Q changes to 
0). However, assume the inverter for x has a delay large compared to the gate delays. 
Then, when x changes to 0, the output of Gate 2 changes to 0 causing the outputs of 
both gates 4 and 5 to change to 0. When the x inverter output changes to 1, P=0 
prevents the output of Gate 1 from changing to 1 so P remains 0; however, the output 
of Gate 3 changes to 1 and Q becomes 1. The circuit stabilizes in state PQ =01. This 
incorrect state transition is due to the static 1 -hazard in P+, which causes a 0 glitch in P 
if the x  inverter delay is large and, because of the feedback, P never changes back to 1. 
This problem can be eliminated by designing the circuits to be free of hazards.
Even if the circuit is free of hazards, delays in the “wrong” places in the circuit 
can cause incorrect state transitions. Consider the circuit in Figure 11 -32(a) start-
ing the circuit in total stable state xPQ=010 and changing x to 1; the next-state 
table indicates the next state should be PQ=00. However, if there is a large delay 
in the line labeled d, the circuit will transition to state PQ=11. The 1 to 0 change 
propagating through the x inverter, Gate 1 and Gate 4 will change P to 0. When P 
changes to 0, the lower inverter output changes to 1 and, if line d at Gate 3 is still 1, 
Gate 3 and Gate 5 change to 1. With Q =1, Gate 2 changes to 1 which causes Gate 4 
to change back to 1. Note that this incorrect operation occurs because the x change does not reach a portion of the logic for Q until after the change in P has propagated 
back to the logic for Q. The potential for this incorrect operation can be detected by 
examining the next-state table and determining whether the next state after a single change in an input is different from the next state after three changes in that input. In the preceding example, starting in total stable state 
xPQ = 010 and changing x to 
1 produces next state PQ=00. Changing x back to 0 produces next state PQ=01. 
Finally, changing x a third time to 1, produces next state PQ=11. The table is said to 
contain an essential hazard at total state xPQ=010.
Essential hazards are properties of the next-state table; they cannot be  eliminated 
by modifying the circuit’s logic. To prevent incorrect operation due to essential haz-ards, it is necessary to control the delays in the circuit. In general, it may be neces-sary to insert delays in the feedback loops of the circuit. For the above example, this would require inserting delays at the outputs of Gates 4 and 5. Inserting delays in the feedback loops, assures that input changes propagate through the next state logic before changes in the state variables feedback to the inputs of the logic.FIGURE 11-32
Asynchronous 
Circuit
© Cengage Learning 2014
Qx P
(a)31
24
5d01x
00PQ
01
11
1000
0011
1001
01
11
10
(b)
356 Unit 11
Both of the problems noted above are due to more than one signal in the cir-
cuit changing with the circuit’s response depending on which signal(s) propagate 
through the circuit first. The static hazard causes a glitch if an input change propa-gates over some path in the circuit more quickly than it propagates over another path. For the essential hazard problem the two signals changing are an external input and a state variable. In both cases there is a “race” between two signal changes with the circuit operation depending on which signal wins the race. A similar problem can exist if two (or more) inputs to an asynchronous circuit can change at the same time. Consider the next state table in Figure 11 -33 and consider starting in total state 
xyPQ=1011 and changing both x and y to 0 at the same time. The table indicates 
the next state should be PQ=11. If the y change propagates through the circuit first, 
then the circuit enters total state xyPQ=1011. Then after the x change propagates 
through the circuit, the total state becomes xyPQ=0011. However, if the x change 
propagates through the circuit first, the total state becomes xyPQ=0100. Then, 
after the y change propagates through the circuit, the total becomes xyPQ=0000. 
The final state depends upon which input change propagates fastest and, hence, the final state may not be PQ =11, as indicated by the next-state table.
A similar race problem can occur if more than one state variable changes at 
(approximately) the same time. Consider the next-state table in Figure 11 -34. The total state 
xPQR =0000 has next state PQR =011 when x changes to 1. If Q changes 
first, the circuit will transition to state PQR =010 and then to PQR =011. However, 
if R changes first, the circuit transitions to state PQR =001 and may stabilize there. 
There is a race between the Q and R  changes and, since the circuit can enter two 
different states depending which signal changes first, the race is called a critical race. FIGURE 11-33
Multiple Input 
Change Example
© Cengage Learning 201400 01xy
00PQ
01
11
1000
0011
11
1011 10
00
0011
1001
01
1100
1100
11
FIGURE 11-34
Multiple-State 
Variable Change 
Example
© Cengage Learning 201401x
000PQR
001
011
010
110
111
101
100000 011
101
101
000
101101000
100001
011
011
110
111
110
110
Latches and Flip-Flops  357
There is a race between the P and Q signals when the circuit starts in total state 
xPQR =1011 and x changes to 0. In this case, the circuit will enter state PQR =101 
no matter which state variable changes first, so the race is not critical.
In general, it is not possible to fix the problem with races between state variables 
by inserting delays in the circuit. For correct operation an asynchronous circuit must 
not contain any critical races.
11.10 Summary
In this unit, we have studied several types of latches and flip-flops. Flip-flops have a clock input, and the output changes only in response to a rising or falling edge of the clock. All of these devices have two output states: 
Q=0 and Q=1. For the 
S-R latch, S=1 sets Q to 1, and R =1 resets Q to 0. S=R=1 is not allowed. The 
S-R flip-flop is similar except that Q only changes after the active edge of the clock. 
The gated D latch transmits D to the Q output when G=1. When G is 0, the cur-
rent value of D  is stored in the latch and Q  does not change. For the D flip-flop, Q  is 
set equal to D after the active clock edge. The D-CE flip-flop works the same way, 
except the clock is only enabled when CE = 1. The J-K flip-flop is similar to the S-R flip-flop in that when 
J=1 the active clock edge sets Q to 1, and when K=1, the 
active edge resets Q to 0. When J=K=1, the active clock edge causes Q  to change 
state. The T flip-flop changes state on the active clock edge when T=1; otherwise, Q 
does not change. Flip-flops can have asynchronous clear and preset inputs that cause Q to be cleared to 0 or preset to 1 independently of the clock.
Flip-flops can be constructed using gate circuits with feedback. Analysis of such 
circuits can be accomplished by tracing signal changes through the gates. Analysis can also be done using flow tables and asynchronous sequential circuit theory, but that is beyond the scope of this text. Timing diagrams are helpful in understanding the time relationships between the input and output signals for a latch or flip-flops. In general, the inputs must be applied a specified time before the active clock edge (the setup time), and they must be held constant a specified time after the active edge (the hold time). The time after the active clock edge before Q changes is the 
propagation delay.
The characteristic (next-state) equation for a flip-flop can be derived as follows: 
First, make a truth table that gives the next state ( Q
+) as a function of the present 
state (Q ) and the inputs. Any illegal input combinations should be treated as don’t-
cares. Then, plot a map for Q+ and read the characteristic equation from the map.
The characteristic equations for the latches and flip-flops discussed in this chap-
ter are:
 Q+=S+R′Q (SR= 0)             (S-R latch or flip-flop ) (11 -6)
 Q+=GD +G′Q                          (gated D latch ) (11 -7)
 Q+=D                                           (D flip-flop ) (11 -8)
358 Unit 11
 Q+=D·CE+Q·CE′                    (D-CE flip-flop ) (11 -9)
 Q+=JQ ′+K′Q                           (J-K flip-flop ) (11 -10)
 Q+=T ⊕ Q=TQ′ +T ′Q         (T flip-flop ) (11 -11)
In each case, Q represents an initial or present state of the flip-flop, and Q+ rep-
resents the final or next state. These equations are valid only when the appropriate 
restrictions on the flip-flop inputs are observed. For the S-R flip-flop, S=R=1 is 
forbidden. For the master-slave S-R flip-flop, S and R  should not change during the 
half of the clock cycle preceding the active edge. Setup and hold time restrictions must also be satisfied.
The characteristic equations given above apply to both latches and flip-flops, but 
their interpretation is different for the two cases. For example, for the gated D latch, Q
+ represents the state of the flip-flop a short time after one of the inputs changes. 
However, for the D flip-flop, Q+ represents the state of the flip-flop a short time after 
the active clock edge.
Conversion of one type of flip-flop to another is usually possible by adding exter-
nal gates. Figure 11 -28 shows how a J-K flip-flop and a D flip-flop can be converted to a T flip-flop.
Problems
11.1 Assume that the inverter in the given circuit has a propagation delay of 5 ns and the AND gate has a propagation delay of 10 ns. Draw a timing diagram for the cir-cuit showing 
X, Y, and Z . Assume that X is initially 0, Y is initially 1, after 10 ns X 
becomes 1 for 80 ns, and then X is 0 again.
11.2 A latch can be constructed from an OR gate, an AND gate, and an inverter con-nected as follows:
(a)  What restriction must be placed on R and 
H so that P will always equal Q′ 
(under steady-state conditions)?Y
XZ
R
HQ
P
Latches and Flip-Flops  359
(b)  Construct a next-state table and derive the characteristic (next-state) equation 
for the latch.
(c) Complete the following timing diagram for the latch.
11.3 This problem illustrates the improper operation that can occur if both inputs to an 
S-R latch ar e 1 and are then changed back to 0. For Figure 11 -6, complete the follow-
ing timing chart, assuming that each gate has a propagation delay of exactly 10 ns. Assume that initially P =1 and 
Q=0. Note that when t =100 ns, S  and R  are both 
changed to 0. Then, 10 ns later, both P and Q will change to 1. Because these 1’s are 
fed back to the gate inputs, what will happen after another 10 ns?
11.4 Design a gated D latch using only NAND gates and one inverter.
11.5 What change must be made to Figure 11 -19(a) to implement a falling-edge-triggered D flip-flop? Complete the following timing diagr am for the modified flip-flop.
11.6 A reset-dominant flip-flop behaves like an S-R flip-flop, except that the input 
S=R=1 is allowed, and the flip-flop is reset when S=R=1.
(a) Derive the characteristic equation for a reset-dominant flip-flop.QPG2DClock = G1PQHR
0QPRS
50 100
140150 200 t(ns)
360 Unit 11
(b)  Show how a reset-dominant flip-flop can be constructed by adding gate(s) to an 
S-R flip-flop.
11.7 Complete the following timing diagram for the flip-flop of Figure 11 -24(a).
11.8 Complete the following diagrams for the falling-edge-triggered D-CE flip-flop of 
Figure 11 -31(c). Assume Q begins at 1.
(a)  First draw Q based on your understanding of the behavior of a D flip-flop with 
clock enable.
(b)  Now draw in the internal signal D  from Figure 11 -31(c), and confirm that this 
gives the same Q as in (a).
11.9 (a)  Complete the following timing diagram for a J-K flip-flop with a falling-edge 
trigger and asynchronous ClrN and PreN inputs.QKJClock
DQCEDinClock
QClockKJPreNClrN
Latches and Flip-Flops  361
(b)  Complete the timing diagram for the following circuit. Note that the Ck inputs 
on the two flip-flops are different.
11.10 Convert by adding external gates:
(a) a D flip-flop to a J-K flip-flop.(b) a T flip-flop to a D flip-flop.(c) a T flip-flop to a D flip-flop with clock enable.
11.11 Complete the following timing diagram for an S-R latch. Assume Q  begins at 1.
11.12 Using a truth table similar to Figure 11 -8(b), confirm that each of these circuits is an S-R latch. What happens when 
S=R=1 for each circuit?
11.13 An AB latch operates as follows: If A=0 and B=0, the latch state is Q=0; if either 
A=1 or B =1 (but not both), the latch output does not change; and when both 
A=1 and B =1, the latch state is Q=1.
(a) Construct the state table and derive the characteristic equation for this AB latch.
(b)  Derive a circuit for the AB latch that has four two-input NAND gates and two 
inverters.
(c)  In your circuit of part (b), are there any transitions between input combinations 
that might cause unreliable operation? Verify your answer.Q ′1 Q1
CkCLRClrN
ClockD1Q ′2 Q2
CkCLR
D2
Q2Q1ClockClrN
QRS
S
RQ
Q ′
SRQ
Q ′
(a) (b)00
011001
11
362 Unit 11
(d)  In your circuit of part (b), is there a gate output that provides the signal Q ′? 
Verify your answer.
(e)  Derive a circuit for the AB latch using four two-input NOR gates and two 
inverters.
(f  ) Answer parts (c) and (d) for your circuit of part (e).
11.14 (a) Construct a state table for this circuit and identify the stable states of the circuit.
(b) Derive a Boolean algebra equation for the next value of the output Q  in terms 
of Q , A and B .
(c) Analyze the behavior of the circuit. Is it a useful circuit? If not, explain why not; 
if yes, explain what it does.
11.15 The following circuit is intended to be a gated latch circuit where the signal G is 
the gate.
(a)  Derive the next-state equation for this circuit using Q as the state variable and 
P as an output.
(b)  Construct the state table and output table for the circuit. Circle the stable states 
of the circuit.
(c)  Are there any restrictions on the allowable input combinations on M and N? 
Explain your answer.
(d) Is the output P usable as the complement of Q ? Verify your answer.
(e)  Assume that Gate 1 has a propagation delay of 30 ns and Gates 2, 3, and 4 have 
propagation delays of 10 ns. Construct a timing diagram for the circuit for the following input change: M =N=
Q=0 with G changing from 1 to 0.2-to-1MUXYI1
I0
S
2-to-1
MUXYI1
I0
SQ0
A
1
B
M
N
GPQ1
23
4
Latches and Flip-Flops  363
11.16 Analyze the latch circuit shown.
(a)  Derive the next-state equation for this circuit using Q as the state variable and 
P as an output.
(b)  Construct the state table and output table for the circuit. Circle the stable states 
of the circuit.
(c)  Are there any restrictions on the allowable input combinations on A and B ? 
Explain your answer.
(d) Is the output P usable as the complement of Q ? Verify your answer.
A
B Q
P
RSQGD11.17 Derive the characteristic equations for the following latches and flip-flops in product-of-sums form.(a) S-R latch or flip-flop(b) Gated D latch(c) D flip-flop(d) D-CE flip-flop(e) J-K flip-flop(f  ) T flip-flop
11.18 Complete the following timing diagrams for a gated D latch. Assume 
Q begins at 0.
(a) First draw Q based on your understanding of the behavior of a gated D latch.
(b)  Now draw in the internal signals S and R  from Figure 11 -14, and confirm that 
S and R  give the same value for Q as in (a).
364 Unit 11
11.19 Complete the following diagrams for the rising-edge-triggered D flip-flop of 
Figure 11 -19. Assume Q  begins at 1.
(a) First draw Q based on your understanding of the behavior of a D flip-flop.
(b)  Now draw in the internal signal P from Figure 11 -19, and confirm that P gives the 
same Q as in (a).
11.20 A set-dominant flip-flop is similar to the reset-dominant flip-flop of Problem 11.6 except that the input combination 
S=R=1 sets the flip-flop. Repeat Problem 11.6 
for a set-dominant flip-flop.
11.21 Fill in the timing diagram for a falling-edge-triggered S-R flip-flop. Assume Q 
begins at 0.
11.22 Fill in the timing diagram for a falling-edge-triggered J-K flip-flop.(a) Assume Q begins at 0.
(b) Assume Q begins at 1, but Clock, 
J, and K are the same.PQDClock
QRSClock
QKJClock
Latches and Flip-Flops  365
11.23 (a)  Find the input for a rising-edge-triggered D flip-flop that would produce the 
output Q  as shown. Fill in the timing diagram.
(b) Repeat for a rising-edge-triggered T flip-flop.
11.24 Here is the diagram of a 3-bit ripple counter. Assume Q0=Q1=Q2=0 at t=0, 
and assume each flip-flop has a delay of 1 ns from the clock input to the Q output. 
Fill in Q0, Q1, and Q2 of the timing diagram. Flip-flop Q1, will be triggered when Q0 
changes from 0 to 1.
11.25 Fill in the following timing diagram for a rising-edge-triggered T flip-flop with an 
asychronous active-low PreN input. Assume Q  begins at 1.
11.26 The ClrN and PreN inputs introduced in Section 11.8 are called asynchronous because they oper ate independently of the clock (i.e., they are not synchronized 
with the clock). We can also make flip-flops with synchronous clears or preset inputs. QTPreNClockQ2Q1Q0Clock
5111
10 15 20 25 30 35 40 45 50Q0
T
ClockQ1
TQ2
TTDQClock
366 Unit 11
A D-flip-flop with an active-low synchronous ClrN input may be constructed from a 
regular D flip-flop as follows.
DD
ClrNQ
Clk
Q2Q1DClrNClkFill in the timing diagram. For Q1, assume a synchronous ClrN as above, and for 
Q2, assume an asynchronous ClrN as in Section 11.8. Assume Q1=Q2=0 at the 
beginning.
11.27 (a) Construct a D flip-flop using an inverter and an S-R flip-flop.
(b) If the propagation delay and setup time of the S-R flip-flop in (a) are 2.5 ns and 
1.5 ns, respectively, and if the inverter has a propagation delay of 1 ns, what are the propagation delay and setup time of the D flip-flop of part (a)?
11.28 Redesign the debouncing circuit of Figure 11 -9 using the 
S-R latch of Figure 11 -10.
11.29 (a)  Use the characteristic equation for the gated D latch to implement a two-level, 
NAND-gate circuit for the gated D latch.
(b) What hazards exist in the part (a) circuit for Q+?
(c) Modify the circuit of part (a) to obtain a two-level, NAND gate circuit for Q+ 
that is free of hazards.
(d) Add another output, P, to the circuit of part (a) so that P =Q′ whenever the 
circuit is in a stable state. When the circuit is in an unstable state, the value of P is a don’t care. Use the simplest circuit to obtain 
P. (Note: The circuit for P need 
not be two level.)
11.30 Consider converting the gated S-R latch of Figure 11 -11 into a gated D latch by add-
ing an inverter and making S=D and R =D′.
(a) Derive the next-state equation for Q+ from the circuit.
(b) Does the equation from part (a) contain any hazards? Verify your answer.
(c) Show that the equation from part (a) can be simplified to the characteristic 
equation for the gated D latch.
Latches and Flip-Flops  367
11.31 (a)  Derive a NOR-gate version of the gated S-R latch analogous to Figure 11 -11 
by replacing each NAND gate with a NOR gate. Re-label the inputs so that 
Table 11 -2 is the next-state table for the circuit; carefully indicate whether the inputs are active low or active high.
(b) Derive the next-state equation for Q
+ from the circuit of part (a).
(c) Determine any hazards contained in the next state equation of part (b). ( Hint: It 
may be easiest to write the equation as a product of sums rather than as a sum of products.)
(d) What would be the disadvantage of allowing 
S=1 and R =1 in this circuit? 
Consider the effect on the P output, any race conditions that might result, and the effect of any hazards in the Q
+ equation.
11.32 (a)  Redesign the circuit of Figure 11 -32 so that P+ and Q+ are free of hazards. Use 6 
two-input NAND gates and inverters as needed.
(b) Add two ouputs, U and V , to your circuit of part (a) so that the values on U and 
V count the number of times x has changed (0 to 1 and 1 to 0) modulo 4. ( U and 
V will cycle through the values 00, 01, 10, 11, 00, 01, . . . as x changes.) Assume 
that initially x=0.
11.33 For each of the 8 stable states of Figure 11 -33, consider changing both inputs and
(a) determine the correct next state
(b) the sequence of changes if x changes first, and
(c) the sequence of changes if y changes first
For parts (b) and (c), indicate whether the final state is correct or not and whether there might be a glitch in 
P or Q .
11.34 Label the states in Figure 11 -34 from a=000 to h =100. Determine a new assign-
ment of values of P, Q and R to states a through h so that every transition from a 
stable state is free of races or, else, the race is noncritical. (Retain 000 as the encoding for a.) Identify any noncritical races.
Programmed Exercise 11.35
Cover the bottom part of each page with a sheet of paper and slide it down as you check your answers.
The internal logic diagram of a falling-edge-triggered D flip-flop follows. This 
flip-flop consists of two basic S-R latches with added gates. When the clock input 
(CK) is 1, the value of D is stored in the first S-R latch (P). When the clock changes 
from 1 to 0, the value of P is transferred to the output latch (Q). Thus, the operation 
is similar to that of the master-slave S-R flip-flop shown in Figure 11 -23, except for the edges at which the data is stored.
368 Unit 11
Q
Q ′DPR
SCK
In this exercise you will be asked to analyze the operation of the D flip-flop 
shown above by filling in a table showing the values of CK, D, P, S, R, and Q after 
each change of input. It will be helpful if you mark the changes in these values on the 
circuit diagram as you trace the signals. Initially, assume the following signal values:
CKDP S RQ
0 0 0 0 1 0 (stable)
CK DP S RQ
1. 0 0 0 0 1 0 (stable)
2 . 100010?3.Verify by tracing signals through the circuit that this is a stable condition of the circuit; 
that is, no change will occur in P , S, R, or Q. Now assume that CK is changed to 1:
Trace the change in CK through the circuit to see if a change in P, S, or R  will occur. 
If a change does occur, mark row 2 of the preceding table “unstable” and enter the new values in row 3.
Answer: 2. 1 0 0 0 1 0 (unstable)
3. 1 0 0 0 0 0 (stable)
4. 1 1 0 0 0 0 (unstable)5. 1 1 ?
Verify that row 3 is stable; that is, by tracing signals show that no further change in 
P, S, R, or Q will occur. Next D  is changed to 1 as shown in row 4. Verify that row 4 
is unstable, fill in the new values in row 5, and indicate if row 5 is stable or unstable.
Answer: CK DP S RQ
5. 1 1 1 0 0 0 (stable)
6 . 011000?7. 0 1 ?
8. 0 1
Then CK is changed to 0 (row 6). If row 6 is unstable, indicate the new value of S 
in row 7 . If row 7 is unstable, indicate the new value of Q in row 8. Then determine 
whether row 8 is stable or not.
Latches and Flip-Flops  369
Answer: CK DP S RQ
  7. 0 1 1 1 0 0 (unstable)
  8. 0 1 1 1 0 1 (stable)  9. 0 0 (stable)
10. 1 011. 1 0
Next, D is changed back to 0 (row 9). Fill in the values in row 9 and verify that it is 
stable. CK is changed to 1 in row 10. If row 10 is unstable, fill in row 11 and indicate 
whether it is stable or not.
Answer:   9. 0 0 1 1 0 1 (stable)
10. 1 0 1 1 0 1 (unstable)11. 1 0 0 0 0 1 (stable)12. 0 013. 0 014. 0 0
CK is changed back to 0 in row 12. Complete the rest of the table.
Answer: 12. 0 0 0 0 0 1 (unstable)13. 0 0 0 0 1 1 (unstable)14. 0 0 0 0 1 0 (stable)
Using the previous results, plot P and Q on the following timing diagram. Verify that 
your answer is consistent with the description of the flip-flop operation given in the 
first paragraph of this exercise.
QPDCK2468 1 0 1 2 Row
QPDCK2468 1 0 1 2 Row Answer:
370Registers and CountersUNIT
12
Objectives
1. Explain the operation of registers. Show how to transfer data between registers 
using a tri-state bus.
2. Explain the operation of shift registers, show how to build them using flip-flops, and analyze their operation. Construct a timing diagram for a shift register.
3. Explain the operation of binary counters, show how to build them using flip-flops and gates, and analyze their operation.
4. Given the present state and desired next state of a flip-flop, determine the required flip-flop inputs.
5. Given the desired counting sequence for a counter, derive the flip-flop input equations.
6. Explain the procedures used for deriving flip-flop input equations.
7. Construct a timing diagram for a counter by tracing signals through the circuit.
Registers and Counters  371
Study Guide
1. Study Section 12.1, Registers and Register Transfers.
(a) For the diagram of Figure 12-4, suppose registers A, B, C, and D  hold 
the 8-bit binary numbers representing 91, 70, 249, and 118, respectively.  Suppose 
G and H are both initially 0. What are the contents of G and H 
(decimal equivalent) after the rising edge of the clock:
(1) if EF=10, LdG =0, and LdH =1 at the rising edge?
(2) if EF=01, LdG =0, and LdH =1 at the next rising edge?
(3) if EF=11, LdG =1, and LdH =1 at the next rising edge?
(4) if EF=00, LdG =1, and LdH =0 at the next rising edge?
(5) if EF=10, LdG =0, and LdH =0 at the next rising edge?
(b) Work Problem 12.1.
2. Study Section 12.2, Shift Registers .
(a) Compare the block diagrams for the shift registers of Figure 12-7 and 
12-10. Which one changes state on the rising edge of the clock pulse? The  falling edge?
(b) Complete the following table and timing diagram (see next page) for the 
shift register of Figure 12-8.
Clock 
Cycle 
NumberState of Shift Register 
When CLK = 1
Q7Q6 Q5 Q4 Q3 Q2 Q1Q0
1 0 000000 02
3456789
10111213141516
372 Unit 12
SOSICLK23456789 1 0 1 1 1 2 1 3 1 4 1 5 1 61
(c) Explain in words the function of the MUX on the D input of flip-flop Q3 in 
Figure 12-10(b). Explain in words the meaning of the first of Equation (12-1).
(d) Verify that Equations (12-1) are consistent with Table 12-1.
(e) Work Problem 12.2.
3. Study Section 12.3, Design of Binary Counters, and Section 12.4, Counters for 
Other Sequences.
(a) For Figure 12-14, if CBA =101, which of the T inputs is 1?
(b) Complete the following timing diagram for the binary counter of Figure 12-14. 
The initial value of Clock is 1; this does not count as a rising edge.
(c) Using the results of (b), draw a transition graph for this binary counter 
(similar to Figure 12-22).TATBTCABC 00 00
01 01
10 01Clock
Registers and Counters  373
(d) Complete the following timing diagram for the binary counter of Figure 12-16.
DADBDCABCClock
0000
0011
0101
(e) Use Table 12-4 to verify that the values of TC, TB, and TA in Table 12-2 are 
correct.
(f ) What happens if the circuit of Figure 12-24 is started in one of the don’t-
care states and, then, a clock pulse occurs? In particular, augment the tran-
sition graph of Figure 12-26 to indicate the result for starting in states 101 and 110.
(g) What happens if the circuit of Figure 12-27 is started in one of the don’t-
care states and then a clock pulse occurs? In particular, augment the transi-tion graph of Figure 12-22 to indicate the result for starting in states 001, 101, and 110.
(h) Work Problems 12.3, 12.4, 12.5, 12.6, and 12.7 .
4. Study Section 12.5, Counter Design Using 
S-R   and  J-K Flip-Flops.
(a) Referring to Table 12-5(c):
If Q =Q+=0, explain in words why R is a don’t-care.
If Q =Q+=1, explain in words why S is a don’t-care.
If Q=0 and Q+=1, what value should S have and why?
If Q =1 and Q+=0, what value should R have and why?
374 Unit 12
(b) For Figure 12-30, verify that the RB  and SB maps are consistent with the B+ 
map, and verify that the Rc  and Sc maps are consistent with the C+ map.
(c) In Figure 12-30, where do the gate inputs (C , B, A , etc.) come from?
(d) For Figure 12-30(c), which flip-flop inputs will be 1 if CBA=100? What 
will be the state after the rising clock edge?
(e) Complete the following transition graph by tracing signals in Figure 12-30(c). 
Compare your answer with Figure 12-22. What will happen if the counter is 
in state 110 and a clock pulse occurs?
(f ) Referring to Table 12-7(c):
If Q =Q+=0, explain in words why K is a don’t-care.
If Q =Q+=1, explain in words why J is a don’t-care.
If Q=0 and Q+=1, explain why both JK=10 and JK=11 will produce 
the required state change.
If Q=1 and Q+=0, give two sets of values for J and K which will produce 
the required state change, and explain why your answer is valid.
(g) Verify that the maps of Figure 12-31(b) can be derived from the maps of 
Figure 12-31(a).
(h) Compare the number of logic gates in Figures 12-30 and 12-31. The J-K 
realization requires fewer gates than the S-R realization because the J-K 
maps have more don’t-cares than the S-R maps.
(i) Draw in the implied feedback connections on the circuit of Figure 12-31(c).
 (  j) By tracing signals through the circuit, verify that the state sequence for 
Figure 12-31(c) is correct.000
100
Registers and Counters  375
(k) Find a minimum expression for F1 and for F2. (Hint: No variables are 
required.)
(l) Work Problems 12.8 and 12.9.
5. Study Section 12.6, Derivation of Flip-Flop Input Equations—Summary.
(a) Make sure that you know how to derive input equations for the different 
types of flip-flops. It is important that you understand the procedures for 
deriving the equations; merely memorizing the rules is not sufficient.
(b) Table 12-9 is provided mainly for reference. It is not intended that you 
memorize this table; instead you should understand the reasons for the entries in the table. If you understand the reasons why a given map entry is 0, 1, or X, you should be able to derive the flip-flop input maps without reference to a table.
6. Work the part of Problem 12.10 that you have been assigned. Bring your solu-tion to this problem with you when you come to take the readiness test.F1 F201
00BCA
01
11
10XX
1 X
X 1
XX01
00BCA
01
1110XX
0 X
XXXX
Registers and Counters
A register consists of a group of flip-flops with a common clock input. Registers are 
commonly used to store and shift binary data. Counters are another simple type of sequential circuit. A counter is usually constructed from two or more flip-flops which 
376 Unit 12
change states in a prescribed sequence when input pulses are received. In this unit, 
you will learn procedures for deriving flip-flop input equations for counters. These procedures will be applied to more general types of sequential circuits in later units.
12.1 Registers and Register Transfers
Several D flip-flops may be grouped together with a common clock to form a register (Figure 12-1(a)). Because each flip-flop can store one bit of information, this register can store four bits of information. This register has a load signal that is ANDed with the clock. When Load =0, the register is not clocked, and it holds its present value. 
FIGURE 12-1
4-Bit D Flip-Flop 
Registers with Data, 
Load, Clear, and 
Clock Inputs
© Cengage Learning 2014Q3
D3Clr
(a) Using gated clockData inData out
0→1
1ClrN
Load
Clk
101Q2
D2Clr0→1
Q1
D1Clr0→0
Q0
D0Clr0→1
Q3
D3Clr
(b) With clock enable
(c) SymbolData inData out
0→1
1Load
ClrN
Clk
101Q2
D2Clr0→1
Q1
D1Clr0→0
Q0
D0 CE CE CE CEClr
Q
D CE
Load Clk44
Clr ClrN0→1
Registers and Counters  377
When it is time to load data into the register, Load is set to 1 for one clock period. 
When Load =1, the clock signal (Clk) is transmitted to the flip-flop clock inputs and 
the data applied to the D inputs will be loaded into the flip-flops on the falling edge 
of the clock. For example, if the Q outputs are 0000 (Q3=Q2=Q1=Q0=0) and 
the data inputs are 1101 (D3=1, D2=1, D1=0 and D0=1), after the falling edge 
of the clock Q will change from 0000 to 1101 as indicated. (The notation 0 →1 at the 
flip-flop outputs indicates a change from 0 to 1.)
The flip-flops in the register have asynchronous clear inputs that are connected 
to a common clear signal, ClrN. The bubble at the clear inputs indicates that a logic 0 is required to clear the flip-flops. ClrN is normally 1, and if it is changed momentarily to 0, the Q  outputs of all four flip-flops will become 0.
As discussed in Section 11.8, gating the clock with another signal can cause timing 
problems. If flip-flops with clock enable are available, the register can be designed as shown in Figure 12-1(b). The load signal is connected to all four CE inputs. When Load =0, the clock is disabled and the register holds its data. When Load is 1, the 
clock is enabled, and the data applied to the D inputs will be loaded into the flip-flops, 
following the falling edge of the clock. Figure 12-1(c) shows a symbol for the 4-bit reg-ister using bus notation for the D  inputs and Q  outputs. A group of wires that perform 
a common function is often referred to as a bus. A heavy line is used to represent a bus, and a slash with a number beside it indicates the number of bits in the bus.
Transferring data between registers is a common operation in digital systems. 
Figure 12-2 shows how data can be transferred from the output of one of two regis-ters into a third register using tri-state buffers. If En =1 and Load =1, the output of 
register 
A is enabled onto the tri-state bus and the data in register A will be stored in 
Q after the rising edge of the clock. If En =0 and Load =1, the output of register B 
will be enabled onto the tri-state bus and stored in Q after the rising edge of the clock.
Figure 12-3(a) shows an integrated circuit register that contains eight D flip-flops 
with tri-state buffers at the flip-flop outputs. These buffers are enabled when En =0. 
A symbol for this 8-bit register is shown in Figure 12-3(b).
Figure 12-4 shows how data can be transferred from one of four 8-bit registers into 
one of two other registers. Registers A, B, C, and D are of the type shown in Figure 12-3. FIGURE 12-2
Data Transfer 
Between Registers
© Cengage Learning 2014A1
FF
D1
CEFF
D2Q1
Q2
CE
ClkEn
LoadFFA2
FF
B1
FF
B2
FFRegister
A Register A =
   Flip-flops A1 and A2
Register B =   Flip-flops B
1 and B2
Register Q =   Flip-flops Q
1 and Q2Register
BRegister
QTri-State Bus
378 Unit 12
The outputs from these registers are all connected in parallel to a common tri-state 
bus. Registers G and H are similar to the register of Figure 12-1 except that they have 
eight flip-flops instead of four. The flip-flop inputs of registers G and  H are also con-
nected to the bus. When EnA =0, the tri-state outputs of register A are enabled onto 
the bus. If LdG=1, these signals on the bus are loaded into register G after the rising 
clock edge (or into register H if LdH =1). Similarly, the data in register B, C, or D is 
transferred to G (or H) when EnB, En C, or EnD  is 0, respectively and LdG=1 (or 
LdH =1). If Ld G=LdH =1, both G and H will be loaded from the bus. The four 
enable signals may be generated by a decoder. The operation can be summarized as follows:
If EF=00, A is stored in G (or H).
If EF=01, B is stored in G (or H).
If EF=10, C is stored in G (or H).
If EF=11, D is stored in G (or H).
Note that 8 bits of data are transferred in parallel from register 
A, B, C, or D  to 
register G or H. As an alternative to using a bus with tri-state logic, eight 4-to-1 
 multiplexers could be used, but this would lead to a more complex circuit.
Parallel Adder with Accumulator
In computer circuits, it is frequently desirable to store one number in a register of flip-flops (called an accumulator) and add a second number to it, leaving the result stored in the accumulator. One way to build a parallel adder with an accumulator is to add a register to the adder of Figure 4-2, resulting in the circuit of Figure 12-5. Suppose that the number 
X=xn . . . x2x1 is stored in the accumulator. Then, the number Y= FIGURE 12-4
Data Transfer Using 
a Tri-State Bus
© Cengage Learning 2014
EnABus8
8 8Clock LdGRegister
G
Register
AEnB
E
F8
Register
BEnC8
Register
C
DecoderEnD8
Register
DCE
8Clock LdHRegister
HCEFIGURE 12-3
Logic Diagram for 
8-Bit Register with 
Tri-State Output
© Cengage Learning 2014Q1 Q2 Q7 Q8
D1 D2 D7 D8Q...En
ClkEn
Clk8
8
(a)(b)
Registers and Counters  379
yn . . . y2 y1 is applied to the full adder inputs, and after the carry has propagated through 
the adders, the sum of X and Y appears at the adder outputs. An add signal ( Ad) is used 
to load the adder outputs into the accumulator flip-flops on the rising clock edge. If 
si=1, the next state of flip-flop xi will be 1. If si=0, the next state of flip-flop xi will be 
0. Thus, x+
i   =si, and if Ad=1, the number X in the accumulator is replaced with the 
sum of X and Y, following the rising edge of the clock.
Observe that the adder with accumulator is an iterative structure that consists of 
a number of identical cells. Each cell contains a full adder and an associated accu-
mulator flip-flop. Cell i, which has inputs ci and yi and outputs ci +1 and xi, is referred 
to as a typical cell.
Before addition can take place, the accumulator must be loaded with X. This can 
be accomplished in several ways. The easiest way is to first clear the accumulator using the asynchronous clear inputs on the flip-flops, and then put the 
X data on the 
Y inputs to the adder and add to the accumulator in the normal way. Alternatively, 
we could add multiplexers at the accumulator inputs so that we could select either the 
Y input data or the adder output to load into the accumulator. This would elimi-
nate the extra step of clearing the accumulator but would add to the hardware com-plexity. Figure 12-6 shows a typical cell of the adder where the accumulator  flip-flop FIGURE 12-5 n-Bit Parallel Adder with Accumulator
Q
D CE
Full
AdderQ
D CE
Full
AdderQ
D CE
Full
AdderQ
D CEAccumulator
Register
Full
Adder ...... ...
...xn xi x2 x1
sn si s2 s1xn xi x2 x1Ad
CLK
ClrN
yn yi y2 y1cn ci ci + 1 cn + 1c2 c3 c1 = 0Q ′ Q ′ Q ′ Q ′
FIGURE 12-6
Adder Cell with 
Multiplexer
© Cengage Learning 2014Q
D CECK
CLK
FAxi
ci
yisi
ci + 1Ad
Ld
10© Cengage Learning 2014
380 Unit 12
can either be loaded directly from yi or from the sum output (si). When Ld=1 the 
multiplexer selects yi, and yi is loaded into the accumulator flip-flop (xi) on the rising 
clock edge. When Ad=1 and Ld=0, the adder output ( si) is loaded into xi. The Ad 
and Ld signals are ORed together to enable the clock when either addition or load-
ing occurs. When Ad=Ld=0, the clock is disabled and the accumulator outputs 
do not change.
12.2 Shift Registers
A shift register is a register in which binary data can be stored, and this data can be 
shifted to the left or right when a shift signal is applied. Bits shifted out one end of the register may be lost, or if the shift register is of cyclic type, bits shifted out one end are shifted back in the other end. Figure 12-7(a) illustrates a 4-bit right-shift register with serial input and output constructed from D  flip-flops. When 
Shift=1, 
the clock is enabled and shifting occurs on the rising clock edge. When Shift=0, 
no shifting occurs and the data in the register is unchanged. The serial input (SI) is 
loaded into the first flip-flop (Q3) by the rising edge of the clock. At the same time, 
(a) Flip-flop connections
(b) Timing diagramD3Q3
CED2Q2
CED1Q1
CED0Q0
CESerial in
(SI)
Shift
ClockSerial out
(SO)
Q0Q1Q2Q3SIClockFIGURE 12-7
Right-Shift  
Register
© Cengage Learning 2014
Registers and Counters  381
8-Bit Serial-In, Serial-Out
Shift Register
CLK
SI
(Serial in)SO
(Serial out)SO
(Serial out)SI
(Serial in)
CLK(a) Block diagram
(b) Logic diagramSQQ7 Q0
RQ ′SQ
RQ ′SQRQ ′SQRQ ′SQRQ ′SQRQ ′SQRQ ′SQRQ ′the output of the first flip-flop is loaded into the second flip-flop, the output of the 
second flip-flop is loaded into the third flip-flop, and the output of the third flip-flop is loaded into the last flip-flop. Because of the propagation delay of the flip-flops, the output value loaded into each flip-flop is the value before the rising clock edge. Figure 12-7(b) illustrates the timing when the shift register initially contains 0101 and the serial input sequence is 1, 1, 0, 1. The sequence of shift register states is 0101, 1010, 1101, 0110, 1011.
If we connect the serial output to the serial input, as shown by the dashed line, the 
resulting cyclic shift register performs an end-around shift. If the initial contents of the register is 0111, after one clock cycle the contents is 1011. After a second pulse, the state is 1101, then 1110, and the fourth pulse returns the register to the initial 0111 state.
Shift registers with 4, 8, or more flip-flops are available in integrated circuit form. 
Figure 12-8 illustrates an 8-bit serial-in, serial-out shift register. Serial in means 
that data is shifted into the first flip-flop one bit at a time, and the flip-flops cannot be loaded in parallel. Serial out means that data can only be read out of the last  
flip-flop and the outputs from the other flip-flops are not connected to terminals of the integrated circuit. The inputs to the first flip-flop are 
S=SI and R=SI′. Thus, if 
SI=1, a 1 is shifted into the register when it is clocked, and if SI=0, a 0 is shifted in. 
Figure 12-9 shows a typical timing diagram.
Figure 12-10(a) shows a 4-bit parallel-in, parallel-out shift register. Parallel-in 
implies that all four bits can be loaded at the same time, and parallel-out implies that all bits can be read out at the same time. The shift register has two control inputs, 
FIGURE 12-9
Typical Timing 
Diagram for 
Shift Register of 
Figure 12-8
© Cengage Learning 2014CLK
SOSI23456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 71
7 Clock Periods7 Clock PeriodsFIGURE 12-8
8-Bit Serial-In, 
Serial-Out Shift 
Register
© Cengage Learning 2014
382 Unit 12
shift  enable (Sh) and load enable (L). If Sh=1 (and L =1 or L =0),  clocking 
the register causes the serial input (SI) to be shifted into the first flip-flop, while the 
data in flip-flops Q3, Q2, and Q1 are shifted right. If Sh=0 and L =1, clocking the 
shift register will cause the four data inputs (D3, D2, D1, D0) to be loaded in paral-
lel into the flip-flops. If Sh=L=0, clocking the register causes no change of state. 
Table 12-1 summarizes the operation of this shift register. All state changes occur 
immediately following the falling edge of the clock.
The shift register can be implemented using MUXes and D flip-flops, as shown 
in Figure 12-10(b). For the first flip-flop, when Sh=L=0, the flip-flop Q3 output is 
selected by the MUX, so Q  +
3=Q3 and no state change occurs. When Sh=0 and 
L=1, the data input D3 is selected and loaded into the flip-flop. When Sh=1 and FIGURE 12-10
Parallel-In,  
Parallel-Out  
Right-Shift  
Register
© Cengage Learning 20144-bit Parallel-In,
Parallel-Out
Shift RegisterParallel Output
Parallel Input
(a) Block diagram
(b) Implementation using flip-flops and MUXesSI(Serial In)SO(Serial Out)
Sh(Shift Enable)
L(Load Enable)
CLK
D3D2D1D0Q3Q2Q1Q0
00
01
1011D
D3SI
Sh
L
CLKQ3
D2 D1 D0QQ2 Q1 Q0
0001
1011 DQ0001
1011 DQ0001
1011 DQ
Inputs Next State
Sh (Shift) L (Load) Q3+Q2   +Q1  +Q0  +Action
00 Q3Q2 Q1Q0 No change
01 D3 D2 D1 D0 Load
1X SI Q3 Q2Q1 Right shiftTABLE12-1
Shift Register 
Operation 
© Cengage Learning 2014
Registers and Counters  383
L=0 or 1, SI is selected and loaded into the flip-flop. The second MUX selects 
Q2, D2, or Q3, etc. The next-state equations for the flip-flops are
 Q3+=  Sh′  · L′ · Q3 + Sh′  · L  · D3  + Sh  · SI
Q2+=  Sh′  · L′ · Q2 + Sh′  · L · D2  + Sh  · Q3
Q1+=  Sh′  · L′ · Q1 + Sh′  · L ·  D1  + Sh  · Q2
Q0+=  Sh′  · L′ · Q0 + Sh′  · L · D0  + Sh  · Q1 (12-1)
A typical application of this register is the conversion of parallel data to serial 
data. The output from the last flip-flop (Q0) serves as a serial output as well as one 
of the parallel outputs. Figure 12-11 shows a typical timing diagram. The first clock 
pulse loads data into the shift register in parallel. During the next four clock pulses, this data is available at the serial output. Assuming that the register is initially clear 
(Q3Q2Q1Q0=0000 ), that the serial input is SI=0 throughout, and that the data 
inputs D3D2D1D0 are 1011 during the load time (t0), the resulting waveforms are as 
shown. Shifting occurs at the end of t1, t2, and t3, and the serial output can be read 
during these clock times. During t4, Sh=L=0, so no state change occurs.
Figure 12-12(a) shows a 3-bit shift register with the Q1′ output from the last 
 flip-flop fed back into the D input of the first flip-flop. If the initial state of the reg-
ister is 000, the initial value of D3 is 1, so after the first clock pulse, the register state 
is 100. Successive states are shown on the transition graph of Figure 12-12(b). When 
FIGURE 12-11
Timing Diagram for 
Shift Register
© Cengage Learning 2014
Q0
t0 t1 t2 t3 t4 t5Q1Q2Q3D3, D1, D0Sh(Shift)L(Load)CLK
1000
010010101 (0) 1 0 1 (1)
FIGURE 12-12
Shift Register  
with Inverted 
Feedback
© Cengage Learning 2014000
111011001
110100
101010
D3Q3
Q′3D2Q2 D1Q1
CLK
(a) Flip-flop connections (b) Transition graphQ′2 Q′1
384 Unit 12
the register is in state 001, D3 is 0, and the next register state is 000. Then, successive 
clock pulses take the register around the loop again. Note that states 010 and 101 are 
not in the main loop. If the register is in state 010, then a shift pulse takes it to 101 and vice versa; therefore, we have a secondary loop on the transition graph. 
A circuit that cycles through a fixed sequence of states is called a counter. A 
shift register with inverted feedback (Figure 12-12) is called a Johnson counter or a twisted ring counter. If the feedback is not inverted (e.g., Q
1 connected to D3 in 
Figure 12-12), the shift register counter is called a ring counter.
Figure 12-13 shows the general form of a shift register counter where the bit 
being shifted into the leftmost stage can be a general function of the shift register contents. If the gate logic only contains exclusive-OR gates, the counter is called a linear (feedback) shift register counter. It can be shown that, for each integer n, 
there exists a linear n-bit shift register counter that generates a count cycle of length 
2
n−1; all states are included except for the all 0’s state. For many values of n only a 
small number of exclusive-OR gates is required. Linear shift register counters have many applications, including as random number generators and as encoders and decoders for linear error-correcting codes.
12.3 Design of Binary Counters
The counters discussed in this chapter are all synchronous counters. This means the operation of the flip-flops is synchronized by a common clock pulse so that when several flip-flops must change state, the state changes occur simultaneously. Ripple counters, in which the state change of one flip-flop triggers another flip-flop, are not discussed in detail. See Problems 11.24 and 12.19 for examples.
We will first construct a binary counter using three T flip-flops to count clock 
pulses (Figure 12-14). We will assume that all the flip-flops change state a short time following the rising edge of the input pulse. The state of the counter is determined by the states of the individual flip-flops; for example, if flip-flop 
C is in state 0, B  
in state 1, and A in state 1, the state of the counter is 011. Initially, assume that all 
 flip-flops are set to the 0 state. When a clock pulse is received, the counter will change to state 001; when a second pulse is received, the state will change to 010, etc. The sequence of flip-flop states is CBA =000, 001, 010, 011, 100, 101, 110, 111, 000, . . . 
Note that when the counter reaches state 111, the next pulse resets it to the 000 state, and then the sequence repeats.
First, we will design the counter by inspection of the counting sequence; then, we 
will use a systematic procedure which can be generalized to other types of counters. The problem is to determine the flip-flop inputs— T
C, TB, and TA. From the preceding 
counting sequence, observe that A changes state every time a clock pulse is received. FIGURE 12-13
General Shift 
Register Counter
© Cengage Learning 2014Clk
Gate LogicN-Bit Shift Register SI
N
Registers and Counters  385
Because A changes state on every rising clock edge, TA must equal 1. Next, observe 
that B changes state only if A=1. Therefore, A is connected to TB as shown, so that 
if A=1, B will change state when a rising clock edge occurs. Similarly, C changes 
state when a rising clock edge occurs only if B and A are both 1. Therefore, an AND 
gate is connected to TC so that C will change state if B =1 and A=1 when a rising 
clock edge occurs.
Now, we will verify that the circuit of Figure 12-14 counts properly by tracing 
signals through the circuit. Initially, CBA=000, so only TA is 1 and the state will 
change to 001 when the first active clock edge arrives. Then, TB=TA=1, and the 
state will change to 010 when the second active clock arrives. This process continues 
until finally when state 111 is reached, TC=TB=TA=1, and all flip-flops return to 
the 0 state.
Next, we will redesign the binary counter by using a transition table (Table 12-2). 
This table shows the present state of flip-flops C, B, and A (before a clock pulse is 
received) and the corresponding next state (after the clock pulse is received). For example, if the flip-flops are in state 
CBA=011 and a clock pulse is received, the 
next state will be C+B+A+=100. Although the clock is not explicit in the table, 
it is understood to be the input that causes the counter to go to the next state in sequence. A third column in the table is used to derive the inputs for T
C, TB, and TA. 
Whenever the entries in the A and A+ columns differ, flip-flop A must change state 
and TA must be 1. Similarly, if B and B+ differ, B must change state so TB must be 1. 
For example, if CBA =011, C+B+A+=100, all three flip-flops must change state, so 
TCTBTA=111.FIGURE 12-14
Synchronous  
Binary Counter
© Cengage Learning 2014C C ′
TCB B ′
TBA A ′
TA
1
Clock
Present State Next State Flip-Flop Inputs
CBA C   +B   +A   +TCTBTA
000 001 001
001 010 011010 011 001011 100 111100 101 001101 110 011110 111 001111 000 111TABLE12-2
Transition Table for 
Binary Counter 
© Cengage Learning 2014
386 Unit 12
TC, TB, and TA are now derived from the table as functions of C, B, and A. By 
inspection, TA=1. Figure 12-15 shows the Karnaugh maps for TC and TB, from 
which TC=BA and TB=A. These equations yield the same circuit derived previ-
ously for Figure 12-14.
Next, we will redesign the binary counter to use D flip-flops instead of T flip-flops. 
The easiest way to do this is to convert each D flip-flop to a T flip-flop by adding 
an XOR (exclusive-OR) gate, as shown in Figure 11 -28(b). Figure 12-16 shows the resulting counter circuit. The rightmost XOR gate can be replaced with an inverter because 
A ⊕ 1=A′.
FIGURE 12-15
Karnaugh Maps  
for Binary Counter
© Cengage Learning 2014
TC TB01
00BAC
01
11
1000
00
110001
00BAC
01
111000
11
1100
FIGURE 12-16
Binary Counter 
with D Flip-Flops
© Cengage Learning 2014C C ′
D
Clock1B B ′
DA A ′
D
We can also derive the D flip-flop inputs for the binary counter starting with its 
transition table (Table 12-2). For a D flip-flop, Q+=D. By inspection of the table, 
QA+=A′, so DA=A′. The maps for Q+
B and Q+
C are plotted in Figure 12-17 . The 
D input equations derived from the maps are
 DA=A+=A′
DB=B+=BA ′+B′A=B ⊕ A
DC=C+=C′BA+CB′ +CA ′=C′BA+C(BA)′=C ⊕ BA (12-2)
which give the same logic circuit as was obtained by inspection.
Registers and Counters  387
FIGURE 12-18
Transition Graph 
and Table for 
Up-Down  
Counter
© Cengage Learning 2014000
111
110
101
100011010001U
D
DD
DD
D DDU
UU
UU
U UC+B+A+
CBA U D
000 001 111
001 010 000010 011 001011 100 010100 101 011101 110 100110 111 101111 000 110FIGURE 12-17
Karnaugh Maps  
for D Flip-Flops
© Cengage Learning 2014
DC DA DB01
00BAC
01
11
1001
01
100101
00BAC
01
111000
11
001101
00BAC
01
111011
00
0011
The up-down counter can be implemented using D flip-flops and gates, as shown in 
Figure 12-19. The corresponding logic equations are
DA=A+=A ⊕ (U+D)
DB=B+=B ⊕ (UA+DA ′)
DC=C+=C ⊕ (UBA +DB ′A′)
When U=1 and D =0, these equations reduce to equations for a binary up counter 
(Equation (12-2)).
When U=0 and D =1, these equations reduce to
DA=A+=A ⊕ 1=A′   (A changes state every clock cycle)
DB=B+=B ⊕ A′   (B changes state when A  =  0)
DC=C+=C ⊕ B′A′   (C changes state when B  =  A  =  0)Next, we will analyze an up-down binary counter. The transition graph and table 
for an up-down counter are shown in Figure 12-18. When U=1, the counter counts 
up in the sequence 000, 001, 010, 011, 100, 101, 110, 111, 000 . . . When D=1, the 
counter counts down in the sequence 000, 111, 110, 101, 100, 011, 010, 001, 000 . . . When 
U=D=0, the counter state does not change, and U=D=1 is not allowed.
388 Unit 12
FIGURE 12-19
Binary Up-Down 
Counter
© Cengage Learning 2014C C ′
Clock Clock Clock
DU
DD U UDB B ′
DA A ′
D
FIGURE 12-20
Loadable Counter 
with Count Enable
© Cengage Learning 2014
(a)Q
D
Clk33
ClrNCt
LdClrN Ld Ct B+C+A+
0X X 0 0 0
11 X DCDBDA (load)
10 0 CBA (no change)
1 0 1 Present state 1
(b)+By inspection of the table in Figure 12-18, we can verify that these are the correct 
equations for a down counter. For every row of the table, A+=A′, so A changes 
state every clock cycle. For those rows where A=0, B+=B′. For those rows where 
B=0 and A=0, C+=C′.
Next, we will design a loadable counter (Figure 12-20(a)). This counter has two 
control signals Ld (load) and Ct (count). When Ld=1 binary data is loaded into the 
counter on the rising clock edge, and when Ct=1, the counter is incremented on 
the rising clock edge. When Ld=Ct=0, the counter holds its present state. When 
Ld=Ct=1, load overrides count, and data is loaded into the counter. The coun-
ter also has an asynchronous clear input that clears the counter when ClrN is 0. Figure 12-20(b) summarizes the counter operation. All state changes occur on the rising edge of the clock (except for the asynchronous clear).
Figure 12-21 shows how the loadable counter can be implemented using flip-flops, 
MUXes, and gates. When Ld=1, each MUX selects a D
i input, and because the out-
put of each AND gate is 0, the output of each XOR gate is Di, which gets stored in 
a flip-flop. When Ld =0 and Ct=1, each MUX selects one of the flip-flop outputs 
(C, B, or A). The circuit then becomes equivalent to Figure 12-16, and the counter is 
incremented on the rising clock edge.
Registers and Counters  389
The next-state equations for the counter of Figure 12-21 are
A+=DA=(Ld′·A+Ld  ·DAin) ⊕ Ld′·Ct
B+=DB=(Ld′·B+Ld  ·DBin) ⊕ Ld′·Ct  ·A
C+=DC=(Ld′·C+Ld  ·DCin) ⊕ Ld′·Ct  · B · A
When Ld=0 and Ct=1, these equations reduce to A+=A′, B+=B ⊕ A, and 
C+=C ⊕ BA, which are the equations previously derived for a 3-bit counter.
12.4 Counters for Other Sequences
In some applications, the sequence of states of a counter is not in straight binary 
order. Figure 12-22 shows the transition graph for such a counter. The arrows indi-cate the state sequence. If this counter is started in state 000, the first clock pulse will take it to state 100, the next pulse to 111, etc. The clock pulse is implicitly understood to be the input to the circuit and not shown on the graph. The corresponding transi-tion table for the counter is Table 12-3. Note that the next state is unspecified for the present states 001, 101, and 110.
We will design the counter specified by Table 12-3 using T flip-flops. We could 
derive T
C, TB, and TA directly from this table, as in the preceding example. However, 
it is often more convenient to plot next-state maps showing C+, B+, and A+ as func-
tions of C, B, and A, and then derive TC, TB, and TA from these maps. The next-state 
maps in Figure 12-23(a) are easily plotted from inspection of Table 12-3. From the first row of the table, the 
CBA=000 squares on the C+, B+, and A+ maps are filled 
in with 1, 0, and 0, respectively. From the second row, the CBA=001 squares on all 
three maps are filled in with don’t-cares. From the third row, the CBA=010 squares 
on the C+, B+, and A+ maps are filled in with 0, 1, and 1, respectively. The next-state 
maps can be quickly completed by continuing in this manner.C C ′′ ′
Clk
Ld
Ld
CtDC
DCinClrNB B
Clk
LdDB
DBinClrNA A
Clk
LdDA
DAinClrNFIGURE 12-21
Circuit for 
Figure 12-20
© Cengage Learning 2014
390 Unit 12
CBA C+B+A+
000 100
001 –––010 011011 000100 111101 –––110 –––111 010TABLE 12-3
Transition Table for 
Figure 12-22 
1 101
XX
0 0
000BACC = 0 half C = 1 half
(a) Next-state maps for Table 12-3B = 0 half
B = 1 half
C+01
11
10 X0 101
XX
0 1
100BAC
B+01
1110
XA = 1 halfA = 0 half 0 101
XX
0 0
100BAC
A+01
1110
X
1 001
XX
0 1
000BACC = 0 half C = 1 half
(b) Derivation of T inputsTC = C ′B ′ + CB TB = C ′A + CB ′ TA = C + BB = 0 half
B = 1 half
TC01
11
10 X0 101
XX
1 0
000BAC
TB01
1110
XA = 1 halfA = 0 half 0 101
XX
1 1
100BAC
TA01
1110
XFIGURE 12-23FIGURE 12-22
Transition Graph 
for Counter
© Cengage Learning 2014000
011
010 111100
© Cengage Learning 2014© Cengage Learning 2014
Registers and Counters  391
Next, we will derive the maps for the T inputs from the next-state maps. In the fol-
lowing discussion, the general symbol Q  represents the present state of the  flip-flop 
(C, B, or A) under consideration, and Q+ represents the next state ( C+, B+, or A+) 
of the same flip-flop. Given the present state of a T flip-flop (Q) and the desired next 
state (Q+), the T input must be 1 whenever a change of state is required. Thus, T=1 
whenever Q+≠Q, as shown in Table 12-4.
In general, the next-state map for flip-flop Q gives Q+ as a function of Q and 
several other variables. The value written in each square of the map gives the value 
of Q+, while the value of Q is determined from the row or column headings. Given 
the map for Q+, we can then form the map for TQ by simply putting a 1 in each 
square of the TQ map for which Q+ is different from Q. Thus, to form the TC map in 
Figure 12-23(b) from the C+ map in Figure 12-23(a), we place a 1 in the CBA=000 
square of TC because C=0 and C+=1 for this square. We also place a 1 in the 111 
square of TC because C=1 and C+=0 for this square.
If we don’t care what the next state of a flip-flop is for some combination of varia-
bles, we don’t care what the flip-flop input is for that combination of variables. There-fore, if the Q
+ map has a don’t-care in some square, the TQ map will have a don’t-care 
in the corresponding square. Thus, the TC map has don’t-cares for CBA =001, 101, 
and 110 because C+ has don’t-cares in the corresponding squares.
Instead of transforming the Q+ map into the TQ map one square at a time, we 
can divide the Q+ map into two halves corresponding to Q=0 and Q=1, and trans-
form each half of the map. From Table 12-4, whenever Q=0, T=Q+, and whenever 
Q=1,  T=(Q+)′. Therefore, to transform the Q+ map into a T map, we copy the 
half for which Q=0 and complement the half for which Q=1, leaving the don’t-
cares unchanged.
We will apply this method to transform the C+, B+, and A+ maps for our counter 
shown in Figure 12-23(a) into T maps. For the first map, C corresponds to Q (and C+ 
to Q+), so to get the TC map from the C+ map, we complement the second column 
(where C=1) and leave the rest of the map unchanged. Similarly, to get TB from B+, 
we complement the bottom half of the B  map, and to get TA from A+, we comple-
ment the middle two rows. This yields the maps and equations of Figure 12-23(b) and the circuit shown in Figure 12-24. The clock input is connected to the clock (CK) input of each flip-flop so that the flip-flops can change state only in response to a clock pulse. The gate inputs connect directly to the corresponding flip-flop outputs as indicated by the dashed lines. To facilitate reading similar circuit diagrams, such connecting wires will be omitted in the remainder of the book.
The timing diagram of Figure 12-25, derived by tracing signals through the circuit, 
verifies that the counter functions according to the state diagram of Figure 12-22; for example, starting with 
CBA=000, TC=1 and TB=TA=0. Therefore, when the 
clock pulse comes along, only flip-flop C changes state, and the new state is 100. QQ+T
00 0
01 1 T =  Q+ ⊕ Q
10 111 0TABLE 12-4
Input for  
T Flip-Flop 
© Cengage Learning 2014
392 Unit 12
Then, TC=0 and TB=TA=1, so flip-flops B  and A change state when the next 
clock pulse occurs, etc. Note that the flip-flops change state following the falling 
clock edge.
Although the original transition table for the counter (Table 12-3) is not com-
pletely specified, the next states of states 001, 101, and 110 have been specified in the process of completing the circuit design. For example, if the flip-flops are initially set to C=0, B =0, and 
A=1, tracing signals through the circuit shows that TC=TB=1 
and TA=0, so that the state will change to 111 when a clock pulse is applied. This 
behavior is indicated by the dashed line in Figure 12-26. Once state 111 is reached, FIGURE 12-24
Counter Using  
T Flip-Flops
© Cengage Learning 2014C C ′
TCCKB B′
TBCKA A ′
TACKFF FF FF
CLK
C′B′CB
CB CB ′C′A
FIGURE 12-25
Timing Diagram  
for Figure 12-24
© Cengage Learning 2014CLK
0 1 1 000
0
TATBTCABC
0011 1
001 010
FIGURE 12-26
Transition Graph  
for Counter
© Cengage Learning 2014000
011
010 111 001100
Registers and Counters  393
successive clock pulses will cause the counter to continue in the original counting 
sequence as indicated on the transition graph. When the power in a circuit is first turned on, the initial states of the flip-flops may be unpredictable. For this reason, all of the don’t-care states in a counter should be checked to make sure that they eventu-ally lead into the main counting sequence unless a power-up reset is provided. Such a counter is sometimes called self-starting.
In summary, the following procedure can be used to design a counter using 
T flip-flops:
1. Form a transition table which gives the next flip-flop states for each combination 
of present flip-flop states.
2. Plot the next-state maps from the table.
3. Plot a 
T input map for each flip-flop. When filling in the TQ map, TQ must be 1 
whenever Q+≠Q. This means that the TQ map can be formed from the Q+ 
map by complementing the Q=1 half of the map and leaving the Q=0 half 
unchanged.
4. Find the T input equations from the maps and realize the circuit.
Counter Design Using D Flip-Flops
For a D flip-flop, Q+=D, so the D input map is identical with the next-state map. 
Therefore, the equation for D  can be read directly from the Q+ map. For the counter 
of Figure 12-22, the following equations can be read from the next-state maps shown in Figure 12-23(a):
D
C=C+
 =B′     DB =B+=C+BA ′
DA=A+=CA ′+BA ′=A′(C+B)
This leads to the circuit shown in Figure 12-27 using D flip-flops. Note that the 
connecting wires between the flip-flop outputs and the gate inputs have been omit-ted to facilitate reading the diagram.
FIGURE 12-27
Counter of 
Figure 12-22  
Using D Flip-Flops
© Cengage Learning 2014C C ′
DCCKFF
BA ′B′B
CB′
DBCKFF
CBA
A′A′
DACKFF
CLK
An alternative to directly designing counters for nonbinary sequences is to use 
a binary counter or some other counter and add decoding logic to generate the 
394 Unit 12
desired outputs. This approach may result in a simpler overall circuit. As an example, 
the count cycle of length 5 of Figure 12-22 can be obtained using a five-stage ring counter with decoding logic. If the stages of the ring counter are Q
5, Q4, . . ., Q1, then 
the outputs are obtained by the decoding equations
OC=Q4+Q3
OB=Q3+Q2+Q1
OA=Q3+Q1
Counters and shift registers with clear, preset, or parallel load capability can also be used to generate nonbinary count cycles. Consider a binary counter with a clear input as shown Figure 12-28. The binary counter 
(N=4) can be converted to a BCD 
decade (decimal) counter if the gate logic causes the counter to transfer from a count of 9 to a count of 0 (rather than 10). If the clear input is a synchronous clear, then the logic required is
Clr=Q
3Q0
assuming Q3, Q2, Q1, Q0 are the four counter outputs. Note that the counter never 
enters states 10 through 15 so these are don’t-cares for the Clr function. If the clear input is an asynchronous input, then the logic required is
Clr=Q
3Q1
In this case states 11 through 15 are don’t-cares for Clr. On the next active edge of the clock, when the counter is in state 9, the counter will temporarily enter state 10, causing Clr to become active and return the counter to state 0. Such transient states could cause glitches in other logic using the counter outputs.
FIGURE 12-28
Binary Counter 
with Clear
© Cengage Learning 2014CLKClr
Gate LogicN-Bit Binary Counter
N
As another example, consider the binary counter of Figure 12-29 (N=4) that 
has a parallel load capability. It can be used to create a decimal counter that counts using the excess-3 code. The counter must cycle through states 3 through 12. The logic must generate Ld when the counter is in state 12 and the parallel inputs must be 0011.
D
3=0, D2=0, D1=1, D0=1
Ld=Q3Q2
States 0, 1, 2, 13, 14 and 15 are don’t-cares.
Registers and Counters  395
12.5 Counter Design Using S-R and J-K Flip-Flops
The procedures used to design a counter with S-R flip-flops are similar to the pro-
cedures discussed in Sections 12.3 and 12.4. However, instead of deriving an input equation for each D or T flip-flop, the 
S and R input equations must be derived. We 
will now develop methods for deriving these S and R  flip-flop input equations.
Table 12-5(a) describes the behavior of the S-R flip-flop. Given S, R, and Q , we 
can determine Q+ from this table. However, the problem we must solve is to deter-
mine S and R  given the present state Q and the desired next state Q+. If the present 
state of the flip-flop is Q=0 and the desired next state is Q+=1, a 1 must be applied 
to the S input to set the flip-flop to l. If the present state is 1, and the desired next 
state is 0, a 1 must be applied to the R  input to reset the flip-flop to 0. Restrictions 
on the flip-flop inputs require that S=0 if R =1, and R=0 if S=1. Thus, when 
forming Table 12-5(b), the rows corresponding to QQ+=01 and 10 are filled in with 
SR=10 and 01, respectively. If the present state and next state are both 0,  S must 
be 0 to prevent setting the flip-flop to 1. However, R may be either 0 or 1 because 
when Q=0, R =1 has no effect on the flip-flop state. Similarly, if the present state 
and next state are both 1, R must be 0 to prevent resetting the flip-flop, but  S may 
be either 0 or 1. The required S and R inputs are summarized in Table 12-5(b). 
Table 12- 5(c) is the same as 12-5(b), except the alternative choices for R and S have 
been indicated by don’t-cares.FIGURE 12-29
Binary Counter 
with Parallel Load
© Cengage Learning 2014
ClkLd
Gate LogicN-Bit Binary CounterDN−1, . . . , D0
NN
TABLE 12-5
S-R Flip-Flop 
Inputs (a)
SRQ Q+
000 0
001 1010 0011 0100 1101 1110 –111 –f inputs not
allowed(b)
QQ+SR
00 e0  0
01
01 1010 01
11 e0
  0
10(c)
QQ+SR
00 0X
01 10
10 0111 X0© Cengage Learning 2014
396 Unit 12
Next, we will redesign the counter of Figure 12-22 using S-R flip-flops. Table 12-3 
is repeated in Table 12-6 with columns added for the S and R flip-flop inputs. These 
columns can be filled in using Table 12-5(c). For CBA=000, C=0 and C+=1, so 
SC=1, RC=0. For CBA=010 and 011, C=0 and C+=0, so SC=0 and RC=X. 
For CBA=100, C=1 and C+=1, so SC=X and RC=0. For row 111, C=1 and 
C+=0, so SC=0 and RC=l. For CBA=001, 101, and 110, C+=X, so SC=RC=X. 
Similarly, the values of SB and RB are derived from the values of B and B+, and 
SA and RA are derived from A and A+. The resulting flip-flop input functions are 
mapped in Figure 12-30(b).
It is generally faster and easier to derive the S-R flip-flop input maps directly 
from the next-state maps than to derive them from the transition table as was done 
in Table 12-6. For each flip-flop, we will derive the S and R input maps from the 
next-state (Q+) map using Table 12-5(c) to determine the values for S and R . Just 
as we did for the T flip-flop, we will use the next-state maps for C+, B+, and A+ in 
Figure 12-23(a) as a starting point for deriving the S-R flip-flop input equations. For convenience, these maps are repeated in Figure 12-30(a). We will consider one-half of each next-state map at a time when deriving the input maps. We will start with flip-flop C
 (Q=C and Q+=C+) and consider the C=0 column of the map. From 
Table 12-5(c), if C=0 and C+=1, then S=1 and R =0. Therefore, for every square 
in the C=0 column where C+=1, we plot SC=1 and RC=0 (or blank) in the cor-
responding squares of the input maps. Similarly, for every square in the C=0 column 
where C+=0, we plot SC=0 and RC=X on the input maps. For the C=1 column, if 
C+=0, we plot SC=0 and RC=1; if C+=1, we plot SC=X and RC=0. Don’t-cares 
on the C+ map remain don’t-cares on the SC and RC maps, because if we do not care 
what the next state is, we do not care what the input is. In a similar manner, we can derive the 
SB and RB maps from the B+ map by working with the B=0 (top) half 
of the map and the B=1 (bottom) half of the map. As before, 1’s are placed on the 
S or R map when the flip-flop must be set or reset. S is a don’t-care if Q=1 and no 
state change is required, and R=X if Q=0 and no state change is required. Finally, 
SA and RA are derived from the A+ map. Figure 12-30(c) shows the resulting circuit.
The procedure used to design a counter with J-K flip-flops is very similar to that 
used for S-R flip-flops. The J-K flip-flop is similar to the S-R flip-flop except that J and 
K can be 1 simultaneously, in which case the flip-flop changes state. Table 12-7(a) 
gives the next state (Q+) as a function of J, K, and Q. Using this table, we can derive 
the required input conditions for J and K when Q and Q+ are given. Thus if a change 
from Q=0 to Q+=1 is required, either the flip-flop can be set to 1 by using J=1 CBA C+B+A+SCRCSBRBSARA
0 0 0 100 100X0X
0 0 1 ––– XXXXXX0 1 0 011 0XX0 1 00 1 1 0 0 0 0X01011 0 0 1 1 1 X010101 0 1 ––– XXXXXX1 1 0 ––– XXXXXX1 1 1 010 0 1X0 0 1TABLE 12-6 
© Cengage Learning 2014
Registers and Counters  397
(and K=0) or the state can be changed by using J=K=1. In other words, J must 
be l, but K is a don’t-care. Similarly, a state change from 1 to 0 can be accomplished 
by resetting the flip-flop with K =1 (and J=0) or by changing the flip-flop state 
with J=K=1. When no state change is required, the inputs are the same as the 
corresponding inputs for the S-R flip-flops. The J-K flip-flop input requirements are 
summarized in Tables 12-7(b) and 12-7(c).
We will now redesign the counter of Figure 12-22 using J-K flip-flops. 
Table 12-3 is repeated in Table 12-8 with columns added for the J and K flip-flop inputs. We will fill in these columns using Table 12-7(c). For 
CBA=000, C=0 1 101
XX
0 0
000BAC
(a) Next-state mapsB = 0 half
B = 1 half
C+01
11
10 X
01
XX
X 1
X00BAC
(b) S-R flip-flop equations
(c) Logic circuitRC01
1110
X1X
XX
SC
RC = ASC = B′X01
XX
X
100BAC
RB01
11
10 X1
XX
X
SB
RB = C ′ASB = CX X01
XX
X
1 100BAC
RA01
11
10 X1
X
1X
SA
RA = ASA = CA ′ + BA ′
    = A ′(C + B)X0 101
XX
0 1
100BAC
B+01
1110
XA = 1 halfA = 0 half 0 101
XX
0 0
100BAC
A+01
1110
X
Q Q′C C′
B′ A
CLKS RQ Q′B B′
AC ′CS RQ Q′A A′
AS R
A′
BCFIGURE 12-30
Counter of 
Figure 12-22 Using 
S-R Flip-Flops
© Cengage Learning 2014
398 Unit 12
and C+=1, so  JC=1 and KC=X. For CBA=010 and 011, C=0 and C+=0, so 
JC=0 and KC=X. The remaining table entries are filled in similarly. The result-
ing J-K flip-flop input functions are plotted in Figure 12-31(b). After deriving 
the flip-flop input equations from the J-K maps, we can draw the logic circuit of Figure 12-31(c).
12.6 Derivation of Flip-Flop Input  
Equations—Summary
The input equation for the flip-flops in a sequential circuit may be derived from the 
next-state equations by using truth tables or by using Karnaugh maps. For circuits with three to five variables, it is convenient to first plot maps for the next-state equa-tions, and then transform these maps into maps for the flip-flop inputs.
Given the present state of a flip-flop 
(Q) and the desired next state (Q+), 
Table 12-9 gives the required inputs for various types of flip-flops. For the D flip-flop, the input is the same as the next state. For the T flip-flop, the input is 1 whenever a state change is required. For the S-R flip-flop, 
S is 1 whenever the flip-flop must be 
set to 1 and R is 1 when it must be reset to 0. We do not care what S is if the flip-flop 
state is 1 and must remain 1; we do not care what R is if the flip-flop state is 0 and CBA C+B+A+JCKCJBKBJAKA
0 0 0 1 0 0 1 X0X0X
0 0 1 – – – X XXXXX010 011 0 X X 0 1 X0 1 1 0 0 0 0 XX1X11 0 0 1 1 1 X 01X1X1 0 1 – – – X XXXXX1 1 0 – – – X XXXXX1 1 1 0 1 0 X 1X0X1(a)
JKQ Q+
000 0
001 1010 0011 0100 1101 1110 1111 0TABLE 12-7
J-K Flip-Flop  
Inputs 
(b)
QQ+JK
00 e00
01
01 e1011
10 e0111
11 e0010(c)
QQ+JK
00 0X
01 1X10 X111 X0
TABLE 12-8 © Cengage Learning 2014
© Cengage Learning 2014
Registers and Counters  399
must remain 0. For a J-K flip-flop, the J and K inputs are the same as S and R , respec-
tively, except that when one input is 1 the other input is X. This difference arises 
because S=R=1 is not allowed, but J=K=1 causes a change of state.
Table 12-9 summarizes the rules for transforming next-state maps into flip-flop 
input maps. Before applying these rules, we must copy any don’t-cares from the  next-state maps onto the input maps. Then, we must work with the Q=0 and Q =1 
halves of each next-state map separately. The rules given in Table 12-9 are easily derived by comparing the values of Q
+ with the corresponding input values. For 
example, in the Q=0 column of the table, we see that J is the same as Q+, so the 
Q=0 half of the J map is the same as the Q+ map. In the Q =1 column, J=X (inde-
pendent of Q+), so we fill in the Q =1 half of the J map with X’s.1 101
XX
0 0
000BAC
(a) Next-state mapsB = 0 half
B = 1 half
C+01
11
10 X
01
XX
X1X 00BAC
(b) J-K flip-flop input equations
(c) Logic circuit (omitting the feedback lines)JC01
1110
XX
X
X
XX
1
KC
JC = B ′ KC = AX01 01 01 01
XX
XX
XX1 00BAC
JB01
11
10X
X
1XX
KB
JB = CKB = C ′AX01
XX1
X
1X00BAC
JA01
1110
XXX
XX
1
X1
X
KA
JA = C + BKA = 10 101
XX
0 1
100BAC
B+01
11
10 XA = 1 halfA = 0 half 0 101
XX
0 0
100BAC
A+01
1110
X
C C′
B′ A
CLKJC KCB B′
C′ACJB KBA A′
1JA KA
CBCK CK CKFF FF FFFIGURE 12-31
Counter of 
Figure 12-22 Using 
J-K Flip-Flops
© Cengage Learning 2014
400 Unit 12
For the S-R flip-flop, note that when Q=0, R=X if Q+=0; and when Q =1, 
R=1 if Q+=0. Therefore, to form the R map from the Q+ map, replace 0’s with X’s 
on the Q =0 half of the map and replace 0’s with 1’s on the Q=1 half (and fill in 
0’s for the remaining entries). Similarly, to form the S map from the Q+ map, copy 
the 1’s on the Q=0 half of the map, and replace the 1’s with X’s on the Q=1 half.Type of 
Flip-Flop InputQ=0 Q=1Rules for Forming Input Map 
From Next-State Map*
Q+=0Q+=1Q+=0Q+=1Q=0 Half of 
MapQ=1 Half of 
Map
Delay D 0101 n o  change no change
Toggle T 0110 n o  change complement
Set-Reset S 0 1 0 X no change replace 1’s 
with X’s**
R X 0 1 0 replace 0’s 
with X’s**complement
J-K J 0 1 X X no change fill fill in with X’s
K X X 1 0 in with X’s complement
Q+ means the next state of Q
X is a don’t-care
*Always copy X’s from the next-state map onto the input maps first.
**Fill in the remaining squares with 0’s.
0 101
1 0
0 0
100ABQ
Q+
Next-state map01
11
10 X
0X01
1 0
0 0
100ABQ
S = AB ′ + Q ′A ′B01
1110
XX 001
0 1
X 1
000ABQ
R = QB
S-R input maps01
1110
X0X01
1X
0X
100ABQ
J = A ′B + AB ′01
1110
XX 001
X 1
X 1
X00ABQ
K = B
J-K input maps01
1110
X0 101
1 0
0 0
100ABQ
D = Q ′A ′B + QB ′ + AB ′
D input map01
1110
X0 001
1 1
0 1
100ABQ
T = A ′B + AB ′ + QB
T input map01
1110
XTABLE 12-9
Determination of 
Flip-Flop Input  
Equations from 
Next-State 
Equations  
Using Karnaugh 
Maps 
Example 
(illustrating the use of Table 12-9)© Cengage Learning 2014
Registers and Counters  401
Examples of deriving four-variable input maps are given in Figure 12-32. In 
each case, Qi represents the flip-flop for which input equations are being derived 
A, B, and C represent other variables on which the next state depends. As shown 
in Figure 12-32(a), a 1 is placed on the T1 map whenever Q1 must change state. In 
Figure 12-32(b), 1’s are placed on the Q2=0 half of the S2 map whenever Q2 must 
be set to 1, and 1’s are placed on the Q2=1 half of the R2 map whenever Q2 must 
be reset. Figure 12-32(c) illustrates derivation of J3 and K3 by using separate J and 
K maps. As will be seen in Unit 14, the methods used to derive flip-flop input equa-
tions for counters are easily extended to general sequential circuits.
The procedures for deriving flip-flop input equations discussed in this unit can be 
extended to other types of flip-flops. If we want to derive input equations for a dif-
ferent type of flip-flop, the first step is to construct a table which gives the next state FIGURE 12-32
Derivation of 
Flip-Flop Input 
Equations Using 
Four -Variable Maps
© Cengage Learning 20140 1 0 100 01 11 10
X 1 1 0
1XX 1
000BCQ1A
01
11
10 0 0X0 1 1 000 01 11 10
X 1 0 1
1XX 0
000BCQ1A
T1 Q1 = 0
half
Q2 = 0
half01
1110
0 1X
1X 1 000 01 11 10
0 0X 1
1 0X 1
X00CQ2AB
01
1110
0 0 10X 0X00 01 11 10
1 1X 0
0 1X 0
X00CQ2AB
R201
1110
XX 01X 1 000 01 11 10
0 0XX
X 0XX
X00CQ2AB
S201
1110
0 0 1Q1 = 1
half
Q1+
Q2+
Q3+(a)
(b)
0 0 1X00 01 11 10
0 1X 1
XX 0 0
100Q3CAB
01
11
10 1 1 00 0 1X00 01 11 10
0 1X 1
XXXX
X00Q3CAB
J3 = A + BC01
1110
XXXXXXX00 01 11 10
XXXX
XX 1 1
000Q3CAB
K3 = C + AB ′01
1110
0 0 1
(c)Q2 = 1 half
Q3 = 0 half
Q3 = 1 half
402 Unit 12
(Q+) as a function of the present state (Q) and the flip-flop inputs. From this table, 
we can construct another table which gives the required flip-flop input combinations 
for each of the four possible pairs of values of Q  and Q+. Then, using this table, we 
can plot a Karnaugh map for each input function and derive minimum expressions from the maps.
Problems
12.1 Consider a 6-bit adder with an accumulator, as in Figure 12-5. Suppose the X reg-
ister contains a number from a previous calculation. We do not want this number. Instead, we want 
X to equal 3 ×Y. (X=x5x4x3x2x1x0 and Y =y5y4y3y2y1y0.) On the 
timing diagram, give values for Ad and ClrN so that we will have X=3×Y held in 
the accumulator.
12.2 The shift register of Figure 12-10 can be made to shift to the left by adding external connections between the Q outputs and D inputs. Draw a block diagram like the one 
in Figure 12-10(a) and indicate the appropriate connections. Which input line would serve as a serial input in this case? With the connections you have made, what should 
Sh and L  be for a left shift? For a right shift?
12.3 Show how to modify the internal circuitry of the shift register of Figure 12-10 so that it will also shift to the left without external connections as in Problem 12.2. Replace 
Sh and L  with A and B  and let the register operate according to the following table:
12.4 (a) Design a 4-bit synchronous binary counter using T flip-flops.
(Hint: Add one flip-flop, with necessary gates, to the left side of Figure 12-14.Verify that the gates for the other three flip-flops do not change.)
(b) Repeat (a) using D flip-flops. See Figure 12-16.Inputs Next State
Action AB Q  +
3Q  +
2Q  +
1Q  +
0
00 Q3Q2Q1Q0 no change
01 SI Q3Q2Q1 right shift
10 Q2Q1Q0SI left shift
11 D3D2D1D0 loadClrNAdCLK
Registers and Counters  403
12.5 Repeat Problem 12.4(a) using D flip-flops, but implement each D input as a sum of 
products, without using XOR gates. ( Hint: Use Equations (12-2). As in Problem 12.4, 
you will need one more equation.)
12.6 Design a circuit using D flip-flops that will generate the sequence 0, 0, 1, 0, 1, 1 and 
repeat. Do this by designing a counter for any sequence of states such that the first flip-flop takes on this sequence. There are many correct answers, but do not duplicate states, because each state can have only one next state.
12.7 Design a 3-bit counter which counts in the sequence:  001, 011, 010, 110, 111, 101, 100, (repeat) 001, . . .
(a) Use D flip-flops.
(b) Use T flip-flops.
In each case, what will happen if the counter is started in state 000?
12.8 Design a 3-bit counter which counts in the sequence:  001, 011, 010, 110, 111, 101, 100, (repeat) 001, . . .
(a) Use J-K flip-flops.
(b) Use S-R flip-flops.
In each case, what will happen if the counter is started in state 000?
12.9 An M-N flip-flop works as follows:
If M
N=00, the next state of the flip-flop is 0.
If M N=01, the next state of the flip-flop is the same as the present state.
If M N=10, the next state of the flip-flop is the complement of the present state.
If M N=11, the next state of the flip-flop is 1.
(a) Complete the following table (use don’t-cares when possible):
(b) Using this table and Karnaugh maps, derive and minimize the input equations for a 
counter composed of three M-N flip-flops which counts in the following sequence: CBA =000, 001, 011, 111, 101, 100, (repeat) 000, . . .
12.10 Design a counter which counts in the sequence that has been assigned to you. Use  
D flip-flops and NAND gates. Simulate your design using SimUaid.
(a) 000, 001, 011, 101, 111, 010, (repeat) 000, . . .
(b) 000, 011, 101, 111, 010, 110, (repeat) 000, . . .
(c) 000, 110, 111, 100, 101, 001, (repeat) 000, . . .
(d) 000, 100, 001, 110, 101, 111, (repeat) 000, . . .
(e) 000, 010, 111, 101, 011, 110, (repeat) 000, . . .Present State Next State
Q Q+M N
00
011011
404 Unit 12
(f ) 000, 100, 001, 111, 110, 101, (repeat) 000, . . .
(g) 000, 010, 111, 101, 001, 110, (repeat) 000, . . .
(h) 000, 101, 010, 011, 001, 110, (repeat) 000, . . .
(i) 000, 100, 010, 001, 110, 111, (repeat) 000, . . .
(j) 000, 001, 111, 010, 110, 011, (repeat) 000, . . .
(k) 000, 100, 010, 001, 101, 111, (repeat) 000, . . .
(l) 000, 011, 111, 110, 001, 100, (repeat) 000, . . .
(m) 000, 100, 111, 110, 010, 011, (repeat) 000, . . .
(n) 000, 011, 111, 110, 010, 100, (repeat) 000, . . .
12.11 Redesign the right-shift register circuit of Figure 12-10 using four D flip-flops with clock enable, four 2-to-1 MUXes, and a single OR gate.
12.12 Design a left-shift register similar to that of Figure 12-10. Your register should shift left if 
Sh=1, load if Sh=0 and L=1, and hold its state if Sh=L=0.
(a) Draw the circuit using four D flip-flops and four 4-to-1 MUXes.
(b) Give the next-state equations for the flip-flops.
12.13 A 74178 shift register is described by the given table. All state changes occur on the 1 -0 transition of the clock. The shift register is connected as shown. Complete the timing diagram.
Sh Ld Q  +
AQ  +
B Q  +
C Q  +
D
00 QA QB QC QD
01 DA DB DC DD
1 X SI QA QB QC
QDSI = Q CQBQALdShClockQD QAQBQC
DD DADBDC74178
0101SI
Sh
LdClock
Registers and Counters  405
12.14 Design a 5-bit synchronous binary counter. (Hint: See Problem 12.4.)
(a) Use T flip-flops.
(b) Use D flip-flops.
12.15 Construct a 4-bit Johnson counter using J-K flip-flops. (See Figure 12-12 for a Johnson 
counter.) What sequence of states does the counter go through if it is started in state 0000? State 0110?
12.16 Design a 3-bit binary up-down counter which functions the same as the up-down counter of Figure 12-18 and Figure 12-19. Use a 3-bit register of D flip-flops, a 3-bit adder, and one OR gate. (If you are clever enough, you can do it without the OR gate.) (Hint: To subtract one, add 111.)
12.17 Design a decade counter which counts in the sequence:  0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 0000, . . .
(a) Use D flip-flops.
(b) Use J-K flip-flops.
(c) Use S-R flip-flops.
(d) Use T flip-flops.
(e) Draw a complete state diagram for the counter of (b) showing what happens 
when the counter is started in each of the unused states.
12.18 Repeat Problem 12.17 for the downward decade sequence:  0000, 1001, 1000, 0111, 0110, 0101, 0100, 0011, 0010, 0001, 0000, . . .
12.19 (a)  Derive the state graph for the ripple counter below. Show the transient states 
that occur between stable states.
(b) Modify the ripple counter so that it cycles through the same states but in reverse 
order. (Use the same type of flip-flop.) ( Hint: First construct a state graph for the 
modified counter showing the transient states between stable states.)
12.20 Design a 3-bit counter which counts in the sequence:  001, 100, 101, 111, 110, 010, 011, 001, . . .
(a) Use D flip-flops.
(b) Use J-K flip-flops.JQ
Q′ KClk Clk1Q0 Q1 Q2 Q3
Clk Clk ClkJQ
Q′ KJQ
Q′ KJQ
Q′ K
406 Unit 12
(c) Use T flip-flops.
(d) Use S-R flip-flops.
(e) What will happen if the counter of (a) is started in state 000?
12.21 Design a decade counter using the following 2-4-2-1 weighted code for decimal 
 digits. Use NAND gates and the indicated flip-flop types.
(a) Use D flip-flops.
(b) Use J-K flip-flops.
(c) Use T flip-flops.
(d) Use S-R flip-flops.
12.22 Repeat Problem 12.21 using NOR gates instead of NAND gates.
12.23 Design a decade counter using the excess-3 code for decimal digits. Use NAND gates and the indicated flip-flop types.
(a) Use D flip-flops.
(b) Use J-K flip-flops.
(c) Use T flip-flops.
(d) Use S-R flip-flops.
12.24 Repeat Problem 12.23 using NOR gates instead of NAND gates.
12.25 The following binary counter increments on each rising clock edge unless the exter-nal clear (ClrN) control input is low.
(a) Implement a modulo 12 counter using this binary counter assuming the Clr con-
trol input is a synchronous control input.
(b) Repeat part (a) assuming Clr is an asynchronous control input.Digit ABCD
0 0000
1 00012 00103 00114 01005 10116 11007 11018 11109 1111
CLKClr 4-Bit Counter
Q3Q2Q1Q0ClrN
Registers and Counters  407
12.26 The following binary counter operates according to the function table given. Using this 
binary counter, implement a decimal counter that uses the 2-4-2-1 weighted code for representing decimal digits. Minimize the gate logic required by using the parallel load inputs only to change the counting sequence from straight binary to 2-4-2-1 code.
ClrN Ld Function
0 — Clear
1 1 Parallel Load1 0 IncrementCLKClr4-Bit CounterLdP3 P2 P1P0
Q3 Q2 Q1Q0ClrN
12.27 For each value of N, there exists an exclusive-OR circuit for the linear shift register 
counter of Figure 12-13 so that the counter cycles through 2N−1 counts.
(a) For N=3, construct the transition graph for the counter if Sin=Q2 ⊕ Q1. (The 
shift register stages are numbered Q0, Q1, Q2 from left to right.)
(b) For N=4, find an exclusive-OR circuit so that the counter cycles through 15 
counts.
(c) Make a simple modification to the logic of part (b) so that the counter cycles 
through 16 counts. (The counter is no longer linear.)
12.28 When started in state 0, an n -stage Johnson (twisted-ring) counter cycles through 
2n states. Other count cycles will be obtained if the counter is started in other states. 
Determine all count cycles for the Johnson counter when
(a) n=3,
(b) n=4, and
(c) n=5.
12.29 When started in state 0, an n -stage Johnson (twisted-ring) counter cycles through 
2n states. A simple modification of the counter will cause it to cycle through 2n −1 
states. (Assume the counter is implemented with D flip-flops.)
(a) Determine the equation for the shift register input so that the all 1’s state is 
eliminated from the cycle with 2 n states to obtain a cycle of length 2 n−1.
(b) Repeat part (a) for the case when the all 0’s state is eliminated.
12.30 Repeat Problem 12.29 assuming the counter is implemented with J-K flip-flops.
12.31 Binary up counters can be designed using J-K flip-flops by noting that the least signif-
icant stage, Q0, always toggles and stage Qi always toggles when stages 0, . . . (i−1) 
are 1. This approach can be modified to design counters with a shorter cycle and obtaining nearly minimum equations. Note that an optimum solution may not have the same equations for 
J and K.
408 Unit 12
(a) Modify the binary up counter design to obtain a BCD decade up counter using 
J-K flip-flops.
(b) Modify the binary up counter design to obtain an excess-3 decade up counter 
using J-K flip-flops.
(c) Modify the design for part (b) so that the counters can be cascaded to obtain 
excess-3 counters that can count to 99, 999, etc.
12.32 A three-stage binary up-down counter has control input U; when U=0, the counter 
counts down and when U=1, the counter counts up. Design this counter with a 
minimum number of NAND gates, using
(a) reset-dominant S-R flip-flops.
(b) D-CE flip-flops.
12.33 A two-stage counter has two input control lines, M and N. The count sequences are 
as follows:
(a) Design the counter assuming the outputs come directly from J-K flip-flops.
(b) Design the counter assuming a two-stage binary counter is used with the 
J-K  flip-flop outputs decoded.
12.34 A pulse-generating circuit generates eight repetitive pulses as shown in the figure. 
Implement the pulse-generating circuit using the counter circuits listed and a mini-mum of gate logic. Use J-K flip-flops for the counters that trigger on the falling edge of a clock that has a frequency eight times the frequency of one of the pulses. The pulses must be free of glitches; explain any restrictions on the propagation delays of gates and flip-flops so that the pulses will be glitch free.
(a) Ring counter (A ring counter is a shift register with end-to-end feedback.)
(b) Johnson counter
(c) Binary counterMN Sequence
00 0, 1, 2, 3, 0,  . . . .
01 0, 1, 0, 1, 0, 1, . . .10 2, 0, 2, 0, 2, 0, . . .11 1, 2, 1, 2, 1, 2, . . .
T0
T1
T2
T3
T4
T5
T6
T7
Registers and Counters  409
12.35 A U-V flip-flop behaves as follows:
If UV=00, the flip-flop does not change state.
If UV=10, the flip-flop is set to Q =0.
If UV=11, the flip-flop changes state.
The input combination UV=01 is not allowed.
(a) Give the characteristic (next-state) equation for this flip-flop.
(b) Complete the following table, using don’t-cares where possible.
(c) Realize the following next-state equation for Q using a U-V flip-flop: Q+= 
A+BQ. Find equations for U and V.
12.36 A M-F flip-flop behaves as follows:
If MF =01, the flip-flop changes state.
If MF =11, the flip-flop is set to Q =0.
If MF =00, the flip-flop is set to Q =1.
The input combination MF =10 is not allowed.
(a) Give the characteristic (next-state) equation for this flip-flop.
(b) Complete the table, using don’t-cares where possible.
(c) Realize the following next-state equation for Q using a MF flip-flop: Q+ =
CQ+DQ′ . Find equations for M and F.
12.37 An L-M flip-flop works as follows:
If LM =00, the next state of the flip-flop is 1.
If LM =01, the next state of the flip-flop is the same as the present state.
If LM =10, the next state of the flip-flop is the complement of the present state.
If LM =11, the next state of the flip-flop is 0.
(a) Complete the following table (use don’t-cares when possible):QQ+MF
00
01
1011
Present State Next State
Q Q+L M
00
01
10
11QQ+UV
00
011011
410 Unit 12
(b) Using this table and Karnaugh maps, derive and minimize the input equations 
for a counter composed of three L-M flip-flops which counts in the following 
sequence: ABC=000, 100, 101, 111, 011, 001, 000, . . . 
12.38 A sequential circuit contains a register of four flip-flops. Initially a binary number N
 (0000 ≤N≤1100 ) is stored in the flip-flops. After a single clock pulse is applied 
to the circuit, the register should contain N+0011. In other words, the function of 
the sequential circuit is to add 3 to the contents of a 4-bit register. Design the circuit using J-K flip-flops.
12.39 When an adder is part of a larger digital system, an arrangement like the given figure often works well. For the control signals and the input data in the following table, give the value of the addend, the accumulator, and the bus at the end of each clock cycle (i.e., immediately before the active clock edge). Express the register and bus values in decimal.
Accumulator
Register8-Bit
Adder
CE LdAc Addend
RegisterCE LdAd88
888 88
EnAd
88
EnIn
Input
DataBus
Clock 
CycleInput 
Data EnIn EnAd LdAc LdAdAccumulator 
RegisterAddend 
Register Bus
0 1 8 1010 0 01 8
1 1 3 1001
2 1 5 01103 9 3 10014 4 7 01105 2 2 10016 00100
12.40 A digital system can perform any four-variable bitwise logic function, but it may take 
several clock cycles. (A bitwise logic function performs the same logic function on each bit.) Recall that the NAND operation is functionally complete (i.e., we can do any logic function by a series of NAND operations). On the following 8-bit registers, En is a tri-state buffer enable as in Figure 12-3, and CE is a clock enable as in Figure 12-1.
Registers and Counters  411
CE
En A
CK8 8
8 8
88 8
CE
En B
CKCE8 NAND Gates
EnRXY
C
CKCE
En D
CK88
Inputs Next State
Action AB Q  +
3Q  +
2Q  +
1Q  +
0
00 Q3Q2Q1Q0 No change
01 SIQ3Q2Q1 Right shift
10 D3D2D1D0 Load
11 Q0Q1Q2Q3 Reverse bits(a) Show how to connect a 2-to-4 decoder (with inverting outputs) so that the next 
rising edge of the clock will load the result into register A, B, C, or D for control 
inputs G0G1=00, 01, 10, or 11, respectively.
(b) Show how to connect three control signals, E0, E1, and E2, to the registers so that 
E0=0 places the A register contents on the X bus, E0=1 places B onto the 
X bus, E1E2=00 places C onto the Y bus, E1E2=01 places D onto the Y bus, 
E1E2=10 places 00000000 on the Y bus, and E1E2=11 places 11111111 on the 
Y bus. You may use a few additional gates. ( Hint: Connect E2 to all 8 data inputs 
on the tri-state buffer on the right side of the circuit.)
(c) Show how to make the bits in the C register be the OR of the correspond-
ing bits in the A register and in the D register, in four clock cycles. Tell what 
G0, G1, E0, E1, and E2 should be for each cycle. ( Hint: Use DeMorgan’s law and 
X′=(X NAND 1 ).)
12.41 Show how to make the shift register of Figure 12-10 reverse the order of its bits 
(i.e., Q3+=Q0, Q+
2=Q1, Q+
1=Q2, and Q+
0=Q3).
(a) Use external connections between the Q outputs and the D inputs. What should 
the values of Sh and L  be for a reversal?
(b) Change the internal circuitry to allow bit reversal, so that the D inputs may be 
used for other purposes. Replace Sh and L  with A and B, and let the register 
operate according to the following table:
412Analysis of Clocked Sequential 
CircuitsUNIT
13
Objectives
1. Analyze a sequential circuit by signal tracing.
2. Given a sequential circuit, write the next-state equations for the flip-flops and 
derive the state graph or state table. Using the state graph, determine the state sequence and output sequence for a given input sequence.
3. Explain the difference between a Mealy machine and a Moore machine.
4. Given a state table, construct the corresponding state graph, and conversely.
5. Given a sequential circuit or a state table and an input sequence, draw a tim-ing chart for the circuit. Determine the output sequence from the timing chart, neglecting any false outputs.
6. Draw a general model for a clocked Mealy or Moore sequential circuit. Explain the operation of the circuit in terms of these models. Explain why a clock is needed to ensure proper operation of the circuit.
Analysis of Clocked Sequential Circuits  413
Study Guide
1. Study Section 13.1, A Sequential Parity Checker.
(a) Explain how parity can be used for error detection.
(b) Verify that the parity checker (Figure 13-4) will produce the output wave-
form given in Figure 13-2 when the input waveform is as shown.
2. Study Section 13.2, Analysis by Signal Tracing and Timing Charts.
(a) What is the difference between a Mealy machine and a Moore machine?
(b) For normal operation of clocked sequential circuits of the types discussed 
in this section, when should the inputs be changed?
When do the flip-flops change state?At what times can the output change for a Moore circuit?At what times can the output change for a Mealy circuit?
(c) At what time (with respect to the clock) should the output of a Mealy cir-
cuit be read?
(d) Why can false outputs appear in a Mealy circuit and not in a Moore circuit?
What can be done to eliminate the false outputs?
If the output of a Mealy circuit is used as an input to another Mealy circuit syn-
chronized by the same clock, will false outputs cause any problem? Explain.
(e) Examine the timing diagram of Figure 13-8. The value of 
Z will always 
be correct just before the falling (active) clock edge that causes the state change. Note there are two types of false outputs. A false 0 output occurs if 
Z is 1 just before two successive falling clock edges, and Z goes to 0 
between the clock edges. A false 1 output occurs if Z is 0 just before two 
successive falling clock edges and Z goes to 1 between the edges. When the 
output is 0 (or 1) just before an active clock edge and 1 (or 0) just before the next, the output may be temporarily incorrect after the state changes 
414 Unit 13
following the first active edge but before the input has changed to its next 
value. In this case, we will not say that a false output has occurred because the sequence of outputs is still correct.
3. Study Section 13.3, State Tables and Graphs.
(a) In Equations (13-1) through (13-5), at what time (with respect to the clock) 
is the right-hand side evaluated?
What does Q
+ mean?
(b) Derive the timing chart of Figure 13-6 using Table 13-2(a).
(c) What is the difference between the state graphs for Mealy and Moore 
machines?
(d) For a state table, Table 13-3(b) for example, what do the terms “ present state,” 
“next state,” and “ present output” mean with respect to the active clock edge?
(e) Why does a Moore state table have only one output column?
(f  ) For ease in making state tables from Karnaugh maps and vice versa, tran-
sition tables with three or four states are often written with states in the 
order 00, 01, 11, 10. However, this is not necessary. (In fact, for sequential circuits with five or more states, it is impossible.) For example, the follow-ing transition table is equivalent to Table 13-2(a); the third and fourth rows have been interchanged. It equally represents the circuit of Figure 13-5.
ABA+B+
X=0X=1 Z
00 10 01 0
01 00 11 110 11 01 111 01 11 0
Clock
X
A
B
Z
Zd4. The following timing chart was derived from the circuit of Figure 13-7 .
Analysis of Clocked Sequential Circuits  415
(a) Noting that extra input changes which occur between clock pulses cannot 
affect the state of the circuit, what is the effective input sequence seen by 
the flip-flops in the circuit?
(b) Using Table 13-3, verify the waveforms given for A, B, and Z.
(c) Indicate any false outputs. What is the correct output sequence from the 
circuit?
(d) Using the effective input sequence from (a), determine the output sequence 
from the state graph (Figure 13-11). This output sequence should be the same as your answer to (c).
(e) The output 
Z is fed into a clocked D flip-flop, using the same clock (Clock) 
as the circuit. Sketch the waveform for Zd. Does Zd have any false outputs?
(f  ) Starting with Figure 13-11, construct the corresponding state table. Verify 
that your answer is the same as Table 13-3(b). Note that the output label on a given arrow of the graph is associated with the state from which the arrow originates.
(g) Assume that the flip-flops in Figure 13-7 are changed to flip-flops which trig-
ger on the rising edge of the clock; that is, the inversion circles are removed from the clock inputs. Also, the clock waveform in Figure 13-8 is replaced with
The input waveform is left unchanged. What changes, if any, would occur in 
the remainder of the timing diagram? Explain.
5. Consider the following state tables:D
Clock CK Q′Q Zd Z
Clock
Moore 
N.S.
P.S. X=01 Z
S0 S1S00
S1 S3S20
S2 S3S00
S3 S3S01Mealy  
N.S. Z
P.S. X=01 X=01
S0 S1S0 00
S1 S0S2 10
S2 S0S0 10
416 Unit 13
(a) Draw the corresponding state graphs.
(b) Show that the same output sequence is obtained from both state graphs when 
the input sequence is 010 (ignore the initial output for the Moore circuit).
(c) Using the state tables, complete the following timing diagrams for the 
two circuits. Note that the Mealy circuit has a false output, but the Moore 
does not. Also note that the output from the Moore circuit is delayed with respect to the Mealy.
ClockMealy
01 0
01StateX
S0 S1 S2S0
ZMoore
010X
S0
Z
D
ClockCombinational
CircuitD
Q2Q1Z1
Z2X1
X2
Q1+
Q2+(d) Work Programmed Exercise 13.1.
(e) Work Problems 13.2 and 13.3.
6. Study Section 13.4, General Models for Sequential Circuits.
(a) A Mealy sequential circuit has the form shown. The combinational circuit 
realizes the following equations:
Q+
1=X1′Q1+X1Q1′Q2′     Z1=X1Q1
Q+
2=X1Q2′+X2′Q1     Z2=X1′Q1+X2Q2′
Analysis of Clocked Sequential Circuits  417
Initially, X1=X2=1 and Q1=Q2=0 as shown.
(1) Before the falling clock edge, show the values of the four  combinational 
circuit outputs on the preceding diagram and on the following timing chart.
(2) Show the signal values on the circuit and timing chart immediately after 
the falling edge.
(3) Show any further changes in signal values which will occur after the new 
values of Q1 and Q2 have propagated through the circuit.
(4) Next change X1 to 0 and repeat steps (1), (2), and (3). Show the values for 
each step on the circuit and on the timing chart.
(5) Next change the inputs to X1=1 and X2=0 and repeat steps (1), (2), 
and (3).
(6) Change X2 to 1 and repeat.
Clock
X1
X2
Q1
Q2
Z1
Z2
(b) Draw a block diagram for a general model of a Mealy circuit, using 
J-K flip- flops as memory elements. If the circuit has n output variables and 
k flip-flops, how many outputs will the combinational subcircuit have?
(c) If the circuit of Figure 13-5 were not synchronized using a clock, but instead, 
the flip-flops were updated continuously, and if the XOR gate had a longer 
delay than the OR gate, what problem could appear?
(d) The minimum clock period for a Moore circuit is determined the same way 
as for a Mealy circuit. Should tc be determined by the combinational subcir-
cuit for the flip-flop inputs or for the outputs? (See Figure 13-19.)
(e) We can think of the binary counter of Figure 12-15 as a Moore circuit if we 
say the outputs Z1, Z2, and Z3 are Z1=A,  Z2=B, and Z3=C. (The com-
binational subcircuit for outputs has no gates, but that is okay.) If the XOR gates have a propagation delay of 
4  ns and the AND gate has a  propagation 
418 Unit 13
delay of 2  ns, what is the longest total propagation delay through the combi-
national subcircuit for flip-flops (i.e., the XOR gates and the AND gate) to 
the D inputs of the flip-flops? If the flip-flops have tsu=3 ns and tp=3 ns, 
what is the minimum clock period for the binary counter?
(f  ) In Equations (13-6) and (13-7), what do the symbols δ  and λ  mean?
Equation (13-7) is for a Mealy circuit. What is the corresponding equation for a Moore circuit?
(g) For Table 13-5,
7. Work Problems 13.4 through 13.6.
8. When you are satisfied that you can meet the objectives, take the readiness test.δ
(S3, 1)= ________________ λ(S3, 1)= ________________
δ(S1, 2)= ________________ λ(S1, 2)= ________________
Analysis of Clocked 
Sequential Circuits
The sequential circuits which we discussed in Chapter 12 perform simple functions 
such as shifting or counting. The counters we designed go through a fixed sequence of states and have no inputs other than a clock pulse that causes the state to change. We will now consider sequential circuits that have additional inputs. In general, the sequence of outputs and the sequence of flip-flop states for such circuits will depend on the input sequence which is applied to the circuit. Given a sequential circuit and an input sequence, we can analyze the circuit to determine the flip-flop state sequence and the output sequence by tracing the 0 and 1 signals through the circuit. Although signal tracing may be adequate for small circuits, for larger circuits it is better to construct a state graph or state table which represents the behavior 
Analysis of Clocked Sequential Circuits  419
of the circuit. Then, we can determine the output and state sequences from the 
graph or table. Such graphs and tables are also useful for the design of sequential circuits.
In this chapter we will also study the timing relationships between the inputs, the 
clock, and the outputs for sequential circuits by constructing timing diagrams. These timing relationships are very important when a sequential circuit is used as part of a larger digital system. After analyzing several specific sequential circuits, we will discuss a general model for a sequential circuit which consists of a combinational circuit together with flip-flops that serve as memory.
00000001
00000010011011011010101101110000
8-Bit Word7 Data Bits Parity Bits
Parity
CheckerZ
ClockX
(Data Input)FIGURE 13-1
Block Diagram 
for Parity Checker
© Cengage Learning 201413.1 A Sequential Parity Checker
When binary data is transmitted or stored, an extra bit (called a parity bit) is fre-
quently added for purposes of error detection. For example, if data is being trans-mitted in groups of 7 bits, an eighth bit can be added to each group of 7 bits to make the total number of 1’s in each block of 8 bits an odd number. When the total num-ber of 1 bits in the block (including the parity bit) is odd, we say that the parity is odd. Alternately, the parity bit could be chosen such that the total number of 1’s in the block is even, in which case we would have even parity. Some examples of 8-bit words with odd parity are
If any single bit in the 8-bit word is changed from 0 to 1 or from 1 to 0, the parity is 
no longer odd. Thus, if any single bit error occurs in transmission of a word with odd parity, the presence of this error can be detected because the number of 1 bits in the word has been changed from odd to even.
As a simple example of a sequential circuit which has one input in addition to 
the clock, we will design a parity checker for serial data. (Serial implies that the data enters the circuit sequentially, one bit at a time.) This circuit has the form shown in Figure 13-1. When a sequence of 0’s and 1’s is applied to the 
X input, the output of 
420 Unit 13
the circuit should be Z=1 if the total number of 1 inputs received is odd; that is, the 
output should be 1 if the input parity is odd. Thus, if data which originally had odd 
parity is transmitted to the circuit, a final output of Z=0 indicates that an error in 
transmission has occurred.
The value of X is read at the time of the active clock edge. The X input must be 
synchronized with the clock so that it assumes its next value before the next active clock edge. The clock input is necessary in order to distinguish consecutive 0’s or consecutive 1’s on the 
X input. Typical input and output waveforms are shown in 
Figure 13-2.
We will start the design by constructing a state graph (Figure 13-3). The sequen-
tial circuit must “remember” whether the total number of 1 inputs received is even or odd; therefore, only two states are required. We will designate these states as S
0 
and S1, corresponding respectively to an even number of 1’s received and an odd 
number of 1’s received. We will start the circuit in state S0 because initially zero 1’s 
have been received, and zero is an even number. As indicated in Figure 13-3, if the circuit is in state 
S0 (even number of 1’s received) and X=0 is received, the circuit 
must stay in S0 because the number of 1’s received is still even. However, if X=1 is 
received, the circuit goes to state S1 because the number of 1’s received is then odd. 
Similarly, if the circuit is in state S1 (odd number of 1’s received) a 0 input causes no 
state change, but a 1 causes a change to S0 because the number of 1’s received is then 
even. The output Z should be 1 whenever the circuit is in state S1 (odd number of 1’s 
received). The output is listed below the state on the state graph.
Table 13-1(a) gives the same information as the state graph in tabular form. For 
example, the table shows that if the present state is S0, the output is Z=0, and if the 
input is X=1, the next state will be S1.
Because only two states are required, a single flip-flop (Q) will suffice. We will let 
Q=0 correspond to state S0 and Q =1 correspond to S1. We can then set up a table 
which shows the next state of flip-flop Q as a function of the present state and X. If 
we use a T flip-flop, T must be 1 whenever Q and Q+ differ. From Table 13-1(b), the 
T input must be 1 whenever X=1. Figure 13-4 shows the resulting circuit.
Figure 13-2 shows the output waveform for the circuit. When X=1, the flip-flop 
changes state after the falling edge of the clock. Note that the final value of Z is 0 
because an even number of 1’s was received. If the number of 1’s received had been odd, the final value of 
Z would be l. In this case, it would be necessary to reset the 
FIGURE 13-2
Waveforms for 
Parity Checker
© Cengage Learning 2014Clock11 1 1 00 0 0X
Z = Q
FIGURE 13-3
State Graph for 
Parity Checker
© Cengage Learning 2014S0
Z = 0X = 1
X = 1S1
Z = 1X = 0 X = 0
Analysis of Clocked Sequential Circuits  421
flip-flop to the proper initial state (Q=0) before checking the parity of another 
input sequence.
13.2 Analysis by Signal Tracing  
and Timing Charts
In this section we will analyze clocked sequential circuits to find the output sequence 
resulting from a given input sequence by tracing 0 and 1 signals through the circuit. The basic procedure is as follows:
1. Assume an initial state of the flip-flops (all flip-flops reset to 0 unless otherwise 
specified).
2. For the first input in the given sequence, determine the circuit output(s) and flip-flop inputs.
3. Determine the new set of flip-flop states after the next active clock edge.
4. Determine the output(s) that corresponds to the new states.
5. Repeat 2, 3, and 4 for each input in the given sequence.
As we carry out the analysis, we will construct a timing chart which shows the 
relationship between the input signal, the clock, the flip-flop states, and the circuit output. We have already seen how to construct timing charts for flip-flops (Unit 11) and counters (Unit 12).
In this unit we will use edge-triggered flip-flops that change state shortly after 
the active edge (rising or falling edge) of the clock. We will assume that the flip-flop inputs are stable a sufficient time before and after the active clock edge so that setup and hold time requirements are met. When the state of the sequential circuit changes, the change will always occur in response to the active clock edge. The circuit output may change at the time the flip-flops change state or at the time the input changes depending on the type of circuit.(a)
Present 
StateNext State Present 
Output X=0 X=1
S0 S0 S1 0
S1 S1 S0 1
ClockCKQ′ Q
TZ
XFIGURE 13-4
Parity CheckerTABLE 13-1 
State and 
Transition Tables 
for Parity Checker(b)
QQ+T
Z X=0X=1X=0X=1
00 1 0 1 0
11 0 0 1 1© Cengage Learning 2014
© Cengage Learning 2014
422 Unit 13
Two types of clocked sequential circuits will be considered—those in which the out-
put depends only on the present state of the flip-flops and those in which the output 
depends on both the present state of the flip-flops and on the value of the circuit inputs. If the output of a sequential circuit is a function of the present state only (as in Figures 13-4 and 13-5), the circuit is often referred to as a Moore machine. The state graph for a Moore machine has the output associated with the state (as in Figures 13-3 and 13-9). If the output is a function of both the present state and the input (as in Figure 13-7), the circuit is referred to as a Mealy machine. The state graph for a Mealy machine has the 
output associated with the arrow going between states (as in Figure 13-11).
As an example of a Moore circuit, we will analyze Figure 13-5 using an input 
sequence 
X=01101. In this circuit, the initial state is A=B=0, and all state changes 
occur after the rising edge of the clock, as shown in Figure 13-6. The X input is synchro-
nized with the clock so that it assumes its next value after each rising edge. Because Z 
is a function only of the present state (in this case, Z =A ⊕ B) the output will only 
change when the state changes. Initially, X=0, so DA=1 and DB=0, and the state 
will change to A=1 and B=0 after the first rising clock edge. Then X is changed to 1, 
so DA=0, DB=1 and the state changes to AB=01 after the second rising clock edge. 
After the state change, X remains 1, so DA=DB=1, and the next rising edge causes 
the state to change to 11. When X changes to 0, DA=0 and DB=1, and the state 
changes to AB=01 on the fourth rising edge. Then, with X=1, DA=DB=1, so the 
Clock ClockA′ A
DAZ
XX A B′B′ B
DBFIGURE 13-5
Moore Sequential 
Circuit to Be 
Analyzed
(0) 1 1 0 1 0ClockX
A
B
ZFIGURE 13-6
Timing Chart for 
Figure 13-5 © Cengage Learning 2014
© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  423
fifth rising clock edge causes the state to change to AB=11. The input, state, and out-
put sequences are plotted on the timing chart of Figure 13-6 and are also listed below.
X= 0 1 1 0 1
A= 0 1 0 1 0 1
B= 0 0 1 1 1 1
Z=(0) 1 1 0 1 0
When the circuit is reset to its initial state (A=B=0), the initial output is Z=0. 
Because this initial 0 is not in response to any X input, it should be ignored. The 
resulting output sequence is Z=11010. Note that for the Moore circuit, the output 
which results from application of a given input does not appear until after the active 
clock edge; therefore, the output sequence is displaced in time with respect to the input sequence.
As an example of a Mealy circuit, we will analyze Figure 13-7 and construct a 
timing chart using the input sequence 
X=10101. The input is synchronized with 
the clock so that input changes occur after the falling edge, as shown in Figure 13-8. In this example, the output depends on both the input 
(X) and the flip-flop states 
(A  and  B), so Z may change either when the input changes or when the flip-flops 
change state. Initially, assume that the flip-flop states are A=0, B=0. If X=1, the 
output is Z =1 and JB=KA=1. After the falling edge of the first clock pulse, B  
changes to 1 so Z changes to 0. If the input is changed to X=0, Z will change back 
to 1. All flip-flop inputs are then 0, so no state change occurs with the second falling edge. When 
X is changed to 1, Z becomes 0 and JA=KA=JB=1. A changes to 1 
on the third falling clock edge, at which time Z changes to 1. Next, X is changed to 
0 so Z becomes 0, and no state change occurs with the fourth clock pulse. Then, X 
is changed to 1, and Z becomes 1. Because JA=KA=JB=KB=1, the fifth clock 
pulse returns the circuit to the initial state. The input, state, and output sequences are plotted on the timing chart of Figure 13-8 and are also listed below.
X=10  10  1
A=00  01  1 0
B=01  11  1 0
Z=1(0) 1  0(1) 0  1  (False outputs are indicated in parentheses.)
FIGURE 13-7
Mealy Sequential 
Circuit to Be 
Analyzed
© Cengage Learning 2014A′ A
JA KA
Z
X
XBCK
Clock ClockB′ B
JB KB
XX
B′
X
A
X′
A′
B
XACK
424 Unit 13
A careful interpretation of the output waveform (Z) of the Mealy circuit is nec-
essary. After the circuit has changed state and before the input is changed, the output 
may temporarily assume an incorrect value, which we call a false output. As indi-
cated on the timing chart, this false value arises when the circuit has assumed a new state but the old input associated with the previous state is still present.
For a clocked sequential circuit, the value of the input immediately preceding 
the active clock edge determines the next state of the flip-flops. Extra input changes which might occur between active clock edges do not affect the state of the flip-flops. In a similar manner, the output from a Mealy circuit is only of interest immediately preceding the active clock edge, and extra output changes (false outputs) which might occur between active clock edges should be ignored.
Two types of false outputs can occur, as indicated in Figure 13-8. In one case the 
output 
Z momentarily goes to 0 and returns to 1 before the active clock edge. In the 
other case, the output Z momentarily goes to 1 and returns to 0 before the active 
edge. These false outputs are often referred to as glitches and spikes. In both cases, 
two changes of output occur when no change is expected. Ignoring the false outputs by reading the output just before the falling clock edge, the output sequence for the circuit is Z =11001. If circuit delays are negligible, the false outputs could be 
eliminated if the input 
X was allowed to change only at the same time as the falling 
edge of the clock. If the output of the circuit is fed into a second sequential circuit which uses the same clock, the false outputs will not cause any problem because the inputs to the second circuit can cause a change of state only when a falling clock edge occurs. Because the output of a Moore circuit can change state only when the flip-flops change state and not when the input changes, no false outputs can appear in a Moore circuit.
For the Mealy circuit, the output which corresponds to a given input appears 
shortly after the application of that input. Because the correct output appears before the active clock edge, the output sequence is not displaced in time with respect to the 
input sequence as was the case for the Moore circuit. There are a few examples of Moore circuits (i.e., a circuit whose outputs only depend on the present state) whose outputs are not delayed with respect to the input sequence. (See Problem 13.17 for an example.)11
"False" 1 output "False" 0 output10 001 11 0
ClockX
A
B
ZFIGURE 13-8
Timing Chart 
for Circuit of 
Figure 13-7
© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  425
13.3 State Tables and Graphs
In the previous section we analyzed clocked sequential circuits by signal tracing and 
the construction of timing charts. Although this is satisfactory for small circuits and short input sequences, the construction of state tables and graphs provides a more systematic approach which is useful for the analysis of larger circuits and which leads to a general synthesis procedure for sequential circuits.
The transition table and the state table for a sequential circuit specify the next 
state and output of the circuit in terms of its present state and input. A state in a transition table is specified by the flip-flop output values corresponding to the state. A state in a state table is specified symbolically. When analyzing a sequential circuit, the transition table is derived from the circuit as described below. Given a transition table, a state table for the circuit is derived by assigning symbols to the states. The design process for a sequential circuit reverses this process; usually a state table is determined first; then a transition table is derived by assigning binary combinations to the states.
The following method can be used to construct the transition table:
1. Determine the flip-flop input equations and the output equations from the circuit.
2. Derive the next-state equation for each flip-flop from its input equations, using one of the following relations:
D
  flip-flop Q+=D (13-1)
D-CE   flip-flop Q+=D·CE+Q·CE′ (13-2)
T  flip-flop Q+=T ⊕ Q (13-3)
S-R   flip-flop Q+=S+R′Q (13-4)
J-K  flip-flop Q+=JQ ′+K′Q (13-5)
3. Plot a next-state map for each flip-flop.
4. Combine these maps to form the transition table. Such a transition table, which gives the next state of the flip-flops as a function of their present state and the circuit inputs.
As an example of this procedure, we will derive the transition table for the circuit of Figure 13-5:
1. The flip-flop input equations and output equation are
D
A=X ⊕ B ′ DB=X+Α Z=A ⊕ B
2. The next-state equations for the flip-flops are
A+=X ⊕ B ′ B+=X+A
426 Unit 13
4. Combining these maps yields the transition table in Table 13-2(a), which gives 
the next state of both flip-flops (A+B+) as a function of the present state and 
input. The output function Z is then added to the table. In this example, the out-
put depends only on the present state of the flip-flops and not on the input, so only a single output column is required.
Using Table 13-2(a), we can construct the timing chart of Figure 13-6 or any 
other timing chart for some given input sequence and specified initial state. Initially 
AB=00 and X=0, so Z=0 and A+B+=10. This means that after the rising clock 
edge, the flip-flop state will be AB=10. Then, with AB=10, the output is Z =1. 
The next input is X=1, so A+B+=01 and the state will change after the next rising 
clock edge. Continuing in this manner, we can complete the timing chart.
If we are not interested in the flip-flop output values corresponding to the states, 
we can replace each combination of flip-flop states with a single symbol which rep-resents the state of the circuit. Replacing 00 with S
0, 01 with S1, 11 with S2, and 10 
with S3 in Table 13-2(a) yields the state table shown in Table 13-2(b). The Z column 
is labeled Present Output because it is the output associated with the Present State. The state graph of Figure 13-9 represents Table 13-2(b). Each node of the graph represents a state of the circuit, and the corresponding output is placed in the circle below the state symbol. The arc joining two nodes is labeled with the value of 
X 
which will cause a state change between these nodes. Thus, if the circuit is in state S0 
and X=1, a clock edge will cause a transition to state S1.1001
01
01100AB
A
+X
01
1110 00101
01
11
100AB
B+X
01
11
10 13. The corresponding maps are
(a)
ABA+B+
Z X=0 X=1
00 10 01 0
01 00 11 111 01 11 010 11 01 1TABLE 13-2 
Moore Transition 
and State Tables for 
Figure 13-5(b)
Present 
StateNext State Present 
Output (Z) X=0 X=1
S0 S3 S1 0
S1 S0 S2 1
S2 S1 S2 0
S3 S2 S1 1© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  427
Next, we will construct the state table and graph for the Mealy machine of 
Figure 13-7. The next-state and output equations are
A+=JAA′+KA′A=XBA ′+X′A
B+=JBB′+KB′B=XB ′+(AX) ′B=XB ′+X′B+A′B
 Z=X′A′B+XB ′+XA
The next-state and output maps (Figure 13-10) combine to form the transition table 
in Table 13-3(a). Given values for A, B, and X, the current value of the output is 
determined from the Z column of this table, and the states of the flip-flops after the 
active clock edge are determined from the A+B+ columns.
We can construct the timing chart of Figure 13-8 using Table 13-3(a). Initially 
with A=B=0 and X=1, the table shows that Z =1 and A+B+=01. Therefore, 
after the falling clock edge, the state of flip-flop B will change to 1, as indicated in 
Figure 13-8. Now, from the 01 row of the table, if X is still 1, the output will be 0 until 
the input is changed to X=0. Then, the output is Z=1, and the next falling clock 
edge produces no state change. Finish stepping through the state table in this man-ner and verify that 
A, B, and Z are as given in Figure 13-8.
If we let AB=00 correspond to circuit state S0, 01 to S1, 11 to S2, and 10 to S3, 
we can construct the state table in Table 13-3(b) and the state graph of Figure 13-11. In Table 13-3(b), the Present Output column gives the output associated with the 
0001
01
10100AB
A
+X
01
1110 00101
11
10000AB
B
+X
01
1110 10101
10
01
000AB
ZX
01
11
10 1FIGURE 13-1011
0 00
0
1
1S0
0
S1
1
S2
0S3
1FIGURE 13-9
Moore State  
Graph for 
Figure 13-5
© Cengage Learning 2014
© Cengage Learning 2014
428 Unit 13
present state and present input. Thus, if the present state is S0 and the input changes 
from 0 to 1, the output will immediately change from 0 to 1. However, the state will 
not change to the next state (S1) until after the clock pulse. For Figure 13-11, the 
labels on the arrows between states are of the form X/Z, where the symbol before 
the slash is the input and the symbol after the slash is the corresponding output. Thus, in state S
0 an input of 0 gives an output of 0, and an input of 1 gives an out-
put of 1. For any given input sequence, we can easily trace out the state and output sequences on the state graph. For the input sequence 
X=10101, verify that the cor-
responding output sequence is 11001. This agrees with Figure 13-8 if the false out-puts are ignored. Note that the false outputs do not show on the state graph because the inputs are read at the active clock edge, and no provision is made for extra input changes between active edges.
Next, we will analyze the operation of a serial adder (Figure 13-12(a)) that adds 
two n-bit binary numbers 
X=xn–1 · · · x1x0 and Y =yn–1 · · · y1y0. The operation of the 
serial adder is similar to the parallel adder of Figure 4-2 except that the binary num-bers are fed in serially, one pair of bits at a time, and the sum is read out serially, one bit at a time. First, 
x0 and y0 are fed in; a sum digit s0 is generated, and the carry c1 is 
stored. At the next clock time, x1 and y1 are fed in and added to c1 to give the next 
sum digit s1 and the new carry c2, which is stored. This process continues until all bits 
have been added. A full adder is used to add the xi, yi and ci bits to form ci+1 and si.  
A D flip-flop is used to store the carry (ci+1) on the rising edge of the clock. The xi 
and yi inputs must be synchronized with the clock.
Figure 13-13 shows a timing diagram for the serial adder. In this example we 
add 10011 +00110 to give a sum of 11001 and a final carry of 0. Initially the carry 
flip-flop must be cleared so that c0=0. We start by adding the least-significant (right-
most) bits in each word. Adding 1 +0+0 gives s0=1 and c1=0, which is stored in 
the flip-flop at the rising clock edge. Because y1 is 1, adding 1 +1+0 gives s1=0 (a)
ABA+B+Z
X= 01 X= 01
00 00 01 0 1
01 01 11 1 011 11 00 0 1
10 10 01 0 1TABLE 13-3 
Mealy T ransition 
and State Tables  
for Figure 13-7(b)
Present
StateNext StatePresent 
Output
X= 01 X= 01
S0 S0S1 01
S1 S1S2 10
S2 S2S0 01
S3 S3S1 01
S0
S3 S1 S2
0
01
01
11
10
0
1
1 0
0
0
1FIGURE 13-11
Mealy State  
Graph for 
Figure 13-7
© Cengage Learning 2014© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  429
and c2=1, which is stored in the flip-flop on the rising clock edge. This process con-
tinues until the addition is completed. Reading the sum output just before the rising 
edge of the clock gives the correct result.
The truth table for the full adder (Table 4-4) is repeated in Figure 13-12(b) in 
modified form. Using this table, we can construct a state graph (Figure 13-14) for the serial adder. The serial adder is a Mealy machine with inputs 
xi and yi and output si. 
The two states represent a carry (ci) of 0 and 1, respectively. From the table, ci is the 
present state of the sequential circuit, and ci+1 is the next state. If we start in S0 (no 
carry), and xi  yi=11, the output is si=0 and the next state is S1. This is indicated by 
the arrow going from state S0 to S1.
Table 13-4 shows a state table for a Mealy sequential circuit with two inputs 
and two outputs. Figure 13-15 shows the corresponding state graph. The notation 00, 01/00 on the arc from S
3 to S2 means if X1=X2=0 or X1=0 and X2=1, then 
Z1=0 and Z2=0.FIGURE 13-12
Serial Adder
© Cengage Learning 2014
Clock CK Q′Q Dxi
yi
cisi
ci + 1
(a) With D flip-flopFull
Adder
FIGURE 13-13
Timing Diagram  
for Serial Adder
© Cengage Learning 2014
11 1 00Clock
xi
yi
ci
ci + 1
sixiyici ci1si
000 0 0
00 10 1
01 00 1
01 11 0
10 00 1
10 11 0
11 01 0
11 11 1
(b) Truth table
FIGURE 13-14
State Graph for 
Serial Adder
© Cengage Learning 2014xiyisi00
001
110
111
0
00
1,, 01
010
011
1,,
S0 S1
430 Unit 13
Construction and Interpretation of Timing Charts
Several important points concerning the construction and interpretation of timing 
charts are summarized as follows:
1. When constructing timing charts, note that a state change can only occur 
after the rising (or falling) edge of the clock, depending on the type of flip-flop used.
2. The input will normally be stable immediately before and after the active clock edge.
3. For a Moore circuit, the output can change only when the state changes, but for a Mealy circuit, the output can change when the input changes as well as when the state changes. A false output may occur between the time the state changes and the time the input is changed to its new value. (In other words, if the state has changed to its next value, but the old input is still present, the output may be temporarily incorrect.)
4. False outputs are difficult to determine from the state graph, so use either signal tracing through the circuit or use the state table when constructing timing charts for Mealy circuits.Present 
StateNext State Present Output (Z1Z2)
X1X2 = 00 01 10 11 X1X2= 00 01 10 11
S0 S3S2S1S0 00 10 11 01
S1 S0S1S2S3 10 10 11 11
S2 S3S0S1S1 00 10 11 01
S3 S2S2S1S0 00 00 01 01TABLE 13-4 
A State Table with 
Multiple Inputs  
and Outputs
00
1010
1101
10
01
1011
1111
0111
01
00
00
10
01
00
0001
10 10
11
10
1111
0100, 01
00,S0
S1
S2S3FIGURE 13-15
State Graph for 
Table 13-4
© Cengage Learning 2014© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  431
5. When using a Mealy state table for constructing timing charts, the procedure is 
as follows:(a) For the first input, read the present output and plot it.(b) Read the next state and plot it (following the active edge of the clock pulse).(c) Go to the row in the table which corresponds to the next state and read the 
output under the old input column and plot it. (This may be a false output.)
(d) Change to the next input and repeat steps (a), (b), and (c). (Note: If you are just trying to read the correct output sequence from the 
table, step (c) is naturally omitted.)
6. For Mealy circuits, the best time to read the output is just before the active edge of the clock, because the input(s) must be stable at that time and the output will be correct.
The example in Figure 13-16 shows a state graph, a state table, a circuit that imple-
ments the table, and a timing chart. When the state is 
S0 and the input is X=0, the 
output from the state graph, state table, circuit, and timing chart is Z=1 (labeled A 
on the figure). Note that this output occurs before the rising edge of the clock. In a 
Mealy circuit, the output is a function of the present state and input; therefore, the output should be read just before the clock edge that causes the state to change.
S1 S0
Clock
State, Q
X
Z
AS0 S1 S1ZXAA
B B F FA
EDD
E
B CD
Read X and Z in shaded area
(before rising edge of clock).Inital values
are shown.
E F0
10
0Q
D Q′ 110/1
1/1
0/0 0 1QX  = 01 1 0
00 S0S1 S1
1 S1S0 S1, 1/0
ClockFIGURE 13-16
© Cengage Learning 2014
432 Unit 13
As you continue to study this example, each time the input X changes, trace the 
changes on the state graph, the state table, the circuit, and the timing chart. Because 
the input X was 0 before the first rising edge of the clock, the state changes to S1 
after the first rising edge of the clock. Because of the state change, the output also changes (B on the timing chart), but because the input has not yet changed to its new value, the output value may not be correct. We refer to this as a false output or glitch. 
If the input changes several times before it assumes its correct value, the output may also change several times 
(C). The input must assume its correct value before the ris-
ing edge of the clock, and the output should be read at this time (D). After the rising 
clock edge, the state stays the same and the output stays the same for this particular example. In general, the state may change after a rising edge of the clock, and the state change may result in an output change. Again, the output value may be wrong because the input still has the old value 
(E). When the input is changed to its new 
value, the output changes to its new value (F), and this value should be read before 
the next rising clock edge.
If we look at the input and output just before each rising edge of the clock, we 
find the following sequences:
X=010
Z=110
You should be able to verify the sequence for Z using the state graph, using the state 
table, and using the circuit diagram.
The synthesis procedure for sequential circuits, discussed in detail in Units 14 
through 16, is just the opposite of the procedure used for analysis. Starting with the specifications for the sequential circuit to be synthesized, a state graph is con-structed. This graph is then translated to a state table, and the flip-flop output values are assigned for each state. The flip-flop input equations are then derived, and finally, the logic diagram for the circuit is drawn. For example, to synthesize the circuit in Figure 13-7 , we would start with the state graph of Figure 13-11. Then, we would derive the state table in Table 13-3(b), the transition table in Table 13-3(a), the next-state and output equations, and, finally, the circuit of Figure 13-7 .
13.4 General Models for Sequential Circuits
A sequential circuit can be divided conveniently into two parts—the flip-flops which serve as memory for the circuit and the combinational logic which realizes the input functions for the flip-flops and the output functions. The combinational logic may be implemented with gates, with a ROM, or with a PLA. Figure 13-17 illustrates the general model for a clocked Mealy sequential circuit with m inputs, n  outputs, and 
k clocked D flip-flops used as memory. Drawing the model in this form emphasizes 
the presence of feedback in the sequential circuit because the flip-flop outputs are fed back as inputs to the combinational subcircuit. The combinational subcircuit realizes 
Analysis of Clocked Sequential Circuits  433
the n output functions and the k next-state functions, which serve as inputs to the  
D flip-flops:
Z1=f1(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk)
Z2=f2(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk)
 ⋮
Zn=fn(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk) . n output functions
Q+
1=D1=g1(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk)
Q+
2=D2=g2(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk)
 ⋮
Q+
k=Dk=gk(X1, X2, . . . , Xm, Q1, Q2, . . . , Qk) . k next-state 
          functionsFIGURE 13-17
General Model  
for Mealy Circuit 
Using Clocked  
D Flip-Flops
© Cengage Learning 2014
DkQk
CK
ClockCombinational
Subcircuit
Q2Q1D1
D2Z1
Z2X1
X2
QkZn Xm
Qk+CKQ2
Q2+CKQ1
Q1+......
...
............
When a set of inputs is applied to the circuit, the combinational subcircuit gener-
ates the outputs (Z1, Z2, . . . , Zn) and the flip-flop inputs (D1, D2, . . . ,  Dk). Then, a 
clock pulse is applied and the flip-flops change to the proper next state. This process 
is repeated for each set of inputs. Note that at a given point in time, the outputs of the flip-flops represent the present state of the circuit 
(Q1, Q2, . . . ,  Qk). These Qi’s 
feed back into the combinational circuit, which generates the flip-flop inputs using the Q
i’s and the X inputs. When D flip-flops are used, Di=Q+
i; therefore, the combi-
national circuit outputs are labeled Q+
1, Q+
2, etc. Although the model in Figure 13-17 
uses D flip-flops, a similar model may be used for other types of clocked flip-flops, in 
434 Unit 13
which case the combinational circuit must generate the appropriate flip-flop inputs 
instead of the next-state functions.
The clock synchronizes the operation of the flip-flops and prevents timing prob-
lems. The gates (or other logic) in the combinational subcircuit have finite propaga-tion delays, so when the inputs to the circuit are changed, a finite time is required before the flip-flop inputs reach their final values. Because the gate delays are not all the same, the flip-flop input signals may contain transients, and they may change at different times. If the next active clock edge does not occur until all flip-flop input signals have reached their final steady-state values, the unequal gate delays will not cause any timing problems. All flip-flops which must change state do so at the same time in response to the active edge of the clock. When the flip-flops change state, the new flip-flop outputs are fed back into the combinational subcircuit. However, no further change in the flip-flop states can occur until the next clock pulse.
We can determine the fastest clock speed (the minimum clock period) from the 
general model of the Mealy circuit in Figure 13-17 . The computation of the minimum clock period is similar to that of Figure 11 -21, except that we must also consider the effect of the 
X inputs. Figure 13-18 shows the sequence of events during one clock 
period. Following the active edge of the clock the flip-flops change state, and the flip-flop output is stable after the propagation delay ( t
p). The new values of Q then 
propagate through the combinational circuit so that the D values are stable after the 
combinational circuit delay (tc). Then, the flip-flop setup time (tsu) must elapse before 
the next active clock edge. Thus, the propagation delay in the flip-flops, the propaga-tion delay in the combinational subcircuit, and the setup time for the flip-flops deter-mine how fast the sequential circuit can operate, and the minimum clock period is
t
clk (min)=tp+tc+tsu
The preceding discussion assumes that the X inputs are stable no later than tc+tsu 
before the next active clock edge. If this is not the case, then we must calculate the minimum clock period by
t
clk (min)=tx+tc+tsu
where tx is the time after the active clock edge at which the X inputs are stable.
Another property of the circuit affecting the minimum clock period is the clock 
skew. The clock edge that causes the flip-flops to change state does not necessarily reach all flip-flop clock inputs at the same time; the difference in the arrival time of the clock edges to two flip-flops is the clock skew for those two flip-flops. Clock skew is caused by differing propagation delays over the clock lines and by different clock buffer propagation delays. In Figure 13-18, assume that the clock skew between the two flip-flops is t
sk. Furthermore, assume that the clock skew is such that the second 
flip-flop receives the clock edge before first flip-flop does. Then, the clock skew is added to setup time as part of the clock period. The minimum clock period is
T
clk (min)=tp+tc+tsu+tsk
A different constraint applies if the clock skew is such that the second flip-flop receives the clock edge after the first flip-flop does. In this case, proper circuit 
Analysis of Clocked Sequential Circuits  435
operation requires that the input to the second flip-flop not change until after the 
clock skew time plus the flip-flop hold time, th. It is necessary that
tp+tc≥tsk+th
In the worst case, there may not be any combinational logic between the two flip-flops (e.g., a shift register does not have any logic between the flip-flops). In this case,
t
p≥tsk+th
In order to satisfy this constraint, it may be necessary to route the clock line so the second flip-flop receives the clock signal before the first clock signal.
The general model for the clocked Moore circuit (Figure 13-19) is similar to the 
clocked Mealy circuit. The output subcircuit is drawn separately for the Moore cir-cuit because the output is only a function of the present state of the flip-flops and not a function of the circuit inputs. Operation of the Moore circuit is similar to that of the Mealy except when a set of inputs is applied to the Moore circuit, the result-ing outputs do not appear until after the clock causes the flip-flops to change state.
To facilitate the study of sequential circuits with multiple inputs and outputs, 
the assignment of symbols to represent each combination of input values and each combination of output values is convenient. For example, we can replace Table 13-4 
Minimum Clock Period (tclk)
Flip-Flop
Propagation
Delay
(tp)Combinational
Circuit Delay
(tc)Setup Time
(tsu)
Active edge
of ClockQ
Outputs
StableD
Inputs
StableNext active
Edge of ClockFIGURE 13-18
Minimum Clock 
Period for a 
Sequential Circuit
FIGURE 13-19
General Model  
for Moore Circuit 
Using Clocked  
D Flip-Flops
© Cengage Learning 2014
DkQk
CK
ClockCombinational
Subcircuit
(for Flip-Flop
Inputs)Combinational
Subcircuit
(for Outputs)Q2Q1D1
D2Z1
Z2X1
X2
QkZn Xm
Qk+CKQ2
Q2+CKQ1
Q1+
......
...
...
.........
..................© Cengage Learning 2014
436 Unit 13
with Table 13-5 if we let X=0 represent the input combination X1X2=00,    X=1 
represent X1X2=01, etc., and similarly let Z =0 represent the output combination 
Z1Z2=00,   Z=1, represent Z1Z2=01, etc. In this way we can specify the behavior 
of any sequential circuit in terms of a single input variable X and a single output 
variable Z.
Table 13-5 specifies two functions, the next-state function and the output function. 
The next-state function, designated δ, gives the next state of the circuit (i.e., the state 
after the clock pulse) in terms of the present state (S) and the present input (X):
 S+=δ(S, X) (13-6)
The output function, designated λ , gives the output of the circuit (Z) in terms of the 
present state (S) and input (X):
 Z=λ(S, X) (13-7)
Values of S+ and Z can be determined from the state table. From Table 13-5, we have
δ(S0, 1)=S2   δ(S2, 3)=S1
λ(S0, 1)=2   λ(S2, 3)=1
We will use the λ and δ notation when we discuss equivalent sequential circuits in 
Unit 15.
Programmed Exercise 13.1
Cover the answer to each exercise with a sheet of paper and slide it down as you 
check your answers.
13.1(a) In this exercise you will analyze the following sequential circuit using a state table 
and a timing chart.
Derive the next-state and output equations.
A+ = _____________________________________________
  B+ = _____________________________________________
Z   = _____________________________________________Present 
StateNext State Present Output (Z)
X= 0123 X= 0123
S0 S3S2S1S0 0231
S1 S0S1S2S3 2233
S2 S3S0S1S1 0231
S3 S2S2S1S0 0011TABLE 13-5 
State Table with 
Multiple Inputs  
and Outputs
© Cengage Learning 2014
Analysis of Clocked Sequential Circuits  437
AnswerA′ A
ADAZ
BCK
ClockB′ B
JB KB
X′X′
X XB
X
A
A′CK
Z=XA+X′B,  B+=(A′ ⊕ X)B′+XB=A′B′X′+AB ′X+XB
A+=B(A+X)
13.1(b) Plot these equations on maps and complete the transition table.
01
00AB
A+X
01
11
1001
00AB
B+X
01
111001
00AB
ZX
01
1110ABA+B+Z
X=0 1 0 1
00
0111
10
 Answer to 13.1(b)
ABA+B+Z
X=010 1
S0 00 01 00 0 0
S1 01 00 11 1 0
S2 11 10 11 1 1
S3 10 00 01 0 1
13.1(c) Convert your transition table to a state table using the given state numbering.
Next State Output
X=0101
S0
S1
S2
S3
438 Unit 13
 Answer to 13.1(c)
X=010 1
S0 S1S000
S1 S0S210
S2 S3S211
S3 S0S101
 
13.1(d) Complete the corresponding state graph.
S0
S1
S2S30
01
0
 Answer to 13.1(d)
S0
S1
S2S3
1
0
1
11
10
10
01
0
0
0
0
1
Analysis of Clocked Sequential Circuits  439
13.1(e) Using this graph, determine the state sequence and output sequence if the initial 
state is S0 and the input sequence is X=0, 1, 0, 1.
(1) The initial output with X=0 in state S0 is Z = ___________ and the next state 
is ___________.
(2) The output in this state when the next input (X=1) is applied is Z= 
___________ and the next state is ___________.
(3) When the third input (X=0) is applied, the output is Z = ___________  and the 
next state is ___________.
(4) When the last input is applied, Z  = _________ and the final state is __________.
In summary, the state sequence is S0, ___________, ___________, ___________, 
___________. The output sequence is Z  = ___________.
Clock
X Answer to 13.1(e) S0, S1, S2, S3, S1  Z=0011
13.1(f) This sequence for Z is the correct output sequence. Next, we will determine the 
timing chart including any false outputs for Z. Assuming that X changes midway 
between falling and rising clock edges, draw the waveform for X  (X=0, 1, 0, 1).
Clock
X
A
BABA+B+
1 X=0
00 01 00
01 00 1111 10 11
10 00 01
13.1(g) Referring to the transition table, sketch the waveforms for A and B  assuming that 
initially A=B=0. The state sequence is
AB=00, ___________, ___________, ___________, ___________.Answer
440 Unit 13
Answer  (Note that A and B  change immediately after the falling clock edge.)
Clock
X
A
B
Z
t7 t6 t5 t4 t3 t2 t1ABZ
X=01
00 0 0
01 1 011 1 110 0 1
Check your state sequence  
against the answer to 13.1(e), noting that S
0=00,   S1=01,   S2=11 
and S3=10.
13.1(h) Using the output table, sketch the waveform for Z. At time t1, X=A=B=0,  
so Z  = ___________. At time t2, X  = __________ and AB  = ___________, 
so    Z   = ___________. At time t3, X  = ___________ and AB  = ___________, so 
Z  = ___________. Complete the waveform for Z, showing the output at t4,  t5, etc.
Answer   (Note that Z can change immediately following the change in X or immediately  
following the falling clock edge.)
Clock
X
Z
t7 t6 t5 t4 t3 t2 t1
13.1(i) (1)  Because this is a Mealy circuit, the correct times to read the output are during 
intervals t1, __________, __________, and __________.
(2) The correct output sequence is therefore Z = ___________.
(3) False outputs may occur during intervals ___________, ___________, and 
___________.
(4) In two of these intervals, false outputs actually occur. These intervals are 
___________ and ___________.
Analysis of Clocked Sequential Circuits  441
Answer  (1) t1, t3, t5 and t7
(2) Check your Z sequence against the answer to 13.1(e).
(3) t2, t4, and t6
(4) t2 and t6 (output during t4 is not false because it is the same as t5).
13.1(j) Finally, we will verify part of the timing chart by signal tracing on the original circuit 
(see 13.1(a)).
(1) Initially, A=B=0 and X=0, so DA= ___________,  JB= ___________,  
KB= ___________, and Z = ___________.
(2) After the clock pulse A= ___________, B = ___________, and  
Z= ___________.
(3) After X is changed to 1, DA= ___________,  JB= ___________,  
KB= ___________, and Z = ___________.
(4) After the clock pulse, A= ___________, B = ___________, and  
Z= ___________.
Check your answers against the timing chart. Answer to (1) corresponds to t1, (2) to 
t2, (3) to t3, and (4) to t4.
S
R
ClockCKXZ S
RCK
Q2Q2 Q3 S
RCK
Q3 Q1Q1
′′ ′
13.3 (a)  For the following sequential circuit, find the next-state equation or map for each 
flip-flop. (Is this a Mealy or Moore machine?) Using these next-state equations or maps, construct a transition table and graph for the circuit.
(b) What is the output sequence when the input sequence is 
X=01100?
(c) Draw a timing diagram for the input sequence in (b). Show the clock, X, A, B,  
and Z. Assume that the input changes between falling and rising clock edges.Problems
13.2 Construct a transition graph for the shift register shown. ( X is the input, and Z is the 
output.) Is this a Mealy or Moore machine?
442 Unit 13
13.4 A sequential circuit has the form shown in Figure 13-17 , with
D1=Q2Q3′   D3=Q2′ +X
D2=Q3      Z=XQ2′ +X′Q2
(a) Construct a transition table and state graph for the circuit. (Is this a Mealy or 
Moore machine?)
(b) Draw a timing diagram for the circuit showing the clock, X, Q1, Q2, Q3  and Z. 
Use the input sequence X=01011. Change X between clock edges so that we 
can see false outputs, and indicate any false outputs on the diagram.
(c) Compare the output sequence obtained from the timing diagram with that from 
the transition graph.
(d) At what time with respect to the clock should the input be changed in order to 
eliminate the false output(s)?
13.5 Below is a transition table with the outputs missing. The output should be 
Z=X′B′+XB.
(a) Is this a Mealy machine or Moore machine?
(b) Fill in the outputs on the transition table.
(c) Give the transition graph.
(d) For an input sequence of X=10101, give a timing diagram for the clock, 
X, A, B, C, and Z. State changes occur on the rising clock edge. What is the cor-
rect output sequence for Z? Change X between rising and falling clock edges 
so that we can see false outputs, and indicate any false outputs on the diagram.ClockA′ A
JA KA
X′
X′Z
A′
B′B
XCK
ClockB′ B
JB KBCK
A+B+C+
ABC X=0X=1
000 011 010
001 000 100010 100 100011 010 000100 100 001
Analysis of Clocked Sequential Circuits  443
13.6 A sequential circuit of the form shown in Figure 13-17 is constructed using a ROM 
and two rising-edge-triggered D flip-flops. The contents of the ROM are given in 
the table. Assume the propagation delay of the ROM is 8 ns, the setup time for the 
flip-flops is 2  ns, and the propagation delay of the flip-flops is 4 ns.
(a) What is the minimum clock period for this circuit?
(b) Draw a timing diagram for this circuit, using the given delays and the mini-
mum clock period of part (a). Give the clock, X, D1, D2, Q1, Q2 and Z. Assume 
Q1Q2=00 to start with and assume X takes on its new value 4 ns after each 
rising edge. Use the input sequence X=0, 1, 1, 0. Specify the correct output 
sequence for Z.
(c) Construct a state table and a state graph for the circuit.
13.7 (a) Construct a transition table and state graph for the circuit shown.
(b) Construct a timing chart for the circuit for an input sequence X=10111. 
(Assume that initially Q1=Q2=0 and that X changes midway between the 
rising and falling clock edges.)
(c) List the output values produced by the input sequence.Q1Q2X D1D2 Z
0 00100
0 011000 100000 111101 001101 010111 100111 11111
X
ZClk Ck FFQ1 J1
K1
Ck FFQ2 J2
K2Q2′Q1′
444 Unit 13
13.9 (a) Construct a transition table and state graph for the circuit shown.
(b) Construct a timing chart for the input sequence X1X2=11, 11, 01, 10, 10, 00. 
(Assume that initially Q1=Q2=0 and that X1 and X2 change midway between 
the rising and falling clock edges.)
(c) List the output values produced by the input sequence.X
ZClk Ck FFQ1 J1
K1
Ck FFQ2 J2
K2Q2′Q1′13.8 (a) Construct a transition table and state graph for the circuit shown.
(b) Construct a timing chart for the input sequence X=10101. (Assume that ini-
tially Q1=Q2=0 and that X changes midway between the rising and falling 
clock edges.) Indicate the times Z has the correct value.
(c) List the output values produced by the input sequence.
ClockZ
CkD2 Q2
Q2′CkD1 Q1
Q1′Q1
Q1
Q2
X1′
Q2
X1
X1′
X2′X1′
X2′
X2
Q2Q1′
Analysis of Clocked Sequential Circuits  445
13.11 (a) Construct a transition table and state graph for the given circuit.
(b) Construct a timing chart for the circuit for an input sequence X=10011. 
Indicate at what times Z has the correct value and specify the correct output 
sequence. (Assume that X changes midway between falling and rising clock 
edges.) Initially, Q1=Q2=0.ClockX2
Z
CkD2 Q2
Q2′CkD1 Q1
Q1′
Q1′
Q2X1
Q1
Q1
Q2
X2
Q2
1X1
X2′X′X2
Q2
Q1′
Q1 Q1 Q2 Q2
J1 K1 J2 K2
XXX
XZX
Q2 Q1Clock Clock′ ′
′13.10 (a) Construct a transition table and state graph for the circuit shown.
(b) Construct a timing chart for the input sequence X1X2=01, 10, 01, 11, 11, 01. 
(Assume that initially Q1=Q2=0 and that X1 and X2 change midway between 
the rising and falling clock edges.)
(c) List the output values produced by the input sequence.
446 Unit 13
13.13 A sequential circuit has one input X, one output Z, and three flip-flops Q1, Q2 and 
Q3. The transition and output tables for the circuit follow:13.12 Repeat Problem 13.11 for the circuit below and X1X2=10, 01, 10, 11, 11, 10.
X2ClockQ1 Q1 Q2 Q2
D1 D2Z
Q1 Q1Clock
Q2 X1 X1X2
X1X2 X1Q2 Q2 Q1 ′′ ′
′ ′
Present 
StateNext State Output (Z)
X=0 X=1 X=0 X=1
000 100 101 1 0
001 100 101 0 1010 000 000 1 0011 000 000 0 1100 111 110 1 0101 110 110 0 1110 011 010 1 0111 011 011 0 1
(a) Construct a timing chart for the input sequence X=0101 and initial state 
Q1Q2Q3=000. Identify any false outputs. (Assume that the flip-flops are rising-
edge triggered and that the input changes midway between the rising and falling 
edges of the clock.)
(b) List the output values produced by the input sequence.
13.14 Repeat Problem 13.13 for the input sequence X=1001 and initial state Q1Q2Q3=000.
13.15 A sequential circuit has the form shown in Figure 13-17 with
D1=Q2Q3′+XQ1′      D3=Q2′+X
D2=Q3+X′Q2      Z=XQ2′+X′Q2
Analysis of Clocked Sequential Circuits  447
(a) Construct a state table and state graph for the circuit.
(b) Draw a timing diagram for the circuit showing the clock, X, Q1, Q2, Q3 and Z. 
Use the input sequence X=01011 and assume that X changes midway between 
falling and rising clock edges. Indicate any false outputs on the diagram.
(c) Compare the output sequence obtained from the timing diagram with that from 
the state graph.
(d) At what time with respect to the clock should the input be changed in order to 
eliminate the false output(s)?
13.16 Repeat Problem 13.15 for the given equations and the input sequence X=01100.
D1=Q3′X′        D3=Q3′X+Q1Q2
D2=Q3′Q1+XQ2′       Z=XQ3+X′Q′
13.17 Two sequential circuits have the form shown in Figure 13-17. The initial state of 
both circuits is Q2Q1Q0 =000. The two circuits perform the same function but with 
different timing between the input and output.
(a) Construct a state table and state graph for each circuit. (In the state graphs only 
include states reachable from the initial state.)
(b) Describe in words when each circuit produces Z=1. (Hint: Consider three consecu-
tive inputs as a 3-bit binary number with the most significant bit being sent first.)
(c) Considering the dependence of the output on the input, are the circuits Moore 
or Mealy circuits?
(d) Considering the timing of when Z=1 with respect to the input, do the circuits 
have Mealy or Moore type timing?
Circuit 1 Circuit 2
Q+
2=Q2′Q0
Q+
1=XQ2′Q1+XQ2′Q0′
Q+
0=Q2′
Z =Q2Q1Q+
2=Q2′Q0
Q+
1=XQ1+XQ0′+Q2Q1
Q+
0=Q2′
Z=Q1Q0′
13.18 Analyze the following clocked synchronous sequential circuit by performing the 
following steps:
(a) Write the equations for the flip-flop inputs and the output equation.
(b) Construct the transition and output tables.
(c) Construct the transition graph.
(d) Give a one sentence description of when the circuit produces an output of 0.
Q X D
ZQ′ Clk
ClkQ D
Q′ ClkQ1 Q2
448 Unit 13
13.19 Repeat Problem 13.18 for the following circuit:
X
Z
ClkQ D
Q′ ClkQ1Q D
Q′ ClkQ2
X
ZClk Ck FFQ1J1
K1
Ck FFQ2J2
K2Q2′
Q2
Q1
Q2′Q1′
13.21 A Mealy sequential circuit has one input, one output, and two flip-flops. A timing dia-
gram for the circuit follows. Construct a transition table and state graph for the circuit.
X
Q1
Q2
ZClock13.20 Consider the circuit shown.
(a) Construct a transition table and state graph for the following circuit. Is the circuit 
a Mealy or Moore circuit? Does the circuit have any unused states? Assume 00 
is the initial state.
(b) Draw a timing diagram for the input sequence X=01100.
(c) What is the output sequence for the input sequence?
Analysis of Clocked Sequential Circuits  449
13.22 Repeat Problem 13.21 for the following timing diagram.
13.23 Given the following timing chart for a sequential circuit, construct as much of the 
transition table as possible. Is this a Mealy or Moore circuit?
13.24 Given the following timing chart for a sequential circuit, construct as much of the 
transition table as possible.Clock
X
Q1
Q2
Z
Q1
Q2X1
X2
Z1
Z2Clock
X1
X2
Q1
Q2
Z1
Z2Clock
450 Unit 13
13.25 For the following sequential circuit, the table gives the contents of the PLA. (All 
PLA outputs are 0 for input combinations not listed in the table.)
(a) Construct a transition table and draw a state graph.
(b) Draw a timing diagram showing the clock, X, Q1, Q2,  and Z for the input 
sequence X=10011. Assume that initially Q1=Q2=0.
(c) Identify any false outputs in the timing diagram. What is the correct output 
sequence for Z?
XQ1Q2D1D2Z
01– 100
101 1000–1 011100 011110 001
CkD2Q2+
+Q1PLAQ2X Z
CkD1Q1
Clock
13.26 A sequential circuit of the form shown in Figure 13-17 is constructed using a ROM 
and two D flip-flops. The contents of the ROM are given in the table.
(a) Draw a timing diagram for the circuit for the input sequence X1X2=10, 01, 11, 10. 
Assume that input changes occur midway between rising and falling clock edges. 
Indicate any false outputs on the diagram, and specify the correct output sequence for Z
1 and Z2.
(b) Construct a transition table and state graph for the circuit.
Q1Q2X1X2 D1D2Z1Z2
00 00 0010
00 01 001000 10 011000 11 011001 00 110001 01 111001 10 100101 11 101110 00 110010 01 000010 10 110110 11 000111 00 100011 01 010011 10 100011 11 0100
Analysis of Clocked Sequential Circuits  451
13.27 For the following state graph, construct a transition table. Then, give the timing dia-
gram for the input sequence X=101001. Assume X changes midway between the 
falling and rising edges of the clock, and that the flip-flops are falling-edge triggered. 
What is the correct output sequence?
1
01
01
00
00
0
1
11
10
0
0
00
0S0
S3 S4S1 S2
13.28 For the circuit of Problem 13.3, assume the delays of the NAND gates and NOR 
gates are 3  ns, and assume the delay of the inverter is 2  ns. Assume the propagation 
delays and setup times for the J-K flip-flops are 4 ns and 2  ns, respectively.
(a) Fill in the given timing diagram. The clock period is 15  ns, and 1-ns increments 
are marked on the clock signal. Does the circuit operate properly with these timing parameters?
(b) What is the minimum clock period for this circuit, if 
X is changed early enough? 
How late may X change with this clock period without causing improper opera-
tion of the circuit?
X
A
B
JA
KA
JB = KB
Z5 ns 10 ns 15 ns 20 ns 25 ns 30 ns 35 ns
Clock
13.29 Draw a timing diagram for the following circuit starting with an initial state 
ABC=000 and using an input sequence X=01010. Assume that the input changes 
occur midway between the falling and rising clock edges. Give the output sequence, 
and indicate false outputs, if any. Verify that your answer is correct by making a state table for the circuit.
452 Unit 13
13.30 (a)  For the following sequential circuit, write the next-state equations for flip-flops 
A and B .
(b) Using these equations, find the transition table and draw the state graph.A′ A
J K
X′CXC ′CkC′ C
J KCkB′ B
D
XC ′ X′ C A′ X0 X
ACk
XZ
BX ′A B′ X′C′XAB′
Clock
A′ A
S R
X2 X2′
X2′
X2′X1Z1
Z2′X1′
X1′
X1′BB ′B
BA
AB′
B′A′
A′ClkB′ B
T
Clk
453Derivation of State Graphs 
and TablesUNIT
14
Objectives
1. Given a problem statement for the design of a Mealy or Moore sequential 
 circuit, find the corresponding state graph and table.
2. Explain the significance of each state in your graph or table in terms of the input sequences required to reach that state.
3. Check your state graph using appropriate input sequences.
454 Unit 14
Study Guide
1. Study Section 14.1, Design of a Sequence Detector.
(a) Verify that the state graph in Figure 14-4 will produce the correct output 
sequence for Z when the input sequence for X is as given in Equation (14-1).
(b) Using the equations from the Karnaugh maps on p. 460, construct the next-
state table for the circuit and verify that it is the same as given in Table 14-2, 
except that the new table will have four states because the don’t-cares were assigned in the process of designing the circuit.
(c) Complete the design of the Moore sequential circuit whose transition table 
is given by Table 14-4. Use clocked J-K flip-flops for 
A and B .
(d) Verify that the state graph of Figure 14-6 gives the correct output sequence 
when the input sequence (14-1) is applied. (Ignore the initial output for the Moore graph.)
2. Study Section 14.2, More Complex Design Problems.
3. Study Section 14.3, Guidelines for Construction of State Graphs . Study the exam-
ples carefully and observe how some of the guidelines were applied.
4. Work through Programmed Exercises 14.1, 14.2, and 14.3.
5. A very important part of deriving state tables or state graphs is knowing how to tell when your answer is right (or wrong!). One way to do this is to make up a suitable list of test sequences, apply them to the state graph, and check the resulting output sequences.
6. To gain proficiency in construction of state tables or graphs requires a fair amount of practice. Work Problems 14.4, 14.5, 14.6, 14.7 , and 14.8. The problems on the readiness tests will be about the same order of difficulty as these prob-lems, so make sure that you can work them in a reasonable time.
Note: Do not look at the answers to these problems in the back of the book until you have tried the problems and checked your answers using the fol-lowing test sequences:
14.4 
X=     0  1  1  1  0  1  0  1
     Z=(0)  0  0  0  0  1  1  1  1
(Your solution should have five self-loops. A self-loop is an arrow 
which starts at one state and goes back to the same state.)
14.5 X =1 0 1 0 1 0 0 1 0 0 0 1 0 0
Z1=0 0 0 1 0 1 0 0 0 0 0 0 0 0
Z2=0 0 0 0 0 0 1 0 0 1 0 0 0 1
(Your solution should have four self-loops.)
14.6 X1=      1  0  0  1  0  1  1  0  0  0
X2=      1  0  0  0  0  1  0  0  1  0
  Z  =(0) 0  1  1  1  0  0  0  1  1  0
(Your solution should have at least four self-loops.)
Derivation of State Graphs and Tables  455
14.7 (a) X=0 0 1 1 0 1 0 1 0 1 1
Z=1 1 0 0 0 1 1 0 0 0 1
(Your solution should have three self-loops.)
 (b) X=1 1 1 0 0 1 0 1 0 1
   Z=0 0 0 0 1 0 0 0 0 1
14.8 (a) X1=0 0 1 1 1 1 0 0 1 0 0
X2=0 1 0 1 1 0 1 0 0 1 1
   Z1=0 1 1 1 0 0 0 0 1 0 0
   Z2=0 0 0 0 0 1 1 1 0 1 0
(b)  You should get the same sequences as in (a) after an initial 
output of Z1Z2=00.
7. If you have the LogicAid program available, use it to check your state tables. This 
has several advantages over looking at the answers in the back of the book. First, 
LogicAid will determine whether or not your solution is correct even if your states are numbered differently from those in the solution, or even if the number of states is different. Second, if your solution is wrong, LogicAid will find a short input 
sequence for which your state table fails, and you can use this sequence to help locate the error in your solution. If you are having trouble learning to derive state graphs, LogicAid has a state graph tutor mode which can be used to check partial 
state graphs. By using the partial graph checker, you can check your graph after adding each state, and then correct any errors before proceeding to the next state.
8. Read Section 14.4, Serial Data Code Conversion.
(a) Complete the following timing diagram, showing waveforms for the NRZ, 
NRZI, RZ, and Manchester coding schemes:
Bit sequence 01 00 11 10
NRZ
NRZI
RZ
Manchester
Clock
(b) The timing chart of Figure 14-21(b) shows several glitches. By referring to 
the state table, explain why the second glitch is present.
(c) Consider Figure 14-21. If an error in data transmission occurs, the input 
sequence X=01 or 10 could occur. Add an Error state to the state dia-
gram. The circuit should go to this error state if such an error occurs.
(d) Work Problem 14.9.
456 Unit 14
9. Read Section 14.5, Alphanumeric State Graph Notation.
(a) Sometimes all outputs are 0 for a given state or arc. We denote this by plac-
ing a 0 in the place of the output. For example, a Moore state with all out-
puts being 0 might be labeled S3/0, and a Mealy arc with all outputs being 
0 might be labeled X′Y/0.
(b) Try to write the row of a Mealy state table that describes state S3 in the 
following partial state graph. You cannot, because there are two contradic-tory directions when 
S=N=1. Also, the row is not completely specified. 
Redraw state S3 so that S takes priority over N, and so that the circuit stays 
in state S3 with no output if no directions are specified by the partial state 
graph. Then, give the state table row. Show that it has no contradictions and that it is completely specified.
t0t1t2 t0t1t2
X= 10 0 Z= – – 0 (– is a don’t-care output)
11 0 – – 1S1
S5S3N
Z
S
0
XZ
Circuit A Circuit CB
Sequential Circuit
Subsystem(c) Work Problems 14.10 and 14.11.
10. Read Section 14.6, Incompletely Specified State Tables.
Complete the following example:The sequential circuit shown below has three parts. Assume that circuit A can 
only generate two possible output sequences, 
X=100 and X=110. Thus, the 
sequential circuit subsystem ( B) has only two possible input sequences. When 
the third input in the sequence is received, the output of B is to be Z=0 if 100 
was received and Z=1 if 110 was received. Assume that circuit C ignores the 
value of Z at other times so that we do not care what Z is during the first two 
inputs in the X sequence.
The possible input-output sequences for circuit B are listed in the following 
table, where t0, t1, and t2 represent successive clock times.
Derivation of State Graphs and Tables  457
Derivation of State Graphs 
and Tables
In Unit 13 we analyzed sequential circuits using timing charts and state graphs. Now, 
we will consider the design of sequential circuits starting from a problem statement which specifies the desired relationship between the input and output sequences. The first step in the design is to construct a state table or graph which specifies the desired behavior of the circuit. Flip-flop input equations and output equations can then be derived from this table. Construction of the state table or graph, one of the most important and challenging parts of sequential circuit design, is discussed in detail in this unit.
14.1 Design of a Sequence Detector
To illustrate the design of a clocked Mealy sequential circuit, we will design a sequence detector. The circuit has the form shown in Figure 14-1.X=0 101
S0 – S1––
S1
S2
S3Complete the following incompletely specified state table for circuit B:
Note that the next state entry for S0 with X=0 is a don’t-care because 0 can never 
occur as the first input in the sequence. When the third input in the sequence is 
received, why will the next state and output for X=1 be don’t-cares?
11. When you are satisfied that you can meet all of the objectives, take the  readiness test.
458 Unit 14
The circuit will examine a string of 0’s and 1’s applied to the X input and generate 
an output Z=1 only when a prescribed input sequence occurs. It will be assumed 
that the input X can only change between clock pulses. Specifically, we will design 
the circuit so that any input sequence ending in 101 will produce an output Z=1 
coincident with the last 1. The circuit does not reset when a 1 output occurs. A typical 
input sequence and the corresponding output sequence are
 X= 0011011001 01010 0
Z= 0000010000 01010 0
 ( t i m e :01234567891 01 11 21 31 41 5 ) (14-1)
Initially, we do not know how many flip-flops will be required, so we will designate the circuit states as 
S0, S1, etc., and later assign flip-flop states to correspond to the circuit 
states. We will construct a state graph to show the sequence of states and outputs which occur in response to different inputs. Initially, we will start the circuit in a reset state des-ignated 
S0. If a 0 input is received, the circuit can stay in S0 because the input sequence 
we are looking for does not start with 0. However, if a 1 is received, the circuit must go to a new state 
(S1) to “remember” that the first input in the desired sequence has been 
received (Figure 14-2). The labels on the graph are of the form X/Z, where the symbol 
before the slash is the input and the symbol after the slash is the corresponding output.
When in state S1, if we receive a 0, the circuit must change to a new state (S2) to 
remember that the first two inputs of the desired sequence (10) have been received. If a 1 is received in state 
S2, the desired input sequence (101) is complete and the 
output should be l. The question arises whether the circuit should then go to a new state or back to 
S0 or S1. Because the circuit is not supposed to reset when an output 
occurs, we cannot go back to S0. However, because the last 1 in a sequence can also 
be the first 1 in a new sequence, we can return to S1, as indicated in Figure 14-3.
1
00
0
S0
S1FIGURE 14-2
1
0
1
1
0
00
0S0
S1
S2FIGURE 14-1
Sequence Detector 
to Be Designed
© Cengage Learning 2014Z X
Clock
© Cengage Learning 2014
FIGURE 14-3
© Cengage Learning 2014
Derivation of State Graphs and Tables  459
State S0 is the starting state, state S1 indicates that a sequence ending in 1 has 
been received, and state S2 indicates that a sequence ending in 10 has been received. 
An alternative way to start the solution would be to first define states in this manner 
and then construct the state graph. Converting the state graph to a state table yields Table 14-1. For example, the arc from S
2 to S1 is labeled 1/1. This means that when the 
present state is S2 and X=1, the present output is 1. This 1 output is present as soon 
as X becomes 1, that is, before the state change occurs. Therefore, the 1 is placed in 
the S2 row of the table.FIGURE 14-4
Mealy State Graph 
for Sequence 
Detector
© Cengage Learning 20141
0
1
01
1
0
00
0
0
0S0
S1
S2
Present 
StateNext State
X=0 X=1Present 
Output
X=0 X=1
S0 S0 S1 00
S1 S2 S1 00
S2 S0 S1 01TABLE 14-1The graph of Figure 14-3 is still incomplete. If a 1 input occurs when in state S1, we 
can stay in S1 because the sequence is simply restarted. If a 0 input occurs in state S2, 
we have received two 0’s in a row and must reset the circuit to state S0 because 00 is not 
part of the desired input sequence, and going to one of the other states could lead to an incorrect output. The final state graph is given in Figure 14-4. Note that for a single input variable each state must have two exit lines (one for each value of the input vari-able) but may have any number of entry lines, depending on the circuit specifications.
ABA+B+ 
X=0 X=1Z
X=0 X=1
00 00 01 0 0
01 10 01 0 010 00 01 0 1TABLE 14-2At this point, we are ready to design a circuit which has the behavior described 
by the state table. Because one flip-flop can have only two states, two flip-flops are 
needed to represent the three states. Designate the two flip-flops as A and B. Let 
flip-flop states A=0 and B=0 correspond to circuit state S0; A=0 and B=1 cor-
respond to S1; and A=1 and B=0 correspond to circuit state S2. Each circuit state 
is then represented by a unique combination of flip-flop states. Substituting the flip-flop states for 
S0, S1, and S2 in the state table yields the transition table (Table 14-2).© Cengage Learning 2014
© Cengage Learning 2014
460 Unit 14
The flip-flop inputs are then derived from the next-state maps using the 
same method that was used for counters (Section 12.4). If D flip-flops are used, 
DA=A+=X′B and DB=B+=X, which leads to the circuit shown in Figure 14-5. 
Initially, we will reset both flip-flops to the 0 state. By tracing signals through the cir-cuit, you can verify that an output Z=1 will occur when an input sequence ending in 
101 occurs. To avoid reading false outputs, always read the value of 
Z after the input 
has changed and before the active clock edge.
ClockCkA′ A
DCkB′ B
D
Z
X
The procedure for finding the state graph for a Moore machine is similar to that 
used for a Mealy machine, except that the output is written with the state instead of with the transition between states. We will rework the previous example as a Moore machine to illustrate this procedure. The circuit should produce an output of 1 only if an input sequence ending in 101 has occurred. The design is similar to that for the From this table, we can plot the next-state maps for the flip-flops and the map for 
the output function 
Z:
FIGURE 14-5
© Cengage Learning 20140001
10
XX
000ABX
01
11
10 0
A+ = X′B0101
01
XX
000AB
B+ = XX
01
11
10 10001
00
XX
000AB
Z = XAX
01
11
10 1
Derivation of State Graphs and Tables  461
We now complete the graph, as shown in Figure 14-6. Note the sequence 100 resets 
the circuit to S0. A sequence 1010 takes the circuit back to S2 because another 1 input 
should cause Z to become 1 again.1
00S0
0S1
0
S2
0
1
100S0
0S1
0
S2
0S3
1Now, when a 1 input occurs to complete the 101 sequence, the output must become 1;  therefore, we cannot go back to state 
S1 and must create a new state S3 with a 1 output:
FIGURE 14-6
Moore State Graph 
for Sequence 
Detector
© Cengage Learning 201411
110
0
00S0
0S1
0
S2
0S3
1
The state table corresponding to the circuit is given by Table 14-3. Note that there 
is a single column for the output because the output is determined by the present state and does not depend on 
X. Note that in this example the Moore machine requires 
one more state than the Mealy machine which detects the same input sequence.
Present 
StateNext State 
X=0 X=1  Present
Output (Z )
S0 S0 S1 0
S1 S2 S1 0
S2 S0 S3 0
S3 S2 S1 1TABLE 14-3Mealy machine up until the input sequence 10 has occurred, except that 0 output is associated with states S
0, S1, and S2:
© Cengage Learning 2014
462 Unit 14
Because there are four states, two flip-flops are required to realize the circuit. 
Using the state assignment AB=00 for S0, AB=01 for S1, AB=11 for S2, and 
AB=10 for S3, the following transition table for the flip-flops results (Table 14-4):
ABA+B+ 
X=0 X=1 Z
00 00 01 0
01 11 01 011 00 01 010 11 01 1TABLE 14-4
The output function is Z=AB ′. Note that Z depends only on the flip-flop states 
and is independent of Z, while for the corresponding Mealy machine, Z was a func-
tion of X. The derivation of the flip-flop input equations is straightforward and will 
not be given here.
The preceding 101 sequence detectors can be called sliding window sequence 
detectors because the sequence being detected can occur anywhere in the input 
sequence. The windows can be overlapping or they may be restricted to be nonoverlapping. The first two output sequences in Figure 14-7 illustrate the dis-tinction between overlapping and nonoverlapping windows for an example input sequence and 101 sequence detectors. (The circuits corresponding to Figure 14-4 and Figure 14-6 allow overlapping windows.) In addition, these examples assume that the complete 101 sequence must occur after time 0 to be recognized; this is equivalent to assuming that the circuit responds as if the initial state were preceded by a 0 input. An alternative assumption is that the circuit responds as if the initial state were preceded by a 1 input; the third and fourth output sequences in Figure 14-7 are for this assumption. If state 
S1 were made the initial state in Figure 14-4 and Figure 14-6, 
then the circuits would respond as if the initial state were preceded by a 1 input.
In contrast to a sliding window sequence detector, a disjoint window  sequence 
detector divides the input sequence into windows of fixed length (normally the length of the sequence to be detected) and only recognizes the input sequence when confined to one of the windows. The last output sequence in Figure 14-7 is for the 101 sequence detector using disjoint windows of length 3. (Making the window longer than the sequence is equivalent to changing the sequence recognized. For example, detecting 101 anywhere in disjoint windows of length 4 is equivalent to detecting any of the sequences: 0101, 1101, 1010, and 1011.) A sequence detector for disjoint windows will usually be more complex than a similar detector for sliding windows, because the detector must record where bits occur within the window in addition to detecting the sequence.
Disjoint window sequence detectors apply naturally in certain cases. For exam-
ple, if an input sequence contains successive BCD digits, then the input sequence would be divided into disjoint windows of length 4. A sequence detector might examine each window to determine if it contains a valid BCD digit, or a different detector might determine the parity of each BCD digit.© Cengage Learning 2014
Derivation of State Graphs and Tables  463
14.2 More Complex Design Problems
In this section we will derive a state graph for a sequential circuit of somewhat 
greater complexity than the previous examples. The circuit to be designed again has the form shown in Figure 14-1. The output 
Z should be 1 if the input sequence ends 
in either 010 or 1001, and Z should be 0 otherwise. Before attempting to draw the 
state graph, we will work out some typical input-output sequences to make sure that we have a clear understanding of the problem statement. We will determine the desired output sequence for the following input sequence:
X=0 0 10100100 0 10011 0
↑↑↑ ↑ ↑↑
abc d e f
Z=0 0 01010110 0 01010 0
At point a , the input sequence ends in 010, one of the sequences for which we are 
looking, so the output is Z=1. At point b, the input again ends in 010, so Z=1. 
Note that overlapping sequences are allowed because the problem statement does not say anything about resetting the circuit when a 1 output occurs. At point c, the 
input sequence ends in 1001, so 
Z is again 1. Why do we have a 1 output at points d, e, 
and f   ? This is just one of many input sequences. A state machine that gives the cor-
rect output for this sequence will not necessarily give the correct output for all other sequences.
We will start construction of the state graph by working with the two sequences 
which lead to a 1 output. Then, we will later add arrows and states as required to make sure that the output is correct for other cases. We start off with a reset state 
S0 which corresponds to having received no inputs. Whenever an input is received 
that corresponds to part of one of the sequences for which we are looking, the cir-cuit should go to a new state to “remember” having received this input. Figure 14-8 shows a partial state graph which gives a 1 output for the sequence 010. In this graph 
S1 corresponds to having received a sequence ending in 0, S2 to a sequence ending 
in 01, and S3 to a sequence ending in 010. Now, if a 1 input is received in state S3, we 
again have a sequence ending in 01, which is part of the input sequence for which we FIGURE 14-7 Different Types of Sequence Detector
Different 101 Sequence Detectors X010101011101010101
Sliding windows, overlapping Z000101010001010101
Sliding windows, nonoverlapping Z000100010001000100
Sliding windows, overlapping, initial 1 Z010101010001010101
Sliding windows, nonoverlapping, initial 1 Z010001000001000100
Disjoint windows Z000001000001000001
© Cengage Learning 2014
464 Unit 14
are looking. Therefore, we can go back to state S2 (arrow a) because S2 corresponds 
to having received a sequence ending in 01. Then, if we get another 0 in state S2, we 
go to S3 with a 1 output. This is correct because the sequence again ends in 010.
Next, we will construct the part of the graph corresponding to the sequence 1001. 
Again, we start in the reset state S0, and when we receive a 1 input, we go to S4 
(Figure 14-9, arrow b) to remember that we have received the first 1 in the sequence 
1001. The next input in the sequence is 0, and when this 0 is received, we should ask the question: Should we create a new state to correspond to a sequence ending in 10, or can we go to one of the previous states on the state graph? Because S
3 cor-
responds to a sequence ending in 10, we can go to S3 (arrow c ). The fact that we did 
not have an initial 0 this time does not matter because 10 starts off the sequence for which we are looking. If we get a 0 input when in S
3, the input sequence received 
will end in 100 regardless of the path we took to get to S3. Because there is so far no 
state corresponding to the sequence 100, we create a new state S5 to indicate having 
received a sequence ending in 100.
If we get a 1 input when in state S5, this completes the sequence 1001 and gives a 
1 output as indicated by arrow e. Again, we ask the question: Can we go back to one 
of the previous states or do we have to create a new state? Because the end of the sequence 1001 is 01, and S
2 corresponds to a sequence ending in 01, we can go back 
to S2 (Figure 14-10). If we get another 001, we have again completed the sequence 
1001 and get another 1 output.0
0
0
1
1
0a1
0
S3 S2S0
S1FIGURE 14-8 State Sequence Received
S0 Reset
S1 0
S2 01
S3 010
0
0
0
0
0
00
1
1
?11
0
eb
c
d1
01
0
S3 S2S0
S5S1 S4FIGURE 14-9 State Sequence Ends in
S0 Reset
S1 0 (but not 10)
S2 01
S3 10
S4 1 (but not 01)
S5 100© Cengage Learning 2014
© Cengage Learning 2014
Derivation of State Graphs and Tables  465
We have now taken care of putting out a 1 when either the sequence 010 or 1001 
is completed. Next, we will go back and complete the state graph to take care of 
the other input sequences, for which we have not already accounted. In state S1, we 
have accounted for a 1 input but not a 0 input. If we are in S1 and get a 0 input, to 
which state should we go? If a 0 input occurs in S1, we have a sequence ending in 00. 
Because 00 is not part of either of the input sequences for which we are looking, we can ignore the extra 0 and stay in S
1 (arrow f). No matter how many extra 0’s occur, 
we still have a sequence ending in 0, and we stay in S1 until a 1 input occurs. In S2, 
we have taken care of the 0 input case but not the 1 input case. If a 1 is received, the input sequence ends in 11. Because 11 is not part of either the sequence 010 or 1001, we do not need a state which corresponds to a sequence ending in 11. We cannot stay in S
2 because S2 corresponds to a sequence ending in 01. Therefore, we go to S4, 
which corresponds to having received a sequence ending in 1 (arrow g). S3 already 
has arrows corresponding to 0 and 1 inputs, so we examine S4 next. If a 1 is received 
in S4, the input sequence ends in 11. We can stay in S4 and ignore the extra 1 (arrow h) 
because 11 is not part of either sequence for which we are looking. In S5, if we get a 0 
input, the sequence ends in 000. Because 000 is not contained in either 010 or 1001, we can go back to S
1, because S1 corresponds to having received a sequence ending 
in one (or more) 0’s. This completes the state graph because every state has arrows leaving it which correspond to both 0 and 1 inputs. We should now go back and check the state graph against the original input sequences to make sure that a 1 output is always obtained for a sequence ending in 010 or 1001 and that a 1 output does not occur for any other sequence.
Next, we will derive the state graph for a Moore sequential circuit with one input 
X and one output Z. The output Z is to be 1 if the total number of 1’s received is 
odd and at least two consecutive 0’s have been received. A typical input and output sequence is
X=  1  0  1  1  0  0  1  1
↑   ↑   ↑↑ ↑
  a           b      c  d  e
Z= (0) 0   0  0  0  0  1  0  1 State Sequence Ends in
S0 Reset
S1 0 (but not 10)
S2 01
S3 10
S4 1 (but not 01)
S5 100
0
00
00
00
0
0
00
1
1
11
0i
eh
cgf
1
01
01
0 1
0
S3 S2S0
S5S1 S4FIGURE 14-10
© Cengage Learning 2014
466 Unit 14
We have shifted the Z sequence to the right to emphasize that for a Moore circuit 
an input change does not affect Z immediately, but Z can change only after the next 
active clock edge. The initial 0 in parentheses is the output associated with the reset 
state. At points a and b in the preceding sequence, an odd number of 1’s has been 
received, but two consecutive 0’s have not been received, so the output remains 0. At points c and e , an odd number of 1’s and two consecutive 0’s have been received, so 
Z=1. At point d, Z=
0 because the number of 1’s is even.
We start construction of the Moore state graph (Figure 14-11) with the reset state 
S0, and we associate a 0 output with this state. First, we will consider keeping track 
of whether the number of 1’s is even or odd. If we get a 1 input in S0, we will go to 
state S1 to indicate an odd number of 1’s received. The output for S1 is 0 because 
two consecutive 0’s have not been received. When a second 1 is received, should we go to a new state or go back to S
0? For this problem, it is unnecessary to distinguish 
between an even number of 1’s and no 1’s received, so we can go back to S0. A third 
1 then takes us to S1 (odd number of 1’s), a fourth 1 to S0 (even 1’s), and so forth.
If a 0 is received in S0, this starts a sequence of two consecutive 0’s, so we go to S2 
(0 output) in Figure 14-12. Another 0 then takes us to S3 to indicate two consecutive 
0’s received. The output is still 0 in S3 because the number of 1’s received is even. 
Now if we get a 1 input, we have received an odd number of 1’s and go to S4. (Why 
can we not go to S1?) In S4 we have received two consecutive 0’s and an odd number 
of 1’s, so the output is 1.
If we receive a 1 in S4, we have an even number of 1’s and two consecutive 0’s, so 
we can return to S3 (arrow a). The output in S3 is 0, and when we get another 1 input, 
the number of 1’s is odd, so we again go to S4 with a 1 output. Now, suppose that we 
are in S1 (odd number of 1’s received), and we get a 0. We cannot go to S2 (Why?), so 
we go to a new state S5 (Figure 14-13, arrow b) which corresponds to an odd number 
of 1’s followed by a 0. Another 0 results in two consecutive 0’s, and we can go to S4 
(arrow c ) which gives us a 1 output.Reset or
even 1’sOdd 1’s1
1S0
0S1
0FIGURE 14-11
State Sequence Received
S0 Reset or even 1’s
S1 Odd 1’s
S2 Even 1’s and ends in 0
S3 Even 1’s and 00 has occurred
S4 00 has occurred and odd 1’s0
0
a1
1S0
0S1
0
S2
0
1
1S4
1S3
0FIGURE 14-12© Cengage Learning 2014
© Cengage Learning 2014
Derivation of State Graphs and Tables  467
Now, we must go back and complete the state graph by making sure that there are 
two arrows leaving each state. In S2, a 1 input means that we have received an odd 
number of 1’s. Because we have not received two consecutive 0’s, we must return to S1 
(arrow d) and start counting 0’s over again. Similarly, if we receive a 1 in S5, we return 
to S0 (Why?). Now, what should happen if we receive a 0 in S3? Referring to the 
original problem statement, we see that once two consecutive 0’s have been received, 
additional 0’s can be ignored. Therefore, we can stay in S3 (arrow f). Similarly, extra 
0 inputs can be ignored in S4 (arrow g). This completes the Moore state diagram, and 
we should go back and verify that the correct output sequence is obtained for various input sequences.
00
0
000e d
b
g c f1
1
1
1S0
0S1
0
S2
0
1
Even 1’s Odd 1’s1S4
1S5
0
S3
0State Input Sequences
S0 Reset or even 1’s
S1 Odd 1’s
S2 Even 1’s and ends in 0
S3 Even 1’s and 00 has occurred
S4 Odd 1’s and 00 has occurred
S5 Odd 1’s and ends in 0FIGURE 14-13
14.3 Guidelines for Construction of State Graphs
Although there is no one specific procedure which can be used to derive state graphs 
or tables for every problem, the following guidelines should prove helpful:
1. First, construct some sample input and output sequences to make sure that you 
understand the problem statement.
2. Determine under what conditions, if any, the circuit should reset to its initial state.
3. If only one or two sequences lead to a nonzero output, a good way to start is to construct a partial state graph for those sequences.
4. Another way to get started is to determine what sequences or groups of sequences must be remembered by the circuit and set up states accordingly.
5. Each time you add an arrow to the state graph, determine whether it can go to one of the previously defined states or whether a new state must be added.
6. Check your graph to make sure there is one and only one path leaving each state for each combination of values of the input variables.
7. When your graph is complete, test it by applying the input sequences formulated in part 1 and making sure the output sequences are correct.© Cengage Learning 2014
468 Unit 14
Several examples of deriving state graphs or tables follow.
A sequential circuit has one input (X) and one output (Z). The circuit examines groups 
of four consecutive inputs and produces an output Z=1 if the input sequence 0101 
or 1001 occurs. The circuit resets after every four inputs. Find the Mealy state graph.
Solution A typical sequence of inputs and outputs is
X=0101 `0010 `1001 `0100
Z=0001 0000 0001 0000
The vertical bars indicate the points at which the circuit resets to the initial state. Note 
that an input sequence of either 01 or 10 followed by 01 will produce an output of Z=1. Therefore, the circuit can go to the same state if either 01 or 10 is received. The 
partial state graph for the two sequences leading to a 1 output is shown in Figure 14-14.
Note that the circuit resets to 
S0 when the fourth input is received. Next, we 
add arrows and labels to the graph to take care of sequences which do not give a 1 output, as shown in Figure 14-15.Example 1
FIGURE 14-14
Partial State 
Graph for 
Example 1
© Cengage Learning  
2014 1
10
0
0
0
0
01
01
0
S3
S4S0
S1 S2State Sequence Received
S0 Reset
S1 0
S2 1
S3 01 or 10
S4 010 or 100
1
10
0
0
0
0
00
0
1
00
00
0
0
01
01
01
0
1
01
0
S3
S4S0
S1 S2
S5
S6FIGURE 14-15
Complete 
State Graph 
for Example 1
© Cengage Learning  
2014State Sequence Received
S0 Reset
S1 0
S2 1
S3 01 or 10
S4 010 or 100
S5 Two inputs received, no 1 
output is possible
S6 Three inputs received, no 1 
output is possible
Derivation of State Graphs and Tables  469
The addition of states S5 and S6 was necessary so that the circuit would not reset 
to S0 before four inputs were received. Note that once a 00 or 11 input sequence has 
been received (state S5), no output of 1 is possible until the circuit is reset.
A sequential circuit has one input (X) and two outputs (Z1  and   Z2). An output 
Z1=1 occurs every time the input sequence 100 is completed, provided that the 
sequence  010 has never occurred. An output Z2=1 occurs every time the input 
sequence 010 is completed. Note that once a Z2=1 output has occurred, Z1=1 can 
never occur but not vice versa. Find a Mealy state graph and table.
Solution A typical sequence of inputs and outputs is:
 X=1001100101   ┆010010110100
Z1=0010001000   ┆000000000000
Z2=0000000010   ┆101001000010
Note that the sequence 100 occurs twice before 010 occurs, and Z1=1 each time. 
However, once 010 occurs and Z2=1, Z1=0 even when 100 occurs again. Z2=1 all 
five times that 010 occurs. Because we were not told to reset the circuit, 01010 means 
that 010 occurred twice.
We can begin to solve this problem by constructing the part of the state graph 
which will give the correct outputs for the sequences 100 and 010. Figure 14-16(a) shows this portion of the state graph.
An important question to ask at this point is, what does this circuit need to remember 
to give the correct outputs? The circuit will need to remember how much progress has been made on the sequence 010, so it will know when to output Z
2=1. The cir-
cuit will also need to remember how much progress has been made on the sequence 100 and whether 010 has ever occurred, so it will know when to output Z
1=1.
Keeping track of what is remembered by each state will help us make the cor-
rect state graph. Table 14-5 will help us to do this. State S0 is the initial state of the Example 2
FIGURE 14-16
Partial Graphs for 
Example 2
© Cengage Learning  
20141
001
00
1
000
000
00
0
00
0
100
011
00
0
01
1
001
000
100
001
000
00
S4S0
S1 S3
S2 S4S0
S1 S3
S2
(a) (b)
470 Unit 14
circuit, so there is no progress on either sequence, and 010 has never occurred. State 
S1 is the state we go to when a 1 is received from S0, so in state S1, we have made 
progress on the sequence 100 by getting a 1. In state S1, we have made progress on 
the sequence 100 by getting 10. Similarly, states S3 and S4 represent progress of 0 and 
01 toward 010. In S1, there is no progress toward the sequence 010, and in S3, there 
is no progress toward the sequence 100. However, in S2, we have received 10, so if 
the next two inputs are 1 and 0, the sequence 010 will be completed. Therefore, in S2, 
we have not only made progress of 10 toward 100, but we have also made progress 
of 0 toward 010. Similarly, in S4, we have made progress of 1 toward 100, as well as 
progress of 01 toward 010.
Using this information, we can fill in more of the state graph to get Figure 14-16(b). 
If the circuit is in state S1 and a 1 is received, then the last two inputs are 11. The 
previous 1 is of no use toward the sequence 100. However, the circuit will need to remember the new 1, and there is a progress of 1 toward the sequence 100. There is no progress on the sequence 010, and 010 has never occurred, but this is the same situation as state S
1. Therefore, the circuit should return to state S1. Similarly, if a 0 
is received in state S3, the last two inputs are 00. There is a progress only of 0 toward 
the sequence 010, there is no progress toward 100, and 010 has never occurred, so the circuit should return to state S
3. In state S2, if a 0 is received, the sequence 
100 is complete and the circuit should output Z1=1. Then, there is no progress on 
another sequence of 100, and 010 has still not occurred. However, the last input is 0, so there is progress of 0 toward the sequence 010. We can see from Table 14-5 that this is the same situation as S
3, so the circuit should go to state S3. If, in state S2, a 1 
is received, we have made progress of 01 toward 010 and progress of 1 toward 100, and 010 has still not occurred. We can see from Table 14-5 that the circuit should go to state S
4.
If a 0 is received in state S4, the sequence 010 is complete, and we should output 
Z2=1. At this point we must go to a new state (S5) to remember that 010 has been 
received so that Z1=1 can never occur again. When S5 is reached, we stop looking 
for 100 and only look for 010. Figure 14-17(a) shows a partial state graph that out-puts Z
2=1 when the input sequence ends in 010. In S5 we have progress of 0 toward 
010 and additional 0’s can be ignored by looping back to S5. In S6 we have progress 
of 01 toward 010. If a 0 is received, the sequence is completed, Z2=1 and we can go 
back to S5 because this 0 starts the 010 sequence again.TABLE 14-5
State Descriptions 
for Example 2State Description
S0 No progress on 100 No progress on 010
010 has never occurredS1 Progress of 1 on 100 No progress on 010
S2 Progress of 10 on 100 Progress of 0 on 010
S3 No progress on 100 Progress of 0 on 010
S4 Progress of 1 on 100 Progress of 01 on 010
S5 Progress of 0 on 010
010 has occurred S6 Progress of 01 on 010
S7 No Progress on 010© Cengage Learning  
2014
Derivation of State Graphs and Tables  471
If we receive a 1 in state S6, the 010 sequence is broken and we must add a new 
state (S7) to start looking for 010 again. In state S7 we ignore additional 1’s, and 
when a 0 is received, we go back to S5 because this 0 starts the 010 sequence over 
again. Figure 14-17(b) shows the complete state graph, and the corresponding table 
is Table 14-6.FIGURE 14-17
State Graphs for 
Example 2
© Cengage Learning  
20141
00
1
00
1
000
00
1
00
1
001
00
1
00
1
001
000
100
000
00
0
01
0
010
010
011
000
000
00
0
00
S4S0
S1 S3
S2S5
S6S7
S6S5
(a) Partial graph for 010 (b) Complete state graph
TABLE 14-6 
Present 
StateNext State  Output (Z1Z2)
X=0X=1X=0 X=1
S0 S3 S1 00 00
S1 S2 S1 00 00
S2 S3 S4 10 00
S3 S3 S4 00 00
S4 S5 S1 01 00
S5 S5 S6 00 00
S6 S5 S7 01 00
S7 S5 S7 00 00
Example 3 A sequential circuit has two inputs (X1, X2) and one output (Z). The output remains 
a constant value unless one of the following input sequences occurs:
(a) The input sequence X1 X2=01, 11 causes the output to become 0.
(b) The input sequence X1 X2=10, 11 causes the output to become 1.
(c) The input sequence X1 X2=10, 01 causes the output to change value.
(The notation X1X2=01, 11 means X1=0, X2=1 followed by X1=1, X2=1.) 
Derive a Moore state graph for the circuit.
Solution  The only sequences of input pairs which affect the output are of length two. There-fore, the previous and present inputs will determine the output, and the circuit must remember only the previous input pair. At first, it appears that three states are © Cengage Learning  
2014
472 Unit 14
required, corresponding to the last input received being X1X2=01, 10 and (00 or 11). 
Note that it is unnecessary to use a separate state for 00 and 11 because neither input 
starts a sequence which leads to an output change. However, for each of these states the output could be either 0 or 1, so we will initially define six states as follows:
Using this state designation, we can then set up a state table (Table 14-7). The six-
row table given here can be reduced to five rows, using the methods given in Unit 15.
The 
S4 row of this table was derived as follows. If 00 is received, the input sequence 
has been 10, 00, so the output does not change, and we go to S0 to remember that the 
last input received was 00. If 01 is received, the input sequence has been 10, 01, so the output must change to 1, and we go to 
S3 to remember that the last input received 
was 01. If 11 is received, the input sequence has been 10, 11, so the output should become 1, and we go to 
S1. If 10 is received, the input sequence has been 10, 10, so the 
output does not change, and we remain in S4. Verify for yourself that the other rows 
in the table are correct. The state graph is shown in Figure 14-18.  Previous  
Input (X1X2)Output  
(Z) State
Designation
00 or 11 0 S0
00 or 11 1 S1
01 0 S2
01 1 S3
10 0 S4
10 1 S5
TABLE 14-7 
FIGURE 14-18
State Graph for 
Example 3
© Cengage Learning  
201400, 11
00, 11
00, 1100, 1111
1110
00
0010
10010101
010101
10
1010S3
1S4
0
S1
1S5
1S0
0
S2
0Present Next State
  State Z X1X2=00 01 11 10
S0 0 S0S2 S0S4
S1 1 S1S3 S1S5
S2 0 S0S2 S0S4
S3 1 S1S3 S0S5
S4 0 S0S3 S1S4
S5 1 S1S2 S1S5 
 © Cengage Learning  
2014
Derivation of State Graphs and Tables  473
14.4 Serial Data Code Conversion
As a final example of state graph construction, we will design a converter for serial 
data. Binary data is frequently transmitted between computers as a serial stream of bits. As shown in Figure 14-19(a), a clock signal is often transmitted along with the data, so the receiver can read the data at the proper time. Alternatively (Figure 14-19(b)), only the serial data is transmitted, and a clock recovery circuit (called a digital phase-locked loop) is used to regenerate the clock signal at the receiver.
Figure 14-20 shows four different coding schemes for serial data together 
with the clock used to synchronize the data transmission. The example shows the transmission of the bit sequence 0, 1, 1, 1, 0, 0, 1, 0. With the NRZ (non-return-to-zero) code, each bit is transmitted for one bit time without any change. With the NRZI (non-return-to-zero-inverted) code, the data is encoded by the presence or absence of transitions in the output signal. For each 0 in the original sequence, the 
FIGURE 14-19
Serial Data 
Transmission
© Cengage Learning 2014Serial Data
ClockTransmitter Receiver
(a)
Serial Data
ClockTransmitter Receiver
(b)Clock
Recovery
Circuit
FIGURE 14-20
Coding Schemes 
for Serial Data 
Transmission
© Cengage Learning 2014Bit Sequence 01 11 00 10
NRZ
NRZI
RZ
Manchester
Clock
1 bit
time
474 Unit 14
bit transmitted is the same as the previous bit transmitted. For each 1 in the origi-
nal sequence, the bit transmitted is the complement of the previous bit transmitted. Thus, the preceding sequence is encoded as 0, 1, 0, 1, 1, 1, 0, 0. In other words, a 0 is encoded by no change in the transmitted value, and a 1 is encoded by inverting the previous transmitted value. For the RZ (return-to-zero) code, a 0 is transmitted as a 0 for one full bit time, but a 1 is transmitted as a 1 for the first half of the bit time and, then, the signal returns to 0 for the second half. For the Manchester code, a 0 is transmitted as 0 for the first half of the bit time and 1 for the second half, but a 1 is transmitted as 1 for the first half and 0 for the second half. Thus, the encoded bit always changes in the middle of the bit time. When the original bit sequence has a long string of 1’s and 0’s, the Manchester code has more transitions. This makes it easier to recover the clock signal.
We will design a sequential circuit which converts an NRZ-coded bit stream to 
a Manchester-coded bit stream (Figure 14-21(a)). In order to do this, we will use a clock, Clock2, that is twice the frequency of the basic clock (Figure 14-21(b)). In this way, all output changes will occur on the same edge of Clock2, and we can use the standard synchronous design techniques which we have been using in this unit. First, we will design a Mealy circuit to do the code conversion. Note that if the NRZ bit is 0, it will be 0 for two Clock2 periods. Similarly, if the NRZ bit is 1, it will be 1 for two Clock2 periods. Thus, starting in the reset state ( S
0 in 
Figure 14-21(c)), the only two possible input sequences are 00 and 11. For the sequence 00, when the first 0 is received, the output is 0. At the end of the first Clock2 period, the circuit goes to S
1. The input is still 0, so the output becomes 
1 and remains 1 for one Clock2 period, and then the circuit resets to S0. For the 
sequence 11, when the first 1 is received, the output is 1 for one Clock2 period and, then, the circuit goes to S
2. Then, the output is 0 for one Clock2 period, and 
the circuit resets to S0.
When we convert the Mealy graph to a state table (Figure 14-21(d)), the next 
state of S1 with an input of 1 is not specified and is represented by a dash. Similarly, 
the next state of S2 with a 0 input is not specified. The dashes are like don’t-cares, 
in that we do not care what the next state will be because the corresponding input sequence never occurs. A careful timing analysis for the Mealy circuit shows some possible glitches (false outputs) in the output waveform (Figure 14-21(b)). The input waveform may not be exactly synchronized with the clock, and we have exagger-ated this condition in the figure by shifting the input waveform to the right so that the input changes do not line up with the clock edges. For this situation, we will use the state table to analyze the occurrence of glitches in the 
Z output. The first glitch 
shown in the timing chart occurs when the circuit is in state S1, with an input X=0. 
The state table shows that the output is Z=1, and when the clock goes low, the state 
changes to S0. At this time, the input is still X=0, so Z becomes 0. Then X changes 
to 1, Z becomes 1 again, so a glitch has occurred in the output during the time inter-
val between the clock change and the input change. The next glitch occurs in S2 with 
X=1 and Z =0. When the clock goes low, the output momentarily becomes 1 until 
X is changed to 0.
Derivation of State Graphs and Tables  475
FIGURE 14-21
Mealy Circuit for 
NRZ to Manchester 
Conversion
© Cengage Learning 2014
NRZ (X)
Manchester
(Ideal)
Clock2
State
Z (Actual)0 0 00 00 00 1
0
S0S1S0S2S0S2S0S2S0S1S0S1S0S2S0S1000 00 0 0 11 1 1 1 1 1 111111 1 1
1 Clock PeriodZXNRZ Data
Clock2Manchester DataConversion
Circuit
(a) Conversion circuit
(b) Timing chart
(c) State graphS0
S2 S10
11
00
01
1
Present 
StateNext State Output ( Z)
X=0X=1X=0 X=1
S0 S1 S2 01
S1 S0 –1 –
S2 – S0 –0
(d) State table
To overcome the possible glitch problem with the Mealy circuit, we will redesign 
the circuit in Moore form (Figure 14-22 on the next page). Because the output of a 
Moore circuit cannot change until after the active edge of the clock, the output will be delayed by one clock period. Starting in S
0, the input sequence 00 takes us to state 
S1 with a 0 output and, then, to S2 with a 1 output. Starting in S0, 11 takes us to S3 
with a 1 output, and the second 1 can take us back to S0 which has a 0 output. To 
complete the graph, we add the two arrows starting in S2. Note that a 1 input cannot 
occur in S1, and a 0 output cannot occur in S3, so the corresponding state table has 
two don’t-cares.
476 Unit 14
14.5 Alphanumeric State Graph Notation
When a state sequential circuit has several inputs, it is often convenient to label the state 
graph arcs with alphanumeric input variable names instead of 0’s and 1’s. This makes it easier to understand the state graph and often leads to a simpler state graph. Consider the following example: A sequential circuit has two inputs 
(F=forward, R=reverse ) 
and three outputs (Z1,  Z2,  and  Z3). If the input sequence is all F ’s, the output 
sequence is Z1Z2Z3Z1Z2Z3  .  .  . ; if the input sequence is all R’s, the output sequence is 
Z3Z2Z1Z3Z2Z1  . . . . Figure 14-23(a) shows a preliminary Moore state graph that gives 
the specified output sequences. An arc label F means that the corresponding state 
transition occurs when F=1. The notation Z1 within a state means that the output Z1 
is 1, and the other outputs (Z2  and  Z3) are 0. As long as F is 1, the graph cycles through 
the states S0, S1, S2, S0,  .  .  . which gives the output sequence Z1Z2Z3Z1  .  .  . . When 
R=1 the state and output sequences occur in reverse order.
At this point the state graph is not completely specified. What happens if both 
inputs are 0? What happens if both are 1 at the same time? For example, in state S0 
if F=R=1, does the circuit go to state S1 or to S2? Because the circuit can only be FIGURE 14-22
Moore Circuit for 
NRZ to Manchester 
Conversion
© Cengage Learning 2014X (NRZ)
Clock2
State
Z0 0 00 00 00 1
0 0S0S1S2S3S0S3S0S3S0S1S2S1S2S3S0S1
000 00 0 0 11 1 1 1 1 111111 1 1
1 Clock Period
(a) Timing chart
(b) State graph11
10
00S0
0S1
0
S3
1S2
1
Present 
StateNext StatePresent 
Output (Z ) X=0X=1
S0 S1 S3 0
S1 S2 –0
S2 S1 S3 1
S3 – S0 1
(c) State table
Derivation of State Graphs and Tables  477
in one state at a time, we must assign a priority. We will assume that input F takes 
priority over input R. We can then modify the state graph to implement this priority. 
By replacing R with F′R, this means that the corresponding state transition only 
occurs if R =1 and F=0. When F =R=0, we will assume that the output should 
not change. This can be accomplished by adding a self-loop to each state with an arc 
label F′R′. The resulting state graph (Figure 14-23(b)) is completely specified for all 
combinations of values of F and R, and if both inputs are 1, F takes precedence over 
R. If we convert the graph to a table, the result is Table 14-8.FIGURE 14-23
State Graphs with 
Variable Names on 
Arc Labels
© Cengage Learning 2014S0
Z1
FF
FR
RR
S2
Z3S1
Z2S0
Z1
FF
F′R′ FF′RF′RF ′R
S2
Z3S1
Z2
(a) (b)F′R′F′R′
TABLE 14-8
State Table for 
Figure 14-23 NS Output
PS FR=00 01 10 11 Z1 Z2 Z3
S0 S0S2S1S1 1  0  0
S1 S1S0S2S2 0  1  0
S2 S2S1S0S0 0  0  1
When we construct a state graph using input variable names on the arcs, we 
should be careful to make sure that the graph is properly specified. To do this, we can check the labels on all the arcs emanating from each state. For state 
S0, if we OR 
together all of the arc labels, we simplify the result to get
F+F′ R+F′ R′=F+F′=1
This result indicates that for any combination of values of the input variables, one of the labels must be 1.
If we AND together every possible pair of arc labels emanating from 
S0 we get
F·F′ R=0,   F·F′ R′=0,   F′ R·F′R′=0
This result indicates that for any combination of input values, only one arc label can have a value of 1.
In general, a completely specified state graph has the following properties:  
(1) When we OR together all input labels on arcs emanating from a state, the result reduces to 1. (2) When we AND together any pair of input labels on arcs emanating from a state, the result is 0. Property (1) ensures that for every input combination, at least one next state is defined. Property (2) ensures that for every input combination, © Cengage Learning 2014
478 Unit 14
no more than one next state is defined. If both properties are true, then exactly 
one next state is defined, and the graph is properly specified. If we know that cer-tain input combinations cannot occur, then an incompletely specified graph may be acceptable.
We will use the following notation on Mealy state graphs for sequential circuits: 
XiXj/ZpZq means if inputs Xi and Xj are 1 (we don’t care what the other input values 
are), the outputs Zp and Zq are 1 (and the other outputs are 0). That is, for a circuit with 
four inputs (X1, X2, X3,  and  X4) and four outputs (Z1, Z2, Z3,  and  Z4), X1X4′/Z2Z3 is 
equivalent to 1 --0/0110. This type of notation is very useful for large sequential circuits where there are many inputs and outputs.
We will use a dash to indicate that all inputs are don’t-cares. For example, an arc 
label –
 ∕Z1 means that for any combination of input values, the indicated state transi-
tion will occur and the output Z1 will be 1.
14.6 Incompletely Specified State Tables
In some situations particular input sequences will never occur as inputs to a sequen-tial circuit. In other cases, the output from a sequential circuit is only observed at cer-tain times rather than at every clock time. These situations lead to unspecified next states or outputs in the state table. A state table containing such don’t-cares is called an incompletely specified state table . Similar to using don’t-cares to simplify combina-
tional logic, don’t-cares in state tables can be used to simplify the sequential circuit.
As an example of restricted input sequences, assume an input sequence contains 
successive BCD digits with the most significant bit of each digit occurring first. A Mealy model sequential circuit (a disjoint window sequence detector) examines the input sequence and generates an output of 1 when the last bit of a BCD digit is received if the parity of the digit is even; otherwise, the sequential circuit output is 0. (The parity of a BCD digit is even if it contains an even number of 1’s, i.e., zero or two 1’s.) A state graph for the sequential circuit is shown in Figure 14-24 and a state table in Table 14-9. 
FIGURE 14-24
State Graph for 
BCD Parity Detector
© Cengage Learning 2014
S0 S10
0S30
00
1,1
00
0,1
1
S6
S2 S4
S5S70
0
0
0
0
00
01
01
01
01
0
Derivation of State Graphs and Tables  479
State S0 is the initial state of the circuit and, also, the state at the beginning of each BCD 
digit. State S1 (S2) is the state if the first bit of the BCD digit is 0 (1). After two inputs the 
possible states are S3, S4, and S5, and after three inputs S6 and S7 are the possible states. 
Note that if the first bit (the most significant bit) is 1, then the next two bits must be 0. 
(The only BCD digits starting with 1 are 1000 and 1001.) Consequently, the next states and outputs of states 
S2 and S5 for an input of 1 are not specified—they are don’t-cares. 
Using the don’t-cares to simplify the table (graph) is discussed in Section 15.5.
As an example where the outputs of a sequential circuit are only observed part 
of the time, consider the 101 sequence detector for disjoint windows and assume that the output from the sequence detector is only used at the end of a window. (A sepa-rate counter could be used to determine whether an input is the first, second, or third input of a window.) The outputs from the sequence detector can be left unspecified for the first and second inputs in a window. A state graph for the circuit is shown in Figure 14-25, and Table 14-10 is the corresponding state table. Again the don’t-cares allow simplifying the state graph (table); this is discussed in Section 15.5.TABLE 14-9
State Table for 
Figure 14-24Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S2 00
S1 S3 S4 00
S2 S5 –0 –
S3 S6 S7 00
S4 S7 S6 00
S5 S7 –0 –
S6 S0 S0 10
S7 S0 S0 01
FIGURE 14-25
Disjoint Window 
101 Detector
© Cengage Learning 2014
S0 S21−
S40−0
0,1
1
0−,1−0
0,1
0
S1 S31−0−
TABLE 14-10
State Table for 
Figure 14-25 Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S2 ––
S1 S3 S3 ––
S2 S4 S3 ––
S3 S0 S0 00
S4 S0 S0 01© Cengage Learning 2014
© Cengage Learning 2014
480 Unit 14
Programmed Exercise 14.1
Cover the answer to each problem with a sheet of paper and slide it down as you 
check your answers. Write your answer in the space provided before looking at the 
correct answers.
Problem: A clocked Mealy sequential circuit with one input (X) and one output 
(Z ) is to be designed. The output is to be 0, unless the input is 0 following a sequence 
of exactly two 0 inputs followed by a 1 input.
To make sure you understand the problem statement, specify the output sequence 
for each of the following input sequences:
(a) X=0010
Z=____________
(b) X=. . .  1 0 0 1 0  ( . . .  means  any input sequence  not ending  in 00)
Z=. . .  ______________
(c) X=. . .  00010   Z=. . .  ___________
(d) X=00100100010
Z=______________
(e) Does the circuit reset after a 1 output occurs?
 Answers
 Answer
S0 S1 S2 S30
1
0
01
00
0S0 S1 S2 S3
State Sequence Received
S0 (Reset)
S1 0 or 0010
S2
S3
S4
Note that the arrow from S3 returns to S1 so that an additional input of 010 will pro-
duce another 1 output.
Add a state to the preceding graph which corresponds to “three or more con-
secutive 0’s received.” Also complete the preceding table to indicate the sequence 
received which corresponds to each state.(a) Z=0001 (b) Z=. . .  00001 (c) Z=. . .  00000
(b) Z=00010010000 (e) No
Note that no 1 output occurs in answer (c) because there are three input 0’s in a row.
Add arrows to the following graph so that the sequence X=0010 gives the cor-
rect output (do not add another state).
Derivation of State Graphs and Tables  481
 Answer
The preceding state graph is not complete because there is only one arrow leav-
ing most states. Complete the graph by adding the necessary arrows. Return to one 
of the previously used states when possible.
 Answer
Verify that this state graph gives the proper output sequences for the input 
sequences listed at the start of this exercise. Write down the Mealy state table which corresponds to the preceding graph.
 AnswerS0 S1 S2
S4S30
1
0
0
0
0
0
01
0
1
01
01
0
1
0
0
0State Sequence Received
S0 (Reset)
S1 0 or 0010
S2 00
S3 001
S4 3  (or more) 
consecutive 0’s
Present 
StateNext State Output
01 0 1
S0 S1 S0 00
S1 S2 S0 00
S2 S4 S3 00
S3 S1 S0 10
S4 S4 S0 00S0 S1 S2
S4S30
1
0
0
0
0
0
01
00
0
482 Unit 14
Programmed Exercise 14.2
Problem: A clocked Moore sequential circuit should have an output of Z=1 if the 
total number of 0’s received is an even number greater than zero, provided that two 
consecutive 1’s have never been received.
To make sure that you understand the problem statement, specify the output 
sequence for the following input sequence:
X=      0 0 0 0 1 0 1 0 1 1 0 0 0 0
Z=(0)__________________
      this 0  is  the  initial  output   before   any    inputs    have    been   received
 Answer↑
Z=(0)01011001100000
Note that once two consecutive 1’s have been received, the output can never become 
1 again.
To start the state graph, consider only 0 inputs and construct a Moore state graph 
which gives an ou tput of 1 if the total number of 0’s received is an even number greater than zero.
 Answer
Now add states to the above graph so that starting in S0, if two consecutive 1’s are 
received followed by any other sequence, the output will remain 0. Also, complete the preceding table to indicate the sequence received that corresponds to each state.S00
0 0
0S1
0S2
1State Sequence Received
S0 (Reset)
S1 Odd number of 0’s
S2
S3
S4
S00
0
00
1
110
S3
0S4
0S1
0S2
1State Sequence Received
S0 (Reset)
S1 Odd number of 0’s
S2 Even number of 0’s
S3 1
S4 11 (followed by  
any sequence)
S5
S6 Answer
Derivation of State Graphs and Tables  483
Now complete the graph so that each state has both a 0 and 1 arrow leading away 
from it. Add as few extra states to the graph as possible. Also, complete the preced-
ing table.
S000
0
00
00
1
1
111
11
0
S3
0S4
0S5
0S1
0S2
1S6
1
S5 — odd number of 0’s followed by 1.
S6 — even number of 0’s followed by 1.
Present 
StateNext State
Output 01
S0 S1 S3 0
S1 S2 S5 0
S2 S1 S6 1
S3 S1 S4 0
S4 S4 S4 0
S5 S2 S4 0
S6 S1 S4 1
  AnswerVerify that this state graph gives the proper output sequence for each input 
sequence at the start of this exercise. Write down the Moore state table which cor-responds to the preceding graph. (Note that a Moore table has only one output column.) Answer
484 Unit 14
Programmed Exercise 14.3
Derive the state graph and table for a Moore sequential circuit which has an 
output of 1 iff (1) an even number of 0’s have occurred as inputs and (2) an odd 
number of (non overlapping) pairs of 1’s have occurred. For purposes of this prob-
lem, a pair of 1’s consists of two consecutive 1’s. If three consecutive 1’s occur fol-lowed by a 0, the third 1 is ignored. If four consecutive 1’s occur, this counts as two pairs, etc.
(a) The first step is to analyze the problem and make sure that you understand it. 
Note that both condition (1) and condition (2) must be satisfied in order to have a 1 output. Consider condition (1) by itself. Would condition (1) be satisfied if zero 0’s occurred? ___________
 If one 0 occurred? ___________ Two 0’s? ___________ Three 0’s? _________.
(Hint: Is zero an even or odd number? ___________)
(b) How many states would it take to determine if condition (1) by itself is satisfied, 
and what would be the meaning of each state?
_______________________________________________________________
(c) Now consider condition (2) by itself. For each of the following patterns, deter-
mine whether condition (2) is satisfied:
010___________ 0110___________ 01110___________011110___________ 01010___________ 011010___________0110110___________Now check your answers to (a), (b), and (c).
 Answers to (a) yes, no, yes, no, even
 Answers to (b) two states: even number of 0’s, odd number of 0’s
 Answers to (c) From left to right: no, yes, yes, no, no, yes, no
(d) Consider condition (2) by itself and consider an input sequence of consecutive 
1’s. Draw a Moore state diagram (with only 1 inputs) which will give a 1 output when condition (2) is satisfied. State the meaning of each of the four states in your diagram (for example, odd pairs of 1’s).
Derivation of State Graphs and Tables  485
 Answer to (d)
1
11 1 S0
0S1
0S2
1S3
1
S0 = even pairs of 1’s, S1 = even pairs of 1’s + one 1.
S2 = odd pairs of 1’s, S3 = odd pairs of 1’s + one 1
(e) For the original problem, determine the sequence for Z for the following 
example:
X=   1 1 0 0 1 1 1 1 1 0 0 0 1 1 1 1 0
Z=0 ________________________________
 Answer to (e) X=11001111100011110
Z=001011001101000001
(f  ) Considering that we must keep track of both even or odd 0’s, and even or odd 
pairs of 1’s, how many states should the final graph have? ______________
(g) Construct the final Moore state graph. Draw the graph in a symmetric manner 
with even 0’s on the top side and odd 0’s on the bottom side. List the meanings 
of the states such as
S0=even   0’s and even pairs of 1’s.
(h) Check your answer using the test sequence from part (e). Then, check your 
answers below.
 Answer to (f) Eight states
486 Unit 14
 Answer to (g)
1
111 1
11 10
00 0 0 00
0S0
0
S4
0S1
0
S5
0S2
1
S6
0S3
1
S7
0S0 = even 0’s and even pairs of 1’s, S1 = even 0’s and even pairs of 1’s + one 1,
S2 = even 0’s and odd pairs of 1’s, S3 = even 0’s and odd pairs of 1’s + one 1,
S4 = odd 0’s and even pairs of 1’s, S5 = odd 0’s and even pairs of 1’s + one 1,
S6 = odd 0’s and odd pairs of 1’s, S7 = odd 0’s and odd pairs of 1’s + one 1
Problems
14.4 A sequential circuit has one input and one output. The output becomes 1 and 
remains  1 thereafter when at least two 0’s and at least two 1’s have occurred as 
inputs, regardless of the order of occurrence. Draw a state graph (Moore type) for the circuit (nine states are sufficient). Your final state graph should be neatly drawn with no crossed lines.
14.5 A sequential circuit has one input (
X) and two outputs ( Z1 and Z2). An output 
Z1=1 occurs every time the input sequence 010 is completed, provided that the 
sequence 100 has never occurred. An output Z2=1 occurs every time the input 100 
is completed. Note that once a Z2=1 output has occurred, Z1=1 can never occur 
but not vice versa. Find a Mealy state graph and state table (minimum number of 
states is eight).
14.6 A sequential circuit has two inputs ( X1 and X2) and one output ( Z). The output 
begins as 0 and remains a constant value unless one of the following input sequences occurs:
(a) The input sequence 
X1X2=01,   00 causes the output to become 0.
(b) The input sequence X1X2=11, 00 causes the output to become 1.
(c) The input sequence X1X2=10, 00 causes the output to change value.
Derive a Moore state table.
Derivation of State Graphs and Tables  487
14.7 A sequential circuit has one input ( X) and one output ( Z).
Draw a Mealy state graph for each of the following cases:
(a) The output is Z=1 iff the total number of 1’s received is divisible by 3. ( Note: 0, 
3, 6, 9,… are divisible by 3.)
(b) The output is Z=1 iff the total number of 1’s received is divisible by 3 and the 
total number of 0’s received is an even number greater than zero (nine states 
are sufficient).
14.8 A sequential circuit has two inputs and two outputs. The inputs ( X1 and X2) repre-
sent a 2-bit binary number, N. If the present value of N is greater than the previous 
value, then Z1 is 1. If the present value of N is less than the previous value, then Z2 
is 1. Otherwise, Z1 and Z2 are 0. When the first pair of inputs is received, there is no 
previous value of N, so we cannot determine whether the present N is greater than 
or less than the previous value; therefore, the “otherwise” category applies.
(a) Find a Mealy state table or graph for the circuit (minimum number of states, 
including starting state, is five).
(b) Find a Moore state table for the circuit (minimum number of states is 11).
14.9 (a)  Derive the state graph and table for a Mealy sequential circuit which converts 
a serial stream of bits from NRZ code to NRZI code. Assume that the clock 
period is the same as the bit time as in Figure 14-20.
(b) Repeat (a) for a Moore sequential circuit.
(c) Draw a timing diagram for your answer to (a), using the NRZ waveform in 
Figure 14-20 as the input waveform to your circuit. If the input changes occur slightly after the clock edge, indicate places in the output waveform where glitches (false outputs) can occur.
(d) Draw the timing diagram for your answer to (b), using the same input waveform 
as in (c).
14.10 For the following state graph, construct the state table, and demonstrate that it is completely specified.
14.11 Design a sequential circuit which will output Z = 1 for exactly four clock cycles 
each time a person pushes a button (which sets 
X=1). The clock for a digital cir-
cuit is usually much faster than a person’s finger! The person probably will not have released the button by the time four clock cycles have passed, so 
X may still be 1 
when the four Z=1 outputs have been generated. Therefore, after Z is 1 for four 
clock cycles, Z should go to 0, until X returns to 0 and then becomes 1 again. Design a 
Mealy state graph for this circuit, using the alphanumeric state graph notation given in Section 14.5.S0 S1
AC ′
DFA′C ′
DE AB′
E
AB
FA′
D
C
0
488 Unit 14
14.12 (a)  A Moore sequential circuit has one input ( x) and one output ( z). z=1 if and 
only if the most recent input was  1 and it was preceded by exactly two 0’s. Derive 
a state table for the circuit.
(b) Repeat for a Mealy circuit (i.e., z=1 if and only if the most recent input is 1 and 
it was preceded by exactly two 0’s). Derive a state table for the circuit.
14.13 (a)  A Mealy sequential circuit has one input ( x) and one output ( z). z can be 1 
when the fourth, eighth, twelfth, etc. inputs are present, and z=1 if and only if 
the most recent input combined with the preceding three inputs was not a valid 
BCD encoding for a decimal digit; otherwise, z=0. Assume the BCD digits 
are received most significant bit first. Derive a state table for the circuit. (Eight states are sufficient.)
(b) Repeat for a Moore circuit (i.e., 
z=1 if and only if, after the fourth, eighth, 
twelfth, etc. inputs have been received, the previous four inputs were not a valid BCD digit). (Nine states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.14 (a)  A Mealy sequential circuit has one input (
x) and one output ( z). z=1 if and 
only if the most recent input, combined with the preceding three inputs, was not a valid BCD encoding of a decimal digit; otherwise, 
z=0. Assume the BCD 
digits are received most significant bit first. Derive a state table for the circuit. 
(Seven states are sufficient.)
(b) Repeat for a Moore circuit (i.e., z = 1 if and only if the previous four inputs were 
not a valid BCD digit). (Thirteen states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.15 (a)  A Mealy sequential circuit has one input ( x) and one output ( z). z can be 1 
when the fourth, eighth, twelfth, etc. inputs are present, and z=1 if and only if 
the most recent input combined with the preceding three inputs was not a valid BCD encoding of a decimal digit; otherwise, 
z=0. Assume the BCD digits are 
received least significant bit first. Derive a state table for the circuit. (Six states 
are sufficient.)
(b) Repeat for a Moore circuit (i.e., z=1 if and only if, after the fourth, eighth, 
twelfth, etc. inputs have been received, the previous four inputs were not a valid BCD digit).
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.16 (a)  A Mealy sequential circuit has one input (
x) and one output ( z). z=1 if and only 
if the most recent input, combined with the preceding three inputs, was not a valid BCD encoding of a decimal digit; otherwise, 
z=0. Assume the BCD digits 
are received least significant bit first. Derive a state table for the circuit.  Assume that in the reset state all previous inputs were 0. (Three states are sufficient.)
Derivation of State Graphs and Tables  489
(b) Repeat for a Moore circuit (i.e., z=1 if and only if the previous four inputs were 
not a valid BCD digit). (Four states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.17 (a)  A Mealy sequential circuit has one input ( x) and one output ( z). z can be 1 
when the fourth, eighth, twelfth, etc. inputs are present, and z=1 if and only if 
the most recent input, combined with the preceding three inputs, was not a valid 
excess-3 encoding of a decimal digit; otherwise, z=0. Assume the excess-3 dig-
its are received most significant bit first. Derive a state table for the circuit. (Ten 
states are sufficient.)
(b) Repeat for a Moore circuit (i.e., z=1 if and only if, after the fourth, eighth, 
twelfth, etc. inputs have been received, the previous four inputs were not a valid excess-3 digit). (Eleven states are sufficient.)
(c) Is it possible to for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.18 (a)  A Mealy sequential circuit has one input (
x) and one output ( z). z=1 if and only 
if the most recent input, combined with the preceding three inputs, was not a valid excess-3 encoding of a decimal integer; otherwise, 
z=0. Assume the excess-3  
digits are received most significant bit first. Derive a state table for the cir-
cuit. Assume that in the reset state all previous inputs were 0. (Eight states are  sufficient.)
(b) Repeat for a Moore circuit (i.e., 
z=1 if and only if the previous four inputs were 
not a valid excess-3 digit). (Fourteen states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.19 (a)  A Mealy sequential circuit has one input ( x) and one output ( z). z can be 1 
when the fourth, eighth, twelfth, etc. inputs are present, and z=1 if and only if 
the most recent input, combined with the preceding three inputs, was not a valid excess-3 encoding of a decimal digit; otherwise, 
z=0. Assume the excess-3 dig-
its are received least significant bit first. Derive a state table for the circuit. (Nine states are sufficient.)
(b) Repeat for a Moore circuit (i.e., 
z=1 if and only if, after the fourth, eighth, 
twelfth, etc. inputs have been received, the previous four inputs were not a valid excess-3 digit). (Ten states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.20 (a)  A Mealy sequential circuit has one input (
x) and one output ( z). z=1 if and only 
if the most recent input combined with the preceding three inputs was not a valid excess-3 encoding of a decimal digit; otherwise, 
z=0. Assume the excess-3 digits 
are received least significant bit first. Derive a state table for the circuit. Assume that in the reset state all previous inputs were 0. (Six states are sufficient.)
490 Unit 14
(b) Repeat for a Moore circuit (i.e., z=1 if and only if the previous four inputs were 
not a valid excess-3 digit). (Eight states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth 
input bit is present rather than after it has been received? Explain your answer.
14.21 A sequential circuit has one input and one output. The output becomes 1 and 
remains  1 thereafter when at least one 1 and three 0’s have occurred as inputs, regardless of the order of occurrence. Draw a state graph (Moore type) for the cir-cuit (eight states are sufficient). Your final state graph should be neatly drawn with no crossed lines.
14.22 A sequential circuit has one input (
X) and two outputs ( Z1 and Z2). An output 
Z1=1 occurs every time the input sequence 100 is completed provided that the 
sequence 011 has never occurred. An output Z2=1 occurs every time the input 011 
is completed. Note that once a Z2=1 output has occurred, Z1=1 can never occur 
but not vice versa. Find a Mealy state graph and state table (minimum number of 
states is eight).
14.23 A sequential circuit has two inputs ( X1 and X2) and one output ( Z). The output 
begins as 0 and remains a constant value unless one of the following input sequences occurs:
(a) The input sequence 
X1X2=11, 10 causes the output to become 0.
(b) The input sequence X1X2=00, 10 causes the output to become 1.
(c) The input sequence X1X2=01, 10 causes the output to toggle.
Derive a Moore state table and state graph.
14.24 A sequential circuit has one input ( X) and one output ( Z).
Draw a Mealy state graph for each of the following cases:
(a) The output is Z =1 iff the total number of 1’s received is divisible by 4.
(Note: 0, 4, 8, 12,… are divisible by 4.)
(b) The output is Z=1 iff the total number of 1’s received is divisible by 4 and the 
total number of 0’s received is an odd number (eight states are sufficient).
14.25 A sequential circuit has two inputs and two outputs. The inputs ( X1 and X2) repre-
sent a 2-bit binary number, N. If the present value of N plus the previous value of N 
is greater than 2, then the Z1 is 1. If the present value of N times the previous value 
of N is greater than 2, then Z2 is 1. Otherwise, Z1 and Z2 are 0. When the first pair of 
inputs is received, use 0 as the previous value of N.
(a) Find a Mealy state table or graph for the circuit (minimum number of states 
is four).
(b) Find a Moore state table for the circuit (minimum number of states is 10, but any 
correct answer with 16 or fewer states is acceptable).
14.26 A Moore sequential circuit has one input and one output. When the input sequence 011 occurs, the output becomes 1 and remains 1 until the sequence 011 occurs again 
Derivation of State Graphs and Tables  491
in which case the output returns to 0. The output then remains 0 until 011 occurs a 
third time, etc. For example, the input sequence
X=0 1 0 1 1 0 1 0 1 1 0 1 0 0 1 1 1
has the output
Z=(0) 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 1 1
Derive the state graph (six states minimum).
14.27 Work Problem 14.26 if the input sequence 101 causes the output to change value. For example, the input sequence
X=0 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0
has the output
Z=(0) 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 1
(six states minimum).
14.28 A Mealy sequential circuit has two inputs and one output. If the total number of 0’s received is 
≥4 and at least three pairs of inputs have occurred, then the output 
should be 1 coincident with the last input pair in the sequence. Whenever a 1 output occurs, the circuit resets. Derive a state graph and state table. Specify the meaning of each state. For example, S
0 means reset, S1 means one pair of inputs received but 
no 0’s received, etc.
Example:
14.29  A Moore sequential circuit has one input and one output. The output should be 1 if the total number of 1’s received is odd and the total number of 0’s received is an even number greater than 0. Derive the state graph and table (six states).
14.30 A Mealy sequential circuit has one input (
X) and two outputs (Z1 and Z2). The cir-
cuit produces an output of Z1=1 whenever the sequence 011 is completed, and an 
output of Z2=1 whenever the sequence 0111 is completed. Derive the state graph 
and table.
14.31 A Moore sequential circuit has two inputs ( X1 and X2) and one output ( Z). Z begins 
at 0. It becomes 1 when X1=1 and X2=1 either concurrently, or one after the other Input sequence: X1=1 1 1 0 0 0 1 1 1 0 0 0 1 1 0 0 0 1 0
X2=1 0 0 0 0 0 1 1 1 1 1 1 0 1 0 0 0 1 0
Output sequence: Z=0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1
492 Unit 14
(in either order). Z returns to zero when X1=X2=0. The following input and out-
put sequence should help you understand the problem:
  X1=       0 1 0 0 1 0 0 0 1 1 0 1 1 0
  X2=       0 0 1 1 0 0 1 1 0 0 0 1 0 0
Z  = (0) 0 0 1 1 1 0 0 0 1 1 0 1 1 0
Give the Moore state graph and table.
14.32 A Mealy sequential circuit has one input ( X) and one output ( Z). The circuit should 
transmit its input, except that it should prevent the sequence 00110 from occurring. 
So Z should be the same as X, except that if the input sequence 00110 occurs, Z 
should be 1 rather than 0 when the last 0 is received, so that the sequence X=0 0 1 1 0 
is replaced with Z =0 0 1 1 1. Derive the state graph and table.
14.33 A Moore sequential circuit has one input and one output. The output is 1 if and only if both of the following conditions are met:
(a) The input sequence contains exactly two groups of 1’s, and(b) Each of these groups contains exactly two 1’s.Each group of 1’s must be separated by at least one 0. A single 1 is considered a group of 1’s containing one 1. For example, the sequence
X=0 1 1 0 0 0 1 1 0 1 1 1 0
satisfies both conditions after the first two pairs of 1’s. However, when more 1’s appear, condition (a) is no longer satisfied. Therefore, the output sequence should be
Z=
(0) 0 0 0 0 0 0 0 1 1 0 0 0 0
On the other hand, the sequence
X=1 0 1 1 0 1 1 0
never satisfies condition (b), because the first group of 1’s contains only one 1. Besides, after the second pair of 1’s, (a) is no longer satisfied because the input sequence con-tains three groups of 1’s. Therefore, the output should always be 0.
Z=
(0) 0 0 0 0 0 0 0 0
Derive a state graph and table.
14.34 A sequential circuit has an input ( X) and an output ( Z). The output is the same as 
the input was two clock periods previously. For example,
X=0 1 0 1 1 0 1 0 1 1 0 1 0 0 0 1
Z=0 0 0 1 0 1 1 0 1 0 1 1 0 1 0 0
The first two values of Z are 0. Find a Mealy state graph and table for the circuit.
Derivation of State Graphs and Tables  493
14.35 A sequential circuit has an input ( X) and an output ( Z). The output is the same as 
the input was three clock periods previously. For example,
X=0 1 0 1 1 0 1 0 1 1 0 1 0 0 0 1
Z=0 0 0 0 1 0 1 1 0 1 0 1 1 0 1 0
The first three values of Z are 0. Find a Mealy state graph and table for the circuit.
14.36 (a)  Construct a Moore state table for the circuit of Problem 14.34. The initial out-
puts are 0.
(b) How many states are required in a Moore state table for the circuit of 
Problem 14.35? Explain
14.37 A sequential circuit has an input ( X) and two outputs ( S and V). X represents a 
4-bit binary number N which is input least significant bit first. S represents a 4-bit 
binary number equal to N+2, which is output least significant bit first. At the time 
the fourth input occurs, V=1 if N +2 is too large to be represented by four bits; 
otherwise, V=0. The circuit always resets after the fourth bit of X is received. Find 
a Mealy state graph and table for the circuit.
Example: X=0111 (binary 14 with the least significant bit first)
S=0000 (because 14 + 2 = 16, and 16 requires 5 bits)
V=0001
14.38 A sequential circuit has an input ( X) and two outputs ( D and B). X represents a 
4-bit binary number N which is input least significant bit first. D represents a 4-bit 
binary number equal to N−2, which is output least significant bit first. At the time 
the fourth input occurs, B=1 if N−2 is less than 0; otherwise B=0. The circuit 
always resets after the fourth bit of X is received. Find a Mealy state graph and table 
for the circuit.
Example: X=0001   1000   1100
D=0110   1111   1000
B=0000   0001   0000
14.39 A sequential circuit has an input ( X) and outputs ( Y and Z). YZ represents a 2-bit 
binary number equal to the number of 1’s that have been received as inputs. The 
circuit resets when the total number of 1’s received is 3, or when the total number of 0’s received is 3. Find a Moore state graph and table for the circuit.
14.40 A sequential circuit has an input 
X and outputs ( Yand Z). YZ represents a 2-bit 
binary number equal to the number of pairs of adjacent 1’s that have been received as inputs. For example, the input sequence 0110 contains one pair, the sequence 01110 two pairs, and the sequence 0110111 contains three pairs of adjacent 1’s. The 
494 Unit 14
circuit resets when the total number of pairs of 1’s received reaches four. Find a 
Moore state graph and table for the circuit.
Input Output
00XX 0000
01XX 001110XX 110011XX 1111Input sequence: X=0 1 0 1 1 0 1 1 1 0 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 0 0 1 0
Output sequences: Y=0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1
Z=0 0 0 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
Input sequence: X=1 1 1 1 1 1 1 1
Output sequences: Y=0 0 1 1 0 0 0 1
Z=0 1 0 1 0 0 1 0
Inputs:  N=0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
D=0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
Q=0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
Outputs:   R=0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0
  C=0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0Examples:
(Hint: Be sure that the circuit resets as shown in the examples.)
14.41 A sequential circuit with one input and one output is used to stretch the first two bits 
of a 4-bit sequence as follows:
After every 4 bits, the circuit resets. Find a Mealy state graph and table for the circuit. The third and fourth bits of the input sequence can be either 1 or 0, so make sure that the circuit will work for all possible combinations.
14.42 A sequential circuit is to be used to control the operation of a vending machine which dispenses a $0.25 product. The circuit has three inputs ( N, D, and Q) and two outputs 
(R and 
C). The coin detector mechanism in the vending machine is synchronized with 
the same clock as the sequential circuit you are to design. The coin detector outputs a single 1 to the N, D, or Q  input for every nickel, dime, or quarter, respectively, that the 
customer inserts. Only one input will be 1 at a time. When the customer has inserted at least $0.25 in any combination of nickels, dimes, and quarters, the vending machine must give change and dispense the product. The coin return mechanism gives change by returning nickels to the customer. For every 1 output on 
C, the coin return mecha-
nism will return one nickel to the customer. The product is dispensed when the circuit outputs a single 1 on output R. The circuit should reset after dispensing the product.
Example: 
The customer inserts a nickel, a dime, and a quarter. The circuit inputs and outputs could look like this:
Derivation of State Graphs and Tables  495
Note that any number of 0’s can occur between 1 inputs.
Derive a Moore state table for the sequential circuit, and for each state indicate how much money the customer has inserted or how much change is due.
14.43 (a)  Derive the state graph and table for a Mealy sequential circuit that converts a 
serial stream of bits from Manchester code to NRZ code. Assume that a double frequency clock (Clock2) is available.
(b) Repeat (a) for a Moore sequential circuit.
(c) Draw a timing diagram similar to Figure 14-21(b) for your answer to (a), using 
the Manchester waveform in Figure 14-21(b) as the input waveform to your cir-cuit. If the input changes occur slightly after the clock edge, indicate places in the output waveform where glitches (false outputs) can occur. If possible, assign the don’t-cares in the output part of your state table to eliminate some of the glitches.
(d) Draw the timing diagram for your answer to (b), using the same input waveform 
as in (c).
14.44 Design a sequential circuit to control a phone answering machine. The circuit should have three inputs (R , A, and 
S) and one output ( Z).R=1for one clock cycle at the 
end of each phone ring. A=1 when the phone is answered. S selects whether the 
machine should answer the phone after two rings ( S=0) or four rings ( S=1). To 
cause the tape recorder to answer the phone, the circuit should set the output Z=1 
after the end of the second ( S=0) or fourth ( S=1) ring, and hold Z =1 until the 
recorder circuit answers the phone (i.e., when A goes to 1). If a person answers the 
phone at any point, A will become 1, and the circuit should reset. Assume that S is 
not changed while the phone is counting rings. Give a Moore state graph for this circuit, using the alphanumeric state graph notation given in Section 14.5.
14.45 For the following state graph, derive the state table.
S1 S2
X1′ X2/Z1Z2X1′ X2/0
X1′ X2′/0X1′ X2′/0S0
X1′X2′/Z2
X1/Z2
X1/0 X1/0X1′ X2/Z1
496 Unit 14
14.47 Modify the BCD parity detector of Table 14-9 for the case where the least significant 
bit of the BCD digits is received first. Construct the incompletely specified Mealy model state table. ( Hint: It can be constructed by specifying states to remember the 
first 3 bits of a BCD digit, but not all sequences of length three have to be distin-guished. It requires at most 11 states.)
14.48 In the parity detector of Table 14-9, assume the decimal digits are encoded using the excess-3 code instead of BCD. Construct the incompletely specified state table for this case. (Ten states are required.)
14.49 In the parity detector of Table 14-9, assume the decimal digits are encoded using the Gray code instead of BCD. Construct the incompletely specified state table for this case. (Eleven states are required.)
14.50 The decimal digits 0 through 5 are encoded as 3-bit binary numbers. They are trans-mitted in disjoint windows of length 3 least significant bit first and are input to a Mealy model circuit. The circuit generates an output of 1 (0) when the third bit is received if the 3 bits have even (odd) parity; the circuit output is a don’t-care for the first 2 bits. Construct an incompletely specified table for the circuit.
14.51 Redo Problem 14.50 assuming the bits are sent most significant bit first.X2X1′  X2
X1′  X2′ S0
X1′ X2
X1Z1X1′ X2′ 
X1′  X2′ X1X2
X1S1
Z2S2
Z314.46 There are two errors in the state graph shown. One state is not completely specified for one combination of 
X1 and X2. In another state, there is a contradiction for one 
combination of X1 and X2. Correct the state graph by making two minor changes. 
Demonstrate that the modified state graph is completely specified.
497Reduction of State Tables  
State AssignmentUNIT
15
Objectives
1. Define equivalent states, state several ways of testing for state equivalence, and 
determine if two states are equivalent.
2. Define equivalent sequential circuits and determine if two circuits are  equivalent.
3. Reduce a state table to a minimum number of rows.
4. Specify a suitable set of state assignments for a state table, eliminating those assignments which are equivalent with respect to the cost of realizing the circuit.
5. State three guidelines which are useful in making state assignments, and apply these to making a good state assignment for a given state table.
6. Given a state table and assignment, form the transition table and derive  flip-flop input equations.
7. Make a one-hot state assignment for a state graph and write the next-state and output equations by inspection.
498 Unit 15
Study Guide
1. Study Section 15.1, Elimination of Redundant States.
2. Study Section 15.2, Equivalent States.
(a) State in words the meaning of λ1(p, X )=λ2(q, X ).
(b) Assuming that N1 and N2 are identical circuits with the following state 
graph, use Definition 15.1 to show that p is not equivalent to q. (Calculate 
λ(p, X  ) and λ (q,  X  ) for X=0,  X=1,  X=00,   X=01, etc.)
r qp
1
1
1
01
00
0
0
00
0
(c) Suppose you were given two sequential circuits ( N1 and N2) in black boxes 
with only input and output terminals available. Each box has a reset button. 
The button on N1 resets it to state p and the button on N2 resets it to state q. 
Could you experimentally determine if p=q using Definition 15.1? Explain.
(d) Apply Theorem 15.1 to show that in Table 15-9, S2≢S3.
(e) Note the difference between the definition of state equivalence 
(Definition 15.1) and the state equivalence theorem (Theorem 15.1). The 
definition requires an examination of output sequences but not next states, 
while the theorem requires looking at both the output and next state for 
each single input. Make sure that you know both the definition and the theorem. Write out the definition of equivalent states:
Write out the state equivalence theorem:When you check your answers, note that the theorem requires equal out-
puts and equivalent next states. This distinction between equal and equiva-
lent is very important. For example, in the following state table, no two states have equal next states, but we can still reduce the table to two states, 
Reduction of State Tables State Assignment  499
because some next states are equivalent. Note that the state equivalence 
theorem tells us that S3≡S0 if S3≡S0, When this happens, we may say 
S3≡S0. What other pair of states are equivalent?
Present 
State Next State Z
S0 S1 S0 0
S1 S0 S2 1
S2 S3 S2 1
S3 S1 S3 0
Next 
StatePresent Output
X=01 X=01
aa b 00
b d a 01
ca b 01
d g f 00
f d g 01
g d f 01
abc d fgfdcb
Next StatePresent Output
X=01 X=01
a bc 01
b db 00
ce a 01
d de 00
ee e 003. Study Section 15.3, Determination of State Equivalence Using an Implication Table .
(a) Fill in the following implication chart to correspond to the given table (first 
pass only).
Your answer should have eight squares with X’s, two squares with one implied 
pair, and four squares with two implied pairs. There should be a check in 
square f-g because the only nontrivial implication of f-g is f-g itself.
(b) Now go through your chart and eliminate all nonequivalent pairs (several 
passes may be required). What is the only equivalent state pair? According to the state equivalence theorem, why is b ≢d? Why is a≢b?
(c) Find all of the equivalent states in the following table using an implication 
table:
(You should have found four pairs of equivalent states. If you found only 
two pairs, reread Section 15.3).Reduce the table to two rows.
500 Unit 15
4. Study Section 15.4, Equivalent Sequential Circuits . Define equivalent sequential 
circuits. (Make sure you know the difference between equivalent states and equiv-
alent circuits.)
5. Work Problems 15.1, 15.2, and 15.3 using the methods of Sections 15.3 and 15.4. 
When forming the implication charts for state equivalence, follow the convention used in the text. That is, label the bottom of the chart starting with the first state and ending with the next-to-last state. Then, label the left side of the chart start-ing with the second state at the top and ending with the last state at the bottom.
6. Study Section 15.5, Reducing Incompletely Specified State Tables.
(a) State two reasons why a state table might be incompletely specified.
(b) For Table 15-5(a), construct the implication chart and find the maximal 
compatibles. Use the maximal compatibles to construct the reduced table with two states.
(c) Show that the state table in Study Guide 10 of Unit 14 can be reduced to 
two states.
7. Read Section 15.6, Derivation of Flip-Flop Input Equations.
(a) Derive J
C and KC from the C+ map of Figure 15-10(a).
00 01 11 10
00
01
11
1000 01 11 10
00
01
11
10
00 01 11 10
00
01
11
10(b) Plot the map for the output function (Z) from the transition table of 
Table 15-9(b) and derive the minimum equation for Z.
Reduction of State Tables State Assignment  501
(c) Derive the J-K input equations for flip-flop A from the next-state map of 
Figure 15-11. Your answers should be
 JA=X2B, KA=X2′B′
(d) Work Problem 15.4.
8. Study Section 15.7 , Equivalent State Assignments.
(a) Fill in the missing assignments (numbered 8 through 18) in Table 15-11. 
First, list the remaining assignments with 01 in the first row and then the 
assignments with 10 in the first row.
(b) Why is it unnecessary to try all possible state assignments to be assured of 
finding a minimum cost circuit?
(c) For symmetrical flip-flops, why is it always possible to assign all 0’s to the 
starting state and still obtain a minimum circuit?
(d) Complete the following transition table for Table 15-12 using assignment A. 
Then, complete the next-state maps and derive D1 and D2.
Q1Q2 X=0 1
00 00 10
011001
XX00Q1Q2X
01
11
10
Q1  = D1+01
XX00Q1Q2X
01
1110
Q2  = D2+
Starting with the equations for assignment A, replace all of the 1’s with 2’s 
and all 2’s with 1’s. Verify that the resulting equations are the same as those 
for assignment B .
Starting with the J and K equations for assignment A, replace each Q with 
Q′ and vice versa. Then, replace the equations for J with the corresponding 
K equations and vice versa. (This corresponds to the transformation given 
in Figure 15-13.) Verify that the resulting equations are the same as for assignment 
C.
Complement the right-hand side of the D equations for assignment A and, 
then, replace each Q  with Q ′ and vice versa. (This corresponds to the 
502 Unit 15
transformation given in Figure 15-14.) Verify that the resulting equations 
are the same as for assignment C.
(e) Show that each of the assignments in Table 15-11 is equivalent to one of the 
assignments in Table 15-13.
 (f ) Why are the following two state assignments equivalent in cost?
10 11 01
01 01 1100 00 0011 10 10
(1) (3) (5) (3) (1) (5)
000 000001 001010 100111 111A 000 011
B 001 111
C 011 101
D 101 110
E 100 010
F 010 001
G 110 000
(g) Show that each of the following assignments can be generated from 
Table 15-13 by permuting and/or complementing columns:
(h) Why is the trial-and-error method of state assignment of limited usefulness?
(i) Read Problem 15.5, and then answer the following questions regarding 
state assignments before you work the problem:
(1) Why should a column not be assigned all 0’s or all 1’s?
(2) Why should two columns not be given the same assignment?(3) Does interchanging two columns affect the cost of realizing the circuit?(4) Does interchanging two rows affect the cost?(5) Why is an assignment which has two identical rows invalid?(6) Consider the following two assignments (the number at the top of each 
column is the decimal equivalent of the binary number in the column):
If we try the column assignment (1) (3) (5), why is it unnecessary to try 
(3) (1) (5)?
Why is it desirable to assign the column values in increasing numerical order?
Reduction of State Tables State Assignment  503
9. Study Section 15.8, Guidelines for State Assignment.
(a) Why do the guidelines for making state assignments help in making an 
economical assignment?
(b) What should be done if all the adjacencies specified by the guidelines 
 cannot be satisfied?
(c) The state assignment guidelines for Figure 15-15(a) indicate that the fol-
lowing sets of states should be given adjacent assignments:
(1)  (S0, S1, S3, S5)  (S3, S5)  (S4, S6)  (S0, S2, S4, S6)
(2)  (S1, S2)  (S2, S3)  (S1, S4)  (S2, S5)2X  (S1, S6)2X
Because the adjacencies from guideline 1 are generally most important, 
we will start by placing one of the largest groups from guideline 1 in four adjacent squares:
S0
S1
S3
S5
Note that (S3,  S5) is also satisfied by this grouping. Place S2,  S4, and S6 in the 
remaining squares to satisfy as many of the remaining guidelines as possible. Keeping in mind that groups labeled 2
X should be given preference over 
groups which are not repeated. Compare your answer with Figure 15-15(b).
(d) Complete the transition table for the state table of Figure 15-17(a), using 
the assignment of Figure 15-17(b).
(e) Complete the next-state and output maps, and verify that the cost of real-
izing the corresponding equations with an AND-OR gate circuit is 13 gates and 35 gate inputs.
 (f ) Find J
1 and K1 from the Q+
1 map.
J1 = _______________________
K1 = ______________________Q+
1 Q+
2 Q+
3
Q1Q2Q3X=0 10 1
a0 0 0 000 100 0 0
b1 1 1 011 110 0 1
c1 0 0 100 000 0 0
504 Unit 15
10. Work Problems 15.6, 15.7 , and 15.8.
11. Study Section 15.9, Using a One-Hot State Assignment.
(a) A one-hot state assignment does not usually give a solution that uses less 
hardware because of the extra flip-flops required. In what situation is it 
often advantageous to use it anyway?
(b) It is easy to derive flip-flop input equations directly from a state graph for 
a one-hot state assignment by inspecting the arcs leading into a given state. Give the next-state equation for Q
5. Only the parts of the state graph which 
are needed to find Q+
5 are given.
(c) For the state graph in Figure 15-20 and the one-hot state assignment shown, 
determine the next-state equations for Q2 and Q3.
Q+
2=____________  and Q+
3=_______________________
(d) For the state graph in Figure 15-20 and the one-hot state assignment shown, 
determine the output equations for Ad and Done.
Ad=____________  and   Done =____________
(e) Work Problem 15.9.
12. When you are satisfied that you can meet all of the objectives, take the readiness test.Q2Q3
Q1 +0 1 0 100 01 11 10
X X
0 100XQ1
01
11
10Q2Q3
Q2 +0 0 0 000 01 11 10
X X
1 100XQ1
01
1110
Q2Q3
Q3 +0 0 0 000 01 11 10
X X
1 000XQ1
01
1110Q2Q3
ZD1 =
0 0 0 000 01 11 10
X X
0 100XQ1
01
1110D2 =
D3 =
Z =
S2 S5X′
0X
0X′Y
P,
505Reduction of State Tables  
State Assignment
Given a description of the desired input-output behavior of a sequential circuit, the 
first step in designing the circuit is to derive a state table using methods similar to the ones discussed in the previous unit. Before we realize this state table using  flip-flops and logic gates, reduction of the state table to a minimum number of states is desir-able. In general, reducing the number of states in a table will reduce the amount of logic required, and the number of flip-flops may also be reduced. For example, if a table with nine states is reduced to eight states, the number of flip-flops required is reduced from four to three, with a possible corresponding reduction in the amount of input logic for the flip-flops. If the table is further reduced to six states, three  flip-flops are still required, but the presence of more don’t-cares in the flip-flop input equations will probably further reduce the required logic.
Given the reduced state table, the next step in synthesizing the circuit is to assign 
binary flip-flop states to correspond to the circuit states. The way in which this assign-ment is made will determine the amount of logic required for the circuit. The problem of finding a good state assignment which leads to an economical circuit is a difficult one, but some guidelines for achieving this are discussed in Sections 15.7–15.8.
The next step in designing the sequential circuit is to derive the flip-flop input 
equations. We have already done this for counters in Unit 12, and we will show how to apply these techniques to more general sequential circuits.
15.1 Elimination of Redundant States
In Unit 14, we were careful to avoid introducing unnecessary states when setting up a state graph or table. We will now approach the problem of deriving the state graph somewhat differently. Initially, when first setting up the state table, we will not be overly concerned with inclusion of extra states, but when the table is complete, we will eliminate any redundant states. In previous units, we have used the notation 
S0,  S1,  S2, . . .  to represent states in a sequential circuit. In this unit, we will frequently 
use A,  B,  C, . . .  (or a ,  b,  c, . . . ) to represent these states.
We will rework Example 1 in Section 14.3. Initially, we will set up enough states 
to remember the first three bits of every possible input sequence. Then, when the fourth bit comes in, we can determine the correct output and reset the circuit to the 
506 Unit 15
initial state. As indicated in Table 15-1, we will designate state A as the reset state. If 
we receive a 0, we go to state B; if we receive a 1, we go to state C. Similarly, starting 
in state B, a 0 takes us to state D to indicate that the sequence 00 has been received, 
and a 1 takes us to state E to indicate that 01 has been received. The remaining states 
are defined in a similar manner. When the fourth input bit is received, we return to 
the reset state. The output is 0 unless we are in state J or L and receive a 1, which 
corresponds to having received 0101 or 1001.
Next, we will attempt to eliminate redundant states from the table. The input 
sequence information was only used in setting up the table and will now be disre-garded. Looking at the table, we see that there is no way of telling states 
H and I 
apart. That is, if we start in state H, the next state is A and the output is 0; similarly, 
if we start in state I, the next state is A and the output is 0. Hence, there is no way of 
telling states H and I apart, and we can replace I with H where it appears in the 
 next-state portion of the table. Having done this, there is no way to reach state I, 
so row I can be removed from the table. We say that H is equivalent to I(H≡I). 
 Similarly, rows K,  M,  N, and P have the same next state and output as H, so K, M, N, 
and P can be replaced by H, and these rows can be deleted. Also, the next states and 
outputs are the same for rows J and L, so J≡L. Thus, L can be replaced with J and 
eliminated from the table. The result is shown in Table 15-2.
Having made these changes in the table, rows D and G are identical and so are 
rows E and F. Therefore, D≡G, and E≡F, so states F and G can be eliminated. 
Figure 15-1 shows a state diagram for the final reduced table. Note that this is identical to the state graph of Figure 14-15, except for the designations for the states. The proce-dure used to find equivalent states in this example is known as row matching. In general, 
row matching is not sufficient to find all equivalent states, except in the special case 
where the circuit resets to the starting state after receiving a fixed number of inputs.   Input 
SequencePresent 
StateNext StatePresent  
Output
X=0 X=1 X=0 X=1
reset A B C 00
0 B D E 00
1 C F G 00
00 D H I 00
01 E J K 00
10 F L M 00
11 G N P 00
000 H A A 00
001 I A A 00
010 J A A 01
011 K A A 00
100 L A A 01
101 M A A 00
110 N A A 00
111 P A A 00TABLE 15-1
State Table for 
Sequence Detector
© Cengage Learning 2014
Reduction of State Tables State Assignment  507
Present 
StateNext StatePresent  
Output
X=0 X=1 X=0X=1
A B C 00
B D E 00
C F E G D 00
D H I H 00
E J K H 00
F L J M H 00
G N H P H 00
H A A 00
I A A 00
J A A 01
K A A 00
L A A 01
M A A 00
N A A 00
P A A 00
FIGURE 15-1
Reduced State 
Table and Graph 
for Sequence 
Detector
© Cengage Learning 20140
0
0
00
00
00
00
00
01
0
1
11
11
01
0
1
0 1
0A
B
D
H JEC
(b)Present Next State Output
State X0X1X0X1
AB C 00
BD E 00
CE D 00
DH H 00
EJ H 00
HA A 00
JA A 01
(a)TABLE 15-2
State Table for 
Sequence Detector
15.2 Equivalent States
As we have seen in the previous example, state tables can be reduced by eliminating 
equivalent states. A state table with fewer rows often requires fewer flip-flops and logic gates to realize; therefore, the determination of equivalent states is important in order to obtain economical realizations of sequential circuits.© Cengage Learning 2014
508 Unit 15
Let us now consider the general problem of state equivalence. Basically, two 
states are equivalent if there is no way of telling them apart through observation of 
the  circuit inputs and outputs. Consider two sequential circuits (these may be dif-ferent circuits or two copies of the same circuit), one which is started in state 
p and 
one which is started in state q (Figure 15-2): Let X represent a sequence of inputs 
X1,  X2, . . . , Xn. Feed the same input sequence X into both circuits and observe the 
output sequences Z1 and Z 2. If these output sequences are the same, so far so good. 
Then, reset the circuits to the states p and q and try a different input sequence for X 
and again compare output sequences. If, for every possible input sequence X, these 
output sequences are the same, then there is no way of telling states p and q apart 
by observing the terminal behavior of the circuits, and we say p is equivalent to 
q( p≡q). On the other hand, if, for some input sequence X, the output sequences Z1 
and Z 2. are different, then we can distinguish between states p and q , and they are 
not equivalent. Because the output sequence is a function of the initial state and the input sequence, we will write
Z
1=λ1( p,  X )Z 2=λ  2(q,  X )
We can then state formally the definition of state equivalence as follows:N1 Z1
Z2Xp
N2q
Definition 15.1FIGURE 15-2
Let N1 and N2 be sequential circuits (not necessarily different). Let X represent a 
sequence of inputs of arbitrary length. Then state p in N1 is equivalent to state q in 
N2 iff λ1( p, X )=λ2(q, X ) for every possible input sequence X.
To apply Definition 15.1 directly, we should first test the circuits with X=0 and 
X=1. Then, we should test with all input sequences of length 2: X=00,   01,   10, and 11. 
Next, we should test with all input sequences of length 3: X=000,   001,   010,   011,   100, 
101,   110, and 111. We should then continue this process with all input sequences of 
length 4, length 5, and so forth. Definition 15.1 is not practical to apply directly in prac-tice because it requires testing the circuit with an infinite number of input sequences in order to prove that two states are equivalent. A more practical way of testing for state equivalence uses the following theorem:
Theorem15.1
1 Two states p and q of a sequential circuit are equivalent iff for 
every single input X, the outputs are the same and the next states are equivalent, that is,
λ( p, X  )=λ(q, X  )  and  δ( p, X  )≡δ(q, X  )
where λ(p, X) is the output given the present state p and input X, and δ( p, X  ) is the 
next state given the present state p and input X. Note that the next states do not 
have to be equal, just equivalent. For example, in Table 15-1, D ≡G, but the next 
states ( H and N for X=0, and I and P for X=1) are not equal.
1See Appendix D for proof.© Cengage Learning 2014
Reduction of State Tables State Assignment  509
The row matching procedure previously discussed is a special case of Theorem 15.1 
where the next states are actually the same instead of just being equivalent. We will use 
this theorem to show that Table 13-4 has no equivalent states. By inspection of the output part of the table, the only possible pair of equivalent states is S
0 and S2. From the table,
S0≡S2 iff (S3≡S3, S2≡S0, S1≡S1,  and  S0≡S1)
But S0≢S1 (because the outputs differ), so the last condition is not satisfied and S0≢S2.
15.3 Determination of State Equivalence  
Using an Implication Table
In this section we will discuss a procedure for finding all of the equivalent states in 
a state table. If the equivalent states found by this procedure are eliminated, then the table can be reduced to a minimum number of states. We will use an implication table (sometimes referred to as a pair chart) to check each pair of states for possible equivalence. The nonequivalent pairs are systematically eliminated until only the equivalent pairs remain.
We will use the example of Table 15-3 to illustrate the implication table method. The 
first step is to construct a chart of the form shown in Figure 15-3. This chart has a square for every possible pair of states. A square in column i and row 
j corresponds to state 
pair i-j. Thus, the squares in the first column correspond to state pairs a-b,  a-c, etc. Note 
that the squares above the diagonal are not included in the chart because if i≡j,  j≡i, 
and only one of the state pairs i-j and j-i is needed. Also, squares corresponding to pairs 
a-a,  b-b, etc., are omitted. To fill in the first column of the chart, we compare row a of 
Table 15-3 with each of the other rows. Because the output for row a is different than the 
output for row c , we place an X in a -c square of the chart to indicate that a≢c. Similarly, 
we place X’s in squares a-e, a-f, and a-h  to indicate that a≢e,  a≢f, and a ≢h because 
of output differences. States a  and b  have the same outputs, and thus, by Theorem 15.1,
a≡b  iff  d≡f  and   c≡h
To indicate this, we place the implied pairs, d-f and c -h, in the a -b square. Similarly, 
because a and d have the same outputs, we place a-d and c-e in the a-d square to 
indicate that
a≡d  iff  a≡d  and   c≡e
Present 
StateNext State Present 
Output X=01
a dc 0
b fh 0
ce d 1
d ae 0
ec a 1
f fb 1
g bh 0
h cg 1TABLE 15-3
© Cengage Learning 2014
510 Unit 15
The entries b -d and c -h in the a -g square indicate that
a≡g  iff  b≡d  and   c≡h
Next, row b  of the state table is compared with each of the remaining rows of the 
table, and column b of the implication chart is filled in. Similarly, the remaining col-
umns in the chart are filled in to complete Figure 15-3. Self-implied pairs are redun-dant, so a -d can be eliminated from square a -d, and c -e from square c -e.
At this point, each square in the implication table has either been filled in with 
an X to indicate that the corresponding state pair is not equivalent (because the out-
puts are different) or filled in with implied pairs. We now check each implied pair. If one of the implied pairs in square i-
j is not equivalent, then by Theorem 15.1, i≢j. 
The a-b square of Figure 15-3 contains two implied pairs ( d-f and c -h). Because d ≢f 
(the d-f square has an X  in it), a ≢b and we place an X  in the a -b square, as shown in 
Figure 15-4. Continuing to check the first column, we note that the a-d square contains 
the implied pair c-e. Because square c-e does not contain an X, we cannot determine at FIGURE 15-3
Implication Chart 
for Table 15-3
© Cengage Learning 2014
abc de fgf
g
hedcb a ≡ b iff d ≡ f and c ≡ h
b ≢ c because the outputs differd–f
c–h
a–d
c–ea–f
e–h
c–e
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–f
FIGURE 15-4
Implication Chart 
After First Pass
© Cengage Learning 2014
abc de fgf
g
hedcbd–f
c–h
c–ea–f
e–h
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–f
Reduction of State Tables State Assignment  511
this point whether or not a ≢d. Similarly, because neither square b -d nor c -h contains 
an X, we cannot determine immediately whether a≢g or not. Going on to the second 
column, we place X’s in squares b-d and b-g because we have already shown a ≢f and 
b≢f. In a similar manner, we check each of the remaining columns and X out squares 
c-f,  d-g,  e-f, and f-h. Figure 15-4 shows the resulting chart.
In going from Figure 15-3 to Figure 15-4, we found several additional nonequiva-
lent state pairs. Therefore, we must go through the chart again to see if the added X’s 
make any other pairs nonequivalent. Rechecking column a, we find that we can place 
an X in square a-g because square b-d has an X. Checking the remaining columns, we 
X out squares c-h and e -h because d -g and a -g have X’s. This completes the second 
pass through the implication table, as shown in Figure 15-5. Because we added some 
X’s on the second pass, a third pass is required.
No new X ’s are added on the third pass through the table, so all squares which corre-
spond to nonequivalent state pairs have been Xed out. The coordinates of the remaining 
squares must then correspond to equivalent state pairs. Because square a-d (in column a , 
row d) does not contain an X , we conclude that a ≡d. Similarly, square c -e does not con-
tain an X , so c≡e. All other squares contain X’s, so there are no other equivalent state 
pairs. Note that we determined equivalent states from the column-row coordinates of the squares without X ’s, not by reading the implied pairs contained within the squares.
If we replace d with a and e with c in Table 15-3, we can eliminate rows d and e, 
and the table reduces to six rows, as shown in Table 15-4.FIGURE 15-5
Implication Chart 
After Secong Pass
© Cengage Learning 2014
abc de fgf
g
hedcbd–f
c–h
c–ea–f
e–h
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–f
Present 
StateNext State
Output X=01
aa c 0
b fh 0
cc a 1
f fb 1
g bh 0
h cg 1TABLE 15-4
© Cengage Learning 2014
512 Unit 15
The implication table method of determining state equivalence can be summa-
rized as follows:
1. Construct a chart which contains a square for each pair of states.
2. Compare each pair of rows in the state table. If the outputs associated with states i 
and j are different, place an X in square i-j to indicate that i≢j. If the outputs are the 
same, place the implied pairs in square i-j. (If the next states of i and j are m and n 
for some input x, then m-n is an implied pair.) If the outputs and next states are the 
same (or if i-j only implies itself), place a check ( Ë) in square i-j to indicate that i≡j.
3. Go through the table square-by-square. If square i-j contains the implied pair m-n, 
and square m -n contains an X , then i ≢j, and an X  should be placed in square i -j.
4. If any X’s were added in step 3, repeat step 3 until no more X’s are added.
5. For each square i -j which does not contain an X, i≡j.
If desired, row matching can be used to partially reduce the state table before con-
structing the implication table. Although we have illustrated this procedure for a Moore table, the same procedure applies to a Mealy table.
15.4 Equivalent Sequential Circuits
In the last section, we found the equivalent states within a single state table so that we could reduce the number of rows in the table. Reducing the number of rows usu-ally leads to a sequential circuit with fewer gates and flip-flops. In this section, we will consider equivalence between sequential circuits. Essentially, two sequential circuits are equivalent if they are capable of doing the same “work.” Equivalence between sequential circuits is defined as follows:
Definition 15.2 Sequential circuit N1 is equivalent to sequential circuit N2 if for each state p in N1, 
there is a state q in N2 such that p≡q, and conversely, for each state s in N2, there is 
a state t in N1 such that s≡t.
Thus, if N1≡N2, for every starting state p in N1, we can find a corresponding start-
ing state q such that λ1(p, X  )≡λ2(q, X  ) for all input sequences X (i.e., the output 
sequences are the same for the same input sequence). Then, in a given application, N
1 could be replaced with its equivalent circuit N2.
If N1 and N2 have only a few states, one way to show that N1≡N2 is to match up 
pairs of equivalent states by inspection and, then, show that Theorem 15.1 is satis-fied for each pair of equivalent states. If both N
1 and N2 have a minimum number of 
states and N1≡N2, then N1 and N2 must have the same number of states. Otherwise, 
one circuit would have a state left over which was not equivalent to any state in the other circuit, and Definition 15.2 would not be satisfied.
Figure 15-6 shows two reduced state tables and their corresponding state graphs. By 
inspecting the state graphs, it appears that if the circuits are equivalent, we must have 
A  
Reduction of State Tables State Assignment  513
equivalent to either S2 or S3 because these are the only states in N2 with self-loops. 
Because the outputs of A and S2 correspond, the only possibility is A≡S2. If we assume 
that A≡S2, this implies that we must have B≡S0, which in turn implies that we must 
have D≡S1 and C≡S3. Using the state tables, we can verify that these assumptions are 
correct because for every pair of assumed equivalent states, the next states are equivalent 
and the outputs are equal when X≡0 and also when X≡1. This verifies that N1≡N2.
The implication table can easily be adapted for determining the equivalence of 
sequential circuits. Because the states of one circuit must be checked for equivalence against states of the other circuit, an implication chart is constructed with rows cor-responding to states of one circuit and columns corresponding to states of the other. For example, for the circuits of Figure 15-6 we can set up the implication table of Figure 15-7(a). The first column of Figure 15-7(a) is filled in by comparing row 
A of the 
state table in Figure 15-6(a) with each of the rows in Figure 15-6(b). Because states A  
and S0 have different outputs, an X is placed in the A-S0 square. Because states A and 
S1 have the same outputs, the implied next-state pairs ( B-S3 and A-S0) are placed in 
the A-S1 square, etc. The remainder of the table is filled in similarly.
In the next step (Figure 15-7(b)), squares corresponding to additional nonequiva-
lent state pairs are crossed out. Thus, square A-S1 is crossed out because A≢S0. FIGURE 15-6
Tables and Graphs 
for Equivalent 
Circuits
© Cengage Learning 2014
S2S0
S1
S31
0
1
00
00
00
0
0
01
11
1CA
DB1
00
0
0
0
0
00
01
1
1
11
0N1
X = X = X = X = 01 01
AB A 00
BC D 01
CA C 01
DC B 00N2
01 01
S0 S3 S1 01
S1 S3 S0 00
S2 S0 S2 00
S3 S2 S3 01
(b)(a)
FIGURE 15-7
Implication Tables 
for Determining 
Circuit Equivalence
© Cengage Learning 2014
ABCDS0
S1
S2
S3A–S3
C–S1C–S3
D–S1
B–S3
A–S0
B–S0
A–S2C–S0
B–S2
C–S2
D–S3A–S2
C–S3C–S3
B–S0
ABCDS0
S1
S2
S3A–S3
C–S1C–S3
D–S1
B–S3
A–S0
B–S0
A–S2C–S0
B–S2
C–S2
D–S3A–S2
C–S3C–S3
B–S0
(a) (b)
514 Unit 15
Similarly, square B-S3 is crossed out because C≢S2, square C-S0 because A≢S3, and 
square D-S2 because B≢S2. Another pass through the table reveals no additional 
nonequivalent pairs; therefore, the remaining equivalent state pairs are
A≡S2 B≡S0 C≡S3 D≡S1
Since each state in N1 has an equivalent state in N2 and conversely, N1≡N2.
15.5 Reducing Incompletely Specified  
State Tables
Reducing incompletely specified state tables is more complicated than reducing 
completely specified tables. We give only a brief introduction here.2 At first it might 
be thought that trying different values for the don’t-cares and reducing the resulting completely specified table will produce the minimal state table. We give two exam-ples to show that this would be very complex for tables with many don’t-cares and, in fact, often does not produce the minimal table. Table 15-5(a) contains two don’t-cares labelled –
1 and –2 so we can try reducing it by trying the four combinations of 
values for the don’t-cares. Figure 15-8 shows the implication charts for the four com-binations 
(DC1 =0 and  1,  DC2 =0 and  1); the table only reduces when both don’t-
cares are 1. In this case the resulting two-state table is the minimal table. However, trying all possibilities if there are many don’t-cares would be very complex and, as Table 15-5(b) shows, does not always produce a minimal table.
If the don’t-care in Table 15-5(b) is replaced by a 0, the outputs make 
S0 and S2 
plus S1 and S2 nonequivalent. Then S0 and S1 are not equivalent because they have 
next states S1 and S2. Similarly, there are no equivalent states if the don’t-care is 
replaced by a 1. However, this table can be reduced to two states. If S1 is duplicated 
with one copy made equivalent to S0 and the other copy made equivalent to S2 as 
shown in Table 15-6, then S0 is equivalent to S1
1 and S2 is equivalent to S2
1 and the 
table can be reduced to two states.
2See McCluskey, Edward J., Logic Design Principles  (Upper Saddle River, NJ: Prentice Hall, 1986) for a 
more complete discussion.Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S3  0−2
S1 S2 S3 −1 0
S2 S1 S0  1 0
S3 S2 S3  0 1
(a)TABLE 15-5 
Incompletely 
Specified  
Examples Present 
StateNext State Output
X=0X=1X=0X=1
S0 S2 S1 01
S1 S1 S0 –1
S2 S2 S1 11
(b)© Cengage Learning 2014
Reduction of State Tables State Assignment  515
For a completely specified table, if S0≡S1 and S1≡S2, then S0≡S2. (Equiva-
lence satisfies the transitivity property.) In the preceding example, for any input 
sequence, S0 and S1 will generate the same output sequence values wherever both 
output sequences have defined values; S0 and S1 are said to be compatible. (We will 
use the symbol ~ to denote compatibility.) Similarly, S1 and S2 are compatible (i.e., 
for any input sequence they will generate the same output sequence values wherever both output sequences have defined values). But this is not true for 
S0 and S2; for the 
single input x=0, they have different outputs. Compatibility does not satisfy transi-
tivity; S0 ~ S1 and S1 ~ S2 does not imply that S0 ~ S2.
To reduce a completely specified table, we find all the maximal sets of states 
containing pairwise equivalent states; since equivalence is transitive, a state of the table is contained in just one of the maximal equivalence classes. The states of the reduced table correspond to these maximal equivalence classes. The first step in reducing an incompletely specified table is to find all maximal sets of states that are pairwise compatible—the maximal compatibles. However, since compatibility does not satisfy transitivity, a given state may be contained in more than one maximal compatible. To reduce an incompletely specified table, a minimum of the maximal compatibles are selected, say 
C1,  C2,  . . .  , Ck, so that
(1) each state of the table appears in at least one of the Ci, and
(2) for each input combination x and each Ci, the next states of the states in Ci are 
contained in some Cj. (It may be that j=i.)
The second condition allows the construction of a state table with the states cor-responding to the selected maximal compatibles; the reduced table will contain  k states. (This procedure is valid for most incompletely specified tables. In some cases 
the states of the reduced table are specified by subsets of the maximal compatibles.)
As an example, consider a circuit that receives binary encodings for decimal 
digits 0, 1, 2, 3, 4 and 5 in disjoint windows of length 3. The bits are received most FIGURE 15-8
Implication Charts 
for Table 15-5(a)
© Cengage Learning 2014
S0S1S1, S2
S1, S2 S1, S2S0, S3 S0, S3 S0, S3
DC1=0, DC2 =0 DC1 =0, DC2 =1 DC1 =1, DC2 =0 DC1 =1, DC2 =1S2
S3
S1 S2 S0S1
S2
S3
S1 S2 S0S1
S2
S3
S1 S2 S0S1
S2
S3
S1 S2
Present 
StateNext State Output
X=0X=1X=0X=1
S0 S2 S1
101
S11 S2
1S0 01
S2
1 S2
1S0 11
S2 S2 S11 11TABLE 15-6 
Modified 
Table 15-5(b)
© Cengage Learning 2014
516 Unit 15
 significant bit first and the circuit generates an output of 1 (0) for the third input 
bit if the 3 bits have even (odd) parity. The output is a don’t-care for the first 2 bits. Table 15-7 was constructed for the circuit where the states are entered for the input sequences shown. Figure 15-9 is the implication chart for Table 15-7 . All pairs of states are compatible except for S
1 and S2 and S3 and S4. S0 ~ S1, S0 ~ S3, 
and S1 ~ S3 implies that (S0 S1 S3) is a compatible set. Similarly, (S0 S2 S3), (S0 S1 S4),  
and (S0 S2 S4) are compatible sets. (S0 S1 S3), and (S0 S2 S3) cannot be combined 
into a larger set since S1 and S2 are not compatible. None of these will combine, so 
(S0 S1 S3), (S0 S2 S3), (S0 S2 S4) and (S0 S2 S4) are the maximal compatible sets.
The next states of (S0 S1 S3) for X=1 are (S0 S2 S4), so if (S0 S1 S3) is one of the 
states in the reduced table, then (S0 S2 S4) must be one of the other states. The next 
states of (S0 S2 S4) for X=0 are (S0 S1 S4), so if (S0 S2 S4) is one of the states in the 
reduced table, then (S0 S1 S4) must be one of the other states. Examining the next 
states for X=0 and X=1 shows that (S0 S1 S3), (S0 S1 S4), and (S0 S2 S4) can be 
used to form a state table; Table 15-8 is the resulting table. (S0 S2 S3) has next states 
(S0 S1 S4) for X=0, so if (S0 S2 S3) were included, the table would have four states; 
Table 15-8 is the minimal reduced table for Table 15-7 .
FIGURE 15-9
Implication Chart 
for Table 15-7
© Cengage Learning 2014S1S1, S3
S2, S4
S0, S1
S0, S2S0, S3
S0, S4S1, S4S3, S4
S0, S4
S0, S1
S0, S2S0, S3
S0, S4S0, S4S2
S3
S0S4
S1 S2 S3Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S2 ––
0 S1 S3 S4 ––
1 S2 S4 –– –
00 S3 S0 S0 10
01, 10 S4 S0 S0 01TABLE 15-7
Even Parity 
Detector For 0 
Through 5
Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S3 A A B 10
S0 S2 S4 B C B 01
S0 S1 S4 C A B 01TABLE 15-8
Reduced Table for 
Table 15-7© Cengage Learning 2014
© Cengage Learning 2014
Reduction of State Tables State Assignment  517
15.6 Derivation of Flip-Flop Input Equations
After the number of states in a state table has been reduced, the following procedure 
can be used to derive the flip-flop input equations:
1. Assign flip-flop state values to correspond to the states in the reduced table.
2. Construct a transition table which gives the next states of the flip-flops as a func-
tion of the present states and inputs.
3. Derive the next-state maps from the transition table.
4. Find flip-flop input maps from the next-state maps using the techniques devel-oped in Unit 12 and find the flip-flop input equations from the maps.
As an example, we will design a sequential circuit to realize Table 15-9(a). 
Because there are seven states, we will need three flip-flops. We will designate the flip-flop outputs as 
A, B, and C.
(a) State table
X=0 10 1
S0 S1S2 00
S1 S3S2 00
S2 S1S4 00
S3 S5S2 00
S4 S1S6 00
S5 S5S2 10
S6 S1S6 01TABLE 15-9 (b) Transition table
A+B+C+Z
ABC X=0 10 1
000 110 001 0 0
110 111 001 0 0001 110 011 0 0111 101 001 0 0011 110 010 0 0101 101 001 1 0010 110 010 0 1
We could make a straight binary state assignment for which S0 is represented 
by flip-flop states ABC =000,  S1 by ABC =001,  S2 by ABC=010, etc. However, 
because the correspondence between flip-flop states and the state names is arbitrary, 
we could use many different state assignments. Using a different assignment may lead to simpler or more complex flip-flop input equations. As an example, we will use the following assignment for the states of flip-flops 
A, B, and C:
 S0=000,   S1=110,   S2=001,   S3=111,   S4=011,   S5=101,   S6=010 (15-1)
This state assignment is derived in Section 15.8, and the reasons why it leads to an economical solution are given in that section. Starting with Table 15-9(a), we substitute 000 for S
0, 110 for S1, 001 for S2, etc. Table 15-9(b) shows the resulting transition table. 
This table gives the next states of flip-flops A,  B, and C in terms of the present states 
and the input X. We can fill in the next-state maps, Figure 15-10(a), directly from this 
table. For XABC=0000 the next-state entry is 110, so we fill in A+=1,  B+=1, and 
C+=0; for XABC=1000 the next-state entry is 001, so we fill in A+=0,  B+=0, 
and C+=1; etc. Because the state assignment ABC=100 is not used, the map squares 
corresponding to XABC=0100   and 1100 are filled with don’t-cares.© Cengage Learning 2014
518 Unit 15
Once the next-state maps have been plotted from the transition table, the flip-
flop input equations can be derived using the techniques developed in Unit 12. As 
shown in Figure 15-10(a), the D flip-flop input equations can be derived directly from the next-state maps because D
A=A+,  DB=B+, and DC=C+. If J-K flip-flops 
are used, the J and K input equations can be derived from the next-state maps as 
illustrated in Figure 15-10(b). As was shown in Section 12.5, the A=0 half of the JA 
map is the same as the A+ map and the A=1 half is all don’t-cares. The A=1 half 
of the KA map is the complement of the A=1 half of the A+ map, and the A=0 
half is all don’t-cares. We can plot the JB and KB in a similar manner by looking at 
the B=0 and B=1 halves of the B+ map. Derivation of the JC and KC maps from 
the C+ map is left as an exercise.
FIGURE 15-10
Next-State Maps 
for Table 15-9
© Cengage Learning 2014
A+ = DA = X ′1XX 000 01 11 10
1 1 0 0
1 1 0 0
100BCXA
01
11
10 1 0 0
JA = X ′1XX 000 01 11 10
1XX 0
1XX 0
100BCXA
01
11
10 XX 0
KA = XXXXX00 01 11 10
X 0 1X
X 0 1X
X00BCXA
01
11
10 0 1X
JB = X ′A′ + A ′C1XX 000 01 11 10
1 1 0 0
XXX X00BCXA
01
11
10 XXX X
KB = AC + XAX XX X00 01 11 10
XXX X
11 0 0
100BCXA
01
11
10 0 0 0B+ = DB = X ′C′ + A ′C + A ′B 1XX 000 01 11 10
1 0 0 1
1 0 0 1
100BCXA
01
11
10 1 0 1
C+ = DC = A + XB ′0XX 100 01 11 10
0 1 1 1
0 1 1 0
000BCXA
01
11
10 1 1 0
(a) Derivation of D flip-flop input equations
(b) Derivation of J-K flip-flop input equationsA = 1A = 0 A = 0
B = 0
B = 0
(a) State table
P.S.Next State
X1X2=Outputs (Z1Z2)
X1X2=
00 01 11 10 00 01 11 10
S0S0S0S1S100 00 01 01
S1S1S3S2S100 10 10 00
S2S3S3S2S211 11 00 00
S3S0S3S2S000 00 00 00TABLE 15-10 (b) Transition table
ABA+B+
X1X2=Outputs (Z1Z2)
X1X2=
00 01 11 10 00 01 11 10
00 00 00 01 01 00 00 01 01
01 01 10 11 01 00 10 10 0011 10 10 11 11 11 11 00 0010 00 10 11 00 00 00 00 00© Cengage Learning 2014
Reduction of State Tables State Assignment  519
Table 15-10(a) represents a sequential circuit with two inputs (X1 and X2) and 
two outputs (Z1 and Z2). Note that the column headings are listed in Karnaugh map 
order because this will facilitate derivation of the flip-flop input equations. Because 
the table has four states, two flip-flops (A and B ) are required to realize the table. 
We will use the state assignment AB=00 for S0, AB=01 for S1, AB=11 for S2,  
and AB=10 for S3. By substituting the corresponding values of AB for the state 
names, we obtain the transition table, Table 15-10(b). We can then fill in the next-state and output maps (Figure 15-11) from the transition table. For example, when 
X1X2AB =0011,   A+B+=10, and Z1Z2=11; therefore, we fill in the 0011 squares of 
the A+,  B+,  Z1, and Z2 maps with l, 0, 1, and 1, respectively. We can read the D flip-
flop input equations directly from the next-state maps.
FIGURE 15-11
Next-State Maps for 
Table 15-10
© Cengage Learning 2014
DA = A+ = X2B +
AB + X2A 0 0 0 000 01 11 10
0 1 1 0
1 1 1 1
000ABX1X2 X1X2 X1X2 X1X2
01
11
10 1 1 0
DB = B+ = X1A′ +
X′2A′B + X1B + X1X20 0 1 100 01 11 10
1 0 1 1
0 0 1 1
000AB
01
11
10 0 1 00 0 0 000 01 11 10
0 1 1 0
1 1 0 0
000AB
01
11
10 0 0 00 0 1 100 01 11 10
0 0 0 0
1 1 0 0
000AB
01
11
10 0 0 0
Z2 = X1A′B′ + X′1AB Z1 = X2A′B + X ′1AB
If J-K, T, or S-R flip-flops are used, the flip-flop input maps can be derived from 
the next-state maps using the techniques given in Section 12.6. As an example, the 
S-R equations for Table 15-10 are derived in Figure 15-12. The SA and RA maps are 
derived from the A+ map by applying Table 12-5(c) to the A=0 and A=1 halves 
of the map. SB and RB are derived in a similar manner.
FIGURE 15-12
Derivation of S-R 
Equations for 
Table 15-10
© Cengage Learning 2014
SA = X2B0 0 0 000 01 11 10
0 1 1 0
XXXX
000ABX1X2 X1X2 X1X2 X1X2
01
11
10 XX 0XXXX00 01 11 10
X 0 0X
0 0 0 0
100AB
01
11
10 0 0 1
SB = X1X2 + X1A′0 0 1 100 01 11 10
X 0XX
0 0XX
000AB
01
11
10 0 1 0
RB = X ′1X2 + X ′1AXX 0 000 01 11 10
0 1 0 0
1 1 0 0
X00AB
01
11
10 X 0X
RA = X ′2B′A = 0
B = 1B = 0
B = 0A = 1
15.7 Equivalent State Assignments
After the number of states in a state table has been reduced, the next step in real-
izing the table is to assign flip-flop states to correspond to the states in the table. The cost of the logic required to realize a sequential circuit is strongly dependent on the way this state assignment is made. Several methods for choosing state assignments to obtain economical realizations are discussed in this chapter. The trial-and-error 
520 Unit 15
method described next is useful for only a small number of states. The guideline 
method discussed in Section 15.8 produces good solutions for some problems, but it is not entirely satisfactory in other cases.
If the number of states is small, it may be feasible to try all possible state assign-
ments, evaluate the cost of the realization for each assignment, and choose the assign-ment with the lowest cost. Consider a state table with three states ( S
0,  S1, and S2) as in 
Table 14-1. Two flip-flops ( A and B) are required to realize this table. The four possible 
assignments for state S0 are AB=00,   AB=01,   AB=10, and AB=11. Choosing one 
of these assignments leaves three possible assignments for state S1 because each state 
must have a unique assignment. Then, after state S1 is assigned, we have two possible 
assignments for state S2. Thus, there are 4 ×3×2=24 possible state assignments for 
the three states, as shown in Table 15-11. As an example, for assignment 7 , the entry 01 in the S
0 row means that flip-flops A and B  are assigned values 0 and l, respectively.
Trying all 24 of these assignments is not really necessary. If we interchange two 
columns in one of the given assignments, the cost of realization will be unchanged because interchanging columns is equivalent to relabeling the flip-flop variables. For example, consider assignment 1 in Table 15-11. The first column of this assignment shows that flip-flop 
A is assigned the values 0, 0, and 1 for states S0, S1, and S2, respec-
tively. Similarly, the second column shows that B is assigned the values 0, 1, and 0. If 
we interchange the two columns, we get assignment 3, for which A has the values 0, 
1, and 0 and B has the values 0, 0, and 1. We could have achieved the same result by 
using assignment 1 and labeling the flip-flop variables BA instead of AB. If we inter-
change the columns of assignment 2, we get assignment 4, so assignments 2 and 4 have the same cost. Similarly, assignments 5 and 6 have the same cost. Interchanging rows, however, will usually change the cost of realization. Thus, assignments 4 and 6 will have a different cost for many state tables.
1234567 1 9 2 0 2 1 2 2 2 3 2 4
S0 00 00 00 00 00 00 01 . . . 11 11 11 11 11 11
S1 01 01 10 10 11 11 00 00 00 01 01 10 10
S2 10 11 01 11 01 10 10 01 10 00 10 00 01
FIGURE 15-13
Equivalent Circuits 
Obtained by 
Complementing Qk
© Cengage Learning 2014p′f1 Qk J
Kf2pf1 Qk
Q′kQ′kJ
Kf2
(a) Circuit A (b) Circuit B
(identical to A except leads to
flip-flop Qk are crossed)TABLE 15-11
State Assignments 
for 3-Row Tables
© Cengage Learning 2014
Reduction of State Tables State Assignment  521
If symmetrical flip-flops such as T, J-K, or S-R are used, complementing one or 
more columns of the state assignment will have no effect on the cost of realiza-
tion. Consider a J-K flip-flop imbedded in a circuit, Figure 15-13(a). Leave the circuit unchanged and interchange the 
J and K input connections and the Qk and Qk′ output 
connections, Figure 15-13(b). If circuit A is started with Qk=p and circuit B  with 
Qk=p′, the behavior of the two circuits will be identical, except the value of Qk will 
always be complemented in the second circuit because whenever J is 1 in the first 
circuit, K will be 1 in the second and conversely. The state table for the second circuit 
is therefore the same as for the first, except the value of Qk is complemented for the 
second circuit. This implies that complementing one or more columns in the state assignment will not affect the cost of the realization when J-K flip-flops are used. Similar reasoning applies to T and S-R flip-flops. Thus, in Table 15-11, assignments 2 and 7 have the same cost, and so do assignments 6 and 19.
If unsymmetrical flip-flops are used such as a D flip-flop, it is still true that per-
muting (i.e., rearranging the order of) columns in the state assignment will not affect the cost; however, complementing a column may require adding an inverter to the circuit, as shown in Figure 15-14. If different types of gates are available, the circuit can generally be redesigned to eliminate the inverter and use the same number of gates as the original. If circuit A in Figure 15-14 is started with Q
k=p and circuit B 
with Qk=p′, the behavior of the two circuits will be identical, except the value of Qk 
will always be complemented in circuit B because f is the same in both circuits and 
D=f ′ for circuit B .
Table 15-12 illustrates the effect of interchanging or complementing state assign-
ment columns on the equations for realizing a specific state table.
FIGURE 15-14
Equivalent Circuits 
Obatined by 
Complemeting Qk
© Cengage Learning 2014p′f Qk
D pf Qk
D
(a) Circuit A (b) Circuit B
(identical to A except for 
connections to flip-flop Qk) Q′kQ′k
Assignments Present 
StateNext State Output
A3 B3 C3 X=0 10 1
00 00 11 S1 S1S3 00
01 10 10 S2 S2S1 01
10 01 01 S3 S3S3 10TABLE 15-12
© Cengage Learning 2014
522 Unit 15
The J-K and D flip-flop input equations for the three assignments can be derived, 
using Karnaugh maps as explained in Unit 12 and Section 15.6. The resulting J and 
K input equations are:
Assignment A Assignment B Assignment C
J1=XQ2′ J2=XQ1′ K1=XQ2
K1=X′ K2=X′ J1=X′ 
J2=X′Q1 J1=X′Q2 K2=X′Q1′
K2=X K1=X J2=X
Z=X′Q1+XQ2 Z=X′Q2+XQ1 Z=X′Q1′+XQ2′
D1=XQ2′ D2=XQ1′ D1=X′+Q2′
D2=X′(Q1+Q2) D1=X′(Q2+Q1) D2=X+Q1Q2
Note that assignment B in Table 15-12 was obtained by interchanging the columns 
of A. The corresponding equations for assignment B are the same as for A, except 
that subscripts 1 and 2 are interchanged. Assignment C was obtained by complement-
ing the columns of A. The Z equation for C is the same as for A, except that Q1 and 
Q2 are complemented. The K and J equations for C are the same, respectively, as 
the J and K equations for A with the Q ’s complemented. The D equations for C can 
be obtained by complementing those for A and, then, complementing the Q’s. Thus, 
the cost of realizing Table 15-12 using J-K flip-flops and any kind of logic gates will be exactly the same for all three assignments. If both AND and OR (or NAND and NOR) gates are available, the cost of realizing the three sets of D equations will be 
the same. If only NOR gates are available, for example, then realizing D
1 and D2 for 
assignment C would require two additional inverters compared with A and B .
By complementing one or more columns, any state assignment can be converted 
to one in which the first state is assigned all 0’s. If we eliminate assignments which can be obtained by permuting or complementing columns of another state assign-ment, Table 15-11 reduces to three assignments (Table 15-13). Thus, when realizing a three-state sequential circuit with symmetrical flip-flops, it is only necessary to try three different state assignments to be assured of a minimum cost realization. Simi-larly, only three different assignments must be tried for four states.
3-State Assignments 4-State Assignments
States 123123
a 00 00 00 00 00 00
b 01 01 11 01 01 11
c 10 11 01 10 11 01
d – – – 11 10 10TABLE 15-13
Nonequivalent 
Assignments for 
Three and Four 
States
© Cengage Learning 2014
Reduction of State Tables State Assignment  523
We will say that two state assignments are equivalent if one can be derived from the 
other by permuting and complementing columns. Two state assignments which are not 
equivalent are said to be distinct. Thus, a four-row table has three distinct state assign-
ments, and any other assignment is equivalent to one of these three. Unfortunately, the number of distinct assignments increases very rapidly with the number of states, as shown in Table 15-14. Hand solution is feasible for two, three, or four states; computer solution is feasible for five through eight states; but for more than nine states it is not practical to try all assignments even if a high-speed computer is used.
15.8 Guidelines for State Assignment
Because trying all nonequivalent state assignments is not practical in most cases, other methods of state assignment are needed. The next method to be discussed involves trying to choose an assignment which will place the 1’s on the flip-flop input maps in adjacent squares so that the corresponding terms can be combined. This method does not apply to all problems, and even when applicable, it does not guar-antee a minimum solution.
Assignments for two states are said to be adjacent if they differ in only one 
 variable. Thus, 010 and 011 are adjacent, but 010 and 001 are not. The following guidelines are useful in making assignments which will place 1’s together (or 0’s together) on the next-state maps:
1. States which have the same next state for a given input should be given adjacent 
assignments.
2. States which are the next states of the same state should be given adjacent assignments.
A third guideline is used for simplification of the output function:
3. States which have the same output for a given input should be given adjacent 
assignments.Number of  
StatesMinimum  
Number of  
State VariablesNumber of  
Distinct 
Assignments
21 1
32 342 35 3 140
6 3 420
7 3 840
8 3 840
9 4 10,810,800
·········
16 4 ≈5.5×10
10TABLE 15-14
Number of Distinct 
(Nonequivalent) 
State Assignments
© Cengage Learning 2014
524 Unit 15
The application of Guideline 3 will place 1’s together on the output maps.
When using the state assignment guidelines, the first step is to write down all 
of the sets of states which should be given adjacent assignments according to the 
guidelines. Then, using a Karnaugh map, try to satisfy as many of these adjacencies as possible. A fair amount of trial and error may be required to fill in the map so that the maximum number of desired state adjacencies is obtained. When filling in the map, keep in mind the following:
(a) Assign the starting state (reset state) to the “0” square on the map. (For an 
exception to this rule, see the one-hot assignment in Section 15-9.) Nothing is to be gained by trying to put the starting state in different squares on the map because the same number of adjacencies can be found no matter where you put the starting state. Usually, assigning “0” to the starting state simplifies the initialization of the circuit using the clear inputs on the flip-flops.
(b) Adjacency conditions from Guideline 1 and adjacency conditions from Guide-
line 2 that are required two or more times should be satisfied first.
(c) When guidelines require that three or four states be adjacent, these states should 
be placed within a group of four adjacent squares on the assignment map.
(d) If the output table is to be considered, then Guideline 3 should also be applied. 
The priority given to adjacency conditions from Guideline 3 should generally be less than that given to Guidelines 1 and 2 if a single output function is being derived. If there are two or more output functions, a higher priority for Guide-line 3 may be appropriate.
The following example should clarify the application of Guidelines 1 and 2. The 
state table from Table 15-9 is repeated in Figure 15-15(a) so that we can illustrate derivation of the state assignment. According to Guideline 1, S
0,  S2,  S4, and S6 should 
be given adjacent assignments because they all have S1 as a next state (with input 0). 
Similarly, S0,  S1,  S3, and S5 should have adjacent assignments because they have S2 as 
a next state (with input 1); also, S3 and S5 should have adjacent assignments and so 
should S4 and S6. The application of Guideline 2 indicates that S1 and S2 should be 
01
00BCA
01
11
10S0
S2
S4
S6S0
S1
S3
S5S5
S3
S1S6
S4
S201
00BCA
01
11
10
(b) Assignment mapsABC X 01 0 1
000 S0 S1S2 00
110 S1 S3S2 00
001 S2 S1S4 00
111 S3 S5S2 00
011 S4 S1S6 00
101 S5 S5S2 10
010 S6 S1S6 01
(a) State table= FIGURE 15-15
© Cengage Learning 2014
Reduction of State Tables State Assignment  525
given adjacent assignments because they are both next states of S0. Similarly, S2 and 
S3 should have adjacent assignments because they are both next states of S1. Further 
application of Guideline 2 indicates that S1 and S4, S2 and S5 (two times), and S1 and 
S6 (two times) should be given adjacent assignments. In summary, the sets of adja-
cent states specified by Guidelines 1 and 2 are
1. (S0,  S1,  S3,  S5)(S3,  S5)(S4,  S6)(S0,  S2,  S4,  S6)
2. (S1,  S2)(S2,  S3)(S1,  S4)(S2,  S5)2x(S1,  S6)2x
We will attempt to fulfill as many of these adjacency conditions as possible. A 
Karnaugh map will be used to make the assignments so that states with adjacent 
assignments will appear in adjacent squares on the map. If the guidelines require that three or four states be adjacent, these states should be placed within a group of four adjacent squares on the assignment map. Two possible ways of filling in the assign-ment maps are shown in Figure 15-15(b). These maps were filled in by trial and error, attempting to fulfill as many of the preceding adjacency conditions as possible. The conditions from Guideline 1 are given preference to conditions from Guideline 2.  
The conditions which are required two times (such as S
2 adjacent to S5, and S1 adja-
cent to S6) are given preference over conditions which are required only once (such 
as S1 adjacent to S2, and S2 adjacent to S3).
The left assignment map in Figure 15-15(b) implies an assignment for the states of 
flip-flops A,  B, and C which is listed to the left of the state table in Figure 15-15(a). This 
assignment is the same as the one given in Equations (15-1). We derived the D flip-flop input equations and 
J and K input equations for this assignment in Section 15.6. 
The cost of realizing the D flip-flop input equations given in Figure 15-10(a) is six gates and 13 inputs. If a straight binary assignment ( S
0=000,   S1=001,   S2=010, 
etc.) were used instead, the cost of realizing the flip-flop input equations would be 10 gates and 39 inputs. Although application of the guidelines gives good results in this example, this is not always the case.
Next, we will explain why the guidelines help to simplify the flip-flop equations 
when the assignment of Figure 15-15(a) is used. Figure 15-16 shows a next-state map which was constructed using this assignment. Note that if 
X=0 and ABC=000, the 
next state is S1; if X=1 and ABC=000, the next state is S2. Because Guideline 1 
was used in making the state assignment, S1 appears in four adjacent squares on the 
next-state map, S5 appears in two adjacent squares, etc.
The next-state maps for the individual flip-flops, Figure 15-16(b), can be derived in the 
usual manner from a transition table, or they can be derived directly from Figure 15-16(a). Using the latter approach, wherever S
1 appears in Figure 15-16(a), it is replaced with 110 
so that 1,   1 and  0 are plotted on the corresponding squares of the A+, B  +, and C+ maps, 
respectively. The other squares on the next-state maps are filled in similarly.
Because four S1’s are adjacent in Figure 15-16(a), the corresponding squares on 
the A+, B  +, and C+ maps have four adjacent 1’s or four adjacent 0’s as indicated 
by the blue shading. This illustrates why Guideline 1 helps to simplify the flip-flop equations. Each time Guideline 2 is applied, two out of the three next-state maps will 
526 Unit 15
have an additional pair of adjacent 1’s or adjacent 0’s. This occurs because two of the 
three state variables are the same for adjacent assignments.
Next, we will apply the state assignment guidelines to Figure 15-17(a). First, we 
list the sets of adjacent states specified by each Guideline:
1.  (b,  d)  (c,  f )  (b,  e)
2.  (a,  c)2x  (d,  f )  (b,  d)  (b,  f )  (c,  e)
3.  (a, c) (b, d) (e, f  )
Next, we try to arrange the states on a map so as to satisfy as many of these pairs 
as possible, but giving preference to the duplicated pairs (b,  d ) and (a,  c). Two such 
arrangements and the corresponding assignments are given in Figure 15-17(b) and 
(c). For Figure 15-17(c), all adjacencies are satisfied except (b,  f ),  (c,  e), and (e,  f ).  
We will derive D flip-flop input equations for this assignment. First, we construct the transition table (Table 15-15) from the state table (Figure 15-17(a)) by replacing a with 100, b with 111, c with 000, etc. Then, we plot the next-state and output maps FIGURE 15-16
Next-State Maps 
for Figure 15-15
© Cengage Learning 2014XX00 01 11 10
00BC
S1 S2
S1 S5 S2 S4
S1 S5 S2 S6
S1 S3 S2 S6XA
01
11
10Adjacent because S1, S3, and
S5 have adjacent
assignments
Adjacent because S4 and
S6 have adjacent
assignments
Adjacent because S3 and S5
have adjacent assignmentsAdjacent because S0, S2, S4, and S6
have adjacent assignments
(a) Next-state maps for Figure 15-15
(b) Next-state maps for Figure 15-15 (cont.)1 XX 100 01 11 10
10011001100
01
11
10 1010 XX 100 01 11 10
01110110000
01
11
10 1101 XX 000 01 11 10
11001100100BCXA
A
+ = DA = X ′ B+ = DB = X ′C′ + A ′C + A ′BC+ = DC = A + XB ′01
1110 100The se pairs are adjacent because S2
and S5 have adjacent assignments
Reduction of State Tables State Assignment  527
(Figure 15-18) from the transition table. The D flip-flop input equations can be read 
directly from these maps:
D1=Q+  
1=X′Q1Q2′+XQ1′
D2=Q+
2=Q3
D3=Q+
3=XQ1′Q2+X′Q3
and the output equation is
Z =XQ2Q3+X′Q2′Q3+XQ2Q3′
The cost of realizing these equations is 10 gates and 26 gate inputs.FIGURE 15-17 State Tables and Assignments
01
00
01
11
10a
dc a
d
fec
b
fe
b01
00
01
11
10
) c ( ) b ( ) a (a = 000
b = 111
c = 100
d = 011
e = 101
f = 110a = 100b = 111
c = 000
d = 011
e = 101
f = 010Q
1
Q2Q3Q1
Q2Q3
X01 X01
aa c 00
bd f 01
cc a 00
dd b 01
eb f 10
fc e 10= =
FIGURE 15-18
Next-State and 
Output Maps for 
Table 15-15
© Cengage Learning 2014
Q1 = D10 1 0 100 01 11 10
X 1 0X
0 0 0 1
000XQ1
Q2Q3
01
11
10 XX 1
+Q2 = D20 0 0 000 01 11 10
X 1 1X
1 1 1 1
000XQ1
Q2Q3
01
1110
XX 0
+Q3 = D30 0 0 000 01 11 10
X 1 0X
1 1 0 1
000XQ1
Q2Q3
01
1110
XX 1
+Z0 0 0 000 01 11 10
X 1 0X
0 0 1 1
100XQ1
Q2Q3
01
1110
XX 0Q1Q2Q3Q1  +Q2  +Q3  +
X=0 1 X=0 1
1 0 0 100 000 0 0
1 1 1 011 010 0 10 0 0 000 100 0 00 1 1 011 111 0 11 0 1 111 010 1 00 1 0 000 101 1 0TABLE 15-15
Transition Table for 
Figure 15-17(a)
© Cengage Learning 2014
© Cengage Learning 2014
528 Unit 15
The assignment of Figure 15-17(b) satisfies all of the guidelines except (d,  f ) and 
(e,  f ). Using this assignment, the cost of realizing the state table with D flip-flops is 
13 gates and 35 gate inputs. We would expect that this assignment would produce 
better results than Figure 15-17(c) because it satisfies one more of the adjacencies given by the guidelines, but just the opposite is true. As illustrated by this example, the assignment which satisfies the most guidelines is not necessarily the best assign-ment. In general, it is a good idea to try several assignments which satisfy most of the guidelines and choose the one which gives the lowest cost solution.
The guidelines work best for D flip-flops and J-K flip-flops. They do not work as 
well for T and S-R flip-flops. In general, the best assignment for one type of flip-flop is not the best for another type.
15.9 Using a One-Hot State Assignment
When designing with CPLDs and FPGAs, we should keep in mind that each logic cell contains one or more flip-flops. These flip-flops are there whether we use them or not. This means that it may not be important to minimize the number of  flip-flops used in the design. Instead, we should try to reduce the total number of logic cells used and try to reduce the interconnections between cells. When several cells must be cascaded to realize a function as in Figure 9-40(b), the propagation delay is longer, and the logic runs slower. In order to design faster logic, we should try to reduce the number of cells required to realize each equation. Using a one-hot state assignment 
may help to accomplish this.
The one-hot assignment uses one flip-flop for each state, so a state machine with 
N states requires N flip-flops. Exactly one of the flip-flops is set to one in each state. 
For example, a system with four states 
(S0,  S1,  S2,  and S3) could use four flip-flops 
(Q0,  Q1,  Q2,  and Q3) with the following state assignment:
 S0: Q0 Q1 Q2 Q3=1000,  S1: 0100,   S2: 0010,   S3: 0001 (15-2)
The other 12 combinations are not used.
We can write next-state and output equations by inspecting the state graph. Con-
sider the partial state graph given in Figure 15-19. Because four arcs lead into S3, there 
are four conditions under which the next state is S3. These conditions are as follows: 
FIGURE 15-19
Partial State Graph
© Cengage Learning 2014S0 S1
S3S2
X1Z1X3Z1X2Z2
X4Z2
Reduction of State Tables State Assignment  529
present state (PS)=S0 and X1=1,  PS=S1 and X2=1,  PS=S2 and X3=1,  PS  =S3
and X4=1. The next state of flip-flop Q3 is 1 under these four conditions (and 0 other-
wise). Therefore, the next-state equation for Q3 can be written as:
Q+
3=X1 (Q0 Q1′ Q2′ Q3′)+X2 (Q0′ Q1 Q2′ Q3′)+ 
    X3 (Q0′ Q1′ Q2 Q3′)+X4 (Q0′ Q1′ Q2′ Q3)
However, because Q0=1 implies Q1=Q2=Q3=0, the Q1′ Q2′ Q3′ term is redun-
dant and can be eliminated. Similarly, all of the primed state variables can be elimi-
nated from the other terms, so the next-state equation reduces to
Q+
3=X1Q0+X2Q1+X3Q2+X4Q3
In general, when a one-hot state assignment is used, each term in the next-state equation for each flip-flop contains exactly one state variable, and the reduced equa-tion can be written by inspecting the state graph.
Similarly, each term in each reduced output equation contains exactly one state 
variable. Because Z
1=1 when PS =S0 and X1=1, and also when PS =S2 and 
X3=1, we can write Z1=X1Q0+X3Q2. By inspecting the state graph, we can also 
write Z2=X2Q1+X4Q3.
When a one-hot assignment is used, resetting the system requires that one flip-
flop be set to 1 instead of resetting all flip-flops to 0. If the flip-flops used do not have a preset input, then we can modify the one-hot assignment by replacing 
Q0 with Q0′ 
throughout. For the Assignment (15-2), the modification is
 S0: Q0  Q1  Q2  Q3=0000,  S1: 1100,   S2: 1010,   S3: 1001 (15-3)
and the modified equations are:
Q+
3=X1Q0′+X2Q1+X3Q2+X4Q3
Z1=X1Q0′+X3Q2, Z2=X2Q1+X4Q3
For the Moore machine of Figure 14-23(b), we will make the following one-hot 
assignment for flip-flops Q0 Q1 Q2: S0=100,   S1=010, and S2=001. When Q0=1, 
the state is S0; when Q1=1, the state is S1; and when Q2=1, the state is S2. By 
inspection, because three arcs lead into each state, the next-state equations are
Q0+=F′R′Q0+FQ2+F′RQ1
Q1+=F′R′Q1+FQ0+F′RQ2
Q2+=F′R′Q2+FQ1+F′RQ0
The output equations are trivial because each output occurs in only one state:
Z1=Q0, Z2=Q1, Z3=Q2
As another example, consider the state graph in Figure 15-20, which represents 
a sequential circuit that controls a binary multiplier. The circuit has three inputs 
(St,  M,  and  K), and four outputs (Load,  Ad, Sh, and Done ). Starting in state S0, if 
St=0, then the circuit stays in S0. If St=1, the circuit outputs Load =1 (the other 
outputs are 0), and the next state is S1. In S1, if M=1, then Ad=1 and the next state 
530 Unit 15
is S2. If M=0 and K=0, the output is Sh=1 and the next state is S1. If M=0 and 
K=1, the output is Sh=1 and the next state is S3. In S2, the output is Sh=1 for 
both K=0 and K=1. If K=0, the next state is S1, and if K=1, the next state is S3. 
In S3, the output is Done =1 and the next state is S0.
Because there are four states, a one-hot state assignment requires four flip-flops. 
The one-hot assignments for each state are shown on the state graph. Only Q0 is 1 
in S0 and the other Q’s are 0. Similarly, only Q1 is 1 in S1 and the other Q’s are 0, etc. 
To determine the next-state equation for Q0, note that two arrows lead into state S0. 
The loop from state S0 back to itself indicates Q+
0=1 if Q0=1 and St=0. The arrow 
from S3 to S0 indicates Q+
0=1 if Q3=1. Therefore,
Q0+=Q0St ′+Q3
Because three arrows lead into S1, Q+
1 has three terms:
Q1+=Q0St+Q1K′M ′+Q2K′
We can also determine the output functions by inspection of the state graph. In 
S0, Load =1 when St=1 and Load =0 for all other states and inputs; therefore, 
Load =Q0St. The output Sh appears in four places on the graph. Sh=1 in S1 if 
K′M ′=1 or if KM′ =1; also, Sh=1 in S2 if K ′=1 or K =1. Therefore,
Sh=Q1 (K′M ′+KM′ )+Q2 (K′+K)=Q1M ′+Q2
When designing with CPLDs or FPGAs, you should try both an assignment with 
a minimum number of state variables and a one-hot assignment to see which one 
leads to a design with the smallest number of logic cells. Alternatively, if the speed of operation is important, the design which leads to the fastest logic should be chosen. When a one-hot assignment is used, more next-state equations are required, but for some state graphs both the next-state and output equations may contain fewer  variables. An equation with fewer variables may require fewer logic cells to realize. The more cells which are cascaded, the longer the propagation delay, and the slower the operation.FIGURE 15-20
Multiplier Control 
State Graph
© Cengage Learning 2014
DoneS0 S1
S2 S3K′M′
_St ′
0St
LoadSh
M
AdKM′
Sh
K′
Sh
K
ShQ0Q1Q2Q3
=1000
00010100
0010
Reduction of State Tables State Assignment  531
Problems
15.1 (a) Reduce the following state table to a minimum number of states.
Present 
StateNext State Present Output
X=0X=1 X=0 X=1
A A E 10
B C F 00
C B H 00
D E F 00
E D A 00
F B F 10
G D H 00
H H G 10
(b) You are given two identical sequential circuits which realize the preceding state 
table. One circuit is initially in state B  and the other circuit is initially in state G. 
Specify an input sequence of length three which could be used to distinguish 
between the two circuits and give the corresponding output sequence from each circuit.
15.2 Reduce the following state table to a minimum number of states.
Present 
StateNext State Present 
Output (Z) X=01
ae e 1
b ce 1
ci h 0
d h a 1
ei f 0
f e g 0
g h b 1
h c d 0
i f b 1
15.3 Digital engineer B. I. Nary has just completed the design of a sequential circuit which 
has the following state table:
Present 
StateNext State Output
X=0 101
S0 S5 S100
S1 S5 S600
S2 S2 S600
S3 S0 S110
S4 S4 S300
S5 S0 S100
S6 S5 S110
532 Unit 15
His assistant, F. L. Ipflop, who has just completed this course, claims that his design can 
be used to replace Mr. Nary’s circuit. Mr. Ipflop’s design has the following state table:
Next State Output
X=010 1
aa b 00
b ac 00
ca b 10
(a) Is Mr. Ipflop correct? (Prove your answer.)
(b) If Mr. Nary’s circuit is always started in state S0, is Mr. Ipflop correct? (Prove 
your answer by showing equivalent states, etc.)
15.4 Realize the following state table using a minimum number of AND and OR gates 
together with
(a) a D flip-flop
(b) an S-R flip-flop
15.5 It is sometimes possible to save logic by using more than the minimum number of 
flip-flops. For both (a) and (b), fill in each state assignment by columns and, then, check for duplicate rows instead of filling in the assignments by rows and checking for permuted columns. If the columns are assigned in ascending numerical order and the first row is all 0’s, then equivalent assignments will not be generated. Do not list degenerate assignments for which two columns are identical or complements of each other, or assignments where one column is all 0’s or all 1’s.
(a) Consider a state table with three states to be realized using three J-K flip-flops. 
To be sure of getting the minimum amount of logic, how many different state assignments must be tried? Enumerate these assignments.
(b) For four states and three flip-flops, 29 assignments must be tried. Enumerate 10 
of these, always assigning 000 to the first state.
15.6 A sequential circuit with one input and one output has the following state table:X1X2X3
000 001 010 011 100 101 110 111 Z
A A A B B B B A A 0
B A B B A A B B A 1
Present 
StateNext State Present 
Output X=0X=1
S1 S5 S4 0
S2 S1 S6 1
S3 S7 S8 1
S4 S7 S1 0
S5 S2 S3 1
S6 S4 S2 0
S7 S6 S8 0
S8 S5 S3 1
Reduction of State Tables State Assignment  533
(a) For this part of the problem, do not consider the flip-flop input equations (this 
means that you can ignore the next-state part of the table). Make a state assign-
ment which might minimize the output equation, and derive the minimum out-put equation for your assignment.
(b) Forget about your solution to (a). Apply Guidelines 1 and 2 to make a state 
assignment, assigning 000 to S
1. Derive input equations for D flip-flops using 
this assignment.
15.7 The following table is to be realized using D flip-flops.
(a) Find a good state assignment using the three guidelines (do not reduce the table 
first.) Try to satisfy as many of the adjacency conditions as possible.
(b) Using this assignment, derive the D flip-flop input equations and the output 
equations.
15.8 (a)  For the following state table, use the three guidelines to determine which of the 
three possible nonequivalent state assignments should give the best solution.X=01Z
X=0 1
A FD 00
B DB 00
C AC 01
D FD 00
E AC 01
F FB 00
Z1Z2
X1X2=00 01 11 10 X1X2=00 01 11 10
AA C B D 00 00 00 00
BB B D D 00 00 10 10
CC A C A 01 01 01 01
DB B C A 01 01 10 10
(b) Using your answer to (a), derive the T flip-flop input equations and the output 
equations.
15.9 Implement the given state graph using D flip-flops and gates. Use a one-hot assign-
ment and write down the logic equations by inspecting the state graph.
S0
S2 S1X′
S
X
P
X
P
Y
0X′
0XY′
PS
X′Y′
P
534 Unit 15
15.10 (a) Reduce the following state table to a minimum number of states.
(b) You are given two identical sequential circuits which realize this state table. One 
circuit is initially in state d, and the other circuit is initially in state c. Specify an 
input sequence of length two which could be used to distinguish between the 
two circuits, and give the corresponding output sequence from each circuit.
15.11 For the following state table:
(a) Reduce the table to a minimum number of states.
(b) Using the basic definition of state equivalence, show that state a is not equiva-
lent to state b .
15.12 A Moore sequential circuit has a single input (X) and a single output (Z). Z is 1 if the 
most recent four inputs contained exactly two consecutive 1’s or exactly two con-secutive 0’s (i.e., the input sequences 0011, 0010, 1001, 1100, 0110, 0100, 1011, and 1101). (The initial state S
0 acts as if the preceding inputs were all 0’s.) The following 
state table was constructed using a sufficient number of states to remember the last four inputs and the output for each state assigned according to the sequence remem-bered by that state.
(a) Reduce the table to a minimum number of states. ( Hint: First use the simple exam-
ple of state equivalence used in Section 15.1 to eliminate as many states as possible.)
(b) For each state in the reduced table, give the input pattern remembered by that state.
(c) Convert the reduced table from part (a) into a Mealy state table that produces 
the same outputs.
(d) Reduce the Mealy state table to a minimum number of states.Present 
StateNext State Present Output
X=01 X=0 1
a h c 10
b c d 01
c h b 00
d f h 00
ec f 01
f f g 00
g g c 10
h ac 10
Present 
StateNext State Present Output
X=0X=1X=0 X=1
ae g 01
b d f 01
ce c 10
d b f 01
e g f 01
f b d 10
g ec 10
Reduction of State Tables State Assignment  535
15.13 A sequential circuit has a single input (X) and a single output (Z). The circuit exam-
ines each disjoint block of four inputs and determines whether the block is a valid 
BCD representation of a decimal digit; if not, Z =1. State S0 is the initial state, and 
the circuit enters state S0 after the fourth input. The BCD digits are received most 
significant bit first. The following state table was constructed as a Mealy table using a sufficient number of states to remember the last three inputs with the output pro-duced when the fourth input bit of a block is received.
(a) Does the resulting table specify a Mealy or a Moore circuit?
(b) Reduce the state table to a minimum number of states. ( Hint: Use the simple exam-
ple of state equivalence used in Section 15.1 to eliminate as many states as possible.)
(c) For each state in the reduced table, give the input pattern remembered by that state.Input 
PatternPresent 
StateNext State Output
X=0X=1 Z
0000 S0 S0 S1 0
0001 S1 S2 S3 0
0010 S2 S4 S5 1
0011 S3 S6 S7 1
0100 S4 S8 S9 1
0101 S5 S10 S11 0
0110 S6 S12 S13 1
0111 S7 S14 S15 0
1000 S8 S0 S1 0
1001 S9 S2 S3 1
1010 S10 S4 S5 0
1011 S11 S6 S7 1
1100 S12 S8 S9 1
1101 S13 S10 S11 1
1110 S14 S12 S13 0
1111 S15 S14 S15 0
Input 
PatternPresent 
StateNext State Present Output Z
X=0 X=1 X=0 X=1
– S1 S2 S3 00
0 S2 S4 S5 00
1 S3 S6 S7 00
00 S4 S8 S9 00
01 S5 S10 S11 00
10 S6 S12 S13 00
11 S7 S14 S15 00
000 S8 S1 S1 00
001 S9 S1 S1 00
010 S10 S1 S1 00
011 S11 S1 S1 00
100 S12 S1 S1 00
101 S13 S1 S1 11
110 S14 S1 S1 11
111 S15 S1 S1 11
536 Unit 15
15.14 A sequential circuit has a single input (X) and a single output (Z). The circuit exam-
ines each disjoint block of four inputs and determines whether the block is a valid 
BCD representation of a decimal digit; if not, Z =1. State S0 is the initial state, and 
the circuit enters state S0 after the fourth input. The BCD digits are received least 
significant bit first. A Mealy state table can be constructed using a sufficient number of states to remember the last three inputs with the output produced when the fourth input bit of a block is received.
(a) Using the method indicated by Problem 15.13, construct a state table for this 
circuit.
(b) Reduce the state table to a minimum number of states. ( Hint: Use the simple 
example of state equivalence used in Section 15.1 to eliminate as many states as possible.)
(c) For each state in the reduced table, give the input pattern(s) remembered by 
that state.
15.15 Reduce each of the following state tables to a minimum number of states:
(a) XY=00 01 11 10 Z
aa c e d 0
b d eea 0
ce a f b 1
d b cc b 0
ec d f a 1
f fb a d 1(b) X=010 1
a bc 10
b ed 10
c gd 11
d eb 10
e fg 10
f hb 11
g hi 01
h gi 01
ia a 01
15.16 Reduce each of the following tables to a minimum number of states:
(a) XY=00 01 11 10 Z
a b ic g 0
b b c f g 0
c h d d f 1
d h ce g 1
e b ci g 0
f f ii k 0
g j k g h 0
h e f c g 0
ii i i d 0
j b f c g 0
k ac e g 1
Reduction of State Tables State Assignment  537
15.17 Circuits N and M have the state tables that follow.
(a) Without first reducing the tables, determine whether circuits N and M are 
 equivalent.
(b) Reduce each table to a minimum number of states, and then show that N is 
equivalent to M by inspecting the reduced tables.(b) XY=00 01 11 10 XY=00 01 11 10
aa a g k 100 0
b c f g d 000 0
c g ca i 100 0
d a d g i 100 0
e f h g a 000 0
f g c d k 100 0
g c j g e 010 0
h g h d k 100 0
i h h g d 000 0
j j j g k 100 0
k cc g d 000 0
M
X=0 1
S0 S3 S10
S1 S0 S10
S2 S0 S21
S3 S0 S31N
X=0 1
A E A 1
B F B 1
C E D 0
D E C 0
E B D 0
F B C 0
15.18 Below is an incompletely specified state table.
(a) Reduce the state table to four states in two different ways by filling in the don’t-
care in the state table in different ways.
(b) Show that your two state tables in part (a) are not equivalent, using an implica-
tion table similar to Figure 15-7 .
(c) Show that your two state tables in (a) are not equivalent by giving a short input 
sequence which gives different outputs for the two state tables.Present 
StateNext State Present 
Output (Z ) X=0 1
S0 S1 S0 0
S1 S0 S2 0
S2 S3 S4 1
S3 S0 S3 0
S4 S0 –0
538 Unit 15
15.19 Repeat 15.18 for this state table (four states).
Present 
StateNext StatePresent Output
(Z)
X=0 1 X=0 1
S0 S1 S5 00
S1 S3 S2 11
S2 S2 S4 01
S3 S4 S2 11
S4 S4 S2 –1
S5 S5 S2 01
(i) (ii) (iii) (iv) (v)
S0 000 010 100 110 001
S1 001 111 101 010 111
S2 010 001 000 111 101
S3 011 110 001 011 011
S4 100 000 111 000 000
S5 101 100 110 100 01015.20 The following are possible state assignments for a six-state sequential circuit.
(a) Which two state assignments are equivalent?
(b) For each assignment (except (i)), give an equivalent assignment for which state 
S0 is assigned to 000.
(c) Give a state assignment which is not equivalent to any of the assignments.
15.21 (a)  For an eight-state sequential circuit using three flip-flops, give three state assign-
ments that assign 000 to S0 and are equivalent to a straight binary assignment.
(b) Give three state assignments that assign 111 to S0 and are not equivalent to a 
straight binary assignment or to each other.
15.22 A sequential circuit with one input and one output has the following state table:
Present 
StateNext State Present 
Output X=0 X=1
A D G 1
B E H 0
C B F 1
D F G 0
E C A 1
F H C 0
G E A 1
H D B 0
(a) For this part of the problem, do not consider the flip-flop input equations (this 
means that you can ignore the next-state part of the table). Make a state assign-
ment which will minimize the output equation, and derive the minimum output equation for your assignment.
Reduction of State Tables State Assignment  539
(b) Forget about your solution to (a). Apply Guidelines 1 and 2 to make a state 
assignment, assigning 000 to A. Derive input equations for D flip-flops using this 
assignment.
15.23 (a)  For the following state table, use the three guidelines to determine which of the 
three possible nonequivalent state assignments should give the best solution.
Z1Z2
X1X2=00 01 11 10 X1X2=00 01 11 10
A A A C C 01 01 01 01
B B D B D 11 11 11 11
C A A B D 11 11 00 00
D D B A C 01 01 01 01
(b) Using your answer to (a), derive J-K flip-flop input equations and the output 
equations.
15.24 Consider the following Moore sequential circuit.
(a) Derive the equations for a one-hot state assignment.
(b) Use Guidelines 1 and 2 to make a “good” state assignment using three state 
 variables. Derive the next-state equations assuming D flip-flops are used.
Present 
StateNext State Present 
Output Z X=0 X=1
A B A 0
B C A 0
C E D 0
D B A 1
E E A 0
15.25 (a)  Reduce the following state table to a minimum number of states using implica-
tion charts.
(b) Use the guideline method to determine a suitable state assignment for the 
reduced table.
(c) Realize the table using D flip-flops.
(d) Realize the table using J-K flip-flops.
X=0 1 Z
A A B 1
B C E 0
C F G 1
D C A 0
E IG 1
F H I 1
G C F 0
H F B 1
I C E 0
540 Unit 15
15.26 Repeat Problem 15.25 for the following table:
X=01Z
A IC 1
B BI1
C CG 1
D IC 0
E DE 0
F IC 0
G EF 0
H HA 1
I AC 1
15.27 Make a suitable state assignment and realize the state graph of Figure 14-10 using:
(a) D flip-flops (b) S-R flip-flops
15.28 Make a suitable state assignment and realize the state graph of Figure 14-13 using:
(a) J-K flip-flops (b) T flip-flops
15.29 Make a suitable state assignment and realize the state table of Problem 14.22 using 
D flip-flops and NAND gates.
15.30 Make a suitable state assignment and realize the state table of Problem 14.5 using 
J-K flip-flops and NAND gates.
15.31 Reduce the state table of Problem 14.6 to a minimum number of rows. Then, make a 
suitable state assignment and realize the state table using D flip-flops.
15.32 Reduce the state table of Problem 14.23 to a minimum number of rows. Then, make 
a suitable state assignment and realize the state table using D flip-flops.
15.33 A logic designer who had not taken this course designed a sequential circuit with 
an input W using three T flip-flops, A, B, and C. The input equations for these flip-
flops are
TA=W ′A′B+W ′BC′ +A′BC′ +AB ′C+WB ′C+WAC
TB=W ′A′C+W ′A′B+A′BC+AB ′C′+WB ′C′+WAC ′
TC=W ′AC+W ′B′C′+WBC +WA′C′
and the output equation is Z=W ′BC′. Find an equivalent sequential circuit which 
uses fewer states. Realize it, trying to minimize the amount of logic required.
15.34 Modify the given state graph so that it is completely specified. Assume that if 
X=Y=1, X takes precedence. Then implement the state graph using D flip-flops 
Reduction of State Tables State Assignment  541
and gates. Use a one-hot assignment and write down the logic equations by inspect-
ing the state graph.
X′Y
X′Y′0
XY′
0XY
S
X
SY
S
PY
0X
0
S1 S2
S3S0
15.35 Implement the following state graph using D flip-flops and gates. Use a one-hot 
assignment and write down the logic equations by inspecting the state graph.
S0X′Y
S1 S20
XY′
0X′Y′
0
X′Y
ZX′Y
Z
XY
0XY
0,
XY
ZY′
0
Y′
0
15.36 A state graph for a single-input sequential circuit is given. Implement the circuit 
using a three-bit parallel loading counter that has the given operation table. Label 
the counter outputs Q2,  Q1,  Q0, where Q0 is the least significant bit and the parallel 
inputs P2,  P1,  P0. (Hint: Because the Ld signal overrides the Cnt signal, the counting 
sequence can easily be changed by doing a parallel load at the appropriate times.)
Clr Ld Cnt Function
0 — — Clear
1 1 — Parallel Load1 0 1 Increment1 0 0 Hold (No change)000
0,1
001 011
0100
0,10,11
542 Unit 15
15.37 Consider the following Mealy sequential circuit.
Present 
StateNext State Present Output
X=0 X=1 X=0 X=1
A B A 00
B C A 00
C D A 01
D D A 00
(a) Use a one-hot state assignment, and implement the circuit using D flip-flops.
(b) Use the state assignment A=00, B=01, C=11, and D=10, and implement 
the circuit using D flip-flops.
(c) Implement the circuit using a 4-bit parallel loading counter instead of flip-flops 
for memory. Assume the synchronous counter controls are as follows:
s1 s0 Function
0 0 Hold
0 1 Increment1 0 Parallel load1 1 Clear
Q3Q2Q1Q0 are the outputs; P3P2P1P0 are the parallel inputs; and Q0 is the least 
significant bit of the counter. (With the proper state assignment, this can be done 
without using the parallel load function of the counter.)
(d) Implement the circuit using a 4-bit parallel loading shift register instead of 
 flip-flops for memory. Assume the synchronous shift register controls are as  follows:
S1 S0 Function
0 0 Hold
0 1 Shift right1 0 Parallel load1 1 Clear
Sin is the input for the shift; Q3Q2Q1Q0 are the outputs; P3P2P1P0 are the parallel 
inputs. When shifting, Sin→Q3, Q3→Q2, Q2→Q1, Q1→Q0. (With the proper 
state assignment, this can be done without using the parallel load function of the 
shift register.)
15.38 A sequential circuit contains two D flip-flops; the excitation equations for the flip-
flops are D1=XQ1+XQ2 and D2=XQ1+XQ2′.
(a) Convert the circuit into an equivalent one where each D flip-flop is replaced by 
a T flip-flop. Do this by converting the next-state equations into the form for a  T flip-flop. (Hint: MQ +NQ ′=
(M ′Q+NQ ′)′Q+(M ′Q+NQ ′)Q′.)
(b) Repeat part (a) by constructing an excitation table for the T flip-flops (i.e., a 
truth table for T1 and T2 as a function of X, Q1, and Q2).
Reduction of State Tables State Assignment  543
(c) Convert the circuit into an equivalent one where each D flip-flop is replaced by 
a J-K flip-flop. Do this by converting the next-state equations into the form for 
a J-K flip-flop.
(d) Repeat part (c) by constructing an excitation table for the J-K flip-flops (i.e., a 
truth table for the J and K flip-flop inputs as a function of X, Q1, and Q2).
15.39 A sequential circuit contains two J-K flip-flops; the excitation equations for the flip-
flops are J1=Q2, K1=Q1, J2=X+Q1′, and K2=1.
(a) Convert the circuit into an equivalent one where each J-K flip-flop is replaced 
by a T flip-flop. Do this by converting the next-state equations into the form for a T flip-flop. (Hint: MQ +NQ ′=
(M ′Q+NQ ′)′Q+(M ′Q+NQ ′)Q′.)
(b) Repeat part (a) by constructing an excitation table for the T flip-flops (i.e., a 
truth table for T1 and T2 as a function of X, Q1, and Q2).
(c) Convert the circuit into an equivalent one where each D flip-flop is replaced by 
an S-R flip-flop. Do this by converting the next-state equations into the form for a S-R flip-flop.
(d) Repeat part (c) by constructing an excitation table for the S-R flip-flops (i.e., a 
truth table for the S and R flip-flop inputs as a function of 
X, Q1, and Q2).
15.40 Show that the following incompletely specified table can be reduced to a table with 
seven states. ( Hint: This table can be reduced by applying row matching where a 
don’t-care “matches” anything.)
Present 
StateNext State Output (Z)
X=0 X=1 X=0 X=1
S0 S1 S2 00
S1 S3 S4 00
S2 S5 S6 00
S3 S7 S8 00
S4 S8 S9 00
S5 S10 S9 00
S6 S9 S8 00
S7 S0 S0 10
S8 S0 –0–
S9 S0 –1–
S10 S0 S0 01
15.41 (a) Find the maximal compatibles for Table 14-10.
(b) Reduce the table to a minimum number of states.
(c) Consider a circuit designed from the reduced table. Describe in words the func-
tion of the circuit.
15.42 (a) Find the maximal compatibles for Table 14-9. (There are seven.)
(b) Reduce the table to a minimum number of states.
544 Unit 15
15.43 Modify the BCD Parity Generator of Table 14-9 so that the outputs are don’t-cares 
for the first three inputs. The new state table is given below.
(a) Find the maximal compatibles for this table. (There are eight.)
(b) Reduce this table to a minimum number of states.
Present 
StateNext State Output
X=0 X=1 X=0 X=1
S0 S1 S2 ––
0 S1 S3 S4 ––
1 S2 S5 S6 ––
00 S3 S0 S0 10
01 S4 S0 –0–
10 S5 S0 S0 01
11 S6 S0 –1–Present 
StateNext State Output
X=0X=1X=0X=1
S0 S1 S2 ––
S1 S3 S4 ––
S2 S5 –––
S3 S6 S7 ––
S4 S7 S6 ––
S5 S7 –––
S6 S0 S0 10
S7 S0 S0 01
15.44 (a) Find the maximal compatibles for the incompletely specified table below.
(b) Reduce the table to a minimum number of states.
15.45 (a) Find the maximal compatibles for the table below. (There are eight.)
(b) Try reducing the table using the maximal compatibles. How many states are 
required?
(c) Show that this table can be reduced to six states using pairs of compatible 
states. (This is an example of a table that cannot be reduced using only maximal 
 compatibles.)
Present 
StateNext State Output (Z)
X=0 X=1 X=0 X=1
S0 S1 S2 ––
S1 S3 S4 ––
S2 S4 S3 ––
S3 S5 S6 ––
S4 S6 S5 ––
S5 S0 S0 10
S6 S0 S0 01
545Sequential Circuit DesignUNIT
16
Objectives
1. Design a sequential circuit using gates and flip-flops.
2. Test your circuit by simulating it and by implementing it in lab.
3. Design a unilateral iterative circuit. Explain the relationship between iterative 
and sequential circuits, and convert from one to the other.
4. Show how to implement a sequential circuit using a ROM or PLA and flip-flops.
5. Explain the operation of CPLDs and FPGAs and show how they can be used to implement sequential logic.
546 Unit 16
Study Guide
1. Study Sections 16.1, Summary of Design Procedure for Sequential Circuits , and 
16.2, Design Example—Code Converter.
(a) Why are the states in the next-state part of Table 16-2 listed in a different 
order from the states in Table 15-1?
(b) Consider the design of a sequential circuit to convert an 8-4-2-1 code to a 
 6-3-1 -1 code (see Table 1 -2). If the least significant bit of an 8-4-2-1 coded 
digit is fed into the circuit at t0, can the least significant bit of the 6-3-1 -1 coded 
digit be determined immediately? Explain. Why can the technique described in this section not be used to design the 8-4-2-1 to 6-3-1 -1 code converter?
2. Study Section 16.3, Design of Iterative Circuits
(a) Draw a state graph for the comparator of Table 16-4. Compare several 
pairs of binary numbers using the scheme represented by Table 16-4 and make sure you understand why this method works. Draw a circuit similar to Figure 16-6 with five cells. Show the values of all the cell inputs and outputs if 
X=10101 and Y=10011.
(b) If the state table for a typical cell of an iterative circuit has n states, what is 
the minimum number of signals required between each pair of adjacent cells?
(c) Work Problem 16.17 .
3. Study Section 16.4, Design of Sequential Circuits Using ROMs and PLAs.
(a) Review Section 9.5, Read-Only Memories, and Section 9.6, Programmable 
Logic Devices.
(b) What size ROM would be required to realize a state table with 13 states, 
two input variables, and three output variables?
(c) In going from Table 16-6(b) to 16-6(c), note that for X=0, Q1Q2Q3=000, 
Z=1, and Q+
1Q+
2Q+
3=D1D2D3=001; therefore, 1001 is entered in the first 
row of the truth table. Verify that the other truth table entries are correct.
(d) Continue the analysis of the PLA realization of the code converter 
which was started in the paragraph following Table 16-7 . In particular, if Q
1Q2Q3=100 and X=1, what will be the PLA outputs? What will the 
state be after the clock?
Sequential Circuit Design  547
(e) Work Problems 16.15 and 16.16.
4. Study Section 16.5, Sequential Circuit Design Using CPLDs, and Section 16.6, 
Sequential Circuit Design Using FPGAs.
(a) How many macrocells of a CoolRunner-II are needed to implement a Moore 
machine with six states, one input, and two outputs? With two inputs?
(b) How many LUT’s of a Virtex/Spartan II are needed to implement each of 
these Moore machines? How many CLB’s?
(c) Rewrite the equations for Q+
2, Q+
1, and Q+
0 of Equations 12-1 to fit into one 
LUT each, as we did for Q+
3 in Equation (16-2), using CE =Ld+Sh.
5. Study Section 16.7 , Simulation and Testing of Sequential Circuits.
(a) Observe the simulator output of Figure 16-23(b), and note the times 
at which the Z output changes. Assuming that each gate and flip-flop in 
Figure 16-22 has a 10-ns delay, explain the Z waveform.
(b) Suppose that you are testing the circuit of Figure 16-4, and that when you set 
X=0 and Q1Q2Q3=011 and pulse the clock, the circuit goes to state 100 
instead of 000. What would you do to determine the cause of the malfunction?
6. Read Section 16.8, Overview of Computer-Aided Design , for general information.
7. Work out your assigned design problem by hand. Then, use LogicAid to check 
your state table using the state table checker, and then verify that your logic equations are correct. Try at least two different state assignments and choose the one which requires the smallest number of logic gates.
8. Answer the following questions before you simulate your circuit or test it in lab. At which of the following times will the output of your circuit be correct? (If you are not absolutely sure that your answer is correct, review Section 13.2, paying particular attention to the timing charts for Mealy circuits.)
(a) Just before the rising clock edge
(b) Just after the rising clock edge (after the state has changed but before the 
input is changed to the next value)
(c) After the input has been changed to the next value, but before the next 
rising edge occurs
9. (a)  Explain how it is possible to get false outputs from your circuit even though 
the circuit is correctly designed and working properly.
548 Unit 16
(b) If the output of your circuit was fed into another sequential circuit using 
the same clock, would the false outputs cause any problems? Explain.
10. When you get your circuit working properly, determine the output sequences 
for the given test sequences. Demonstrate the operation of your circuit to a proctor and have him or her check your output sequences. After successful com-pletion of the project, turn in your design and the test results. (No readiness test is required.)
Sequential Circuit Design
We have already studied the various steps in sequential circuit design—derivation of state tables (Unit 14), state table reduction (Unit 15), state assignment (Unit 15), and derivation of flip-flop input equations (Units 12 and 15). This unit contains a  summary of the design procedure, a comprehensive design example, and procedures for testing your circuit in lab.
16.1 Summary of Design Procedure  
for Sequential Circuits
1. Given the problem statement, determine the required relationship between the 
input and output sequences and derive a state table. For many problems, it is easiest to first construct a state graph.
2. Reduce the table to a minimum number of states. First, eliminate duplicate rows by row matching and, then, form an implication table and follow the procedure in Section 15.3.
Sequential Circuit Design  549
3. If the reduced table has m states (2n–1<m≤2n), n flip-flops are required. Assign 
a unique combination of flip-flop states to correspond to each state in the 
reduced table. The guidelines given in Section 15.8 may prove helpful in finding an assignment which leads to an economical circuit.
4. Form the transition table by substituting the assigned flip-flop states for each state in the reduced state table. The resulting transition table specifies the next states of the flip-flops, and the output in terms of the present states of the  flip-flops and the input.
5. Plot next-state maps and input maps for each flip-flop and derive the flip-flop input equations. (Depending on the type of gates to be used, either determine the sum-of-products form from the 1’s on the map or the product-of-sums form from the 0’s on the map.) Derive the output functions.
6. Realize the flip-flop input equations and the output equations using the avail-able logic gates.
7. Check your design by signal tracing, computer simulation, or laboratory testing.
16.2 Design Example—Code Converter
We will design a sequential circuit to convert BCD to excess-3 code. This circuit adds three to a binary-coded-decimal digit in the range 0 to 9. The input and output will be serial with the least significant bit first. A list of allowed input and output sequences is shown in Table 16-1.
Table 16-1 lists the desired inputs and outputs at times t
0, t1, t2, and t3. After 
receiving four inputs, the circuit should reset to the initial state, ready to receive another group of four inputs. It is not clear at this point whether a sequential circuit can actually be realized to produce the output sequences as specified in Table 16-1 without delaying the output.
X
Input
(BCD)Z
Output
(excess-3)
t3t2t1t0 t3t2t1t0
0000 0011
0001 01000010 01010011 01100100 01110101 10000110 10010111 10101000 10111001 1100TABLE 16-1
© Cengage Learning 2014
550 Unit 16
For example, if at t0 some sequences required an output Z=0 for X=0 and 
other sequences required Z=1 for X=0, it would be impossible to design the cir-
cuit without delaying the output. For Table 16-1 we see that at t0 if the input is 0 the 
output is always 1, and if the input is 1 the output is always 0; therefore, there is no 
conflict at t0. At time t1 the circuit will have available only the inputs received at t1 
and t0. There will be no conflict at t1 if the output at t1 can be determined only from 
the inputs received at t1 and t0. If 00 has been received at t1 and t0, the output should 
be 1 at t1 in all three cases where 00 occurs in the table. If 01 has been received, the 
output should be 0 at t1 in all three cases where 01 occurs. For sequences 10 and 11 
the outputs at t1 should be 0 and 1, respectively. Therefore, there is no output conflict 
at t1. In a similar manner we can check to see that there is no conflict at t2, and at t3 
all four inputs are available, so there is no problem.
We will now proceed to set up the state table (Table 16-2), using the same pro-
cedure as in Section 15.1. The arrangement of next states in the table is different from that in Table 15-1 because in this example the input sequences are received with least significant bit first, while for Table 15-1 the first input bit received is listed first in the sequence. Dashes (don’t-cares) appear in this table because only 10 of the 16 possible 4-bit sequences can occur as inputs to the code converter. The output part of the table is filled in, using the reasoning discussed in the preceding paragraph. For example, if the circuit is in state B  at t
1 and a 1 is received, this means that the 
sequence 10 has been received and the output should be 0.
Next, we will reduce the table using row matching. When matching rows which 
contain dashes (don’t-cares), a dash will match with any state or with any output value. By matching rows in this manner, we have H≡I≡
J≡K≡L and  M≡N≡P. 
After eliminating I, J, K, L, N, and P, we find E≡F≡G and the table reduces to 
seven rows (Table 16-3).
TimeInput Sequence 
Received  
(Least Significant  
Bit First)Present 
StateNext StatePresent 
Output (Z )
X=01 X=01
t0 reset A BC 10
t1 0 B DF 10
1 C EG 01
t200 D HL 01
01 E IM 10
10 F JN 10
11 G KP 10
t3000 H AA 01
001 I AA 01
010 J A− 0−
011 K A− 0−
100 L A− 0−
101 M A− 1−
110 N A− 1−
111 P A− 1−TABLE 16-2
State Table for 
Code Converter
© Cengage Learning 2014
Sequential Circuit Design  551
An alternate approach to deriving Table 16-2 is to start with a state graph. The 
state graph (Figure 16-1) has the form of a tree. Each path starting at the reset state 
represents one of the ten possible input sequences. After the paths for the input sequences have been constructed, the outputs can be filled in by working backward along each path. For example, starting at t
3, the path 0 0 0 0 has outputs 0 0 1 1 and the 
path 1 0 0 0 has outputs 1 0 1 1. Verify that Table 16-2 corresponds to this state graph.
Three flip-flops are required to realize the reduced table because there are seven 
states. Each of the states must be assigned a unique combination of flip-flop states. Some assignments will lead to economical circuits with only a few gates, while other assignments will require many more gates. Using the guidelines given in Section 15.8, states 
B and C, D and E, and H and M should be given adjacent assignments in 
order to simplify the next-state functions. To simplify the output function, states 
(A, B, E,   and  M) and (C, D,  and  H) should be given adjacent assignments. A good 
assignment for this example is given on the map and table in Figure 16-2. After the state assignment has been made, the transition table is filled in according to the assignment, and the next-state maps are plotted as shown in Figure 16-3. The D input 
equations are then read off the Q
+ maps as indicated. Figure 16-4 shows the result-
ing sequential circuit.
FIGURE 16-1
State Graph 
for Code  
Converter
© Cengage Learning 2014t0
t1
t2
t3A
N I J L H PGC
E FB
D
K MReset0
1
0
1
0
0
0
00
00
00
00
00
0
0
10
10
10
1
0
10
11
01
0
1
01
01
0
1
11
1
1
11
1TimePresent 
StateNext  
StatePresent 
Output (Z  )
X=01 X=01
t0 A BC 10
t1 B DE 10
C EE 01
t2 D HH 01
E HM 10
t3 H AA 01
M A− 1 −TABLE 16-3
Reduced State 
Table for Code 
Converter
© Cengage Learning 2014
552 Unit 16
FIGURE 16-3
Karnaugh  
Maps for Code 
Converter Design
© Cengage Learning 2014
D3 = Q+
3=Q1Q2Q3+X′Q1Q′3+XQ ′1Q′2D2=Q2+=Q1 D1 = Q1+=Q21 1 1 100 01 11 10
X 1 1X
0 0 0 0
00000XQ1
Q2Q3
01
11
10 X0 1 1 000 01 11 10
X 1 1X
0 1 1 0
01100XQ1
Q2Q3
01
11
10 X
0 1 0 100 01 11 10
X 0 0X
0 1 1 0
01000XQ1
Q2Q3
01
11
10 X
Z=X′Q′3+XQ31 1 0 000 01 11 10
X 0 1X
0 0 1 1
11000XQ1
Q2Q3
01
11
10 X′
FIGURE 16-4
Code Converter 
Circuit
© Cengage Learning 2014
Q3 A6A5
Z
Q2D
FF1 G1
G2
G3G4G5
G6Q′Q
D
FF2 I1
Q′Q
D
FF3
Q′QQ1
Q1
CLKQ1
Q1A1
A2
A3D3X
X′Q1′
′Q1Q2Q3
Q3
X′
X′Q2
Q2
Q3′
Q2′′
′G7Q+
1Q+
2Q+
3 Z
Q1Q2Q3X=0 X=1X=0X=1
A 0 0 0 1 0 0 1 0 1 1 0
B 1 0 0 1 1 1 1 1 0 1 0
C 1 0 1 1 1 0 1 1 0 0 1
D 1 1 1 0 1 1 0 1 1 0 1
E 1 1 0 0 1 1 0 1 0 1 0
H 0 1 1 0 0 0 0 0 0 0 1
M 0 1 0 0 0 0 x x x 1 x
– 0 0 1 x x x x x x x x
(b) Transition table01
00Q2Q3Q1
01
11
10AB
HD
MEC
(a) Assignment mapFIGURE 16-2
Assignment Map 
and Transition 
Table for Flip-Flops
© Cengage Learning 2014
Sequential Circuit Design  553
16.3 Design of Iterative Circuits
Many of the design procedures used for sequential circuits can be applied to the design 
of iterative circuits. An iterative circuit consists of a number of identical cells intercon-nected in a regular manner. Some operations, such as binary addition, naturally lend themselves to realization with an iterative circuit because the same operation is per-formed on each pair of input bits. The regular structure of an iterative circuit makes it easier to fabricate in integrated circuit form than circuits with less regular structures.
The simplest form of an iterative circuit consists of a linear array of combina-
tional cells with signals between cells traveling in only one direction (Figure 16-5). Each cell is a combinational circuit with one or more primary inputs 
(xi) and pos-
sibly one or more primary outputs (zi). In addition, each cell has one or more sec-
ondary inputs (ai) and one or more secondary outputs (ai +1). The ai signals carry 
information about the “state” of one cell to the next cell.
The primary inputs to the cells (x1, x2, . . . , xn) are applied in parallel; that is, they 
are all applied at the same time. The ai signals then propagate down the line of cells. 
Because the circuit is combinational, the time required for the circuit to reach a steady-state condition is determined only by the delay times of the gates in the cells. As soon as steady state is reached, the outputs may be read. Thus, the iterative circuit can func-tion as a parallel-input, parallel-output device, in contrast with the sequential circuit in which the input and output are serial. One can think of the iterative circuit as receiving its inputs as a sequence in space in contrast with the sequential circuit which receives its inputs as a sequence in time. The parallel adder of Figure 4-3 is an example of an iterative circuit that has four identical cells. The serial adder of Figure 13-12 uses the same full adder cell as the parallel adder, but it receives its inputs serially and stores the carry in a flip-flop instead of propagating it from cell to cell.
Design of a Comparator
As an example, we will design a circuit which compares two n -bit binary numbers and 
determines if they are equal or which one is larger if they are not equal. Direct design as a 2 n-input combinational circuit is not practical for n larger than 4 or 5, so we will try 
the iterative approach. Designate the two binary numbers to be compared as
X=x1x2 . . . xn     and    Y=y1y2 . . . yn
We have numbered the bits from left to right, starting with x1 as the most significant 
bit because we plan to do the comparison from left to right.
FIGURE 16-5
Unilateral  
Iterative Circuit
© Cengage Learning 2014a1a2
Z1X1
Cell
1a3
Z2X2
Cell
2a4
Z3X3
Cell
3aiai + 1
ZiXi
Cell
ianan + 1
ZnXn
Cell
n... ...
554 Unit 16
Figure 16-6 shows the form of the iterative circuit, although the number of leads 
between each pair of cells is not yet known. Comparison proceeds from left to right. 
The first cell compares x1 and y1 and passes on the result of the comparison to the next 
cell, the second cell compares x2 and y2, etc. Finally, xn and yn are compared by the last 
cell, and the output circuit produces signals to indicate if X=Y, X >Y, or X<Y.
We will now design a typical cell for the comparator. To the left of cell i, three 
conditions are possible: X=Y so far (x1 x2 . . . xi–1=y1y2 . . . yi–1), X>Y so far, and 
X<Y so far. We designate these three input conditions as states S0, S1, and S2, respec-
tively. Table 16-4 shows the output state at the right of the cell (Si+1) in terms of the 
xiyi inputs and the input state at the left of the cell (Si). If the numbers are equal to 
the left of cell i and xi=yi, the numbers are still equal including cell i, so Si+1=S0. 
However, if Si=S0 and xiyi=10, then x1x2 . . . xi>y1y2 . . . yi and Si+1=S1. If X>Y 
to the left of cell i, then regardless of the values of xi and yi, x1x2 . . . xi>y1y2 . . . yi 
and Si+1=S1. Similarly, if X<Y to the left of cell i, then X<Y including the inputs 
to cell i , and Si+1=S2.FIGURE 16-6
Form of 
Iterative Circuit 
for Comparing  
Binary Numbers
© Cengage Learning 2014a1a2x1
Cell
1a3x2
Cell
2y1 y2
aiai + 1Z1(X < Y)
Z2(X = Y)
Z3(X > Y)xiyi
Cell
ixnyn
Cell
nanan + 1Output
Cir-
cuit...
b1b2 b3 bi ......
bi + 1 bnbn + 1...
The logic for a typical cell is easily derived from the state table. Because there are 
three states, two intercell signals are required. Using the guidelines from Section 15.8 leads to the state assignment a
ibi=00 for S0, 01 for S1, and 10 for S2. Substituting this 
assignment into the state table yields Table 16-5. Figure 16-7 shows the Karnaugh maps, next-state equations, and the realization of a typical cell using NAND gates. Inverters must be included in the cell because only a
i and bi and not their comple-
ments are transmitted between cells.
The a1b1 inputs to the left end cell must be 00 because we must assume that the 
numbers are equal (all 0) to the left of the most significant bit. The equations for the first cell can then be simplified if desired:
a
2=a1+x1′y1b1′=x1′y1
b2=b1+x1y1′a1′=x1y1′Si+1
Si xiyi=00 01 11 10 Z1Z2Z3
X=Y S0 S0S2 S0 S1 010
X>Y S1 S1S1 S1 S1 001
X<Y S2 S2S2 S2 S2 100TABLE 16-4
State Table for 
Comparator
ai+1bi+1
aibi xiyi=0001 11 10 Z1Z2Z3
0 0 00 10 00 01 0 1 0
0 1 01 01 01 01 0 0 1
1 0 10 10 10 10 1 0 0TABLE 16-5
Transition Table  
for Comparator© Cengage Learning 2014
© Cengage Learning 2014
Sequential Circuit Design  555
For the output circuit, let Z1=1 if X<Y, Z2=1 if X=Y, Z3=1 if X>Y. 
Figure 16-8 shows the output maps, equations, and circuit.
Conversion to a sequential circuit is straightforward. If xi and yi inputs are received 
serially instead of in parallel, Table 16-4 is interpreted as a state table for a sequen-
tial circuit, and the next-state equations are the same as in Figure 16-7 . If D flip-flops are used, the typical cell of Figure 16-7 can be used as the combinational part of the sequential circuit, and Figure 16-9 shows the resulting circuit. After all of the inputs have been read in, the output is determined from the state of the two flip-flops.FIGURE 16-7
Typical Cell  
for Comparator
© Cengage Learning 2014
xi yi
ai
biai
bi′′ai + 1
bi + 1010000 01 11 10
0000
XXXX
100aibi
ai + 1 = ai + xiyibi′ ′ bi + 1 = bi + xiyiai′ ′xiyi
01
11
10 111000100 01 11 10
1111
XXXX
000aibixiyi
01
11
10 000
FIGURE 16-8
Output Circuit  
for Comparator
© Cengage Learning 2014
(X < Y)
Z2
Z3Z1
(X = Y)
(X > Y)Z1=an + 1 Z2=a′n  +1b′n  + 1 Z3=bn + 101
1
X0bn + 1
bn + 1an + 1
an + 1101
1
X0bn + 1an + 1
101
1 X0bn + 1an + 1
1
556 Unit 16
This example indicates that the design of a unilateral iterative circuit is very 
similar to the design of a sequential circuit. The principal difference is that for the 
iterative circuit the inputs are received in parallel as a sequence in space, while for the sequential circuit the inputs are received serially as a sequence in time. For the iterative circuit, the state table specifies the output state of a typical cell in terms of its input state and primary inputs, while for the corresponding sequential circuit, the same table specifies the next state (in time) in terms of the present state and inputs. If D flip-flops are used, the typical cell for the iterative circuit can serve as the com-binational logic for the corresponding sequential circuit. If other flip-flop types are used, the input equations can be derived in the usual manner.
16.4 Design of Sequential Circuits Using  
ROMs and PLAs
A sequential circuit can easily be designed using a ROM (read-only memory) and 
 flip-flops. Referring to the general model of a Mealy sequential circuit given in Figure 13-17 , the combinational part of the sequential circuit can be realized using a ROM. The ROM can be used to realize the output functions 
(Z1, Z2, . . . , Zn) and 
the next-state functions (Q+
1, Q+
2, . . . , Q+
k). The state of the circuit can then be stored 
in a register of D flip-flops and fed back to the input of the ROM. Thus, a Mealy sequential circuit with m inputs, n outputs, and k state variables can be realized using 
k D flip-flops and a ROM with m+k inputs 
(2m+k
 words ) and n +k outputs. The 
Moore sequential circuit of Figure 13-19 can be realized in a similar manner. The next-state and output combinational subcircuits of the Moore circuit can be realized using two ROMs. Alternatively, a single ROM can be used to realize both the next-state and output functions.
Use of D flip-flops is preferable to J-K flip-flops because use of two-input  flip-flops 
would require increasing the number of outputs from the ROM. The fact that the D flip-flop input equations would generally require more gates than the J-K equations is of no consequence because the size of the ROM depends only on the number of FIGURE 16-9
Sequential 
Comparator for 
Binary Numbers
© Cengage Learning 2014
Clock
ClockDa
CKai ai + 1Z1(X < Y)
Z2(X = Y)
Z3(X > Y)xiyi
Typical Cell
(see Fig. 16-7)
biai
bi bi + 1Db
CK
Sequential Circuit Design  557
inputs and outputs and not on the complexity of the equations being realized. For 
this reason, the state assignment which is used is also of little importance, and, gener-ally, a state assignment in straight binary order is as good as any.
In Section 16.2, we realized a code converter using gates and D flip-flops. We 
will now realize this converter using a ROM and D flip-flops. The state table for the converter is reproduced in Table 16-6(a). Because there are seven states, three D flip-flops are required. Thus, a ROM with four inputs (2
4 words) and four outputs 
is required, as shown in Figure 16-10. Using a straight binary state assignment, we can construct the transition table, seen in Table 16-6(b), which gives the next state of the flip-flops as a function of the present state and input. Because we are using D flip-flops, D
1=Q+
1, D2=Q+
2, and D3=Q+
3. The truth table for the ROM, shown 
in Table 16-6(c), is easily constructed from the transition table. This table gives the ROM outputs 
(Z, D1, D2, and  D3) as functions of the ROM inputs (X, Q1, Q2, and  Q3).
Sequential circuits can also be realized using PLAs (programmable logic arrays) 
and flip-flops in a manner similar to using ROMs and flip-flops. However, in the case of PLAs, the state assignment may be important because the use of a good state 
(c) Truth Table
XQ1Q2Q3 ZD1D2D3
00 00 10 01
00 01 10 1100 10 01 0000 11 01 0101 00 11 0101 01 00 0001 10 10 0001 11 xx xx10 00 00 1010 01 01 0010 10 11 0010 11 11 0111 00 01 1011 01 10 0011 10 xx xx11 11 xx xxTABLE 16-6
(b) Transition table
Q+
1Q+
2Q+
3 Z
Q1Q2Q3X=0X=1X=0X=1
A0 0 0 001 010 1 0
B0 0 1 011 100 1 0
C0 1 0 100 100 0 1
D0 1 1 101 101 0 1
E1 0 0 101 110 1 0
H1 0 1 000 000 0 1
M1 1 0 000   – 1 –(a) State table
Present 
StateNext StatePresent 
Output (Z )
X=0 1 X=01
A B C 10
B D E 10
C E E 01
D H H 01
E H M 10
H A A 01
M A –1 –© Cengage Learning 2014
558 Unit 16
assignment can reduce the required number of product terms and, hence, reduce the 
required size of the PLA.
As an example, we will consider realizing the state table of Table 16-6(a) using 
a  PLA and three D flip-flops. The circuit configuration is the same as Figure 16-10, except that the ROM is replaced with a PLA of appropriate size. Using a straight binary assignment leads to the truth table given in Table 16-6(c). This table could be stored in a PLA with four inputs, 13 product terms, and four outputs, but this would offer little reduction in size compared with the 16-word ROM solution discussed earlier.
If the state assignment of Figure 16-2 is used, the resulting output equation and 
D flip-flop input equations, derived from the maps in Figure 16-3, are
 D
1=Q+
1=Q2′
D2=Q+
2=Q1
D3=Q+
3=Q1Q2Q3 + X′Q1Q3′ + XQ1′Q2′
  Z =X′Q3′ + XQ3 (16-1)
The PLA table which corresponds to these equations is in Table 16-7 . Realization 
of this table requires a PLA with four inputs, seven product terms, and four outputs.
X Q1Q2Q3 Z D1D2D3
– –0– 0 100
– 1–– 0 010– 111 0 0010 1–0 0 0011 00– 0 0010 ––0 1 0001 ––1 1 000FIGURE 16-10
Realization of  
Table 16-6(a)  
Using a ROM
© Cengage Learning 2014
ClockD1
CKQ1
Q1Z
Q2
Q2
Q3
Q3++
+ ROM
16 Words
×4 BitsD2
CKX
D3
CK
TABLE 16-7
© Cengage Learning 2014
Sequential Circuit Design  559
Next, we will verify the operation of the circuit of Figure 16-4 using a PLA 
which corresponds to Table 16-7 . Initially, assume that X=0 and Q1Q2Q3=000.  
This selects rows --0- and 0--0 in the table, so Z=1 and D1D2D3=100. After the 
active clock edge, Q1Q2Q3=100. If the next input is X=1, then rows --0- and -1 -- 
are selected, so Z =0 and D1D2D3=110. After the active clock edge, Q1Q2Q3=110. 
Continuing in this manner, we can verify the transition table of Figure 16-2.
PALs also provide a convenient way of realizing sequential circuits. PALs are 
available which contain D flip-flops that have their inputs driven from programma-
ble array logic. Figure 16-11 shows a segment of a sequential PAL. The D flip-flop is driven from an OR gate which is fed by two AND gates. The flip-flop output is fed back to the programmable AND array through a buffer. Thus, the AND gate inputs can be connected to 
A, A ′, B, B′ , Q, or Q ′. The X’s on the diagram show the connec-
tions required to realize the next-state equation
Q+=D =A′BQ ′+AB ′Q
The flip-flop output is connected to an inverting tri-state buffer, which is enabled when En =1.
FIGURE 16-11
Segment of  
a Sequential PAL
© Cengage Learning 2014ClockEn
DQ
Q′Q′
Q′
QQ′ A
AA′B
BB′ Q
Inverting
Tri-State
Output
Buffer
Programmable AND Array
16.5 Sequential Circuit Design Using CPLDs
As discussed in Section 9.7 , a typical CPLD contains a number of macrocells that are grouped into function blocks. Connections between the function blocks are made through an interconnection array. Each macrocell contains a flip-flop and an OR gate, which has its inputs connected to an AND gate array. Some CPLDs are based on PALs, in which case each OR gate has a fixed set of AND gates associated with it. Other CPLDs are based on PLAs, in which case any AND gate output within a function block can be connected to any OR gate input in that block.
Figure 16-12 shows the structure of a Xilinx CoolRunner II CPLD, which uses a 
PLA in each function block. This CPLD family is available in sizes from two to 32 function blocks (32 to 512 macrocells). Each function block has 16 inputs from the AIM (advanced interconnection matrix) and up to 40 outputs to the AIM. Each function block PLA contains the equivalent of 56 AND gates.
560 Unit 16
FIGURE 16-12 CoolRunner-II Architecture1 (Figure based on figures and text owned by Xilinx, Inc., Courtesy 
of Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
1Additional data on Xilinx CPLDs and FPGAs is available from www.Xilinx.com.Function
Block 1Function
Block n
PLA PLAI/O Blocks
I/O Blocks16 16
40 4016 FB 16 FB
16 16I/O Pin MC1
MC2
MC16MC1MC2
MC16AIMI/O Pin
I/O Pin
Fast Inputs
BSC and ISPClock and Control SignalsBSC Path
Fast InputsI/O PinI/O Pin
I/O Pin
JTAG
The basic CoolRunner II architecture is similar to that shown in Figure 9-33. 
Figure 16-13 represents a CoolRunner-II macrocell and the associated AND array. 
Box (1) represents the AND array which is driven by signals from the AIM. Each of the 56 product terms (P-terms) generated by the AND array (2) can have up to 40 variables. Box (3) represents the OR array which selects the AND gates for each macrocell. The OR gate (4) in a specific macrocell can have any subset of the P-terms as inputs. The MUXes on the diagram do not have control inputs shown because each MUX is programmed to select one of its inputs. For example, MUX (5) can be programmed to select a product term, the complement of a product term, a logic 1, or a logic 0 for the MUX output. If logic 1 is selected, the XOR gate complements the OR gate output; if logic 0 is selected, the XOR gate passes the OR gate output without change. By complementing or not complementing the OR gate output, a function can be implemented as either a product of sums or as a sum of products.
The XOR gate output can be routed directly to an I/O block or to the macrocell 
flip-flop input. The flip-flop can be programmed as a D-CE flip-flop or as a T flip-flop. The flip-flop can be programmed as an ordinary flip-flop (F/F), a latch, or a dual-edge triggered flip-flop, which can change state on either clock edge. The CK input and the asynchronous 
S and R  inputs can each be programmed to come from several 
different sources. MUX (6) can invert the clock input or not, so that the flip-flop can trigger on either clock edge. MUX (7) selects either the flip-flop output or the XOR gate output and passes it to an I/O block.
Figure 16-14 shows how a Mealy sequential machine with two inputs, two outputs, 
and two flip-flops can be implemented by a CPLD. Four macrocells are required, two 
Sequential Circuit Design  561
to generate the D inputs to the flip-flops and two to generate the Z outputs. The 
 flip-flop outputs are fed back to the AND array inputs via the interconnection matrix 
(not shown). The number of product terms required depends on the  complexity of the equations for the D ’s and the 
Z’s.
Figure 16-15 shows how the 4-bit loadable right-shift register of Figure 12-16 can be 
implemented using four macrocells of a CPLD. The four OR-gate outputs implement the D inputs specified by Equations (12-1). A total of 12 product terms are required. The 
Q outputs are fed back to the AND array via the interconnection matrix (not shown).FIGURE 16-14
CPLD 
Implementation  
of a Mealy  
Machine
© Cengage Learning 2014FFFF
AND
ArrayX1X2
Q1Macrocells
Q2
Z1
Z2D1
D2FIGURE 16-13 CoolRunner-II Macrocell (Figure based on figures and text owned by Xilinx, Inc., Courtesy of 
Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
GCK0
GCK1
GCK2CTCPTC
PTC49 P-termsTo PTA, PTB, PTC of 
other macrocells
CTC, CTR,
CTS, CTEFrom AIM
4 P-terms
PTAFast Input
from
I/O BlockFeedback
to AIM
PTB
PTC
PLA OR TermPTA
CTS
GSR
GND
GNDVCC
RD/T
CE
CKF/F
LatchDualEDGEQS40
To I/O Block
PTA
CTR
GSR
GND(1)2
222
2
(3)
45
67
562 Unit 16
Figure 16-16 shows how three bits of the parallel adder with accumulator of 
Figure 12-5 can be implemented using a CPLD. Each bit of the adder requires two 
macrocells. One of the macrocells implements the sum function and an accumulator flip-flop. The other macrocell implements the carry, which is fed back into the AND array. The 
Ad signal can be connected to the CE input of each flip-flop via an AND 
gate (not shown). Each bit of the adder requires eight product terms (four for the sum, three for the carry, and one for CE). If the flip-flops are programmed as T  flip-flops, then the logic for the sum can be simplified. For each accumulator flip-flop
X+
i=Xi  ⊕ Yi  ⊕ Ci
Then, the T input is
Ti=X+
i  ⊕   Xi=Yi  ⊕   Ci
which requires only two product terms.FIGURE 16-15
CPLD 
Implementation  
of a Shift Register
© Cengage Learning 2014
FFFF
FF
FFAND
ArraySI
D3
D2
D1
D0
Sh
LdQ3
Q1
Q0Macrocells
Q2
FIGURE 16-16
CPLD 
Implementation  
of a Parallel  
Adder with 
Accumulator
© Cengage Learning 2014S0
S1
S2FF
FF
FFAND
ArrayC0C1
X0
C2
X1
C3
X2Y0
Y1
Y2
Sequential Circuit Design  563
The add signal can be ANDed with the Ti input so that the flip-flop state can change 
only when Ad=1:
Ti=Ad (Yi ⊕ Ci)=Ad Yi Ci ′+Ad Yi ′ Ci
16.6 Sequential Circuit Design Using FPGAs
As discussed in Section 9.8, an FPGA usually consists of an array of configurable 
logic blocks (CLBs) surrounded by a ring of I/O blocks. The FPGA may also contain other components such as memory blocks, clock generators, tri-state buffers, etc. A typical CLB contains two or more function generators, often referred to as look-up tables or LUTs, programmable multiplexers, and D-CE flip-flops (see Figure 9-37). The I/O blocks usually contain additional flip-flops for storing inputs or outputs and tri-state buffers for driving the I/O pins.
Figure 16-17 shows a simplified block diagram for a Xilinx Virtex or Spartan II CLB. 
This CLB is divided into two nearly identical slices. Each slice contains two 4-variable 
function generators (LUTs), two D-CE flip-flops, and additional logic for carry and control. This additional logic includes MUXes for selecting the flip-flop inputs and for multiplexing the LUT outputs to form functions of five or more variables.
Figure 16-18 shows how a Mealy sequential machine with two inputs, two out-
puts, and two flip-flops can be implemented by a FPGA. Four LUTs (FGs or func-tion generators) are required, two to generate the D inputs to the flip-flops and two 
to generate the 
Z outputs. The flip-flop outputs are fed back to the CLB inputs via 
interconnections external to the CLB. The entire circuit fits into one Virtex CLB. This implementation works because each D and 
Z is a function of only four variables 
FIGURE 16-17
Xilinx Virtex/
Spartan II CLB 
(Figure based on 
figures and text 
owned by Xilinx, 
Inc., Courtesy of 
Xilinx, Inc. © Xilinx, 
Inc. 1999–2003. All 
rights reserved.)
F1F2F3F4G1G2G3G4
Carry &
ControlCarry &
Control
Carry &
ControlCarry &
ControlLUT
CIN CINCOUT COUT
YQ
XQ XQYQ
XXBYYB YB
Y
BXBY
BXBYG1G2G3G4
F1F2F3F4
Slice 1 Slice 0XB
X
LUT LUTLUT D
CEQ
RCSP
DCEQ
RCSPDCEQ
RCSP
DCEQ
RCSP
564 Unit 16
(X1, X2, Q1, and  Q2). If more flip-flops or inputs are needed, the D or Z functions 
may have to be decomposed to use additional function generators as in Figure 9-40.
Figure 16-19 shows how the 4-bit loadable right-shift register of Figure 12-16 can 
be implemented using an FPGA. Four LUTs are used to generate the D inputs to 
the flip-flops, and a fifth LUT generates the CE input. If we had implemented Equa-
tions (12-1) directly without using the CE input, we would need to implement four 5-variable functions. This would require eight LUTs because each 5-variable func-tion requires two 4-variable function generators (see Figure 9-40(a)). However, if we set CE =Ld +Sh, then 
CE=0 when Ld =Sh=0 and the flip-flops hold their 
current values. Therefore, we do not need the first term in each of Equations (12-1), and the flip-flop D input equations fit into 4-variable function generators. We can 
rewrite Equation (12-1(a)) in terms of CE as follows:
 Q
+
3=CE′Q3+CE D3f=Ld′Sh′Q3 +(Ld +Sh)(Sh′D3+Sh  SI) (16-2)
where D3f is the D input to flip-flop 3. The D input to the Q3 flip-flop is therefore
D3f=Sh′D3+Sh  SI
FIGURE 16-19
FPGA 
Implementation  
of a Shift Register
© Cengage Learning 2014CE CE DDDD CE CE
FG4
D3ShSI D2Q3 Q2 Q1 Q0
D1 D0CKFF FF FF FF
CK CK CK
FG3 FG2 FG1 FG0
LdFIGURE 16-18
FPGA 
Implementation  
of a Mealy  
Machine
© Cengage Learning 2014X1
Q1 D1
CK FF
CE
CE 11FG1
Q2
Z1X2
Z2D2
CK FFFG2
FG3
FG4
Sequential Circuit Design  565
which is a 3-variable function. We can determine the other three flip-flop D inputs 
in a similar way.
Figure 16-20 shows how three bits of the parallel adder with accumulator of 
Figure 12-5 can be implemented using an FPGA. Each bit of the adder can be imple-
mented with two 3-variable function generators, one for the sum and one for the carry. The 
Ad signal can be connected to the CE input of each flip-flop so that the 
sum is loaded by the rising clock edge when Ad=1. The arrangement for generating 
the carries, shown in Figure 16-20, is rather slow because the carry signal must propa-gate through a function generator and its external interconnections for each bit. Because adders are frequently used in FPGAs, most FPGAs have built-in fast carry logic in addition to the function generators. If the fast carry logic is used, the bottom row of function generators in Figure 16-20 is not needed, and a parallel adder with an accumulator can be implemented using only one function generator for each bit.
16.7 Simulation and Testing of Sequential Circuits
Simulation of a digital system can take place at several levels of detail. At the func-tional level, system operation is described in terms of a sequence of transfers between registers, adders, memories, and other functional units. Simulation at this level may be used to verify the high-level system design. At the logic level, the system is described in terms of logic elements such as gates and flip-flops and their interconnections. Logic level simulation may be used to verify the correctness of the logic design and to ana-lyze the timing. At the circuit level, each gate is described in terms of its circuit com-ponents such as transistors, resistances, and capacitances. Circuit level simulation gives detailed information about voltage levels and switching speeds. In this text, we will consider simulation at the logic level as well as system level simulation using VHDL.
Simulation of sequential circuits is similar to the simulation of combinational 
circuits described in Section 8.5. However, for sequential circuits, the propagation delays associated with the individual logic elements must be taken into account, FIGURE 16-20
FPGA 
Implementation 
of a Parallel Adder 
with Accumulator
© Cengage Learning 2014CE CE DD D CE
C1 C2S2 S1 S0
C3
Y0 Y1 Y2X2 X1 X0
C0(Cin)CKFF FF FF
CK CK
Ad
FG3a
FG2b FG3b FG1bFG2a FG1a
566 Unit 16
and the presence of feedback may cause complications. The simulator output usu-
ally includes timing diagrams which show the times at which different signals in the circuit change. The delays in the gates and flip-flops may be modeled in several ways. The simplest method is to assume that each element has one unit of delay. The use of this unit delay model is generally sufficient to verify that the design is logically correct. If a more detailed timing analysis is required, each logic element may be assigned a nominal delay value. The nominal or typical delays for a device are usu-ally provided by the device manufacturer on the specification sheets.
In practice, no two gates of a given type will have exactly the same delay, and 
the value of the delay may change depending on temperature and voltage levels. For these reasons, manufacturers often specify a minimum and maximum delay value for each type of logic element. Some simulators can take the minimum and maximum delay values into account. Instead of showing the exact time at which a signal changes, the simulator output indicates a time interval in which the signal may change. Figure 16-21 shows the output from an inverter which has a nominal delay of 10
 ns, a minimum delay of 5  ns, and a maximum delay of 15  ns. The shaded 
region indicates that the inverter output may change at any time during the interval.  Min-max delay simulators can be used to verify that a digital system will operate correctly as long as the delay in each element is within its specified range.
Testing of sequential circuits is generally more difficult than testing combina-
tional circuits. If the flip-flop outputs can be observed, then the state table can be verified directly on a row-by-row basis. The state table can be checked out with a simulator or in lab as follows:
1. Using the direct set and clear inputs, set the flip-flop states to correspond to one 
of the present states in the table.
2. For a Moore machine, check to see that the output is correct. For a Mealy machine, check to see that the output is correct for each input combination.
3. For each input combination, clock the circuit and check to see that the next state of the flip-flops is correct. (Reset the circuit to the proper state before each input combination is applied.)
4. Repeat steps 1, 2, and 3 for each of the present states in the table.
In many cases when a sequential circuit is implemented as part of an integrated 
circuit, only the inputs and outputs are available at the IC pins, and observing the state of the internal flip-flops is impossible. In this case, testing must be done by apply-ing input sequences to the circuit and observing the output sequences. Determining a small set of input sequences which will completely test the circuit is generally a 
FIGURE 16-21
Simulator Output 
for an Inverter
© Cengage Learning 2014 AAB
Nominal Delay B
Min-Max Delay B
0 1 02 03 04 05 06 0 t (ns)
Sequential Circuit Design  567
difficult problem that is beyond the scope of this text. The set of test sequences must 
traverse all arcs on the state graph, but this is generally not a sufficient test.
Figure 16-22 shows a simulator screen for testing the Mealy sequential circuit of 
Figure 13-7 . To step through the circuit one input at a time, switches are used for the Clock and 
X inputs. Another switch is used to reset both flip-flops, and two switches 
are used to set flip-flops A and B. Probes are used to observe the Z output and the 
state of the flip-flops. After X has been set to the desired value, the clock cycle is 
simulated by flipping the Clock switch to 1 and back to 0. For a Mealy machine, the output should be read just before the active edge of the clock.
If an incorrect 
Z output is found in the process of verifying the state table, the out-
put circuit can be checked using the techniques discussed in Section 8.5. If one of the next states is wrong, this may be due to an incorrect flip-flop input. After determining which flip-flop goes to the wrong state, the circuit should be reset to the proper present state, and the flip-flop inputs should be checked before applying another clock pulse.
Assume that you have built the circuit of Figure 16-4 to implement the state table of Figure 16-2. Suppose that when you set the flip-flop states to 100, set 
X=1, and pulse 
the clock, the circuit goes to state 111 instead of 110. This indicates that  flip-flop Q3 
went to the wrong state. You should then reset the flip-flops to state 100 and observe the inputs to flip-flop Q
3. Because the flip-flop is supposed to remain in state 0, D3 
should be 0. If D3=1, this indicates that either D3 was derived wrong or that the 
D3 circuit has a problem. Check the D3 map and equation to make sure that D3=0 
when X=1 and Q1Q2Q3=100. If the map and equation are correct, then the D3 
circuit should be checked using the procedure in Section 8.5.FIGURE 16-22
Simulation Screen 
for Figure 13-7
© Cengage Learning 2014Clock
Example
568 Unit 16
After you have verified that the circuit works according to your state table, you 
must then check the circuit to verify that it works according to the problem statement. 
To do this, you must apply appropriate input sequences and observe the resulting out-put sequence. When testing a Mealy circuit, you must be careful to read the outputs at the proper time to avoid reading false outputs (see Section 13.2). The output should be read just before the active edge of the clock. If the output is read immediately follow-ing the active clock edge, a false output may be read. See Figure 13-8 for an example.
Instead of manually stepping through the input sequence, simulated input wave-
forms may be defined for 
X and Clock. Figure 16-23 shows the simulator input wave-
form for the example of Figure 16-22, using the test sequence X=10101. When the 
simulator is run, the timing chart for A, B, and Z will be generated as shown. Note 
that the simulator output is very similar to the timing chart of Figure 13-8. The simu-lator output in Figure 16-23(a) assumes the unit delay model, that is, each gate or flip-flop has one unit of delay. Figure 16-23(b) shows the same simulation using a nominal delay of 10 ns for each gate and flip-flop.
So far in our discussion of sequential circuits, we have assumed that the inputs 
are properly synchronized with the clock. This means that one input in the sequence occurs for each clock cycle, and all input changes satisfy setup and hold time speci-fications. Synchronization is no problem in the laboratory if we use a manual clock because we can easily change the inputs between active clock edges. However, if we operate our circuits at a high clock rate, then synchronization becomes a problem. We must either generate our input sequences in synchronization with the clock, or we must use a special circuit to synchronize the inputs with the clock. The former can 
X
Clock
A
B
Z200 400
(a) Simulator output with a unit delay model
X
Clock
A
B
Z200 400
(b) Simulator output with a nominal delay of 10 nsFIGURE 16-23
© Cengage Learning 2014
Sequential Circuit Design  569
be accomplished by loading the inputs into a shift register, and then using the circuit 
clock to shift them into the circuit one at a time, as shown in Figure 16-24.
If the input changes are not synchronized with the clock, edge-triggered D flip-
flops can be used to synchronize them, as shown in Figure 16-25(a). In this figure, although 
X1 and X2 change at arbitrary times with respect to the clock, X1S and X2S 
change after the rising clock edge, and the inputs to the sequential circuit should be properly synchronized, as shown in Figure 16-25(b). However, this design has an inherent problem and may occasionally fail to operate properly. If a D input changes 
very close to the rising clock edge so that setup and hold times are not satisfied (see Figure 11 -20), one of the flip-flops may malfunction.
Figure 16-26 shows a more reliable synchronizer
2 that uses two D flip-flops to syn-
chronize a single asynchronous input, X. If X changes from 0 to 1 in the critical region 
where the setup or hold time is not satisfied, several outcomes could occur: the flip-flop Q
1 output might change to 1; it might remain 0; it might start to change to 1 and then 
change back or it might oscillate between 0 and 1 for a short time and then settle down to 0 or 1. This region of uncertainty is indicated by the shading on the Q
1 waveform. We 
will assume that the clock period is chosen so that Q1 will be settled in either the 0 or 
1 state by t2. If Q1=1, Q2 will change to 1 shortly after t2. If Q1=0, Q1 will change to 
1 shortly after t2, and Q2 will change to 1 shortly after t3. Because X is an asynchronous 
input, normally it will not matter whether X1S is delayed by one or two clock periods. 
The important thing is that X1S is a clean signal that is synchronized with the clock.
2For more detailed discussion of synchronizer design, see John F. Wakerly. Digital Design Design Principles 
and Practices, 4th ed. Upper Saddle River, NJ (Prentice Hall, 2006).FIGURE 16-24
Using a Shift 
Register to 
Generate 
Synchronized 
Inputs
© Cengage Learning 20140 1 1 0 0 1 0 1 1 1Synchronous
Sequential
Circuit
Clock
InputShift
Clock
ClockX
X1
X2
X1S
X2SDSynchronous
Sequential
Circuit
Clock
Input
ClockClockX1
X1S
X2SX2D
(a) Synchronizer circuit (b) Synchronizer inputs and outputsFIGURE 16-25
© Cengage Learning 2014
570 Unit 16
16.8 Overview of Computer-Aided Design
A wide variety of computer-aided design (CAD) software tools are available to 
assist in the design of digital systems. Many of these CAD programs will run on a personal computer, but others require a more powerful workstation for execution. Several functions performed by these CAD tools are discussed below.
Generation and minimization of logic equations . Programs of this type accept truth 
tables, state tables, or state graphs as input and generate minimized logic equations. 
LogicAid is an example of this type of program.
Generation of bit patterns for programming PLDs . These programs generate a file 
which can be downloaded to a PLD programmer to program PALs and other pro-
grammable logic devices.
Schematic capture. This type of program allows the designer to interactively enter 
and edit a logic diagram for a digital design. The program provides libraries of stand-ard logic components such as gates, flip-flops, registers, adders, counters, etc., which can be selected for inclusion in the diagram. In addition to a plot of the logic dia-gram, the output from a schematic capture program may include a parts list, a list of interconnections between the ICs, and a circuit description file. This file may be used as input to a simulator, PC board layout program, or other CAD programs.
Simulation. We have already discussed several types of simulators in Sections 10.3 and 
16.5. By using such simulators at various points in the design process, designers can correct many errors and resolve critical timing problems before any hardware is actu-ally built. Use of a simulator is essential when an IC is being designed, because the correction of design errors after the IC has been fabricated is very time-consuming and costly.FIGURE 16-26
Synchronizer with 
Two D Flip-Flops
© Cengage Learning 2014
Q1
t1 t2 t3X1S = Q2X1SX
XD1Q1Synchronous
Sequential
Circuit
Clock
InputClock
01
0
ClockCKD2Q2
CK
Sequential Circuit Design  571
SimUaid performs the schematic capture and simulation functions for small digi-
tal systems. It also automatically generates a structural VHDL description from the schematic.
Synthesis tools. Synthesis software accepts as input a description of a desired digital 
system written in VHDL, Verilog, or another hardware description language. The HDL code is analyzed and translated into a circuit description that specifies the needed logic components and the connections between these components. The syn-thesizer output is then fed into software that implements the circuit for a specific target device such as an FPGA, CPLD, or ASIC (application-specific integrated circuit). More details of synthesis and implementation of VHDL code are given in Section 17 .5.
IC design and layout . A digital integrated circuit is typically composed of intercon-
nected transistors which are fabricated on a chip of silicon. Such ICs are usually 
made of several layers of conducting material separated by layers of insulating mate-rial with appropriate connections between layers. The patterns for paths on each layer are transferred into the layers during the fabrication process using masks which are similar to photographic negatives. CAD tools for IC design facilitate the process of specifying the geometries of the transistors, placing the transistors on the chip, and routing the interconnections between them. Libraries of standard modules are available for inclusion in the chip designs. Automatic checking of the designs is provided to verify consistency with design rules. The output from the IC design pro-gram includes the mask patterns necessary for fabricating the IC.
Test generation. As digital systems become more complex, testing the finished prod-
uct becomes increasingly difficult. It is not practical to test the system using all pos-sible combinations or sequences of inputs. Automatic test generation programs are available which attempt to generate a relatively small set of input patterns that will adequately test the system in a reasonable length of time.
PC board layout . Most digital systems are built by mounting the integrated circuit 
components on a printed circuit board. The wiring on such PC boards is made up of 
thin metallic strips which interconnect the ICs. In order to make all of the required connections, these boards typically have two, three, or more layers of interconnect wiring. PC board layout programs perform two main functions—they determine the placement of the ICs on the board, and they route the connections between the ICs. The output of the layout program includes a set of plots which show the wiring on each layer of the PC board.
Many CAD systems integrate several of these CAD tools into a single package 
so that you can, for example, input a logic diagram, simulate its operation, and then lay out a PC board or IC. The design of large, complex integrated circuits and digital systems would not be feasible without the use of appropriate CAD tools.
One method of designing a small digital system with an FPGA uses the following 
steps:
1. Draw a block diagram of the digital system. Define the required control signals 
and construct a state graph that describes the required sequence of operations.
2. Work out a detailed logic design of the system using gates, flip-flops, registers, counters, adders, etc.
572 Unit 16
3. Construct a logic diagram of the system, using a schematic capture program.
4. Simulate and debug the logic diagram and make any necessary corrections to 
the design.
5. Run an implementation program that fits the design into the target FPGA. This program carries out the following steps:
(a) Partition the logic diagram into pieces that will fit into CLBs of the target 
FPGA.
(b) Place the CLBs within the logic cell array of the FPGA and route the con-
nections between the logic cells.
(c) Generate the bit pattern necessary to program the FPGA.
6. Run a timing simulation of the completed design to verify that it meets specifica-tions. Make any necessary corrections and repeat the process as necessary.
7. Download the bit pattern into the internal configuration memory cells in the FPGA and test the operation of the FPGA.
When a hardware description language is used, steps 2 and 3 are replaced with writ-ing HDL code. The HDL code is then simulated and debugged in step 4.
Design Problems
The following problems require the design of a Mealy sequential circuit of the form shown in Figure 16-27 . For purposes of testing, the input 
X will come from a toggle 
switch, and the clock pulse will be supplied manually from a push button or switch.
X(From Toggle
Switch)
Manual ClockCircuit
to Be
DesignedZFIGURE 16-27
16.1 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence 
X and will produce an output of Z =1 for any input sequence ending in 0010 or 100.
Example:
 X =1  1  0  0  1  0  0  1  0  1  0  0  1  0  1
Z =0  0  0  1  0  1  1  0  1  0  0  1  0  1  0
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with a method for manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses 10 or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, © Cengage Learning 2014
Sequential Circuit Design  573
starting in the proper initial state, determine the output sequence for each of the 
following input sequences:
( 1 )001101001010100010010010
( 2 )110011001010100101010010
16.2 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence 
X and will produce an output of Z =1 for any input sequence ending in 1101 or 011.
Example:
 X =0  0  1  1  0  1  1  0  1  0  1  1  0  1  0
Z =0  0  0  1  0  1  1  0  1  0  0  1  0  1  0
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with 
a method for manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses nine or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for each of the following input sequences:
( 1 )110010110101011101101101
( 2 )001100110101011010101101
16.3 Design a sequential circuit (Figure 16-27) to convert excess-3 code to BCD code. 
The input and output should be serial with the least significant bit first. The input 
X 
represents an excess-3 coded decimal digit, and the output Z represents the corre-
sponding BCD code. Design your circuit using three D flip-flops, NAND gates, and 
NOR gates. Any solution which is minimal for your state assignment and uses eight or fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the reset state, determine the output sequence for each of the ten possible input sequences and make a table.
16.4 Design a sequential circuit (Figure 16-27) which adds six to a binary number in the 
range 0000 thr ough 1001. The input and output should be serial with the least signifi-
cant bit first. Find a state table with a minimum number of states. Design the circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is mini-mal for your state assignment and uses 10 or fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, 
574 Unit 16
starting in the reset state, determine the output sequence for each of the ten possible 
input sequences and make a table.
16.5 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence 
X and will produce an output of Z =1 for any input sequence ending in 0110 or 101.
Example:
 X =0  1  0  1  1  0  1
Z =0  0  0  1  0  1  1
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with a method for manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses eight or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for each of the following input sequences:
( 1 )0011011110010100
( 2 )1010001111011000
16.6 Design a Mealy sequential circuit which investigates an input sequence 
X and which 
will produce an output of Z =1 for any input sequence ending in 0101 provided that 
the sequence 110 has never occurred.
Example:
 X =0  1  0  1  0  1  1  0  1  0  1
Z =0  0  0  1  0  1  0  0  0  0  0
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with 
a method for manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses eight or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for the following input sequences:
(1)  X =0  1  0  1  0  0  0  1  0  1  1  0
(2)  X =1  0  1  0  1  0  1  1  0  1  0  1
16.7 Design a Mealy sequential circuit which investigates an input sequence 
X and which 
will produce an output of Z =1 if the total number of 1’s received is even (consider 
Sequential Circuit Design  575
zero 1’s to be an even number of 1’s) and the sequence 00 has occurred at least once. 
Note: The total number of 1’s received includes those received before and after 00.
Example:
 X =1  0  1  0  1  0  0  1  1  0  1
Z =0  0  0  0  0  0  0  1  0  0  1
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with 
a method of manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses 12 or fewer gates and inverters is acceptable; the best known solution uses seven. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for each of the following input sequences:
(1)  X =0  1  1  0  0  1  0  1  0  0
(2)  X =1  0  1  1  1  1  0  0  1  1  1  0
16.8 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence 
X and will produce an output of Z =1 for any input sequence ending in 0011 or 110.
Example:
 X =1  0  1  0  0  1  1  0  0  1  1
Z =0  0  0  0  0  0  1  1  0  0  1
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with a method for manually resetting the flip-flops to the start state. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses 10 or fewer gates and inverters is acceptable; the best known solution uses six. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the reset state, determine the output sequence for each of the following input sequences:
(1)  X =0  0  0  1  0  0  0  1  1  0  1  0
(2)  X =1  1  1  0  0  1  0  0  0  1  1  0
16.9 Design a Mealy sequential circuit which investigates an input sequence 
X and pro-
duces an output Z which is determined by two rules. The initial output from the 
circuit is Z =0. Thereafter, the output Z will equal the preceding value of X (rule 1) 
until the input sequence 001 occurs. Starting with the next input after 001, the out-put 
Z will equal the complement of the present value of X (rule 2) until the sequence 
576 Unit 16
100 occurs. Starting with the next input after 100, the circuit output is again deter-
mined by rule 1, etc. Note that overlapping 001 and 100 sequences may occur.
Example:
 Rule:  1  1  1  1  2  2  2  2  2  1  1  2
     X =1  0  0  1  1  0  1  0  0  0  1  1
     Z =0  1  0  0  0  1  0  1  1  0  0  0
Design your circuit using NAND gates, NOR gates, and three D flip-flops. Your 
circuit should be provided with a method for manually resetting the flip-flops to the 
start state. A minimum solution requires six states. Any solution which is minimal for your state assignment and uses 12 or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the reset state, determine the output sequence for each of the following input sequences:
(1)  X =1  0  0  1  0  0  1  0  0  0  1  1
(2)  X =0  1  1  0  0  0  0  1  1  0  1  1
16.10 The 8, 4,
 –2,  –1 BCD code is similar to the 8-4-2-1 BCD code, except that the weights 
are negative for the two least significant bit positions. For example, 0111 in 8,  4, −2,  −1 
code represents
8×0+4×1+(−2)×1+(−1)×1 = 1
Design a Mealy sequential circuit to convert 8,  4, –2,  –1 code to 8-4-2-1 code. The 
input and output should be serial with the least significant bit first. The input X repre-
sents an 8,  4, –2,  –1 coded decimal digit and the output Z represents the corresponding 
8-4-2-1 BCD code. After four time steps the circuit should reset to the starting state regardless of the input sequence. Design your circuit using three D flip-flops, NAND gates, and NOR gates. Any solution which is minimal for your state assignment and uses eight or fewer gates is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and next state are correct for each input. Then, starting in the reset state, determine the output sequence for each of the 10 possible input sequences and make a table.
16.11 Design a Mealy sequential circuit (Figure 16-27) which adds five to a binary number 
in the range 0000 thr ough 1010. The input and output should be serial with the least 
significant bit first. Find a state table with a minimum number of states. Design the circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses nine or fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and the next state are correct for each input. 
Sequential Circuit Design  577
Then, starting in the reset state, determine the output sequence for each of the 11 
possible input sequences and make a table.
16.12 Design a Mealy sequential circuit (Figure 16-27) to convert a 4-bit binary number 
in the range 0000 thr ough 1010 to its 10’s complement. (The 10’s complement of a 
number N is defined as 10 −N.) The input and output should be serial with the least 
significant bit first. The input X represents the 4-bit binary number, and the output 
Z represents the corresponding 10’s complement. After four time steps, the circuit 
should reset to the starting state regardless of the input sequence. Find a state table with a minimum number of states. Design the circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses nine or fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and the next state are correct for each input. Then, starting in the reset state, determine the output sequence for each of the 11 possible input sequences and make a table.
16.13 Design a Mealy sequential circuit which investigates an input sequence 
X and which 
will produce an output of Z =1 for any input sequence ending in 1010, provided 
that the sequence 001 has occurred at least once.
Example:
 X =1  0  1  0  0  1  0  1  0  1  0
Z =0  0  0  0  0  0  0  0  1  0  1
Notice that the circuit does not reset to the start state when an output of Z =1 
occurs. However, your circuit should have a start state and should be provided with 
a method of manually resetting the flip-flops to the start state. A minimum solution requires six states. Design your circuit using NAND gates, NOR gates, and three D flip-flops. Any solution which is minimal for your state assignment and uses nine or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and the next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for the fol-lowing input sequences:
(1)  X =1  0  0  1  0  0  1  1  0  1  0  1
(2)  X =1  0  1  0  0  0  1  0  1  0  1  0
16.14 Design a Mealy sequential circuit which investigates an input sequence 
X and will 
produce an output of Z =1 whenever the total number of 0’s in the sequence is odd, 
provided that the sequence 01 has occurred at least once.
Example:
 X =1  1  0  0  0  1  1  0  1  0
Z =0  0  0  0  0  1  1  0  0  1
578 Unit 16
A minimum solution requires five states. Design your circuit using NAND gates, 
NOR gates, and three D flip-flops. Your circuit should have a start state and should 
be provided with a method of manually resetting the flip-flops to the start state. Any solution which is minimal for your state assignment and which uses 11 or fewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and 
making sure that the present output and the next state are correct for each input. Then, starting in the proper initial state, determine the output sequence for the fol-lowing input sequences:
(1)  X =1  0  0  0  1  1  0  1  0  0  1
(2)  X =0  0  0  0  1  0  1  0  0  0  1
Additional Problems
16.15 Draw a block diagram that shows how a ROM and D flip-flops could be connected 
to realize Table 13-4 (p. 430). Specify the truth table for the ROM using a straight binary state assignment. (Note that a truth table, not a transition table, is to be  specified.)
16.16 The state table of Figure 15-15(a) is to be realized using a PLA and D flip-flops.
(a) Draw a block diagram.
(b) Specify the contents of the PLA in tabular form using the state assignment of 
Figure 15-15(a). (See Figure 15-16(b) for the D  equations.)
16.17 An iterative circuit has a form similar to Figure 16-6. The output 
Z is to be 1 if the 
total number of X inputs that are 1 is an odd number greater than 2.
(a) Draw a state graph for a typical cell.
(b) Derive the equations and a NAND-gate circuit for a typical cell and for the output 
circuit.
(c) Specify a1 and b1, and simplify the first cell.
(d) Show how a sequential circuit can be constructed using the typical cell and output 
circuit.
16.18 In the iterative circuit below the input X is a 2’s complement number and the output 
Y is the 2’s complement of X. (x0 and y0 are the least significant bits.)
(a) Construct a transition table for typical cell. (Note that a0 is 0.)
(b) Derive expressions for ai +1 and yi.
(c) Construct a sequential circuit that will compute the 2’s complement of its input. 
(Use D flip-flops. Assume the flip-flops are reset at the beginning of an input sequence.)
Sequential Circuit Design  579
16.19 The iterative circuit below compares two positive, unsigned binary numbers X  =
xn–1 . . . x1x0 and Y =yn–1 . . .  y1y0. The numbers are compared from right to left (i.e., 
least significant bits to most significant bits).
(a) Derive the transition table for a typical cell, cell i, so that anbn=00 if 
X =Y, anbn=01 if X >Y, and anbn=10 if X <Y.
(b) Derive minimum sum-of-product expressions for ai+1 and bi+1.Cell
n−1xn−1
yn−1an an−1 Cell
n−2xn−2
yn−2an−2... ...ai+1 Cell
ixi
yiai a1 Cell
0x0
y0a0=0
16.20 Modify the binary comparator of Figure 16-6 so it will compare 2’s complement num-
bers. Let a1=x1 and b1=y1. Note that all four combinations of ai and bi are used; 00 
indicates that X and Y are positive and equal, 11 indicates that X and Y are negative and 
equal, 01 indicates X >Y, and 10 indicates X <Y. (For negative numbers, –2 >–3.)
(a) Derive the transition table for this comparator similar to Table 16-5.
(b) Derive minimal sum-of-product expressions for ai+1 and bi+1.
(c) Derive a circuit for Z1, Z2, and Z3.
(d) Derive a state table for a sequential circuit that compares 2’s complement num-
bers and produces the outputs Z1, Z2, and Z3 using the transition table of part (a)  
as a guideline. Note that the circuit will require a distinct initial state since  
a1 and b1 depend upon x1 and y1.
16.21 Design a sequential circuit having one input and one output that will produce an 
output of 1 for every second 0 it receives and for every second 1 it receives.
Example:
 X(input) =0 1 1 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 1 1 0 1 0
Z(output) =0 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
(a) Design a Mealy sequential circuit using D flip-flops, showing a reduced state 
graph, and equations for the output and D inputs. It should be a reasonably 
economical design.
(b) Repeat part (a) for J-K flip-flops.Cell
n−1xn−1yn−1
bnan
Cell
n−2xn−2yn−2
bn−1an−1
Cell
ixiyi
bi+1ai+1
bn−2an−2
Cell
0x0y0
b1a1
biai
b0a0...
.........
580 Unit 16
(c) Design a Moore sequential circuit using T flip-flops to do the same task, showing 
a state graph and input equations for a reasonably economical design.
16.22 Design a sequential circuit to multiply an 8-4-2-1 binary-coded decimal digit by 3 to 
give a 5-bit binary number. For example, if the input is 0111, the output should be 
10101. The input and output to the circuit should be serial with the least significant bit first. Assume that the input will be 0 at the fifth clock time and reset the circuit after the fifth output bit. (Hint: As each bit is received, multiply it by 3, giving a product of either 00 or 11. Thus we either output 0 and carry 0 to the next column, or output 1 and carry 1 to the next column. If we carry a 1 to the next column, then the sum of the carry and the next product is either 01 or 100. In this case, we either output 1 and carry 0 or output 0 and carry 10 (2) to the next column. What happens if we carry 10 (2) to the next column?)
(a) Derive a state table with a minimum number of states (3 states).
(b) Design the circuit using J-K flip-flops and NAND and NOR gates.
(c) Design the circuit using a PLA and D flip-flops. Give the PLA table.
16.23 A Moore sequential circuit has three inputs (
X2, X1, and X0) that specify a tempera-
ture range in a room. The circuit has two outputs ( I and D) that control a heater 
for the room; I=1 causes the heater to increase its heat output, and D =1 causes 
the heater to decrease its heat output. If the temperature range is 0, 1 or 2, for three successive clock cycles, the circuit generates 
I=1, and conversely if the tempera-
ture range is 5, 6, or 7 , for three successive clock cycles, the circuit generates D =1; 
 otherwise, I=0 and D =0.
(a) Construct a state diagram for the circuit.
(b) Encode the states using a one-hot state assignment and derive the D flip-flop 
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.24 Repeat Problem 16.23 using a Mealy circuit.
16.25 A Moore sequential circuit has two inputs (X  and  Y) and three outputs (Z2, Z1, and  Z0). 
The outputs are a 1’s complement number specifying the number of successive times 
X and Y have been equal or not equal as follows: In decimal, the outputs are 1, 2 and 3, if  
X and Y have been equal for one time, two successive times, and three or more suc-
cessive times, and the outputs are, –1, –2, and  −3 if X and Y have been not equal 
for one time, two successive times, and three or more successive times. Initially, the outputs are all 0.
(a) Construct a state diagram for the circuit.
(b) Encode the states using a one-hot state assignment and derive the D flip-flop 
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.26 Repeat Problem 16.25 using a Mealy sequential circuit.
Sequential Circuit Design  581
16.27 A Moore sequential circuit has two inputs (X  and  Y)and three outputs (Z2, Z1, and  Z0). 
The outputs are a 2’s complement number specifying the number of successive times 
X and Y have been equal or not equal as follows: In decimal, the outputs are 1, 2, 
and 3 if X and Y have been equal for one time, two successive times, and three or 
more successive times, and the outputs are –1,  –2, –3, and – 4 if X and Y have been 
not equal for one time, two successive times, three successive times, and four or more 
successive times. Initially, the outputs are all 0.
(a) Construct a state diagram for the circuit.
(b) Encode the states using a one-hot state assignment and derive the D flip-flop 
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.28 Repeat Problem 16.27 using a Mealy sequential circuit.
16.29 The block diagram for an elevator controller for a two-floor elevator follows. The 
inputs FB1 and FB2 are 1 when someone in the elevator presses the first or second 
floor buttons, respectively. The inputs CALL1 and CALL2 are 1 when someone on the 
first or second floor presses the elevator call button. The inputs FS1 and FS2 are 1 when 
the elevator is at the first or second floor landing. The output UP turns on the motor to 
raise the elevator car; DOWN turns on the motor to lower the elevator. If neither UP 
nor DOWN is 1, then the elevator will not move. R1 and R2 reset the latches (described 
below); and when DO goes to 1, the elevator door opens. After the door opens and 
remains open for a reasonable length of time (as determined by the door controller mechanism), the door controller mechanism closes the door and sets D
C =1. Assume 
that all input signals are properly synchronized with the system clock.
(a) If we were to realize a control circuit that responded to all of the inputs 
FB1, FB2, CALL1, CALL2, FS1, FS2, and D C, we would need to implement 
logic equations with nine or more variables (seven inputs plus at least two state variables). However, if we combine the signals FB
i and CALLi into a signal  
Ni (i=1 or  2) that indicates that the elevator is needed on the specified floor, 
we can reduce the number of inputs into the control circuit. In addition, if the 
FB1
N1R1
R2
UP
DOWN
DON2FB2
DCFS1
FS2CALL1
CALL2Storage
Circuit
Control
CircuitStorage
Circuit
Door
Mechanism
582 Unit 16
signal Ni is stored so that a single pulse on FBi or CALLi will set Ni to 1 until the 
control circuit clears it, then the control circuit will be simplified further. Using a 
D flip-flop and a minimum number of added gates, design a storage circuit that will have an output 1 when either input 
(FBi or  CALLi) becomes 1 and will stay 
1 until reset with a signal Ri.
(b) Using the signals N1 and N2 that indicate that the elevator is needed on the first 
or second floor (to deliver a passenger or pick one up or both), derive a state graph for the elevator controller. (Only four states are needed.)
(c) Realize the storage circuits for N
1 and N2 and the state graph.
16.30 An older model Thunderbird car has three left and three right taillights which flash 
in unique patterns to indicate left and right turns.
Design a Moore sequential circuit to control these lights. The circuit has three 
inputs LEFT, RIGHT, and HAZ. LEFT and RIGHT come from the driver’s turn 
signal switch and cannot be 1 at the same time. As indicated above, when LEFT =1 
the lights flash in a pattern LA on; LA and LB on; LA, LB, and LC on; all off; 
and then the sequence repeats. When RIGHT =1, the light sequence is similar. If 
a switch from LEFT to RIGHT (or vice versa) occurs in the middle of a flashing 
sequence, the circuit should immediately go to the IDLE (lights off) state and, then, 
start the new sequence. HAZ comes from the hazard switch, and when HAZ =1, all 
six lights flash on and off in unison. HAZ takes precedence if LEFT or RIGHT is 
also on. Assume that a clock signal is available with a frequency equal to the desired flashing rate.
(a) Draw the state graph (eight states).
(b) Realize the circuit using six D flip-flops and make a state assignment such that 
each flip-flop output drives one of the six lights directly. (Use LogicAid.)
(c) Realize the circuit using three D flip-flops, using the guidelines to determine a 
suitable state assignment. Note the trade-off between more flip-flops and more gates in (b) and (c).
16.31 Design a sequential circuit to control the motor of a tape player. The logic circuit, 
shown as follows, has five inputs and three outputs. Four of the inputs are the control 
buttons on the tape player. The input PL  is 1 if the play button is pressed, the input 
RE is 1 if the rewind button is pressed, the input F
F is 1 if the fast forward button is 
pressed, and the input ST is 1 if the stop button is pressed. The fifth input to the con-
trol circuit is M, which is 1 if the special music sensor detects music at the current tape 
position. The three outputs of the control circuit are P, R, and F, which make the tape LC LB LA RA RB RCLEFT turn pattern:
LC LB LA RA RB RCRIGHT turn pattern:
Sequential Circuit Design  583
play, rewind, and fast forward, respectively, when 1. No more than one output should 
ever be on at a time; all outputs off cause the motor to stop. The buttons control the tape as follows: If the play button is pressed, the tape player will start playing the tape (output P=1). If the play button is held down and the rewind button is pressed 
and released, the tape player will rewind to the beginning of the current song (output R =1 until M =
0) and then start playing. If the play button is held down and the fast 
forward button is pressed and released, the tape player will fast forward to the end of the current song (output F=1 until M =
0) and then start playing. If rewind or fast 
forward is pressed while play is released, the tape player will rewind or fast forward the tape. Pressing the stop button at any time should stop the tape player motor.
4-bit Regis ter
BCD X2
33
4-bit Regis ter
BCD X2
33 Serial In
4-bit Regis ter
BCD X2
33(a) Construct a state graph chart for the tape player control circuit.
(b) Realize the control circuit using a PLA and D flip-flops.
16.32 The circuit below converts a positive, unsigned binary number into a BCD decimal 
number. The binary number is entered bit serially with the most significant bit first. As each input bit is entered, the BCD number in the registers is multiplied by 2 and the input bit added to it.
(a) Show the contents of the registers after each input bit for the binary number 
110110111.
(b) What is the largest binary number that this circuit can correctly convert to BCD?
(c) Derive the minimum sum-of-product equations for the outputs of the BCD mul-
tiply by 2 circuit. Let 
x3, x2, x1, x0 be the inputs and y3, y2, y1, y0 be the outputs.
16.33 An iterative circuit has an output of 1 from the last cell if and only if the input pat-
tern 1011 or 1101 has occurred as inputs to any four adjacent cells in the circuit.
(a) Find a Moore state graph or table with a minimum number of states.
(b) Make a suitable state assignment, and derive one of the equations for a typical cell.
(c) Derive the output equation.PL
RE
FF
ST
MFRP
584 Unit 16
16.34 An iterative circuit has a form similar to Figure 16-6. The output Z is to be 1 iff at 
least one of the X inputs is 1, and no group of two or more consecutive 1 inputs 
occurs.
Example:
 0 0 1 0 1 0 0 0 1 0 0 gives an output Z =1
0 0 1 0 1 1 0 0 0 0 0 gives an output Z =0
(a) Draw a state graph for a typical cell.
(b) Derive the equations and a NOR-gate circuit for a typical cell and for the output 
circuit.
(c) Specify a1 and b1, and simplify the first cell.
(d) Show how a sequential circuit can be constructed using the typical cell and 
 output circuit.
585VHDL for Sequential LogicUNIT
17
Objectives
1. Represent flip-flops, shift registers, and counters using VHDL processes.
2. Write sequential VHDL statements, including if-then-else, case, and wait 
 statements.
3. Explain the sequence of execution for sequential statements and the order in which signals are updated when a process executes.
4. Represent combinational logic using a process.
5. Represent a sequential logic circuit with VHDL code.
a. Use two processes.
b. Use logic equations and a process that updates the flip-flops.
c. Use a ROM and flip-flops.
6. Given VHDL code for sequential logic, draw the corresponding logic circuit.
7. Compile, simulate, and synthesize a sequential logic module.
586 Unit 17
Study Guide
1. Study Section 17.1, Modeling Flip-Flops Using VHDL Processes.
(a) Under what condition is the expression CLK'event and CLK='0' true?
(b) If the first line of a process is Process (St, Q1, V), under what condition will 
the process execute?
(c) In Figure 17-4, if C1 and C3 are false and C2 is true, which statements will 
execute?
(d) What device does the following VHDL code represent? What happens if 
ClrN=SetN ='0'?
process (CLK, ClrN, SetN)
 if ClrN='0' then Q  <= '0';
 elsif SetN='0' then Q  <= '1';
 elsif CLK'event and CLK='1' then
  Q <= D;
 end if;
end process;
(e) In Figure 17-6, why are RN and SN tested before CLK? If J='1', K ='0', 
and RN changes to '0', and then CLK changes to '0' 10 ns later, what will be the Q output?
(f  ) In Figure 17-6, if the statements Q <
 = Qint; and QN < = not Qint ; are moved 
inside the process just before the end-process statement, why will Q and QN have the wrong values?
(g) Modify the VHDL code in Figure 17-3 to add a clock enable (CE) to the 
flip-flop. (Hint: if CLK'event and 
CLK='1' and ________ .)
(h) Work Problem 17.1.
2. Study Section 17.2, Modeling Registers and Counters Using VHDL Processes.
(a) Add the necessary VHDL code to Figure 17-9 to make a complete VHDL 
module.
(b) In Figure 17-10, if CLK changes to '1' at time 10 ns, at what time will Q 
change? (Remember that it takes Δ time to update a signal).
(c) What change should be made to Figure 17-10 to cause the register to rotate 
left one place instead of shifting left? (Do not use shift operators.)
(d) In Figure 17-11, what changes would be needed to make the clear asyn-
chronous?
VHDL for Sequential Logic  587
(e) In Figure 17-12, under what conditions does Carry2 =1?
(f  ) In Figure 17-11, note that Q is a std_logic vector. Why would the code fail 
to compile if Q is a bit_vector?
(g) In Figure 17-14, if Qout1 ="1111", Qout2 ="1001", P =T1=LdN = 
ClrN='1', what will Qout1 and Qout2 be after the rising edge of CLK?
(h) If the process in Figure 17-13 is replaced with
process (CLK)
begin if CLK'event and 
CLK = '1' then
  if L d = '1' then Q <= D;
  elsif (P and T )='1' then Q <= Q+1;
  elsif Clr='1' then Q  <= "0000 ";
  end if; end if;
end process;
modify Table 17-1 to properly represent the corresponding counter operation.
Control Signals Next State
Clr Ld PT Q+
3Q+
2Q+
1Q+
0
(i) Work Problems 17.2, and 17.3.
3. Study Section 17.3, Modeling Combinational Logic Using VHDL Processes.
(a) For Figure 17-15, if the circuit is represented by a single sequential state-
ment, make the necessary changes in the VHDL code. Assume that the AND gate delay is negligible and the OR gate delay is 5 ns. ( Hint: The 
process sensitivity list should only have three signals on it.)
(b) Work Problem 17.4.
4. Study Section 17.4, Modeling a Sequential Machine.
(a) If Figure 17-16 implements the state table of Table 17-2, what will NextState 
and 
Z be if State =S2 and X='1'?
588 Unit 17
(b) For the VHDL code of Figure 17-17:
(1) Why is the integer range 0 to 6?
(2) Assume that initially CLK='0', State =0, and X='0'. Trace the code 
to answer the following:
If X changes to '1', what happens?
If CLK then changes to '1', what happens? (Hint: Both processes execute.)
Work Problem 17.5.
(c) Explain how the waveform of Figure 17-18 relates to Table 17-2.
Why is there a glitch in the nextstate waveform between next states 0 and 2?
Why does this glitch not cause the state to go to the wrong value?
(d) For the VHDL code of Figure 17-19:
Why do Q1, Q2, and Q3 not appear on the sensitivity list?
If CLK changes from 0 to 1 at time 5 ns, at what time are the new values 
of Q1, Q2, and Q3 computed? At what time do Q1, Q2, and Q3 change to these new values?
(e) Recall that component instantiation statements are concurrent state-
ments. For the VHDL code of Figure 17-20, if Q1 changes, which of these statements will execute immediately? Relate your answer to the circuit of Figure 16-4.
(f  ) For Figure 17-22, what value will be read from the ROM array when 
X='1' 
and Q ="010"?
(g) Work Problem 17.6.
5. Study Section 17.5, Synthesis of VHDL Code.
(a) Implement the following process using only a D-CE flip-flop:
VHDL for Sequential Logic  589
process (CLK)
begin if CLK'event and 
CLK='1' then 
  if En ='1' then Q <= A; end if;
 end if;
end process;
(b) Implement the same code using a D flip-flop without a clock enable and a 
MUX.
(c) Implement the following VHDL code using only D-CE flip-flops:
signal A: bit_vector(3 downto 0)
----------------------------------------process (CLK)begin if CLK'event and 
CLK='1' then
  if A SR='1' then
  A  <= A(3) & A(3 downto  1);
  end if; end if;
end process;
(d) Work Problem 17.7.
6. Study Section 17.6, More About Processes and Sequential Statements.
(a) Write an equivalent process that has no sensitivity list on the first line. Use 
a wait statement instead.
process (B, C)
begin A
 <= B or C;
end process;
(b) For the following process, if B changes at time 2 ns, at what time does state-
ment (2) execute? (The answer is not 7 ns.)
process (B,  D);
 A <= B after 5 ns; --(1)
 C <= D; --(2)
end process;
(c) Work Problem 17.8.
7. Complete the assigned lab exercises before you take the test on Unit 17.
590In Unit 10 we learned how to represent combinational logic in VHDL by using con-
current signal assignment statements. In this unit, we will learn how to represent sequential logic by using VHDL processes.
17.1 Modeling Flip-Flops Using VHDL Processes
A flip-flop can change state either on the rising or on the falling edge of the clock input. This type of behavior is modeled in VHDL by a process. For a simple D flip-flop with a Q output that changes on the rising edge of CLK, the corresponding process is given in Figure 17-1.
The expression in parentheses after the word process is called a sensitivity list, 
and the process executes whenever any signal in the sensitivity list changes. For example, if the process begins with process
(A, B, C ), then the process executes when-
ever any one of A, B, or C changes. When a process finishes executing, it goes back to the beginning and waits for a signal on the sensitivity list to change again.
In Figure 17-1, whenever CLK changes, the process executes once through and, 
then, waits at the start of the process until CLK changes again. The if statement tests 
for a rising edge of the clock, and Q is set equal to D when a rising edge occurs. The expression CLK'event (read as clock tick event) is TRUE whenever the signal CLK changes. If 
CLK='1' is also TRUE, this means that the change was from '0' to '1', 
which is a rising edge. If the flip-flop has a delay of 5  ns between the rising edge of the 
clock and the change in the Q output, we would replace the statement Q <= D; with 
Q <= D after 5 ns; in the process in Figure 17-1.
The statements between begin and end in a process are called sequential 
 statements. In the process in Figure 17-1, Q <= D; is a sequential statement that only VHDL for Sequential Logic
FIGURE 17-1
VHDL Code for a 
Simple D Flip-Flop
© Cengage Learning 2014process (CLK)
begin      if CLK'event and CLK = '1' -- rising edge of CLK            then Q <= D;      end if;end process;DFF
CLK
DQ
VHDL for Sequential Logic  591
executes following the rising edge of CLK. In contrast, the concurrent statement 
Q <= D; executes whenever D changes. If we synthesize the process, the synthesizer 
infers that Q must be a flip-flop because it only changes on the rising edge of CLK. If 
we synthesize the concurrent statement Q <= D; the synthesizer will simply connect 
D to Q with a wire or with a buffer.
In Figure 17-1 note that D is not on the sensitivity list because changing D will not 
cause the flip-flop to change state. Figure 17-2 shows a transparent latch and its VHDL representation. Both G and D are on the sensitivity list because if 
G='1', a change in 
D causes Q to change. If G changes to '0', the process executes, but Q does not change.
FIGURE 17-2
VHDL Code for a 
Transparent Latch
© Cengage Learning 2014process (G,D)
begin      if G = '1' then Q <= D; end if;end process;Q D
G
FIGURE 17-3
VHDL Code for a 
D Flip-Flop with 
Asynchronous Clear
© Cengage Learning 2014ClrNprocess (CLK, ClrN)begin      if ClrN = '0' then Q <= '0';            else if CLK'event and CLK = '1'                    then Q <= D;                    end if;      end if;end process;DFF
CLK
DQIf a flip-flop has an active-low asynchronous clear input (ClrN) that resets the 
flip-flop independently of the clock, then we must modify the process of Figure 17-1 
so that it executes when either CLK or ClrN changes. To do this, we add ClrN to the sensitivity list. The VHDL code for a D flip-flop with asynchronous clear is given in Figure 17-3. Because the asynchronous ClrN signal overrides CLK, ClrN is tested first, and the flip-flop is cleared if ClrN is '0'. Otherwise, CLK is tested, and Q is updated if a rising edge has occurred.
A basic process has the following form:
process(sensitivity-list)
begin sequential-statementsend process;
Whenever one of the signals in the sensitivity list changes, the sequential statements in the process body are executed in sequence one time. The process then goes back to the beginning and waits for a signal in the sensitivity list to change.
In the previous examples, we have used two types of sequential statements—
signal assignment statements and if statements. The basic if statement has the form
if condition then  sequential statements1 else sequential statements2
end if;
592 Unit 17
The condition is a Boolean expression which evaluates to TRUE or FALSE. If it is 
TRUE, sequential statements1 are executed; otherwise, sequential statements2 are executed. VHDL if statements are sequential statements that can be used within a 
process, but they cannot be used as concurrent statements outside of a process. On the other hand, conditional signal assignment statements are concurrent statements that cannot be used within a process.
The most general form of the if statement is
if condition then
 sequential statements{elsif condition then sequential statements} -- 0 or more elsif clauses may be included[else sequential statements]end if;
The curly brackets indicate that any number of elsif clauses may be included, and the 
square brackets indicate that the else clause is optional. The example of Figure 17-4 
shows how a flow chart can be represented using nested ifs or the equivalent using 
elsifs. In this example, C1, C2, and C3 represent conditions that can be TRUE or FALSE, and S1, S2, . . . S8 represent sequential statements. Each if requires a cor-
responding end if, but an elsif does not.
Next, we will write a VHDL module for a J-K flip-flop (Figure 17-5). This flip-flop 
has active-low asynchronous preset (SN) and clear (RN) inputs. State changes related to J and K occur on the falling edge of the clock. In this chapter, we use a suf-fix N to indicate an active-low (negative-logic) signal. For simplicity, we will assume that the condition 
SN=RN =0 does not occur.
FIGURE 17-4
Equivalent 
Representations 
of a Flow Chart 
Using Nested 
Ifs and Elsifs
© Cengage Learning 2014C1T
S1; S2; C2T
S3; S4; C3TF
F
F
S5; S6; S7; S8;
if (C1) then S1; S2;
      else if (C2) then S3; S4;             else if (C3) then S5; S6;                       else S7; S8;                       end if;             end if;end if;if (C1) then S1; S2;      elsif (C2) then S3; S4;      elsif (C3) then S5; S6;      else S7; S8;end if;
VHDL for Sequential Logic  593
The VHDL code for the J-K flip-flop is given in Figure 17-6. The port declaration 
in the entity defines the input and output signals. Within the architecture we define 
a signal Qint that represents the state of the flip-flop internal to the module. The two concurrent statements after begin transmit this internal signal to the Q and QN 
outputs of the flip-flop. We do it this way because an output signal in a port cannot appear on the right side of an assignment statement within the architecture. The flip-flop can change state in response to changes in SN, RN, and CLK, so these three signals are in the sensitivity list of the process. Because RN and SN reset and set the flip-flop independently of the clock, they are tested first. If RN and SN are both '1', then we test for the falling edge of the clock. The condition ( CLK'event and 
CLK ='0') 
is TRUE only if CLK has just changed from '1' to '0'. The next state of the flip-flop is determined by its characteristic equation:
Q
+=JQ ′+K′Q
The 8-ns delay represents the time it takes to set or clear the flip-flop output after 
SN or RN changes to 0. The 10-ns delay represents the time it takes for Q to change after the falling edge of the clock.
FIGURE 17-6
J-K Flip-Flop Model
© Cengage Learning 20141 entity JKFF is
2 port (SN, RN, J, K, CLK: inbit; -- inputs
3 Q, QN: out bit);
4 end JKFF;
5 architecture JKFF1 ofJKFF is
6 signal Q  f o  e u l a v  l a n r e t n i  - - ; t i b : t n i Q
7 begin
8Q tr o p  o t  N Q  d n a  Q  t u p t u o  - - ; t n i Q
9Q N notQint;
10 process (SN, RN, CLK)
11 begin
12 ifRN '0' then Qint '0' after 8 ns; -- RN '0' will clear the FF
13 elsif SN '0' then Qint '1' after 8 ns; -- SN '0' will set the FF
14 elsif CLK'event and CLK '0' then -- falling edge of CLK
15 Qint (J and not Qint) or(not K and Qint) after 10 ns;
16 end if;
17 end process ;
18 end JKFF1;<=
<=
<=<=
<==
=
==
=FIGURE 17-5
J-K Flip-Flop
© Cengage Learning 2014JKFF
CLKRN SN
J KQ QN
594 Unit 17
17.2 Modeling Registers and Counters 
Using VHDL Processes
When several flip-flops change state on the same clock edge, the statements repre-
senting these flip-flops can be placed in the same clocked process. Figure 17-7 shows three flip-flops connected as a cyclic shift register. These flip-flops all change state following the rising edge of the clock. We have assumed a 5-ns propagation delay between the clock edge and the output change. Immediately following the clock edge, the three statements in the process execute in sequence with no delay. The new values of the Q’s are then scheduled to change after 5
 ns. If we omit the delay and replace 
the sequential statements with
Q1 <= Q3;  Q2 <= Q1;  Q3 <= Q2;
the operation is basically the same. The three statements execute in sequence in zero time, and, then, the Q’s change value after 
Δ delay. In both cases the old values of Q1, Q2, 
and Q3 are used to compute the new values. This may seem strange at first, but that is the way the hardware works. At the rising edge of the clock, all of the D inputs are loaded into the flip-flops, but the state change does not occur until after a propagation delay.
Next we will write structural VHDL code for the cyclic shift register using a 
D flip-flop as a component. In the writing of structural VHDL code, instantiation statements are used to specify how components are connected together.  Components 
may be declared and defined either in a library or within the architecture part of the VHDL code. Each copy of a component requires a separate instantiation statement to specify how it is connected to other components and to the port inputs and out-puts. Instantiation statements are concurrent statements, not sequential statements, and therefore they cannot be used within a process. A component can be as simple as a single gate or as complex as a digital system that contains many internal signals, registers, control circuits, and other components. Each instantiation statement rep-resents a copy of a hardware component. The instantiation statement connects the component inputs and outputs, and the component computes new outputs when-ever one of its inputs changes. This is exactly how the real hardware component 
FIGURE 17-7
Cyclic Shift Register
© Cengage Learning 2014Q1 D
Q2 D
Q3 DCLK
process (CLK)
begin      if CLK'event and CLK = '1' then             Q1 <= Q3 after 5 ns;             Q2 <= Q1 after 5 ns;             Q3 <= Q2 after 5 ns;      end if;end process;
VHDL for Sequential Logic  595
works. Instantiating a component is different from calling a function in a computer 
program. A function returns a new value whenever it is called, but an instantiated component computes a new output value whenever its input changes.
The VHDL code of Figure 17-8 has two modules. The first one models a simple 
D flip-flop. The second module instantiates three copies of the D flip-flop compo-nent to model the cyclic shift register of Figure 17-7. Qout represents a 3-bit output from the register. The internal signals (Q1, Q2, and Q3) that are declared within the architecture are used to connect the flip-flop inputs and outputs. Lines 21, 22, and 23 instantiate three copies of the D flip-flop component. Even though the DFF module has a clock input and internal sequential statements, each instantiation statement is still a concurrent statement and must not be placed in a process. If CLK changes, this 
change is passed to the D flip-flop components, and the effect of the clock change is handled within the components.
Figure 17-9 shows a simple register that can be loaded or cleared on the rising edge 
of the clock. If 
CLR=1, the register is cleared, and if Ld =1, the D inputs are loaded 
into the register. This register is fully synchronous so that the Q outputs only change in response to the clock edge and not in response to a change in Ld or CLR. In the VHDL code for the register, Q and D are bit vectors dimensioned 3 downto 0. Because 
the register outputs can only change on the rising edge of the clock, CLR is not on the 
FIGURE 17-8
Structural VHDL 
Code for Cyclic 
Shift Register
© Cengage Learning 20141 entity DFF is --simple DFF
2 port (D, CLK: in bit, q: out bit);
3 end DFF;
4 architecture DFF_simple ofDFF is
5 begin
6 process (CLK)
7 begin
8 if CLK'event and CLK = '1' then
9Q  <= D after 5 ns; end if;
10 end process;
11 end DFF_simple;
12 entity cyclicSR is -- 3-bit cyclic shift register
13 port (CLK: in bit; Qout: out bit_vector(1 to 3) ) ;
14 end cyclicSR;
15 architecture cyclicSR3 ofcyclicSR is
16 component DFF
17 port (D, CLK: in bit; Q: out bit);
18 end component;
19 signal Q1, Q2, Q3: bit;
20 begin
21 FF1: DFF port map (Q3, CLK, Q1);
22 FF2: DFF port map (Q1, CLK, Q2);
23 FF3: DFF port map (Q2, CLK, Q3);
24 Qout <= Q1&Q2&Q3;
25 end cyclicSR3;
596 Unit 17
sensitivity list. It is tested after the rising edge of the clock instead of being tested first 
as in Figure 17-3. If CLR =Ld ='0', Q does not change. Because CLR is tested before 
Ld, if CLR = '1', the elsif prevents Ld from being tested and CLR overrides Ld.
Next, we will model a left-shift register using a VHDL process. The register in 
Figure 17-10 is similar to that in Figure 17-9, except we have added a left-shift con-trol input (LS). When LS is '1', the contents of the register are shifted left and the rightmost bit is set equal to Rin. The shifting is accomplished by taking the rightmost three bits of Q, Q(2 downto 0) and concatenating them with Rin. For example, if 
Q = "1101" and Rin = '0', then Q(2 downto 0) & Rin = "1010", and this value is 
loaded back into the Q register on the rising edge of CLK. The code implies that if 
CLR =Ld =LS='0', then Q remains unchanged.
Figure 17-11 shows a simple synchronous counter. On the rising edge of the clock, 
the counter is cleared when ClrN ='0', and it is incremented when ClrN =En ='1' . 
In this example, the signal Q represents the 4-bit value stored in the counter. Because addition is not defined for bit_vectors, we have declared Q to be of type std_ logic_ vector. Then, we can increment the counter using the overloaded “
+ ” 
operator that is defined in the ieee.std_logic_unsigned package. The statement Q <
 = Q +1; increments the counter. When the counter is in state "1111", the next 
increment takes it back to state "0000".FIGURE 17-9
Register with 
Synchronous 
Clear and Load
© Cengage Learning 2014Q3Q2Q1
RegisterQ0Ld
D3 D2 D1 D0CLKCLRprocess (CLK)
begin      if CLK'event and CLK = '1' then             if CLR = '1' then Q <= "0000";                    elsif Ld = '1' then Q <= D;             end if;      end if;end process;
FIGURE 17-10
Left-Shift Register 
with Synchronous 
Clear and Load
© Cengage Learning 2014Q3Q2Q1
Left SR RinQ0 Ld
D3 D2 D1 D0CLKLS
CLRprocess (CLK)begin  if CLK'event and CLK = '1' then    if CLR = '1' then Q <= "0000";      elsif Ld = '1' then Q <= D;      elsif LS = '1' then Q <= Q(2 downto 0) & Rin;    end if;  end if;end process;
FIGURE 17-11
VHDL Code for a 
Simple Synchronous 
Counter
© Cengage Learning 2014Q3Q2Q1
CounterQ
Q0 En
CLKClr ClrNsignal Q: std_logic_vector(3 downto 0);------------process (CLK)begin      if CLK'event and CLK = '1' then             if ClrN = '0' then Q <= "0000";                    elsif En = '1' then Q <= Q + 1;             end if;      end if;end process;
VHDL for Sequential Logic  597
The 74163 (see Figure 17-12) is a 4-bit fully synchronous binary counter which is 
available in both TTL and CMOS logic families. Although rarely used in new designs 
at present, it represents a general type of counter that is found in many CAD design libraries. In addition to performing the counting function, it can be cleared or loaded in parallel. All operations are synchronized by the clock, and all state changes take place following the rising edge of the clock input.
This counter has four control inputs: ClrN, LdN, P , and T. Inputs P and T are used 
to enable the counting function. Operation of the counter is as follows:
1. If 
ClrN =0, all flip-flops are set to 0 following the rising clock edge.
2. If ClrN =1 and LdN =0, the D inputs are transferred in parallel to the flip-flops 
following the rising clock edge.
3. If ClrN =LdN =1 and P =T=1, the count is enabled and the counter state 
will be incremented by 1 following the rising clock edge.
If T = 1, the counter generates a carry (Cout) in state 15, so
Cout =Q3 Q2 Q1 Q0 T
Table 17-1 summarizes the operation of the counter. Note that ClrN overrides the 
load and count functions in the sense that when ClrN =0, clearing occurs regardless 
of the values of LdN, P , and T. Similarly, LdN overrides the count function. The ClrN 
input on the 74163 is referred to as a synchronous clear input because it clears the 
counter in synchronization with the clock, and no clearing can occur if a clock pulse is not present.
The VHDL description of the counter is shown in Figure 17-13. Q represents the 
four flip-flops that make up the counter. The counter output, Q
out, changes  whenever Q 
changes. The carry output is computed whenever Q or T changes. The first if  statement 
in the process tests for a rising edge of CLK. Because clear overrides load and count, the next if statement tests ClrN first. Because load overrides count, LdN is tested next. 
TABLE 17-1
74163 Counter 
Operation 
© Cengage Learning 2014FIGURE 17-12
Two 74163 
Counters Cascaded 
to Form an  
8-Bit Counter
© Cengage Learning 2014Q3Q2Q1Qout2
Din2Q0
D3D2D174163
D0P P
Clr ClrNLd LdNT Cout Carry2Q3Q2Q1Qout1
Din1Q0
D3D2D174163
D0P
Clr ClrN
CLKLd LdNTP
T1 CoutCarry1
Control Signals Next State
ClrN LdN PT Q+
3 Q+
2 Q+
1 Q+
0
0 X X 0 0 0 0 (Clear)
10 X D3 D2 D1 D0(Parallel load)
11 0 Q3 Q2 Q1 Q0(No change)
1 1 1 Present state +  1 (Increment count)
598 Unit 17
Finally, the counter is incremented if both P and T are 1. Because Q is type std_logic_
vector, we can use the overloaded “ +” operator from the ieee.std_ logic_unsigned 
library to add 1 to increment the counter. The expression Q + 1 would not be legal if 
Q were a bit_vector because addition is not defined for bit_vectors.
To test the counter, we have cascaded two 74163’s to form an 8-bit counter 
(Figure 17-12). When the counter on the right is in state 1111 and T1 =1, the T input 
to the left counter is Carry1 =1. Then, if P=1, on the next clock the right counter is 
incremented to 0000 at the same time the left counter is incremented. Figure 17-14 
shows the VHDL code for the 8-bit counter. In this code we have used the c74163 model as a component and instantiated two copies of it. For convenience in reading the output, we have defined a signal Count which is the integer equivalent of the 8-bit counter value. The function Conv_integer converts a std_logic_vector to an integer.
The two instantiation statements (lines 21 and 22) connect the inputs and outputs 
of two copies of the 4-bit counter component. Each of these concurrent statements will execute when one of the counter inputs changes, and then the corresponding counter module computes new values of the counter outputs. Although the 4-bit FIGURE 17-13
74163 Counter 
Model
© Cengage Learning 2014-- 74163 FULLY SYNCHRONOUS COUNTER
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity c74163 is
6 port(LdN, ClrN, P , T, CLK: in std_logic;
7D : instd_logic_vector(3 downto 0);
8 Cout: outstd_logic; Qout: outstd_logic_vector(3 downto 0) );
9 end c74163;
10 architecture b74163 ofc74163 is
11 signal Q: std_logic_vector(3 downto 0); -- Q is the counter register
12 begin
13 Qout Q;
14 Cout Q(3) and Q(2) and Q(1) and Q(0) andT;
15 process (CLK)
16 begin
17 ifCLK'event and CLK = '1' then -- change state on rising edge
18 ifClrN '0' then Q "0000";
19 elsif LdN '0' then QD ;
20 elsif (P andT) = '1' then Q <= Q + 1; 
21 end if;
22 end if;
23 end process ;
24 end b74163;<=
<=
<= ==<=
VHDL for Sequential Logic  599
counter module (Figure 17-13) contains a process and sequential statements, each 
statement that instantiates a counter module is nevertheless a concurrent statement and cannot be placed within a process.
17.3 Modeling Combinational Logic 
Using VHDL Processes
Although processes are most useful for modeling sequential logic, they can also be 
used to model combinational logic. The circuit of Figure 10-1 can be modeled by the process shown in Figure 17-15.
For a combinational process, every signal that appears on the right side of a 
 signal assignment must appear on the sensitivity list. Suppose that initially A =1, 
and B =
C=D=E=0. If B changes to 1 at time =4 ns, the process executes, and 
the two sequential assignment statements execute in sequence. The new value of FIGURE 17-14
VHDL for 8-Bit 
Counter
© Cengage Learning 2014-- Test module for 74163 counter
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity c74163test is
6 port(ClrN, LdN, P , T1, CLK: in std_logic;
7 Din1, Din2: instd_logic_vector (3 downto 0);
8 Count: outinteger range 0 to255;
9 Carry2: outstd_logic);
10 end c74163test;
11 architecture tester ofc74163test is
12 component c74163
13 port(LdN, ClrN, P , T, CLK: in std_logic;
14 D: instd_logic_vector(3 downto 0);
15 Cout: outstd_logic; Qout: outstd_logic_vector (3 downto 0) );
16 end component ;
17 signal Carry1: std_logic;
18 signal Qout1, Qout2: std_logic_vector (3 downto 0);
19 begin
20 ct1: c74163 port map (LdN, ClrN, P , T1, CLK, Din1, Carry1, Qout1);
21 ct2: c74163 port map (LdN, ClrN, P , Carry1, CLK, Din2, Carry2, Qout2);
22 Count Conv_integer(Qout2 & Qout1);
23 end tester;<=
600 Unit 17
C is computed to be '1', and C is scheduled to change 5 ns later. Meanwhile, E is 
immediately computed using the old value of C, but it does not change because C has not yet changed. After 5 ns, C changes, and because it is on the sensitivity list, the process executes again, and the sequential statements again execute in sequence. This time C does not change, but E is scheduled to change after 5 ns. Because E is not on the sensitivity list, no further execution of the process occurs. The following listing summarizes the operation:
time
  A  B  C  D  E
0    1 0 0 0 0
4   11000
process  executes   (C←1  after   5  ns;  E←0,  no  change )
9   1  1  1  0  0
process   executes   (C←1,  no   change;  E←1  after   5  ns)
14   1  1  1  0  1
  no further execution until A, B, C, or D changes
In Section 10.2, we modeled a MUX using a conditional signal assignment 
 statement and a selected signal assignment statement. Because these are concurrent statements, they cannot be used inside a process. However, the case statement is a 
sequential statement that can be used to model a MUX within a process. The 4-to-1 MUX of Figure 10-7 can be modeled as follows:FIGURE 17-15
VHDL Code for 
Gate Circuit
© Cengage Learning 2014process (A, B, C, D)
begin      C <= A and B after 5 ns;      E <= C or D after 5 ns;end process;A
BDC
E
signal sel: bit_vector(0 to 1);
----------------------------------------------------se
l < = A&B;     -- a concurrent statement, outside of the process
process (sel, I0, I1, I2, I3)begin case sel is     -- a sequential statement in the process
  when "00" =
 >  F  < = I0;
  when "01" =  >  F < = I1;
  when "10" =  >  F  < = I2;
  when "11" =  >  F  < = I3;
  when others =  > null;    -- required if sel is a std_logic_vector;
               -- omit if sel is a bit_vector end case;
end process;
VHDL for Sequential Logic  601
The case statement has the general form:
case expression is
 when  choice1 => se quentia l  statements1
 when  choice2 => se quentia l  statements2
 . . . [when
  others => se quential   statements ]
end case;
The “expression” is evaluated first. If it is equal to “choice1”  , then “sequen-
tial statements1” are executed; if it is equal to “choice2”  , then “sequential state-
ments2” are executed, etc. All possible values of the expression must be included 
in  the  choices.  If all values are not explicitly given, a “ when others” clause is 
required in the case statement. If no action is specified for the other choices, the clause should be
w
hen   others = >  null;
17.4 Modeling a Sequential Machine
In this section we will discuss several ways of writing VHDL descriptions for sequen-tial machines. First, we will write a behavioral model for a Mealy sequential circuit based on the state table of Table 17-2. This table is the same as Table 16-3 with the states renamed. It represents a BCD to excess-3 code converter with inputs and outputs LSB first.
As shown in Figure 17-16, a Mealy machine consists of a combinational cir-
cuit and a state register. The VHDL model of Figure 17-17 uses two processes to represent these two parts of the circuit. Because X and Z are external signals, they 
are declared in the port. State and Nextstate are internal signals that represent the state and next state of the sequential circuit, so they are declared at the start of the architecture. At the behavioral level, we represent the state and next state of the cir-cuit by integer signals with a range of 0 to 6.
TABLE 17-2
State Table for 
Code Converter
© Cengage Learning 2014NS Z
PS X=0X=1X=0X=1
S0 S1 S21 0
S1 S3 S41 0
S2 S4 S40 1
S3 S5 S50 1
S4 S5 S61 0
S5 S0 S00 1
S6 S0– 1 –
602 Unit 17
The first process represents the combinational circuit of Figure 17-16. Because 
the circuit outputs, Z and Nextstate, can change when either the State or X changes, 
the sensitivity list includes both State and X. The case statement tests the value of 
State, and then for each state, the if statement tests X to determine the new values of Z and Nextstate. For state S6, we assigned values to the don’t-cares so that Z and 
Nextstate are independent of X. The second process represents the state register. Whenever the rising edge of the clock occurs, the State is updated to the Nextstate value, so CLK appears in the sensitivity list. A typical sequence of execution for the two processes is as follows:
1. X changes and the first process executes. New values of Z and NextState are 
computed.
2. The clock falls, and the second process executes. Because 
CLK='0', nothing 
happens.
3. The clock rises, and the second process executes again. Because CLK='1', 
State is set equal to the Nextstate value.
4. If State changes, the first process executes again. New values of Z and Nextstate 
are computed.
A simulator command file which can be used to test Figure 17-17 follows:
add wave CLK X State Nextstate Z
force CLK 0 0, 1 100 -repeat 200force X 0 0, 1 350, 0 550, 1 750, 0 950, 1 1350run 1600
The first command specifies the signals which are to be included in the waveform output. The next command defines a clock with period of 200 ns. CLK is '0' at time 
0 ns, '1' at time 100 ns, and repeats every 200 ns. In a command of the form
force signal_name v1 t1, v 2 t2, . . .
signal_name gets the value v1 at time t1, the value v2 at time t2, etc. X is '0' at time 
0 ns, changes to '1' at time 350 ns, changes to '0' at time 550 ns, etc. The X input 
corresponds to the sequence 0010 1001, and only the times at which X changes are FIGURE 17-16
General Model of 
Mealy Sequential 
Machine
© Cengage Learning 2014Combinational
Circuit
State
RegInputs (X ) Outputs (Z)
Nextstate
State
CLK
VHDL for Sequential Logic  603
FIGURE 17-17
Behavioral Model 
for Table 17-2
© Cengage Learning 2014-- This is a behavioral model of a Mealy state machine (Table 17-2) based on its state
-- table. The output (Z) and next state are computed before the active edge of the clock.
-- The state change occurs on the rising edge of the clock.
1 entity SM17_2 is
2 port (X, CLK: inbit;
3Z : outbit);
4 end SM17_2;
5 architecture Table ofSM17_2 is
6 signal State, Nextstate: integer range 0 to6 : 0;
7 begin
8 process (State, X) -- Combinational Circuit
9 begin
10 case State is
11 when 0= >
12 if X = '0' then Z <= '1'; Nextstate <= 1;
13 else Z '0'; Nextstate
14 when 1 =>
15 ifX '0' then Z <= '1'; Nextstate <= 3;
16 else Z
17 when 2 =>
18 ifX = '0' then Z <= '0'; Nextstate <= 4;
19 else Z
20 when 3 =>
21 ifX = '0' then Z <= '0'; Nextstate <= 5;
22 else Z
23 when 4 =>
24 ifX = '0' then Z <= '1'; Nextstate <= 5;
25 else Z <= '0'; Nextstate <= 6; end if;
26 when 5 =>
27 ifX = '0' then Z <= '0'; Nextstate <= 0;
28 else Z <= '1'; Nextstate <= 0; end if;
29 when 6 =>
30 Z <= '1'; Nextstate <= 0;
31 end case;
32 end process ;
33 process (CLK) -- State Register
34 begin
35 ifCLK’event and CLK = '1'  then -- rising edge of clock
36 State37 end if;
38 end process ;
39 endTable;=
<= 2; end if;
<= '1'; Nextstate <= 5; end if;<= '1'; Nextstate <= 4; end if;<= '0'; Nextstate <= 4; end if;=<=
<= Nextstate;
604 Unit 17
specified. Execution of the preceding command file produces the waveforms shown 
in Figure 17-18.
The behavioral VHDL model of Figure 17-17 is based on the state table. After we 
have derived the next-state and output equations from the state table, we can write a data flow VHDL model based on these equations. The VHDL model of Figure 17-19 is based on the next-state and output equations that are derived in Figure 16-3 using the state assignment of Figure 16-2. The flip-flops are updated in a process which is FIGURE 17-18 Waveforms for Figure 17-17
0 500 1000 1500/clk
/x
/z/state
/nextstate0
113502450
3501 2 4502
FIGURE 17-19
Sequential Machine 
Model Using 
Equations
© Cengage Learning 2014-- The following is a description of the sequential machine of Table 17-2 in terms
-- of its next-state equations. The following state assignment was used:
-- S0-- 0; S1-- 4; S2-- 5; S3-- 7; S4-- 6; S5-- 3; S6-- 2
1 entity SM17_2 is 
2 port (X, CLK: inbit;
3Z : outbit);
4 end SM17_2;
5 architecture Equations1_4 ofSM17_2 is 
6 signal Q1, Q2, Q3: bit;
7 begin
8 process (CLK)
9 begin
10 if CLK'event and CLK = '1' then -- rising edge of clock
11 Q1 notQ2 after 10 ns;
12 Q2 Q1 after 10 ns;
13 Q3 (Q1 and Q2 and Q3) or ( notX and Q1 and not Q3) or
14 (X and not Q1 and not Q2) after 10 ns;
15 end if;
16 end process ;
17 Z (not X and not Q3) or(X and Q3) after 20 ns;
18 end Equations1_4;<=>>>>>>>
<=
<=
<= © Cengage Learning 2014
VHDL for Sequential Logic  605
sensitive to CLK. When the rising edge of the clock occurs, Q1, Q2, and Q3 are all 
assigned new values. A 10-ns delay is included to represent the propagation delay between the active edge of the clock and the change of the flip-flop outputs. Even though the assignment statements in the process are executed sequentially, Q1, Q2, and Q3 are all scheduled to be updated at the same time, T +10
 ns, where T is the 
time at which the rising edge of the clock occurred. Thus, the old value of Q1 is used to compute Q2
+, and the old values of Q1, Q2, and Q3 are used to compute Q3+. The 
concurrent assignment statement for Z causes Z to be updated whenever a change 
in X or Q3 occurs. The 20-ns delay represents two gate delays.
After we have designed a sequential circuit using components such as gates 
and  flip-flops, we can write a structural VHDL model based on the actual inter-connection of these components. Figure 17-20 shows a structural VHDL represen-tation of the circuit of Figure 16-4. Seven NAND gates, three D flip-flops, and one inverter are used. All of these components are defined in a library named BITLIB. 
FIGURE 17-20
Structural Model of 
Sequential Machine
© Cengage Learning 2014-- The following is a STRUCTURAL VHDL description of the circuit of Figure 16-4.
1 library BITLIB;
2 useBITLIB.bit_pack. all;
3 entity SM16_4 is
4 port (X, CLK: inbit;
5Z : outbit);
6 end SM16_4;
7 architecture Structure ofSM16_4 is
8 signal A1, A2, A3, A5, A6, D3: bit: '0';
9 signal Q1, Q2, Q3: bit: '0';
10 signal Q1N, Q2N, Q3N, XN: bit: '1';
11 begin
12 I1: Inverter port map (X, XN);
13 G1: Nand3 port map (Q1, Q2, Q3, A1);
14 G2: Nand3 port map (Q1, Q3N, XN, A2);
15 G3: Nand3 port map (X, Q1N, Q2N, A3);
16 G4: Nand3 port map (A1, A2, A3, D3);
17 FF1: DFF port map (Q2N, CLK, Q1, Q1N);
18 FF2: DFF port map (Q1, CLK, Q2, Q2N);
19 FF3: DFF port map (D3, CLK, Q3, Q3N);
20 G5: Nand2 port map (X, Q3, A5);
21 G6: Nand2 port map (XN, Q3N, A6);
22 G7: Nand2 port map (A5, A6, Z);
23 end Structure;=
==
606 Unit 17
The   component declarations and definitions are contained in a package called 
bit_pack. The library and use statements are explained in Section 10.7. Because the 
NAND gates and D flip-flops are declared as components in bit_pack, they are not explicitly declared in the VHDL code. Because Q1, Q2, and Q3 are initialized to '0', the complementary flip-flop outputs (Q1N, Q2N, and Q3N) are initialized to '1'. G1 is a 3-input NAND gate with inputs Q1, Q2, Q3, and output A1. FF1 is a D flip-flop (see Figure 17-1) with the D input connected to Q2N. All of the gates and flip-flops in the bit_pack have a default delay of 10 ns. Executing the following simulator command file produces the waveforms of Figure 17-21.
add wave CLK X Q1 Q2 Q3 Zforce CLK 0 0, 1 100 –repeat 200force X 0 0, 1 350, 0 550, 1 750, 0 950, 1 1350run 1600
Next, we will implement the state machine of Table 16-6(a) using a ROM, as 
shown in Figure 16-10. In the VHDL code (Figure 17-22), we have used packages 
from the IEEE library and IEEE Standard Logic because synthesis tools often use std_logic and std_logic_vector as default types. The constant array ROM1 represents the truth table of Table 16-6(c), which is stored in the ROM. Reading data from the ROM is accomplished by four concurrent statements. First, the ROM address, which is the index into the array, is formed by concatenating X and Q to form a 4-bit 
vector. The index is converted from a std_logic_vector to an integer by calling the conv_integer function. The ROM1 output is split into the D vector that represents the next state and the Z output. The process updates the state register on the rising edge of the clock.
Next, we will write behavioral VHDL code for the state table given in Table 13-4. 
We will use a two-process model as we did in Figure 17-17. We will use nested case statements instead of using if-then-else because the state table has more columns. Figure 17-23 shows a portion of the VHDL code for the combinational part of the circuit. The first case statement branches on the state, and the nested case statement for each state defines the Nextstate and outputs by branching on X12
 (= X1&X2 ). 
The second process (not shown) that updates the state register is identical to the one in Figure 17-17.
FIGURE 17-21 Waveforms for Figure 16-4
0 500 1000 1500/clk
/x
/q1
/q2/q3
/z© Cengage Learning 2014
VHDL for Sequential Logic  607
A Moore machine can be modeled using two processes just like a Mealy machine. 
For example, the first row of the Moore table of Table 14-3 could be modeled within 
the combinational process as follows:
case state is when 
0 =>
  Z  <= '0';
  if X ='0' then Nextstate <= 0; else Nextstate <= 1; end if;
 . . .
Note that the Z output is specified before X is tested because the Moore output only 
depends on the state and not on the input.FIGURE 17-22
Sequential Machine 
Using a ROM
© Cengage Learning 20141 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity SM16_6 is
6 Port ( X :instd_logic;
7 CLK : instd_logic;
8Z  : outstd_logic);
9 end SM16_6;
10 architecture ROM ofSM16_6 is
11 type ROM16X4 is array (0 to15) ofstd_logic_vector (0 to3);
12 constant ROM1: ROM16X4 : ("1001", "1011", "0100", "0101",
, " 0 0 0 0 " , " 0 0 0 1 " , " 0 0 0 0 " , " 1 0 1 1 " 3 1
, " 1 0 1 1 " , " 0 0 1 1 " , " 0 0 1 0 " , " 0 1 0 0 " 4 1
; ) " 0 0 0 0 " , " 0 0 0 0 " , " 0 0 0 1 " , " 0 1 1 0 " 5 1
16 signal Q, D: std_logic_vector (1 to 3) : "000";
17 signal Index, Romout: std_logic_vector (0 to 3);
18 begin
19 Index X&Q; -- X&Q is a 4-bit vector: X Q1 Q2 Q3
20 Romout ROM1 (conv_integer(Index));
-- this statement reads the output from the ROM
-- conv_integer converts Index to an Integer
21 Z Romout(0);22 D Romout(1 to3);
23 process (CLK)
24 begin
25 ifCLK'event and CLK '1' then Q D ;  end if;
26 end process ;
27 end ROM;=
=
 <=
 <=
 <=
 <=
 <= =
608 Unit 17
17.5 Synthesis of VHDL Code
The synthesis software for VHDL translates the VHDL code to a circuit description 
that specifies the needed components and the connections between the components. When writing VHDL code, you should always keep in mind that you are designing hardware, not simply writing a computer program. Each VHDL statement implies certain hardware requirements. So poorly written VHDL code may result in poorly designed hardware. Even if VHDL code gives the correct result when simulated, it may not result in hardware that works correctly when synthesized. Timing prob-lems may prevent the hardware from working properly even though the simulation results are correct.
The synthesis software tries to infer the components needed by “looking” at the 
VHDL code. In order for code to synthesize correctly, certain conventions must be followed. In order to infer flip-flops or registers that change state on the rising edge of a clock signal, an if clause of the form
if clock'event and 
clock='1' then . . . end if;
is required by most synthesizers. For every assignment statement between then and 
end if in the preceding statement, a signal on the left side of the assignment will cause FIGURE 17-23
Partial VHDL Code 
for the Table of 
Figure 13-4
© Cengage Learning 20141 entity Table_13_4 is
2 port(X1, X2, CLK: inbit; Z1, Z2: outbit);
3 endTable_13_4;
4 architecture T1 ofTable_13_4 is
5 signal State, Nextstate: integer range 0 to3: 0;
6 signal X12: bit_vector(0 to1);
7 begin
8 X129 process (State, X12)
10 begin
11 case State is
12 when 0 =>
13 case X12 is
14 when "00" Nextstate 3; Z1 '0'; Z2 '0';
15 when "01" Nextstate 2; Z1 '1'; Z2 '0';
16 when "10" Nextstate 1; Z1 '1'; Z2 '1';
17 when "11" Nextstate 0; Z1 '0'; Z2 '1';
18 when others null; -- not required since X is a bit_vector
19 end case;
20 when 1 -- code for state 1 goes here, etc.=
<=  X1&X2;
<=
<=
<=
<=<=
<=
<=
<=<=
<=
<=
<= =>
 =>
 =>
 =>
=>
= >
VHDL for Sequential Logic  609
creation of a register or flip-flop. The moral to this story is: If you do not want to cre-
ate unnecessary flip-flops, do not put the signal assignments in a clocked process. If clock' event is omitted, the synthesizer may produce latches instead of flip-flops.
Before synthesis is started, we must specify a target device so that the synthesizer 
knows what components are available. We will assume that the target is a CPLD or FPGA that has D flip-flops with clock enable (D-CE flip-flops). We will synthesize the VHDL code for a left-shift register (Figure 17-10). Q and D are 4-bit vectors. Because updates to Q follow “CLK'event and 
CLK ='1' then”, this infers that Q 
must be a register composed of four flip-flops, which we will label Q3, Q2, Q1, and Q0. Because the flip-flops can change state when Clr, Ld, or Ls is '1', we connect the clock enables to an OR gate whose output is Clr +Ld +Ls. Then, we connect 
gates to the D inputs to select the data to be loaded into the flip-flops. If 
Clr=0 and 
Ld =1, D is loaded into the register on the rising clock edge. If Clr=Ld =0 and 
Ls =1, then Q2 is loaded into Q3, Q1 is loaded into Q2, etc. Figure 17-24 shows the 
logic circuit for the first two flip-flops. If Clr=1, the D flip-flop inputs are 0, and the 
register is cleared.
A VHDL synthesizer cannot synthesize delays. Clauses of the form “ after time-
expression” will be ignored by most synthesizers, but some synthesizers require that after clauses be removed. Although the initial values for signals may be specified in port and signal declarations, these initial values are ignored by the synthesizer. A reset signal should be provided if the hardware must be set to a specific initial state. Otherwise, the initial state of the hardware may be unknown, and the hardware may malfunction. When an integer signal is synthesized, the integer is represented in hardware by its binary equivalent. If the range of an integer is not specified, the synthesizer will assume the maximum number of bits, usually 32. Thus,
signal count: integer range 0 to 7;
would result in a 3-bit counter, but
signal count: integer;
could result in a 32-bit counter.
FIGURE 17-24
Synthesis of 
VHDL Code From 
Figure 17-10
© Cengage Learning 2014CE DQ3 Q2
CLK
Clr′ LdLdClr
Ls
Ld′ Ls D3Clr′ Q2CE D
CLK
Clr′ Ld Ld′ Ls D2Clr′ Q1...
610 Unit 17
VHDL signals retain their current values until they are changed. This can result 
in the creation of unwanted latches when the code is synthesized. For example, in a 
combinational process, the statement
if X ='1' then B < = 1; end if;
would create latches to hold the value of B when X changed to '0'. To avoid the crea-
tion of unwanted latches in a combinational process, always include an else clause in 
every if statement. For example,
if X ='1' then B < = 1 else B  < = 2; end if;
would create a MUX to switch the value of B from 1 to 2.
Figure 17-25 shows the VHDL code for a 4-bit adder with accumulator. When 
the synthesizer analyses this code, it infers the presence of a 4-bit adder with carry in and carry out from line 14. When it analyses the clocked process, it infers from 
1 library IEEE;
2 use IEEE.STD_LOGIC_1164.ALL;
3 use IEEE.STD_LOGIC_UNSIGNED.ALL;
4 entity adder is
5 Port (B: in std_logic_vector(3 downto 0);
6 Ld, Ad, Cin, CLK : in std_logic;
7 Aout : out std_logic_vector(3 downto 0);
8 Cout : out std_logic);
9 end adder;
10 architecture Behavioral of adder is
11 signal A : std_logic_vector(3 downto 0);
12 signal Addout : std_logic_vector(4 downto 0);
13 begin
14 Addout ('0' & A) B Cin;15 Cout Addout(4);16 Aout A;17 process (CLK)
18 begin
19 if CLK'event and CLK      '1' then
20 if Ld
21 elsif Ad
22 then A
23 end if;
24 end if;
25 end process ;
26 end Behavioral;A (3:0)
0 1
4-bit AdderCE
CLK 44
44
B440
CinCoutAout
Ld
LdAd
=   
= '1' then A <= B; 
= '1'
<= Addout(3 downto 0); <=<=<= ++FIGURE 17-25 VHDL Code and Synthesis Results for 4-Bit Adder with Accumulator
© Cengage Learning 2014
VHDL for Sequential Logic  611
lines 11, 19, and 20 that A is a 4-bit register that changes state on the rising clock 
edge. It also infers the presence of a 4-wide 2-to-1 multiplexer to select either B or the adder  output to load into A. Because A is loaded when Ld=1 or 
Ad=1, 
the CE input to the register is Ld+Ad. At this point, a block diagram of the syn-
thesized code resembles that shown in Figure 17-25. The synthesizer output is then optimized and fit into a specific target device.
17.6 More About Processes 
and Sequential Statements
An alternative form for a process uses wait statements instead of a sensitivity list. 
A process cannot have both a wait statement and a sensitivity list. A process with wait statements may have the form
processbegin sequential-statements wait-statement sequential-statements wait-statement . . .end process;
This process will execute the sequential-statements until a wait statement is 
encountered. Then, it will wait until the specified wait condition is satisfied. It will 
then execute the next set of sequential-statements until another wait is encountered. It will continue in this manner until the end of the process is reached. Then, it will start over again at the beginning of the process.
Wait statements can be of three different forms:
wait on sensitivity-list;
wait for time-expression;wait until Boolean-expression;
The first form waits until one of the signals on the sensitivity list changes. For 
example, wait on A,B,C; waits until A, B, or C changes and, then, execution pro-
ceeds. The second form waits until the time specified by time expression has lapsed. 
If wait for 5
  ns is used, the process waits for 5   ns before continuing. If wait for 0  ns is 
used, the wait is for one Δ time. Wait statements of the form wait for xx ns are use-
ful for writing VHDL code for simulation; however, they should not be used when  writing VHDL code for synthesis because they are not synthesizable. For the third form of wait statement, the Boolean expression is evaluated whenever one of the signals in the expression changes, and the process continues execution when the expression evaluates to TRUE. For example,
wait until 
A=B;
612 Unit 17
will wait until either A or B changes. Then, A=B is evaluated, and if the result is 
TRUE, the process will continue, or else the process will continue to wait until A or 
B changes again and A=B is TRUE.
After a VHDL simulator is initialized, it executes each process with a sensitivity 
list one time through, and then waits at the beginning of the process for a change in one of the signals on the sensitivity list. If a process has a wait statement, it will ini-tially execute until a wait statement is encountered. Therefore, the following process is equivalent to the one in Figure 17-15:
processbegin 
C < = A and B after 5  ns;
 E < = C or D after 5  ns;
 wait on A, B, C, D;
end process;
The wait statement at the end of the process replaces the sensitivity list at the begin-ning. In this way both processes will initially execute the sequential statements one time and, then, wait until A, B, C, or D changes.
The order in which sequential statements are executed in a process is not neces-
sarily the order in which the signals are updated. Consider the following example:
processbegin wait until CLK'event and CLK =
'1';
 A <= E after 1 0  ns; -- (1)
 B <= F after 5  ns; -- (2)
 C <= G; -- (3)
 D <= H after 5  ns; -- (4)
end process;
This process waits for a rising clock edge. Suppose the clock rises at time =20 ns.  
Statements (1), (2), (3), (4) immediately execute in sequence. A is scheduled to change to E at time =30 ns; B is scheduled to change to F at time =25 ns; C is 
scheduled to change to G at time =20+Δ
  ns; and D is scheduled to change to H 
at time 25 ns. As simulated time advances, first, C changes. Then, B and D change at time =25 ns, and finally A changes at time 30 ns. When clk changes to '0', the wait 
statement is re-evaluated, but it keeps waiting until clk changes to '1', and then the remaining statements execute again.
If several VHDL statements in a process update the same signal at a given time, 
the last value overrides. For example,
process (CLK)begin if CLK'event and 
CLK='0' then
  Q <= A;  Q <= B;  Q <= C;
 end if;
end process;
Every time CLK changes from '1' to '0', after Δ time, Q will change to C.
VHDL for Sequential Logic  613
In this unit, we have introduced processes with sensitivity lists and processes with 
wait statements. The statements within a process are called sequential statements 
because they execute in sequence, in contrast with concurrent statements that exe-cute only when a signal on the right-hand side changes. Signal assignment statements can be either concurrent or sequential. However, if and case statements are always sequential, yet conditional signal assignment statements and selected signal assign-ment statements can only be concurrent.
Problems
17.1 Write VHDL code for a T flip-flop with an active-low asynchronous clear.
17.2 Write VHDL code for the following right-shift register with synchronous clear.
Q3 Q2 Q1
Right SRQ0 Ld
D3 D2 D1 D0CLKRS
CLR Lin
17.3 A 4-bit up/down binary counter with output Q works as follows: All state changes 
occur on the rising edge of the CLK input, except the asynchronous clear (ClrN). When 
ClrN=0, the counter is reset regardless of the values of the other inputs.
If the LOAD input is 0, the data input D is loaded into the counter.If L
OAD =ENT =ENP =UP=1, the counter is incremented.
If LOAD =ENT =ENP =1 and UP=0, the counter is decremented.
If ENT =UP=1, the carry output (CO)=1 when the counter is in state 15.
If ENT =1 and UP=0, the carry output (CO)=1 when the counter is in state 0.
(a) Write a VHDL description of the counter.
(b) Draw a block diagram and write a VHDL description of an 8-bit binary 
up/ down counter that uses two of these 4-bit counters.
17.4 Represent the given circuit using a process with a case statement.
I0
I1 CC′
D
C′
D
D′
ABZI2
I3
614 Unit 17
17.5 Write a VHDL module for the sequential machine of Table 14-1. Use two processes 
as in Figure 17-17.
17.6 (a)  Draw a block diagram showing how Table 13-4 can be realized using a ROM 
and D flip-flops (rising-edge trigger).
(b) Write VHDL code for the circuit of part (a). Use a straight binary state assign-
ment and form the ROM address as X1&X2&Q1&Q2.
17.7 (a)  Draw a circuit that implements the following VHDL code using gates and 
D-CE flip-flops.
signal A,B,Q: bit_vector(1 to 2);
-------------------------------process(CLK) if CLK'event and 
CLK='0' then
  if L dA='1' then Q < = A;
   elsif L dB='1' then Q < = B;
  end if; end if;
end process;
(b) Show how your circuit can be simplified if LdA =LdB ='1' can never occur. 
Use MUXes and D-CE flip-flops in your simplified circuit.
17.8 In the following VHDL process, A, B, C, and D are all integers that have a value of 
0 at time =10
  ns. If E changes from '0' to '1' at time 20   ns, specify the time at which 
each signal will change and the value to which it will change.
p1: process wait on E;
 
A <=  1 after 15   ns;
 B <=  A+1;
 C <=  B+1 after 1 0  ns;
 D <=  B+2 after 3  ns;
 A <=  A+5 after 15   ns;
 B <=  B+7;
end process p1;
17.9 Write the VHDL code for an S-R flip-flop with a rising-edge clock. Use standard 
logic, and output 'X' if S=R='1' at a rising clock edge.
17.10 Write a VHDL module for a D-G latch, using the code of Figure 17-2. Then, write 
a VHDL module to implement the D flip-flop shown in Figure 11 -19, using two instances of the D-G latch module you wrote.
17.11 What device is described by the following VHDL code?
VHDL for Sequential Logic  615
process(CLK, CLR, PRE)
 if CLR='1' then Q  <=  '0';
  elsif PRE ='1' then Q  <=  '1';
  elsif CLK'event and CLK='1' and CE='1' then Q <=  D;
 end if;
end process;
17.12 Write the VHDL code for an 8-bit register with data inputs and tri-state outputs. Use 
control inputs Ld (Load) and En (tri-state output enable).
17.13 Implement a 4-to-2 priority encoder using if and elsif statements.
17.14 Write a VHDL module for a 4-bit comparator. The comparator has two inputs, A 
and B, which are 4-bit std_logic vectors; and three std_logic outputs, AGB, ALB, and AEB. A
GB='1' if A is greater than B, ALB ='1' if A is less than B, ALB ='1' if 
A and B are equal.
17.15 Write the VHDL code for a 6-bit Super-Register with a 3-bit control input A. The 
register operates according to the following table:
A Action
000 Hold State
001 Shift Left010 Shift Right011 Synchronous Clear100 Synchronous Preset101 Count Up110 Count Down111 Load
The register also has a 6-bit output (Q), a 6-bit input (D), a Right-Shift-In input 
(RSI), and a Left-Shift-In input (LSI). Use a case statement.
17.16 Write VHDL code that will display the value of a BCD input on a seven-segment 
display. Use a single process with a case statement to model this combinational cir-
cuit. Refer to Figure 8-15 for a diagram of the seven-segment display.
17.17 The Mealy and Moore circuits shown both produce an output that is the exclusive-
OR of two consecutive inputs. Assume each of the flip-flops has a propagation delay of 10
  ns both from the clock edge and from ClrN, and the exclusive-OR gate has a 
10   ns propagation delay. ClrN is an asynchronous clear.
(a) Create a VHDL dataflow model for the Mealy circuit. Assign type std_logic to 
all signals.
(b) Simulate your code for 400   ns, and record the waveforms for the following input 
patterns:
ClrN 0 at 0  ns, 1 at 20   ns
x 1 at 0  ns, 0 at 60   ns, 1 at 140   ns, 0 at 220   ns
CLK symmetrical 80   ns period starting at 0
616 Unit 17
(c) Repeat part (a) for the Moore circuit.
(d) Repeat part (b) for the Moore circuit.
(e) Explain the differences in the outputs from the two circuits. On the waveforms, 
show the input and output sequences for the two circuits.
CLKx
CkDQ
Q′
clrqz
ClrNCkDQ
Q′
clrQ2Z
CLKX
CkDQ
Q′
clr
ClrNQ1
17.18 A modulo 8 counter cycles through the states Q0Q1Q2Q3=1000, 1100, 0100, 0110,
0010, 0011, 0001, 1001. The counter has eight outputs: Z0=1 when the counter is 
in state 1000 and the CLK is 0 and Z0=0 otherwise; Z1=1 when the counter is in 
state 1100 and the CLK is 0 and Z1=0 otherwise, . . .; Z7=1 when the counter is 
in state 1001 and the CLK is 0 and Z7=0 otherwise. The counter has an asynchro-
nous, active-low reset input ClrN.
(a) Derive minimum equations for the counter outputs.
(b) Assume the counter is implemented using D flip-flops. Find minimum input 
equations for the flip-flops.
(c) Assume the counter is implemented using D-CE flip-flops. Find minimum input 
equations for the flip-flops.
(d) Write a VHDL behavioral description of the counter. Assume the flip-flops are 
positive edge triggered.
(e) Write a VHDL dataflow description of the counter using the equations from 
part (b). Simulate the counter for a cycle to verify your code.
(f  ) Write a VHDL dataflow description of the counter using the equations from 
part (c). Simulate the counter for a cycle to verify your code.
17.19 Repeat Problem 17 . 18 for a modulo 8 counter that cycles through the states 
Q0Q1Q2Q3=1000, 1100, 1110, 0110, 0010, 0011, 1011, 1001.
17.20 Shown is an iterative circuit for comparing two 4-bit positive numbers. All of the 
Cmp modules in the circuit are the same. With the proper inputs for ig and ie, the 
outputs are og =1 and oe =0 if the x is larger than y, og=0 and oe =1 if x and y 
are equal, and og =0 and oe =0 if y is larger than x.
(a) Derive the logic equations that describe the Cmp module.
(b) Using your equations from part (a), write VHDL code that gives a dataflow 
description of a Cmp module.
(c) Using the VHDL module defined in part (b), write structural VHDL code that 
specifies the 4-bit comparator.
VHDL for Sequential Logic  617
(d) Use the Direct VHDL simulator to obtain the signal values for the three input 
combinations: x=0100 y=0011, x=0011 y=0100, and x=0001 y=0001. 
Record the waveform report from the simulator.
x3y3 x2y2 x1y1 x0y0
Cmp3ig
ieCmp2og
oeCmp1 Cmp0
17.21  The following iterative circuit is a priority selection circuit. When one or more of the 
inputs is 1, osel =0 and yi=1 where i  is the largest index such that xi=1. If none 
of the inputs is 1, then all outputs are 0 and osel =1. The four modules in the circuit 
are identical.
(a) Derive the logic equations that describe the Pr module.
(b) Using your equations from part (a), write VHDL code that gives a dataflow 
description of the Pr module.
(c) Using the VHDL module defined in part (b), write structural VHDL code that 
specifies the 4-bit priority selector.
(d) Use the Direct VHDL simulator to obtain the signal values for the three input 
combinations: x=1000,   x=0111, and x=0000 . Record the waveform report 
from the simulator.
17.22 A Mealy sequential machine with one input ( X) and one output ( Z) has the follow-
ing state table.Pr3 isel Pr2 osel Pr1 Pr0x3x2x1x0
y3y2y1y0
Present 
StateNext State Z
X=0 X=1 X=0X=1
S0 S1S 0 0 0
S1S 0 S 210
S2 S3 S2 1 1
S3 S0 S101
618 Unit 17
Write a VHDL module for the sequential machine using a ROM (as in Figure 17-22) 
and a straight binary assignment.
17.23 Repeat Problem 17 . 22 using equations as in Figure 17-19 and using a one-hot state 
assignment. (Hint: It may be easier to do the one-hot state assignment properly if you draw the state graph first.)
17.24 The following VHDL code is for a 2-to-1 MUX, but it contains mistakes. What are 
the mistakes?
library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity mux2 is port (d0, d1 : in bit;
 sel : in Boolean;
 z : out bit);
end mux2;
architecture bvhr of mux2 is
 signal muxsel : integer range 0 to 1;
begin  process(d0, d1, select)  begin muxse
l <=  0;
 if sel then muxse l <= muxse l+1; end if;
 case muxsel is
   when 0  =>  z < = d0 after 2ns;
   when 1  =>  z <  = d1 after 2ns;
 end case;
  end process;end bvhr;
17.25 Give the state table implemented by the following VHDL code.
entity Problem17_25 is port(X, CLK: in bit;
 Z1, Z2: out bit);
end Problem17_25;
architecture Table of Problem17_25 is
 signal State, Nextstate: integer range 0 to 
3 : = 0;
begin
 process(State, X)  --Combinational Circuit
 begin
  case State is  when 
0 =>
VHDL for Sequential Logic  619
   if X ='0' then Z1  <= '1'; Z2 <= '0'; Nextstate  <= 0;
   else Z1  <=  '0'; Z2 <=  '0'; Nextstate  <=  1; end if;
  when 1 = >
   if X ='0' then Z1  <= '0'; Z2 <= '1'; Nextstate  <= 1;
   else Z1  <=  '0'; Z2 <= '1'; Nextstate  <= 2; end if;
  when 2 = >
   if X ='0' then Z1  <= '0'; Z2 <= '1'; Nextstate  <= 2;
   else Z1  <=  '0'; Z2 <=  '1'; Nextstate  <=  3; end if;
  when 3 = >
   if X ='0' then Z1  <= '0'; Z2 <= '0'; Nextstate  <= 0;
   else Z1  <= '1'; Z2 <= '0'; Nextstate  <= 0; end if;
  end case;
 end process;
 process(CLK)  -- State Register
  begin   if CLK'event and 
CLK='1' then  -- rising edge of clock
   State <= Nextstate;
  end if; end process;
end Table;
17.26 Give the state table implemented by the following VHDL code.
entity Problem17_26 is port(X, CLK: in bit;
  Z: out bit);
end Problem17_26;architecture Table of Problem17_26 is
 signal State, Nextstate: integer range 0 to 
3 : = 0;
begin process(State, X)  --Combinational Circuit
 begin
  case State is  when 0
 =>  Z <= '1';
   if X ='0' then Nextstate  <=  1;
   else Nextstate  <= 2; end if;
  when 1  =>  Z <=  '0'
   if X ='0' then Nextstate  <=  3;
   else Nextstate  <= 2; end if;
  when 2  =>  Z <= '0';
   if X ='0' then Nextstate  <= 1;
   else Nextstate  <= 0; end if;
  when 3  =>  Z <= '0';
   if X ='0' then Nextstate  <= 0;
   else Nextstate  <= 1; end if;
620 Unit 17
  end case;
 end process;
-- the clocked process goes here, same as in Problem 17.25end Table;
17.27 Give the state table implemented by the following VHDL code.
entity Problem17_27 is port(X1, X2, CLK: in bit;
  Z: out bit);
end Problem17_27;
architecture Table of Problem17_27 is
 signal State, Nextstate: integer range 0 to 
2 :  = 0;
 signal X12: bit_vector(0 to 1);
begin
 X12  <=  X1&X2;
 process(State, X12)  --Combinational Circuit
 begin
  case State is  when 0
 =>  Z <= '0';
   case X12 is    when 
"00" => Nextstate  <= 0;
    when "01" => Nextstate  <= 1;
    when "10" => Nextstate  <= 2;
    when "11" => Nextstate  <= 0;
   end case;  when 1
 =>  Z <=  '0';
   case X12 is    when 
"00" => Nextstate  <= 0;
    when "01" => Nextstate  <= 1;
    when "10" => Nextstate  <= 2;
    when "11" => Nextstate  <= 1;
   endcase;  when 2
 =>  Z <= '1';
   caseX12is    when 
"00" => Nextstate  <= 0;
    when "01" => Nextstate  <= 1;
    when "10" => Nextstate  <= 2;
    when "11" => Nextstate  <= 2;
   end case;  end case; end process;
-- the clocked process goes here, same as in Problem 17.25.end Table;
VHDL for Sequential Logic  621
17.28 The VHDL specification for a state machine follows. It has one binary input (plus a 
clock and reset) and one binary output.
(a) Construct a state table for this state machine.
(b) Simulate the circuit for the input sequence xin =0101110111, record the wave-
form and list the output sequence produced. Assume that changes in xin occur 
1/4 clock period after the rising edge of CLK.
(c) Find a minimum row state table that describes this state machine.
(d) What input sequences cause the output to become 1? ( Hint: The machine recog-
nizes sequences ending in two different patterns.)
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;entity pttrnrcg is port (CLK, rst, xin : in std_logic;
 zout : out std_logic);
end pttrnrcg;
architecture sttmchn of pttrnrcg is
  type mchnstate is 
(s1,  s2,  s3,  s4,  s5,  s6,  s7,  s8,  s9,  s10);
  signal state, nextstate: mchnstate;
begin
  cmb_lgc: process(state, xin)
  begin case state is
   when s
1 =>
  zout <=  '0';
  if xin ='0' then nextstate <=  s2; else nextstate <= s10; end if;
   when s 2 =>
  zout <= '0';
  if xin ='0' then nextstate <=  s2; else nextstate <= s3; end if;
   when s 3 =>
  zout <= '1';
  if xin ='0' then nextstate <=  s4; else nextstate <=  s6; end if;
   when s 4 =>
  zout <= '0';
  if xin ='0' then nextstate <=  s7; else nextstate <=  s8; end if;
   when s 5 =>
  zout <= '1'; 
  if xin ='0' then nextstate <=  s9; else nextstate <=  s10; end if;
   when s 6 =>
  zout <= '0';
  if xin ='0' then nextstate <=  s9; else nextstate <=  s10; end if;
   when s 7 =>
  zout <= '0';
  if xin ='0' then nextstate <=  s2; else nextstate <=  s3; end if;
   when s 8 =>
622 Unit 17
  zout <= '1';
  if xin ='0' then nextstate <= s 4; else nextstate <= s 5; end if;
   when s 9 =>
  zout <= '0';
  if xin ='0' then nextstate <= s 7; else nextstate <= s 8; end if;
   when s1 0 =>
  zout <= '0';
  if xin ='0' then nextstate <= s 9; else nextstate <= s1 0; end if;
 end case;
  end process cmb_lgc;
  stt_trnstn: process(CLK,rst)
  begin if r
st='1' then
   state <= s 1;
   elsif Rising_Edge (CLK) then
   state <= nextstate; end if;
  end process stt_trnstn;end sttmchn;
17.29 The VHDL specification for a sequential circuit follows. It has one binary input 
(plus a clock and reset) and one binary output. Four architectures are given for the sequential circuit.
(a) For each of these architectures, draw the schematic described by the architec-
ture. Use D flip-flops and AND, OR, and NOT gates.
(b) What differences exist in the outputs produced by these architectures?
 library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity diff1 is   port (CLK, rst, xin : in std_logic;   zout : out std_logic); end diff1;
 architecture df1 of diff1 is
  signal y0,y1,nxty0,nxty1 : std_logic;
 begin   process(y0,y1,xin)   begin  zout
 < = y0 AND (xin XOR y1); nxty 0 < =  NOT y0;  nxty1  < = xin;
   end process;   process(CLK,rst)   begin  if r
st='1' then
    y0  < = '0'; y1 < = '0';
    elsif Rising_Edge (CLK) then
VHDL for Sequential Logic  623
   y 0 < = nxty0;  y1 < = nxty1;
 end if;
  end process;
end df1;
architecture df2 of diff1 is
 signal y0,y1,nxty0,nxty1 : std_logic;
begin zout
 < = y0 AND (xin XOR y1); nxty 0 < =  NOT y0;  nxty1  < = xin;
  process(CLK,rst)  begin if r
st='1' then
   y0  < = '0';  y1 < = '0';
   elsif Rising_Edge (CLK) then
   y 0 < = nxty0;  y1 < = nxty1;
 end if;
  end process;end df2;
architecture df3 of diff1 is
 signal y0,y1 : std_logic;
begin zout
 < = y0 AND (xin XOR y1);
  process(CLK,rst)  begin if r
st='1' then
   y0  < = '0'; y1 < = '0';
   elsif Rising_Edge (CLK) then
   y 0 < =  NOT y0;  y1 < = xin;
 end if;
  end process;end df3;
architecture df4 of diff1 is
 signal y0,y1 : std_logic;
begin  process(CLK,rst)  begin if r
st='1' then
   y0  < = '0';  y1 < = '0';  zout < = '0';
   elsif Rising_Edge (CLK) then
   y 0 < =  NOT y0;   y1 < = xin;   zout < = y0 AND (xin XOR y1);
 end if;
  end process;end df4;
624 Unit 17
17.30 Write a VHDL module for an 8-bit mask circuit. When the signal Store = 1, the 8-bit 
input X is stored in an 8-bit mask register M. The 8-bit output Z of the mask circuit 
is always the AND of the bits of M with the corresponding bits of X. The circuit 
should also have an asynchronous active-high signal Set, which will set all the bits 
of M to 1.
17.31 Write a VHDL module for the sequential machine of Table 14-3. Use two processes 
as in Figure 17-17.
Simulation Problems
17.A Write a behavioral VHDL module that implements the 8-bit shift register of Figure 12-8. Do not use individual flip-flops in your code. Add an active-low asyn-chronous reset input, ClrN. Simulate the module to obtain a timing diagram similar to Figure. 12-9. Then, write VHDL code for a 16-bit serial-in, serial-out shift register using two of these modules.
17.B Write a VHDL module for a 4-bit counter with enable that increments by different amounts, depending on the control input C. If En =
0, the counter holds its state. 
Otherwise, if C=0, the counter increments by 1 every rising clock edge, and if C=1, 
the counter increments by 3 every rising clock edge. The counter also has an active-low asynchronous preset signal, PreN.
17.C Write a VHDL module to implement a counter that counts in the following sequence: 000, 010, 100, 110, 001, 011, 101, 111, (repeat) 000, etc. Use a ROM and D flip-flops.
17.D Write a VHDL module to implement a circuit that can generate a clock signal whose time period is a multiple of the input clock. A control signal F determines the multiplying factor. If F =
0, the output signal has a time period twice that of 
the input clock. If F =1, the output signal has a time period three times that of the 
input clock. The portion of the clock cycle when the clock is 1 may be longer than the portion when it is 0, or vice versa. Use a counter with an active-high synchronous clear input.
17.E Write a VHDL module to implement an 8-bit serial-in, serial-out right-left shift  register with inputs RSI, LSI, En, R, and CLK. RSO and LSO are the serial outputs, 
so they should be the rightmost and leftmost bits of the register. However, the val-ues of the other flip-flops inside the register should not appear on the outputs. When En=1, at the rising edge of the clock, the register shifts right if R =1 or left if R =
0.  
RSI should be the shift-in input if R =1, and LSI should be the shift-in input if R =0.  
When En =0, the register holds its state. There should also be an asynchronous active-
low clear input ClrN.
VHDL for Sequential Logic  625
17.F Work Problem 17.E, but change the register to 6 bits, remove the input En, and add 
an input L. At the rising edge of the clock, if R =1 and L =0, the register shifts right. 
If R =0 and L =1, the register shifts left. If R =L=0 or R =L=1, the register 
holds its state.
17.G Write a VHDL module for a 6-bit accumulator with carry-in (CI) and carry-out (CO). When Ad =0, the accumulator should hold its state. When Ad =1, the accu-
mulator should add the value of the data inputs D (plus CI) to the value already in the accumulator. The accumulator should also have an active-low asynchronous clear signal ClrN.
17.H Write a VHDL module for a 4-bit up-down counter. If En =
0, the counter will hold 
its state. If En =1, the counter will count up if U=1 or down if U=0. The counter 
should also have an asynchronous active-low clear signal ClrN.
17.I Write a VHDL module for a 6-bit up-down counter. If U=1 and D =0, the counter 
will count up, and if U=0 and D =1, the counter will count down. If U=D=0 or 
U=D=1, the counter will hold its state. The counter should also have an asynchro-
nous active-low preset signal PreN that sets all flip-flops to 1.
17.J Write a VHDL module for a memory circuit. The memory stores four 6-bit words in registers. The output Memout is always the value of the memory register selected by the 2-bit select signal Sel. Use tri-state buffers to connect the register outputs. If Ld =1, the register specified by Sel will load the value of the 6-bit input signal 
Memin at the next rising clock edge.
17.K Write a VHDL module for the Parallel-in, Parallel-out right-shift register of Figure 12-10, but add an active-low asynchronous clear signal ClrN. Do not use indi-vidual flip-flops in your code. Simulate the module to obtain a timing diagram simi-lar to Figure 12-11.
17.L Write a VHDL module for an 8-bit accumulator which can also shift the bits in the accumulator register to the left. If Ad =1, the accumulator should add the value 
of the data inputs D to the value already in the accumulator. If Ad =0 and 
Sh=1,  
the bits in the accumulator should shift left (i.e., multiply by 2). If Ad =Sh=0, 
the accumulator should hold its state. The accumulator should also have an active-low asynchronous clear signal ClrN. Assume that carry-in and carry-out signals are unnecessary for this application. Use an overloaded “
+” operator for addition.
17.M Write a VHDL module for an 8-bit accumulator for subtraction, which can also shift the accumulator bits to the right. There are two control inputs, A and B. If A =B=1,  
the value of the data inputs D are subtracted from the accumulator. If A =1 and 
B=
0, the value of the data inputs D are loaded directly into the register. If A=0 
and B =1, the accumulator should shift right with zero fill. If A=B=0, the accu-
mulator should hold its state. Use an overloaded “ −” operator for subtraction.
626Circuits for Arithmetic 
OperationsUNIT
18
Objectives
1. Analyze and explain the operation of various circuits for adding, subtracting, 
multiplying, and dividing binary numbers and for similar operations.
2. Draw a block diagram and design the control circuit for various circuits for adding, subtracting, multiplying, and dividing binary numbers and for similar operations.
Circuits for Arithmetic Operations  627
Study Guide
1. Study Section 18.1, Serial Adder with Accumulator.
(a) Study Figure 18-2 carefully to make sure you understand the operation 
of this type of adder. Work out a table similar to Table 18-1 starting with 
X=6 and Y =3:
X Y ci sic+
i
t0 0110 0011
t1
t2
t3
t4
(b) What changes would be made in this table if the SI input to the addend 
register (Figure 18-1) was connected to a logic 0 instead of to y0?
(c) Note in Table 18-1 that when the adding has finished, the full adder still gener-
ates a sum and a carry output. The full adder consists of combinational logic, 
so it will still automatically do the work of calculating its outputs even when they are not needed. What bits are added to generate the last values of s
i and 
c+
i? (See Figure 18-2(e).) Are the last values of si and c+
i useful for anything?
(d) Work Problem 18.3.
2. Study Section 18.2, Design of a Binary Multiplier.
(a) For the binary multiplier of Figure 18-7 , if the initial contents of the accu-
mulator is 000001101 and the multiplicand is 1111, show the sequence of 
add and shift signals and the contents of the accumulator at each time step.
(b) For the state graph of Figure 18-8, what is the maximum number of clock 
cycles required to carry out the multiplication? The minimum number?
628 Unit 18
(c) For the state graph of Figure 18-9(c), assuming the counter sets K=1 when 
the counter is in state 3 (112), what is the maximum number of clock cycles 
required to carry out the multiplication? The minimum number?
(d) For Figure 18-7 , how many bits would be required for the product register 
if the multiplier was 6 bits and the multiplicand was 8 bits?
(e) Work Problems 18.4 and 18.5.
(f  ) Consider the design of a binary multiplier which multiplies 8 bits by 8 bits to 
give a 16-bit product. What changes would need to be made in Figure 18-7?
If a multiplier control of the type shown in Figure 18-8 were used, how 
many states would be required?
If a control of the type shown in Figure 18-9 is used, how many bits should 
the counter have? K should equal 1 in what state of the counter? How 
many states will the control state graph have?
(g) Work Programmed Exercise  18.1.
3. Study Section 18.3, Design of a Binary Divider.
(a) Using the state graph of Figure 18-11 to determine when to shift or sub-
tract, work through the division example given at the start of this section.
(b) What changes would have to be made in Figure 18-12 if the subtraction was 
done using full adders rather than full subtracters?
(c) For the block diagram of Figure 18-10, under what conditions will an overflow 
occur and why?
(d) Work Programmed Exercise 18.2.
(e) Derive the control circuit equations, Equations (18-1).
(f  ) In Figure 18-13, why is one of the inputs to the bus merger at the 0 input of 
the MUX set to 1?
(g) For a binary multiplier of the type described in Section 18.2, addition is 
done before shifting. Division requires a series of shift and subtract opera-tions. Since division is the inverse of multiplication, which operation should be done first, subtract or shift?
(h) Work Problems 18.6, 18.7 , and 18.8.
Circuits for Arithmetic Operations  629
4. Optional simulation exercises:
(a) Simulate the serial adder of Figure 13-12 and test it.
(b) Connect two 4-bit shift registers to the inputs of the adder that you simu-
lated in (a) to form a serial adder with accumulator (as in Figure 18-1). 
Supply the shift signal and clock signal from switches so that a control circuit is unnecessary. Test your adder using the following pairs of binary numbers:
0101 +0110,
 1011 +1101
(c) Input the control circuit from the equations of Figure 18-4, connect it to the 
circuit which you built in (b), and test it.
5. When you are satisfied that you can meet all of the objectives, take the readi-ness test.
This unit introduces the concept of using a sequential circuit to control a sequence of operations in a digital system. Such a control circuit outputs a sequence of control signals that cause operations such as addition or shifting to take place at the appro-priate times. We will illustrate the use of control circuits by designing a serial adder, a multiplier, and a divider.
18.1 Serial Adder with Accumulator
In this section we will design a control circuit for a serial adder with an accumulator. Figure 18-1 shows a block diagram for the adder. Two shift registers are used to hold the 4-bit numbers to be added, 
X and Y. The X register serves as an accumulator Circuits for Arithmetic 
Operations
630 Unit 18
and the Y register serves as an addend register. When the addition is completed, the 
contents of the X register are replaced with the sum of X and Y. The addend regis-
ter is connected as a cyclic shift register so that after shifting four times it is back in 
its original state, and the number Y is not lost. The box at the left end of each shift 
register shows the inputs: Sh (shift signal), SI (serial input), and Clock. When Sh=1 
and an active clock edge occurs, SI is entered into x3 (or y3) at the same time as the 
contents of the register are shifted one place to the right. The additional connections required for initially loading the 
X and Y registers and clearing the carry flip-flop are 
not shown in the block diagram.
The serial adder, highlighted in blue in the diagram, is the same as the one in 
Figure 13-12, except the D flip-flop has been replaced with a D flip-flop with clock enable. At each clock time, one pair of bits is added. Because the full adder is a combinational circuit, the sum and carry appear at the full adder output after the propagation delay. When 
Sh=1, the falling clock edge shifts the sum bit into the 
accumulator, stores the carry bit in the carry flip-flop, and rotates the addend register one place to the right. Because 
Sh is connected to CE on the flip-flop, the carry is 
only updated when shifting occurs.
Figure 18-2 illustrates the operation of the adder. Shifting occurs on the falling 
clock edge when Sh=1. In this figure, t0 is the time before the first shift, t1 is the 
time after the first shift, t2 is the time after the second shift, etc. Initially, at time t0, 
the accumulator contains X and the addend register contains Y. Because the full 
adder is a combinational circuit, x0, y0, and c0 are added independently of the clock 
to form the sum s0 and carry c1. When the first falling clock edge occurs, s0 is shifted 
into the accumulator and the remaining accumulator digits are shifted one posi-tion to the right. The same clock edge stores c
1 in the carry flip-flop and rotates the 
addend register right. The next pair of bits, x1 and y1, are now at the full adder input, 
and the adder generates the sum and carry, s1 and c2, as seen in Figure 18-2(b). The 
second falling edge shifts s1 into the accumulator, stores c2 in the carry flip-flop, and FIGURE 18-1
Block Diagram for 
Serial Adder with 
Accumulator
© Cengage Learning 2014
Control
CircuitSIAccumulator
Full
Adder
Addend Register
Serial AdderShx3
St (Start Signal)
Clockx2x1x0
SI
CKSh
D
CEQ
Q′Sh y3
ciyisi
ci + 1xi
y2y1y0
Circuits for Arithmetic Operations  631
cycles the addend register right. Bits x2 and y2 are now at the adder input, as seen 
in Figure 18-2(c), and the process continues until all bit pairs have been added, as 
shown in Figure 18-2(e).
Table 18-1 shows a numerical example of the serial adder operation. Initially, 
the accumulator contains 0101 and the addend register contains 0111. At t0, the full 
adder computes 1 +1+0=10, so si=0 and c+
i=1. After the first falling clock FIGURE 18-2
Operation of Serial 
Adder
© Cengage Learning 2014Full
Adder
(a) At time t0x3x2x1x0
y3y2y1y0
Dc0 = 0c1s0
Full
Adder
unused
unused(c) At time t2s1s0x3x2
y1y0y3y2
Dc2c3s2Full
Adder
(b) At time t1s0x3x2x1
y0y3y2y1
Dc1c2s1
Full
Adder
(d) At time t3s2s1s0x3
y2y1y0y3
Dc3c4s3
Full
Adder
(e) At time t4s3s2s1s0
y3y2y1y0
Dc4
TABLE 18-1
Operation of 
Serial Adder
© Cengage Learning 2014X Y CiSiC+
i
t0 0101 0111 0 0 1
t1 0010 1011 1 0 1
t2 0001 1101 1 1 1
t3 1000 1110 1 1 0
t4 1100 0111 0 (1) (0)
632 Unit 18
edge  (time t1) the first sum bit has been entered into the accumulator, the carry 
has been stored in the carry flip-flop, and the addend has been cycled right. After 
four falling clock edges (time t4), the sum of X and Y is in the accumulator, and the 
addend register is back to its original state.
The control circuit for the adder must now be designed so that after receiving a 
start signal, the control circuit will put out four shift signals and then stop. Figure 18-3 shows the state graph and table for the control circuit. The circuit remains in S
0 
until a start signal is received, at which time the circuit outputs Sh=1 and goes to 
S1. Then, at successive clock times, three more shift signals are put out. It will be 
assumed that the start signal is terminated before the circuit returns to state S0 so 
that no further output occurs until another start signal is received. Dashes appear on the graph because once S
1 is reached, the circuit operation continues regardless of 
the value of St. Starting with the state table of Figure 18-3 and using a straight binary 
state assignment, the control circuit equations are derived in Figure 18-4.
A serial processing unit, such as a serial adder with an accumulator, processes data 
one bit at a time. A typical serial processing unit (Figure 18-5) has two shift registers. The output bits from the shift registers are inputs to a combinational circuit. The com-binational circuit generates at least one output bit. This output bit is fed into the input of a shift register. When the active clock edge occurs, this bit is stored in the first bit of the shift register at the same time the registers bits are shifted to the right.
The control for the serial processing unit generates a series of shift signals. When 
the start signal 
(St) is 1, the first shift signal (Sh) is generated. If the shift registers 
FIGURE 18-4
Derivation of 
Control Circuit 
Equations
© Cengage Learning 2014A+B+
AB 01
S0 00 00 01
S1 01 10 10
S2 10 11 11
S3 11 00 00
A+
DA = A ′B + AB ′
= A ⊕ B0001
11
00100ABSt
01
1110 1
B+
DB = St B ′ + AB ′0101
00
00100ABSt
01
1110 1
Sh
Sh = St + A + B0101
11
11
100ABSt
01
11
10 1FIGURE 18-3
State Graph for 
Serial Adder 
Control
© Cengage Learning 2014–/Sh
–/Sh –/ShSt/ShSt ′/0
S1S0
S3
S2Next State Sh
St 01 01
S0 S0 S1 01
S1 S2 S2 11
S2 S3 S3 11
S3 S0 S0 11
Circuits for Arithmetic Operations  633
have n bits, then a total of n shift signals must be generated. If St is 1 for only one 
clock time, then the control state graph (Figure 18-6(a)) stops when it returns to 
state S0. However, if St can remain 1 until after the shifting is completed, then a 
separate stop state is required, as shown in Figure 18-6(b). The control remains in the stop state until 
St returns to 0.
18.2 Design of a Binary Multiplier
Next, we will design a multiplier for positive binary numbers. As illustrated in the example in Section 1.3, binary multiplication requires only shifting and adding. The following example shows how each partial product is added in as soon as it is formed. This eliminates the need for adding more than two binary numbers at a time.
Multiplicand
    1101 (13)
Multiplier         1011 (11)
1101
    1101  
Partial               100111
Products            0000   
100111
1101   
Product             10001111   (143)
The multiplication of two 4-bit numbers requires a 4-bit multiplicand register, a 
4-bit multiplier register, and an 8-bit register for the product. The product register FIGURE 18-5
Typical Serial 
Processing Unit
© Cengage Learning 2014Control StSh
Combinational
CircuitShift Register
Shift Register
FIGURE 18-6
State Graphs for 
Serial Processing 
Unit
© Cengage Learning 2014Sn–1S0
S2S1–/Sh
–/Sh –/Sh–/Sh
–/Sh–/ShSt/Sh St/ShSt′/0
(a)Sn–1StopS0
S2S1St′/0
St/0
St′/0
(b)
bbb
b
634 Unit 18
serves as an accumulator to accumulate the sum of the partial products. Instead of 
shifting the multiplicand left each time before it is added, as was done in the previ-ous example, it is more convenient to shift the product register to the right each time. Figure 18-7 shows a block diagram for such a multiplier. As indicated by the arrows on the diagram, 4 bits from the accumulator and 4 bits from the multiplicand register are connected to the adder inputs; the 4 sum bits and the carry output from the adder are connected back to the accumulator. (The actual connections are similar to the parallel adder with accumulator shown in Figure 12-5.) The adder calculates the sum of its inputs, and when an add signal 
(Ad) occurs, the adder outputs are stored in the 
accumulator by the next rising clock edge, thus causing the multiplicand to be added to the accumulator. An extra bit at the left end of the product register temporarily stores any carry 
(C4) which is generated when the multiplicand is added to the accu-
mulator. Note that when ACC is shifted right, the input to bit 8 of ACC must be 0. Then, a following shift will shift the correct value into bit 7 of ACC. The shift input to ACC is not explicitly shown in Figure 18-7 .
Because the lower four bits of the product register are initially unused, we will 
store the multiplier in this location instead of in a separate register. As each multi-plier bit is used, it is shifted out the right end of the register to make room for addi-tional product bits.
The Load signal loads the multiplier into the lower four bits of ACC and at 
the same time clears the upper 5 bits. The shift signal 
(Sh) causes the contents of 
the product register (including the multiplier) to be shifted one place to the right when the next rising clock edge occurs. The control circuit puts out the proper sequence of add and shift signals after a start signal 
(St=1) has been received. If 
the current multiplier bit (M) is 1, the multiplicand is added to the accumulator 
followed by a right shift; if the multiplier bit is 0, the addition is skipped and only the right shift occurs. The multiplication example at the beginning of this section 
(13×11) is reworked below showing the location of the bits in the registers at 
each clock time.
FIGURE 18-7
Block Diagram for 
Binary Multiplier
© Cengage Learning 2014ACCProduct
C
o
n
t
r
o
lLoad
Sh
Done
St
MAd876543210
Clk
4-Bit Adder
MultiplicandMultiplier
C4
Circuits for Arithmetic Operations  635
The control circuit must be designed to output the proper sequence of add and shift 
signals. Figure 18-8 shows a state graph for the control circuit. The notation used on this graph is defined in Section 14.5. M
/Ad means if M=1, then the output Ad is 1 
(and the other outputs are 0). M ′/Sh means if M ′=1 (M=0), then the output Sh 
is 1 (and the other outputs are 0). In Figure 18-8, S0 is the reset state, and the circuit 
stays in S0 until a start signal (St=1) is received. This generates a Load signal, which 
causes the multiplier to be loaded into the lower 4 bits of the accumulator (ACC) and the upper 5 bits of ACC to be cleared on the next rising clock edge. In state 
S1, the 
low order bit of the multiplier (M) is tested. If M=1, an add signal is generated and, 
then, a shift signal is generated in S2. If M =0 in S1, a shift signal is generated because 
adding 0 can be omitted. Similarly, in states S3, S5, and S7, M is tested to determine 
whether to generate an add signal followed by shift or just a shift signal. A shift signal is always generated at the next clock time following an add signal (states 
S2, S4, S6, and 
S8). After four shifts have been generated, all four multiplier bits have been processed, 
and the control circuit goes to a Done state and terminates the multiplication process.initial contents of product register 000001011 ←M (11)
(add multiplicand because M =1) 1 1 0 1 (13)
after addition 011011011
after shift 001101101 ←M
(add multiplicand because M =1 ) 1101
after addition 100111101
after shift 010011110 ←M
(skip addition because M =0)
after shift 001001111 ←M
(add multiplicand because M =1 ) 1101
after addition 100011111
after shift (final answer) 010001111 ( 1 4 3 )
dividing line between product and multiplier
FIGURE 18-8
State Graph for 
Multiplier Control
© Cengage Learning 2014
S5 S4S3S2S1S0 S9
S8
S7
S6–/Sh–/Done
–/Sh
–/Sh–/ShM/AdM ′/Sh
M ′/Sh
M ′/ShM ′/Sh
M/Ad M/AdM/AdSt/LoadSt′/0
636 Unit 18
Note that the Done signal cannot be turned on in state S7 or S8 because the last 
shift does not occur until the next active clock edge. The last shift occurs at the same 
time the transition to state S9 occurs. The control signal Sh enables the shifting to 
occur at the next rising clock edge, but, by itself, it does not cause the shifting to occur. In general, if a control signal is turned on in state S
n, the resulting action does not 
occur until the next active clock edge takes the circuit to the next state. State S9 could 
be eliminated if it was acceptable to turn on the Done signal in state S0 when St=0.
As the state graph indicates, the control performs two functions—generating add or 
shift signals as needed and counting the number of shifts. If the number of bits is large, it is convenient to divide the control circuit into a counter and an add-shift control, as shown in Figure 18-9(a). First, we will derive a state graph for the add- shift control which tests 
M and St and outputs the proper sequence of add and shift signals (Figure 18-9(b)). 
Then, we will add a completion signal (K) from the counter which stops the multiplier 
after the proper number of shifts have been completed. Starting in S0 in Figure 18-9(b), 
when a start signal (St=1) is received, a Load signal is generated. In state S1, if M=0, 
a shift signal is generated and the circuit stays in S1. If M=1, an add signal is generated 
and the circuit goes to state S2. In S2 a shift signal is generated because a shift always 
follows an add. Back in S1, the next multiplier bit (M) is tested to determine whether 
to shift, or add and then shift. The graph of Figure 18-9(b) will generate the proper sequence of add and shift signals, but it has no provision for stopping the multiplier.
In order to determine when the multiplication is completed, the counter is incre-
mented on the active clock edge each time a shift signal is generated. If the multi-plier is n  bits, a total of n shifts are required. We will design the counter so that a 
completion signal 
(K) is generated after n – 1 shifts have occurred. When K=1, the 
circuit should perform one more addition if necessary and then do the final shift. The control operation in Figure 18-9(c) is the same as Figure 18-9(b) as long as K=
0. In 
state S1, if K=1, we test M as usual. If M=0, we output the final shift signal and 
stop; however, if M =1, we add before shifting and go to state S2. In state S2, if K=1, 
we output one more shift signal and then go to S3. The last shift signal will reset the 
counter to 0 at the same time the add-shift control goes to the Done state.
As an example, consider the multiplier of Figure 18-7 , but replace the control cir-
cuit with Figure 18-9(a). Because n=4, a 2-bit counter is needed, and K=1 when the 
counter is in state 3 (112). Table 18-2 shows the operation of the multiplier when 1101 is 
multiplied by 1011. S0, S1, and S2 represent states of the control circuit (Figure 18-9(c)). 
The contents of the product register at each step is the same as given on p. 635.
FIGURE 18-9
© Cengage 
 Learning 2014
Counter
(a) Multiplier control (b) State graph for
add-shift control–/ShSt
M
KM/AdAdd-Shift
ControlDone
ClkLoad
Ad
ShS0 S1
S2St′/0 M ′/Sh
St/Load
(c) Final state graph for
add-shift controlK′/Sh
K/ShM/AdKM ′/ShS0 S1
S2St′/0 K′M ′/Sh
St/Load
–/Done
S3
Circuits for Arithmetic Operations  637
At time t0 the control is reset and waiting for a start signal. At time tl, the start 
signal St=1, and a Load signal is generated. At time t2, M=1, so an Ad signal is 
generated. When the next clock occurs, the output of the adder is loaded into the 
accumulator and the control goes to S2. At t3, an Sh signal is generated, so, shifting 
occurs and the counter is incremented at the next clock. At t4, M=1, so Ad=1, 
and the adder output is loaded into the accumulator at the next clock. At t5 and t6, 
shifting and counting occurs. At t7, three shifts have occurred and the counter state 
is 11, so K=1. Because M =1, addition occurs, and the control goes to S2. At t8, 
Sh=K=1, so at the next clock the final shift occurs, and the counter is incremented 
back to state 00. At t9, a Done signal is generated.
The multiplier design given here can easily be expanded to 8, 16, or more bits 
simply by increasing the register size and the number of bits in the counter. The add- shift control would remain unchanged.
18.3 Design of a Binary Divider
We will consider the design of a divider for positive binary numbers. As an example, we will design a circuit to divide an 8-bit dividend by a 4-bit divisor to obtain a 4-bit quotient. The following example illustrates the division process:
    1010  quotient  
divisor 1101  10000111   dividend
 1101
  0111
  0000
   1111
(135 ÷13=10 with    1101
a remainder of 5)     0101
    0000
    0101  remainderTABLE 18-2
Operation of a 
Multiplier Using  
a Counter
© Cengage Learning 2014Time State CounterProduct 
Register StMK Load Ad Sh Done
t0 S0 00 000000000 0 0 0 0000
t1 S0 00 000000000 1 0 0 1000
t2 S1 00 000001011 0 1 0 0100
t3 S2 00 011011011 0 1 0 0010
t4 S1 01 001101101 0 1 0 0100
t5 S2 01 100111101 0 1 0 0010
t6 S1 10 010011110 0 0 0 0010
t7 S1 11 001001111 0 1 1 0100
t8 S2 11 100011111 0 1 1 0010
t9 S3 00 010001111 0 1 0 0001
638 Unit 18
Just as binary multiplication can be carried out as a series of add and shift opera-
tions, division can be carried out by a series of subtraction and shift operations. To 
construct the divider, we will use a 9-bit dividend register and a 4-bit divisor register, as shown in Figure 18-10. During the division process, instead of shifting the divi-sor to the right before each subtraction as shown in the preceding example, we will shift the dividend to the left. Note that an extra bit is required on the left end of the dividend register so that a bit is not lost when the dividend is shifted left. Instead of using a separate register to store the quotient, we will enter the quotient bit-by-bit into the right end of the dividend register as the dividend is shifted left. Circuits for initially loading the dividend into the register will be added later.
The preceding division example (135 divided by 13) is now reworked, showing 
the location of the bits in the registers at each clock time. Initially, the dividend and divisor are entered as follows:
000111111 first quotient digit
001111110
1101FIGURE 18-10
Block Diagram for 
Binary Divider
© Cengage Learning 2014Sh
Ld X8X7X6X5X4
Y3Y2Y1Y0CSuSh
St (Start Signal)
V
(Overflow
Indicator)X3X2X1X0
Subtractor
and
ComparatorDividend Register
Control
Clock0
010000111
1101
Subtraction cannot be carried out without a negative result, so we will shift before we subtract. Instead of shifting the divisor one place to the right, we will shift the dividend one place to the left:
1
 0 0 0 0 1 1 1 0
  1 1 0 1Dividing line between dividend and quotient
Note that after the shift, the rightmost position in 
the dividend register is “empty”. 
Subtraction is now carried out, and the first quotient digit of 1 is stored in the unused position of the dividend register:
Next, we shift the dividend one place to the left:
Circuits for Arithmetic Operations  639
Because subtraction would yield a negative result, we shift the dividend to the left 
again, and the second quotient bit remains 0:
011111100
1101
000101101 third quotient digitSubtraction is now carried out, and the third quotient digit of 1 is stored in the unused position of the dividend register:
A final shift is carried out and the fourth quotient bit is set to 0:
0  0  1  0  1
remainder    1  0  1  0
quotient  
The final result agrees with that obtained in the first example. Note that in the first 
step the leftmost 1 in the dividend is shifted left into the leftmost position (X8) in the 
X register. If we did not have a place for this bit, the division operation would have 
failed at this step because 0000 <1101. However, by keeping the leftmost bit in X8, 
10000 ≥1101, and subtraction can occur.
If as a result of a division operation, the quotient would contain more bits than 
are available for storing the quotient, we say that an overflow has occurred. For the divider of Figure 18-10 an overflow would occur if the quotient is greater than 15, because only 4 bits are provided to store the quotient. It is not actually neces-sary to carry out the division to determine if an overflow condition exists, because an initial comparison of the dividend and divisor will tell if the quotient will be too large. For example, if we attempt to divide 135 by 7 , the initial contents of the  registers would be:
0
 1 0 0 0 0 1 1 1
 0 1 1 1        
Because subtraction can be carried out with a nonnegative result, we should subtract the divisor from the dividend and enter a quotient bit of 1 in the rightmost place in the dividend register. However, we cannot do this because the rightmost place con-tains the least significant bit of the dividend, and entering a quotient bit here would destroy that dividend bit. Therefore, the quotient would be too large to store in the 4 bits we have allocated for it, and we have detected an overflow condition. In general, for Figure 18-10, if initially 
X8 X7 X6 X5 X4≥Y3 Y2 Y1 Y0 (i.e., if the left five bits of the 
dividend register exceed or equal the divisor), the quotient will be greater than 15 and an overflow occurs. Note that if 
X8 X7 X6 X5 X4≥Y3 Y2 Y1 Y0, the quotient is
X8 X7 X6 X5 X4 X3 X2 X1 X0
Y3 Y2 Y1 Y0≥X8 X7 X6 X5 X4 0000
Y3 Y2 Y1 Y0 = X8 X7 X6 X5 X4×16
Y3 Y2 Y1 Y0≥16
The operation of the divider can be explained in terms of the block diagram of Figure 18-10. A shift signal 
(Sh) will shift the dividend one place to the left on the 
next rising clock edge. Because the subtracter is a combinational circuit, it computes 
640 Unit 18
X8X7X6X5X4 – Y3Y2Y1Y0, and this difference appears at the subtracter output after 
a propagation delay. A subtract signal (Su) will load the subtracter output into 
X8X7X6X5X4 and set the quotient bit (the rightmost bit in the dividend register) 
to 1 on the next rising clock edge. To accomplish this, Su is connected to both the 
Ld input on the shift register and the data input on flip-flop X0. If the divisor is 
greater than the five leftmost dividend bits, the comparator output is C=0; other-
wise, C=1. The control circuit generates the required sequence of shift and subtract 
signals. Whenever C=0, subtraction cannot occur without a negative result, so a 
shift signal is generated. Whenever C=1, a subtract signal is generated, and the 
quotient bit is set to one.
Figure 18-11 shows the state graph for the control circuit. When a start signal (St) 
occurs, the 8-bit dividend and 4-bit divisor are loaded into the appropriate registers. 
Note that this assumes the divisor and dividend are available and stable during the clock cycle when Load = 1; they may be available before and after this clock cycle, but 
they must be available at least during this clock cycle. If C is 1 after the load, the upper 
half of the dividend is larger than the divisor and the quotient would require five or more bits. Because space is only provided for a 4-bit quotient, this condition constitutes an overflow, so the divider is stopped, and the overflow indicator is set by the 
V output. 
Normally, the initial value of C is 0, so a shift will occur first, and the control circuit will 
go to state S2. Then, if C=1, subtraction occurs. After the subtraction is completed, C 
will always be 0, so the next active clock edge will produce a shift. This process contin-ues until four shifts have occurred, and the control is in state S
5. Then, a final subtrac-
tion occurs if C=1, and no subtraction occurs if C=0. No further shifting is required, 
and the control goes to the stop state. For this example, we will assume that when the start signal 
(St) occurs, it will be 1 for one clock time, and, then, it will remain 0 until the 
control circuit is back in state S0. Therefore, St will always be 0 in states S1 through S5.
We will now design the control circuit using a one-hot assignment (see Section 15.9) 
to implement the state graph. One flip-flop is used for each state with Q0=1 in S0, 
Q1=1 in S1, Q2=1 in S2, etc. By inspection, the next-state and output equations are
 Q+
0=St  ′Q0+CQ1+Q5               Q+
1=StQ0 (18-1)
 Q+
2=C′Q1+CQ2                    Q+
3=C′Q2+CQ3
 Q+
4=C′Q3+CQ4                    Q+
5=C′Q4
 Load =St Q0                         V=CQ1
 Sh=C′(Q1+Q2+Q3+Q4)=C′(Q0+Q5)′
 Su=C(Q2+Q3+Q4+Q5)=C(Q0+Q1)′
FIGURE 18-11
State Graph for 
Divider Control 
Circuit
© Cengage Learning 2014
S5S0
(stop)S1 S2
S4 S3St′/0St/Load
C/V
C/Su
C′/0
C′/Sh
C/SuC′/ShC′/ShC′/Sh
C/SuC/Su
Circuits for Arithmetic Operations  641
Because there are three arrows leading into S0, Q+
0 has three terms. The equation for 
Sh has been simplified by noting that if the circuit is in state S1 or S2 or S3 or S4, it is 
not in state S0 or S5.
The subtracter in Figure 18-10 can be constructed using five full subtracters, as 
shown in Figure 18-12. Because the subtracter is a combinational circuit, whenever 
the numbers in the divisor and dividend registers change, these changes will propa-gate to the subtracter outputs. The borrow signal will propagate through the full subtracters before the subtracter output is transferred to the dividend register. If the last borrow signal 
(b9) is 1, this means that the result is negative. Hence, if b9 is 1, the 
divisor (Y3Y2Y1Y0) is greater than X8X7X6X5X4, and C=0. Therefore, C=b9′, and a 
separate comparator circuit is unnecessary. Under normal operating conditions (no overflow) for this divider, we can also show that C=d
 ′8. At any subtraction step, 
because the divisor is only four bits, d8=1 would allow a second subtraction without 
shifting. However, this can never occur because the quotient digit cannot be greater than 1. Therefore, if subtraction is possible, d
8 will always be 0 after the subtraction, 
so d8=0 implies X8X7X6X5X4 is greater than Y3Y2Y1Y0 and C =d8′.
The block diagram of Figure 18-10 does not show how the dividend is initially 
loaded into the X register. This can be accomplished by adding a MUX at the 
X register inputs, as shown in Figure 18-13. This diagram uses bus notation to avoid 
drawing multiple wires. When several busses are merged together to form a single bus, a bus merger is used. For example, the symbol
5
319
953X0X (3:1)
X (8:4)
FIGURE 18-12
Logic Diagram for 
5-Bit Subtracter
© Cengage Learning 2014Full
Subtracterd8
b9b8 b7 b6 b5b4 = 0
X8 0Full
Subtracterd7
X7Y3Full
Subtracterd6
X6Y2Full
Subtracterd5
X5Y1Full
Subtracterd4
X4Y0means that the 5-bit subtracter output is merged with bits X3X2X1 and a logic 1 to 
form a 9-bit bus. Thus, the MUX output will be d8d7d6d5d4X3X2X11 when Load =0.
Similarly, the symbol
642 Unit 18
represents a bus splitter that splits the 9 bits from the X register into X8 X7 X6 X5 X4 
and X3 X2 X1; X0 is not used. Bus mergers and splitters do not require any actual 
hardware; they are just a symbolic way of showing bus connections.
The X register is a left-shift register with parallel load capability, similar to the 
register in Figure 12-10. On the rising clock edge, it is loaded when Ld =1 and 
shifted left when Sh=1. Because the register must be loaded with the dividend 
when Load =1 and with the subtracter output when Su=1, Load and Su are ORed 
together and connected to the Ld input. The MUX selects the dividend (preceded by 
a 0) when Load =1. When Load =0, it selects the bus merger output which consists 
of the subtracter output, X3 X2 X1, and a logic 1. When Su=1 and the clock rises, this 
MUX output is loaded into X. The net result is that X8 X7 X6 X5 X4 gets the subtracter 
output, X3 X2 X1 is unchanged, and X0 is set to 1.
Figure 18-14 shows an alternative version of the divider. The primary difference 
is the use of a 4-bit subtracter rather than a 5-bit subtracter. The 4-bit subtracter is shown in Figure 18-12 with the leftmost full subtracter deleted. It can be shown that the 4 least significant output bits from the 5-bit subtracter of Figure 18-13 do not depend upon 
X8. (See Problem 18.32.) Since the most significant bit of the 5-bit 
subtracter is discarded by the following shift of the X register, this bit is not needed. 
However, now the borrow from the 4-bit subtracter, b8, is not sufficient to determine 
whether a subtract operation should be done. The state graph of Figure 18-11 still applies, but now C depends on both 
X8 and b8.FIGURE 18-13
Block Diagram for 
Divider Using Bus 
Notation
© Cengage Learning 2014X (8:0)
1 09-Wide
2-to-1 MUXLd
Sh
Clock0
99
9
8
Dividend (7:0)9
5 1
0Load
LoadSu
Sh
5-bit
Subtracter0
5
43
X (3:1)X (8:4)
Y (3:0)
(Divisor)X0Bus
Merger
Bus
Splitter
9
Circuits for Arithmetic Operations  643
FIGURE 18-14
Alternative Divider
© Cengage Learning 2014Load
Su
Sh Sh
Clock
LoadX (8:0)
X (3:1)
X (7:4)b8
Y (3:0)Dividend (7:0)
(Divisor)Ld
0
9
8
88
431
448-wide
2-to-1 MUX
4-bit
Subtracter0
01
FIGURE 18-15
Another 
Alternative Divider
© Cengage Learning 2014Load
Su
Sh Sh
Clock Clock
LoadX (8:4) X (3:0)
X (7:4)b8X3 Q
Y (3:0)Dividend (3:0)
Dividend (7:4)
(Divisor)Ld
ShLd
015
4
44
444
0
4-wide
2-to-1 MUX
4-bit
SubtracterFigure 18-15 shows a second alternative divider. In this version only the upper 
part of the X register is loaded when a subtract operation is required. Then, on the 
following shift operation, a quotient bit of 1, Q =1, is shifted into X0. If no sub-
tract operation is required, a quotient bit of 0, Q =0, is shifted into X0. Thi s simpli-
fies the circuit since only a 4-wide multiplexer is needed. This circuit is analyzed in 
Problem 18.33.
644 Unit 18
Programmed Exercise 18.1
Cover the answers with a sheet of paper and slide it down as you check your answers . 
Write your answer in the space provided before looking at the correct answers .
Thi s exercise concerns the design of a circuit which forms the 2’ s complement 
of a 16-bit binary number. The circuit consists of three main components—a 16-bit 
shift register which initially holds the number to be complemented, a control circuit, and a counter which counts the number of shifts . The control circuit processes the 
number in the shift register one bit at a time and stores the 2’ s complement back in 
the shift register. Draw a block diagram of the circuit. Show the necessary inputs and 
outputs for the control circuit including a start signal 
(N) which is u sed to initiate the 
2’s complement operation.
SI
CKCK
N
ShControl
Circuit ShXZ
K
CounterCK
State a rule for forming the 2’ s complement which is appropriate for use with the 
preceding block diagram.
 Answer Starting with the leas t significant bit, complement all of the bits  to the left of the 
first 1.
Draw a state graph for the control circuit (three states) which implements the pre-ceding rule. The 2’ s complement operation should be initiated when 
N =1. (Assume 
that N will be 1 for only one clock time.) When drawing your graph, do not include 
any provision for stopping the circuit. (In the next step you will be asked to add the signal 
K to your state graph so that the circuit will stop after 16 shifts .) Explain 
the meaning of each state in your graph. Answer
Circuits for Arithmetic Operations  645
 Answer
S2 S1S0N′/0
K′X/Z′
K′X′/Z
K′X/Z     KX /Z
KX ′/Z′X′N/Z′
X′X/Z′XN/Z
XK/Z′
     X ′K/ZS0   Reset
S1   No 1 received, do
       not complement X
S2   A 1 has been received,
       complement XN′/0
X′/Z
X/Z′X′/Z′
X/ZXN/ZX′N/Z′S0
S2 S1
The counter will generate a completion signal (K) when it reaches state 15. Modify  
your state graph so that when K =1, the circuit will complete the 2’s complement oper-
ation and return to the initial state. Also, add the Sh output in the appropriate places.
 Answer Check the input labels on all arrows leaving each state of your graph. Make sure that 
two of the labels on arrows leaving a given state cannot have the value 1 at the same time. Make any necessary corrections to your graph, and then check your final answer.
 Final Answer
(Note: Sh should be added to the graph everywhere Z or Z ′ appears.)
646 Unit 18
Programmed Exercise 18.2
This exercise concerns the design of a binary divider to divide a 6-bit number by a 3-bit 
number to find a 3-bit quotient. The right 3 bits of the dividend register should be used to store the quotient. Draw a block diagram for the divider. Omit the signals required to initially load the dividend register and assume the dividend is already loaded.
 Answer
Sh
Ld X6X5X4X3X2
Y2Y1Y0CSuSh
St (Start Signal)
V
(Overflow
Indicator)X1X0
Subtracter
and
ComparatorDividend Register
Control
Clock0
0 1 0 0 0 1 0 shiftIf the contents of the dividend register is initially 0100010 and the divisor is 110, show the contents of the dividend register after each of the first three rising clock edges. Also, indicate whether a shift or a subtraction should occur next.
Circuits for Arithmetic Operations  647
 Answer 0100010shift
1000100subtract0010101shift0101010shift
Now, show the remaining steps in the computation and check your answer by con-
verting to decimal.
 Answer 1010100subtract
0100101(finished)
If the dividend register initially contained 0011001 and the divisor is 010, can divi-
sion take place? Explain.
 Answer No. Because 011 >010, subtraction should occur first, but there is no place to store 
the quotient bit. In other words, the quotient would be greater than three bits, so an overflow would occur.
Draw a state graph for the divider which will produce the necessary sequence of 
Su 
and Sh signals. Assume that the comparator output is C =1 if the upper four bits of 
the dividend register is greater than the divisor. Include a stop state in your graph 
which is different than the reset state. Assume that the start signal (St) will remain 1 
until the division is completed. The circuit should go to the stop state when division is complete or when an overflow is detected. The circuit should then reset when 
St=0.
648 Unit 18
 Answer
S3S4
(stop)S1S0
(reset)
S2St/0St′/0
StC/V
C/Su
C/SuStC ′/Sh
St′/0
C/Su
C′/0
C′/ShC′/Sh
Binary Multiplier
to Be Designedx3x2x1y3y2y1
Z6Z5Z4Z3Z2Z1Problems
18.3 Design a serial subtracter with accumulator for 5-bit binary numbers . Assume that 
negative numbers are represented by 2’ s complement. Use a circuit of the form of 
Figure 18-1, except implement a serial subtracter using a D-CE flip-flop and any 
kind of gates . Give the state graph for the control circuit. Assume that St will remain 
1 until the subtraction is complete, and the circuit will not re set until St return s to 0.
18.4 Design a binary multiplier which multiplies two 3-bit binary numbers to form a 6-bit 
product. This multiplier is to be a combinational circuit consisting of an array of 
full adders and AND gates (no flip-flops). Demonstrate that your circuit works by showing all of the signals which are present when 111 is multiplied by 111. ( Hint: The 
AND gates can be used to multiply by 0 or 1, and the full adders can be used to add 2 bits plus a carry. Six full adders are required.)
18.5 The binary multiplier of Figure 18-7 has been redesigned so that whenever addition 
occurs the multiplier bit 
(M) will be set to 0. Specifically, the Ad signal is now con-
nected to a synchronous clear input on only the rightmost flip-flop of the product 
Circuits for Arithmetic Operations  649
register of Figure 18-7 . Thus , if M is 1 at a given clock time and addition takes place, 
M will be 0 at the next clock time. Now, we can always add when M =1 and alway s 
shift when M =0. Thi s means that the control circuit does not have to change state 
when M =1, and the number of states can be reduced from ten to six. Draw the 
resulting state graph for the multiplier control with six states .
18.6 In order to allow for a larger number of bits , the control circuit of the binary divider 
(Figure 18-10) is to be redesigned so that it uses a separate counter and a subtract-
shift control which is analogous to Figure 18-9(a). Draw the state graph for the 
 subtract-shift control.
18.7 Below is  the block diagram of a divider which will divide a 5-bit binary number 
X4X3X2X1X0 by a 5-bit binary number Y4Y3Y2Y1Y0. Initially, the 5-bit dividend is 
loaded into bits  X4 through X0, and 0’ s are loaded into bits  X9 through X5. Becaus e of its 
design, overflow will only occur if the divis or is 0. Thi s divider operates  similarly to the 
one given in Figures  18-10 and 18-11, except for the starting placement of the dividend.
Sh
Ld X8X7 X9 X6X5X4
Y3Y2 Y4 Y1Y0C
VSuSh
StX3X2X1X0
Subtracter
and
Comparator
Control
ClockOverflow
Indicator
(a) Give the equation for the overflow s ignal V, generated by the overflow indicator.
(b) Illustrate the operation of the divider when 26 is divided by 5. Specify the 
sequence of Su and Sh outputs and the contents of the dividend register, and 
specify the quotient and the remainder.
(c) Draw the state graph for the control circuit. If there is an overflow, the circuit 
should remain in the starting state. Otherwise, when St=1, the circuit should 
begin operation. Assume that St will be 1 for only one clock cycle.
(d) In Figure 18-10, the subtracter-comparator and the dividend register have one 
more bit on the left than the divisor register. Why is that not necessary here?
18.8 A serial logic unit has two 8-bit shift registers , X and Y, shown as follow s. Inputs  K1 
and K2 determine the operation to be performed on X and Y. When St=1, X and 
Y are shifted into the logic circuit one bit at a time and replaced with new val-
ues. If K1K2=00, X is complemented and Y is unchanged. If K1K2=01, X and Y 
650 Unit 18
are interchanged. If K1K2=10, Y is set to 0 and each bit of X is replaced with the 
exclusive-OR of the corresponding bits of X and Y, that is , the new xi is xi ⊕ yi. If 
K1K2=11, X is unchanged and Y is set to all 1’ s.
ClockSI
ShAdder   Shift
RegisterX Y
L
DecCounter
ZSt
Z ControlSh StSh
CCSIK1xin yin
K2Logic
CircuitShXa
Control
ClockStSI
ShYb
Sh
(a) Derive logic equations for xin and yin.
(b) Derive a state graph for the control circuit. Assume that once St is set to 1 it will 
remain 1 until all 8 bits have been proce ssed. Then, St will be changed back to 0 
some time before the start of the next computation cycle.
(c) Realize the logic circuit using two 4-to-1 multiplexers and a minimum number 
of added gates .
18.9 A circuit for adding one to the contents of a shift register has the following form:
The adder circuit has an internal flip-flop that can be used to store a carry from the 
adder operation. The control unit has a counter available to determine when the add operation is complete. The counter input L enables a parallel load of the counter 
with the length of the shift register. The counter input Dec causes the counter to 
decrement. The counter output 
Z becomes 1 when the counter value is zero. When 
St becomes 1, the control unit generates Sh and C the required number of times to 
cause 1 to be added to the shift register contents . The control unit also generates the 
signals L  and Dec  to control the counter.
Design the adder and the control unit, using D flip-flops and NOR gates .
Circuits for Arithmetic Operations  651
18.10 Repeat Problem 18.9 so that 2 is added to the shift register contents rather than 1.
18.11 Repeat Problem 18.9 so that 3 is added to the shift register contents rather than 1.
18.12 A sequential circuit receives decimal numbers encoded in BCD one digit (4 bits) 
at a time, starting with the least significant digit. The circuit outputs are the 10’ s 
complement of the input number, also encoded in BCD least significant digit first. 
Input decimal numbers are separated by one or more inputs of all 1’ s, during which 
the circuit outputs all 1’ s. Once valid BCD digits of a new number start, the circuit 
resumes computing and outputting the 10’ s complement of the new number.
(a) Cons truct a s tate table and output table for the circuit. (Two s tates  are s ufficient.)
(b) Realize the circuit using a minimum number of flip-flops .
18.13 Repeat Problem 18.12 assuming the decimal digits are encoded in excess-3 and the 
separator between decimal numbers is all 0’ s, which produces all 0’ s on the outputs .
18.14 A circuit that adds one to the contents of a shift register has the following form:
The control circuit outputs I, which should set the ONE ADDER to the proper 
initial state, and then outputs Sh to the shift register the required number of times . 
Design the box labeled “ONE ADDER” using NOR gates and a D flip-flop with 
preset and clear inputs .
EXAMPLE:
18.15 (a)  Draw a block diagram for a multiplier that can multiply two binary numbers , 
where the multiplier is 3 bits and the multiplicand is 4 bits . Use an 8-bit shift 
register along with other necessary blocks .
(b) Draw a state graph for the multiplier control.
(c) Illustrate the operation of the multiplier when 11 is multiplied by 5. Specify the 
sequence of add and shift outputs generated by the control circuit and specify 
the contents of the 8-bit register at each clock time.
(d) Draw the logic diagram for the multiplier using an 8-bit shift register of the form 
of Figure 12-10, a 4-bit adder, three J-K flip-flops , and any necessary gates .Contents of shift register before: 000001011
Contents of shift register after I and 9 Sh outputs: 000001100SI
ClockOne
Adder ShXZ
Sh
ControlI
St
Clock
652 Unit 18
18.16 Work Problem 18.15 if the multiplier is 3 bits and the multiplicand is 5 bits , and show 
20 multiplied by 6. Use a 9-bit shift register similar to Figure 12-10, five full adders , 
three D flip-flops , and a PLA for part (d). Show the PLA table.
18.17 The block diagram for a multiplier for positive binary numbers follows . The counter 
counts the number of shifts and outputs a signal K =1 after two shifts .
KAdM
St
ShAdderX Register
LdShSI
Clock0
ClockAdd-Shift
Control
Counter
(a) Draw the state graph for the control circuit. Assume that St is 1 for one clock 
period to start the multiplier.
(b) Complete the following table showing the operation of the circuit if the multipli-
cand is 11001 and the multiplier is 111:
State Counter X St M K Ad Sh
S0 00 000000111 1 1 0
18.18 Design a binary divider which divides a 7-bit dividend by a 2-bit divisor to give a 
5-bit quotient. The system has an input St that starts the division process .
(a) Draw a block diagram for the subtracter-comparator. You may use full adders 
or full subtracters .
(b) Draw a block diagram for the rest of the system (do not show the adders or sub-
tracters in the subtracter-comparator block).
(c) Draw the state graph for the control circuit. Assume that the start signal (St) is 
present for one clock period.
(d) Give the contents of the dividend register and the value of C at each time step if 
initially the dividend is 01010011 and the divisor is 11.
18.19 (a)  Draw a block diagram for a divider that is  capable of dividing a pos itive 6-bit binary 
number by a pos itive 4-bit binary number to give a 2-bit quotient. Us e a dividend 
regis ter, a divis or regis ter, a s ubtracter-comparator block, and a control block.
Circuits for Arithmetic Operations  653
(b) Draw a state graph for the control circuit. Assume that the start signal St remains 
1 for one or more clock times after the division is complete, and St must be set 
to 0 to reset the circuit.
(c) Show how the subtracter-comparator could be realized using full adders and 
inverters .
(d) Show the contents of the regi sters and the value of C after each time step if ini-
tially the dividend is 101101 and the divisor is 1101.
18.20 Design a controller for an odd-parity generator. The circuit should transmit 7 bits 
from a shift register onto the output X. Then, on the next clock cycle, the eighth 
value of X should be chosen to make the number of 1’ s be odd. In other words , 
the last value of X should be 1 if there was an even number of 1’ s in the shift reg-
ister, so that the 8-bit output word will have odd parity. (Parity was discussed in 
Section 13.1.) The circuit is shown. K will be 1 when the counter reaches 111.
ControlB
K
X R
ShSt
CounterShSI
Clock
Clock
Clock0
K
Clr
(a) Give the state graph for the control circuit. Assume St=1 for one clock cycle 
(three states).
(b) Implement the controller using D flip-flops and any necessary gates . U se a 
 one-hot state assignment.
18.21 Design a serial logic unit to multiply a 6-bit number X by –1. Assume negative num-
bers are represented by their 2’ s complements . Recall that one way to find the 2’ s 
complement is to invert all of the bits to the left of the rightmost 1. If the number 
is –32 = 100000, there is no 6-bit 2’ s complement representation of +32, so an error 
signal E r should be generated.
(a) Give a block diagram for the circuit, using a control block, a 6-bit right-shift 
register, and a 3-bit counter. The controller has inputs St, K, and SO, and outputs 
Er, Clr, Sh, and SI. The shift register is like the register of Figure 12-7 , but it has 
6 bits . The counter has a Clr input and an output K which i s 1 when the counter 
reaches 6. Assume the shift register contains X at the beginning of the opera-
tion. The shift register should contain − X when the operation is complete.
(b) Give the state graph for the control circuit. Be sure the circuit will work properly 
when taking the 2’ s complement of 0. (0×−1=0.)
(c) Implement the controller using a one-hot state assignment and D flip-flops .
654 Unit 18
18.22 A serial Boolean logic unit has two 16-bit shift registers , A and B. A control signal 
(C) is used to select the Boolean operation to be performed. If C =0, the contents 
of A are serially replaced by the bit-by-bit Boolean AND of A and B. If C =1, the 
contents of A are serially replaced by the bit-by-bit exclusive-OR of A and B. After 
the numbers have been placed in A and B , and C is set to 0 or 1, a start signal (St) 
sets the circuit in operation. A counter is u sed to count the number of shifts . When 
the counter reaches state 15, it outputs a signal K =1, which cau ses the control cir-
cuit to stop after one more shift. Assume that St remains 1 and C does not change 
until the operation is completed. The control then remains in the stop state until St 
is changed back to 0.
(a) Draw a block diagram of the system, which includes the shift registers , the coun-
ter, the control circuit, and a logic circuit that generates the serial input (SI) to 
the A register.
(b) Draw a state graph for the control circuit (three states).
(c) Design the control circuit using a PLA and D flip-flops .
(d) Design a logic circuit that generates SI.
18.23 Repeat 18.22, but assume that St=1 for only one clock cycle, and that C may change 
during the operation of the circuit. Therefore, the circuit should operate according to 
what the value of C was when St=1. U se a one-hot state assignment for (c). ( Hint: 
C should be an input to the control circuit, and you will need another output of the 
control circuit to take the place of C in the logic circuit of part (d) of 18.22.)
18.24 A serial logic unit consists of a 4-bit shift register X and a control unit. The control 
unit has a start input (St), a shift output (Sh), and an output M which is the serial 
input to the shift register. In addition, signals C1 and C2 are used to select the logic 
operation performed on the shift register. When St=1, then
If C1C2=00, the content s of register X is serially replaced by all 0’ s.
If C1C2=01, the content s of register X is serially replaced by all 1’ s.
If C1C2=11, the content s of register X is serially replaced by its bit-by-bit comple-
ment. Assume that C1C2 does not change until the selected operation is complete.
(a) Draw a block diagram for the system.
(b) Specify the state graph for the control unit. Assume that St stays 1 for one clock 
period.
(c) Design the control unit (not the shift register) using J-K flip-flops and any kind 
of gates . Al so, de sign the logic inside the control unit which generates the serial 
input M to the shift register. (Hint: M depends only on C1, C2, and X.)
18.25 Design a circuit which sets a specified number of bits on the right side of a shift 
register to 0. The number of bits to be set to 0 is in regi ster N before the start of the 
operation. When St=1, the controller should shift right N times , and then shift left 
N times . The counter only counts down, and K =1 when the counter reache s 000.
(a) Give the circuit. Use a control block, a 3-bit N register, a 3-bit down counter 
with load input (Ld) and K output (which is 1 when the counter reaches 000), 
and an 8-bit right/left shift register which functions according to the table in Problem 12.3 (except that it has 8 bits). Note that the counter does not count up, 
Circuits for Arithmetic Operations  655
so you will have to load N into the counter twice. The controller has inputs St 
and K, and outputs A, B, and Ld.
(b) Give the state graph for the control circuit. Assume St=1 for one clock period.
(c) Implement the controller us ing two D flip-flops . Use a straight binary assignment.
18.26 Design a controller for the circuit of Problem 12.39 that will add three numbers . 
Assume each number (including the firs t one) appears  on the 8-bit input data line for 
two cons ecutive clock cycles . You may not a ssume that the regis ters begin with a value 
of 0. When St=1, the fir st input appears  on the input data line for that clock cycle and 
the next one. The circuit s hould halt when the ans wer goes  into the accumulator, and 
output a s ignal Done = 1. Done should remain 1 until St returns  to 0. You may assume 
St=1 for enough time for the operation to complete. Give the block diagram and the 
state graph (s even s tates ), but you do not need to implement the s tate graph.
18.27 The given multiplier uses only counters to multiply a 4-bit multiplicand by a 4-bit 
multiplier to obtain an 8-bit product. This Ultra-Slow Multiplier is based on the 
principle that multiplication is repeated addition and that addition is repeated incre-menting. The multiplier works a s follows: When the 
St signal is received, the 8-bit 
up counter is cleared, N1 is loaded into 4-bit counter A, and N2 is loaded into 4-bit 
counter B. Then, the controller decrements A and increments the up counter until 
A reaches zero. When A reaches zero, B  is decremented and A is reloaded with N1. 
Then, the process i s repeated until B reaches zero. When B reaches zero, the 8-bit up 
counter contains the product.
(a) Draw the state graph for the controller. Assume St=1 for only one clock period.
8-Bit Up CounterCLR
LD1
CT1
LD2
CT2
ZER2
ZER1Product
ClearControl
St
DoneCount
Load
4Count
Zero Zero
Ultra-Slow Multiplier4-Bit Down
Counter AMultiplicand
Load
Count4-Bit Down
Counter BMultiplier
N14
N2
(b) Realize the state graph using one or two J-K flip-flops and a minimum number 
of gates .
(c) If the multiplier is N1 and the multiplicand is N2, how many clock periods does 
it take for the Ultra-Slow Multiplier to calculate the product?
18.28 The following circuit is  a multiplier circuit for 4-bit pos itive numbers . Multiplication 
is performed by adding the multiplicand to a partial product while decrementing 
the multiplier. This  is continued until the multiplier is  decremented to zero. (If the 
656 Unit 18
multiplier is initially zero, no additions are done.) When the start input (S) changes 
to 1, the multiplicand and multiplier are available; the multiplier circuit loads them 
into A Reg and B Counter, respectively. The partial product register, implemented 
in two parts (P U and PL), is cleared, as is the carry-out FF for the adder (C FF ). To 
avoid having an adder twice as long as the operands, the addition of the multiplicand to the partial product is done in two steps: First, the multiplicand is added to the lower half of the partial product; second, the carry from the first addition is added to the upper half of the partial product. The multiplier in the B counter is decremented for each addition, and the additions continue until the multiplier has been decremented to zero. Then the done signal 
(D) is generated, with the product available in the partial 
product register; D remains asserted and the product available until S returns to 0.
The control signals that the controller must generate are
B Counter
Zero Detect4Multiplier
LB
DB
BZ
ControllerS
DPU Reg4
CP
LPUPL Reg4
A Reg4
CP
LPLLAMultiplicand
MUX
AdderAND ArrayMS EA4
C FF0 1
CCLB Load B Counter
DB Decrement B Counter
CP Clear P U and PL
LPU Load P U
LPL Load PL
LA Load A Reg
MS MUX Select Signal
EA Signal ANDed with A Reg output
CC Clear C FF
D Done
The input signals to the controller are start, S, and BZ; BZ =0 when the B counter 
is zero.
(a) Determine the contents of the partial product register for each addition step 
when the multiplicand is 1011 and the multiplier is 0101.
(b) Draw a state graph for the controller. (Four states are sufficient.)
(c) Realize the controller using D FFs and a one-hot state assignment. Give the 
next-state equations and the controller output equations.
(d) Realize the controller using a minimum number of D FFs.
Circuits for Arithmetic Operations  657
18.29 A few modifications of the circuit of Problem 18.28 are necessary so that it will mul-
tiply 2’s complement numbers. For example, the Controller must have inputs that 
are the sign bits of the multiplier and multiplicand; the B Counter must be able to increment a negative multiplier to 0; and the AND Array must be changed so that its outputs can be the multiplicand, all 0’s or all 1’s.
(a) Redesign the multiplier so that it can multiply 2’s complement numbers using 
these suggested modifications.
(b) Determine the contents of the partial product register for each addition step 
when the multiplicand is 1011 and the multiplier is 0101. Repeat when the mul-tiplicand is 0101 and the multiplier is 1011.
(c) Draw a state graph for the controller. (At most, five states are required.)
(d) Realize the controller using D FFs and a one-hot state assignment. Give the 
next-state equations and the controller output equations.
(e) Realize the controller using a minimum number of D FFs.
18.30 The Ultra-Slow Divider, shown in the following block diagram, works on a principle 
similar to the Ultra-Slow Multiplier in Problem 18.27 . When the 
St signal is received, 
the 8-bit down counter is loaded with the dividend (N1), the 4-bit down counter is 
loaded with the divisor (N2), and the 4-bit quotient up counter is cleared. The divi-
dend counter and the divisor counter are decremented together, and every time the 4-bit divisor counter reaches zero, it is reloaded with the divisor and the quotient up counter is incremented. When the dividend counter reaches zero, the process termi-nates and the quotient counter contains the result.
(a) Draw the state graph for the controller.
(b) Realize the state graph using one or two D flip-flops and a minimum number  
of gates.
(c) If the dividend is N
1 and the divisor is N2, how many clock cycles does it take to 
calculate the quotient?
(d) How can you tell if an overflow occurs during division?
(e) What will happen in your circuit if the divisor is zero?
CLR
EZEROIZERO
LOAD
DOWNUPDividend
Load
Control
ST
DoneCount
Clear
CountZero
Ultra-Slow Divider4-Bit Up
Counter8-Bit Down
Counter
Quotient Load
Count4-Bit Down
CounterDivisor8
N1
4
N2
658 Unit 18
18.31 In Problem 1.42 it was shown that the n-bit 2’s complement integer B =bn−1bn−2 · · ·
b1b0 has the decimal value – bn – 12n – 1+bn – 22n – 2+bn – 32n – 3+· · ·+b12+b0. Based 
on this expression, multiplication of 2’s complement numbers, B ×A, can be done 
by adding bi(A2i) to a partial product for i=0 to n −2 and subtracting bn−1(A2n−1) 
from the partial product.
(a) Based on this algorithm, show the contents of ACC in Figure 18-7 for each step 
of the algorithm for the operands multiplicand A =1101 (−3) and multiplier 
B =1010 (−6). Repeat for operands A = 1000 (−8) and B =0110 (6). Note that 
the value shifted into bit 7 of A CC will no longer be the carry-out from the 
adder as shown in Figure 18-7 (i.e., bit 8 of A CC will have to be replaced with a 
circuit that provides the proper value to shift into bit 7 of A CC).
(b) State in words what value should be shifted into bit 7 of A CC during a shift 
operation.
(c) Modify the circuit of Figure 18-7 so that 2’s complement numbers can be mul-
tiplied using this algorithm. Replace bit 8 of A CC with a circuit that provides 
the value to shift into bit 7 of A CC during a shift operation. Let M3 be the sign 
bit of the multiplicand. Let Su be the control signal from the controller when a 
Subtract operation is required.
(d) Using the modified circuit of part (c), modify the state graph of Figure 18-8 to 
perform 2’s complement multiplication.
(e) Using the modified circuit of part (c), modify the state graph of Figure 18-9(c) to 
perform 2’s complement multiplication.
18.32 (a)  Consider the 5-bit subtracter in Figure 18-13. Show that the four least significant 
output bits from the subtracter do not depend upon X8. Do this by showing 
examples of the four possible cases of X8=0 or 1 and X(7:4) is greater than or 
equal to Y(3:0) or less than Y(3:0).
(b) Only three of the four cases mentioned in part (a) can occur. Illustrate the case 
that cannot occur.
(c) If the state graph of Figure 18-11 describes the operation of the circuit of 
Figure 18-14, what is the expression for C?
(d) Compare the speed and circuit complexity of the dividers in Figures 18-13 
and 18-14.
18.33 (a) Construct a state graph for the divider of Figure 18-15.
(b) Compare the speed and circuit complexity of the dividers in Figures 18-13 
and 18-15.
18.34 This problem involves the design of a circuit that finds the integer part of the 
square root of an 8-bit unsigned binary number N using the method of subtracting 
out odd integers. To find the square root of N, we subtract 1, then 3, then 5, etc., 
Circuits for Arithmetic Operations  659
until we can no longer subtract without the result going negative. The number of 
times we subtract is equal to the integer part of the square root of N. For example, 
to find "27:   27 −1=26; 26 −3=23; 23 −5=18; 18 −7=11; 11 −9=2; 2 −11 
(cannot subtract). Because we subtracted five times, "27:   =5. Note that the final 
odd integer is 1110=10112, and this consists of the square root (1012=510) fol-
lowed by a 1.
660State Machine Design 
with SM ChartsUNIT
19
Objectives
1. Explain the different parts of an SM chart.
2. Given the input sequence to a state machine, determine the output sequence 
from its SM chart and construct a timing diagram.
3. Convert a state graph to an SM chart.
4. Construct an SM chart for the control circuit for a multiplier, divider, or other simple digital system.
5. Determine the next-state and output equations for a state machine by tracing link paths on its SM chart.
6. Realize an SM chart using a PLA or ROM and flip-flops.
State Machine Design with SM Charts  661
Study Guide
1. Study Section 19.1, State Machine Charts.
(a) For the example of Figure 19-2, if X1=0 and X2=1 when the machine is 
in state S1, specify the values of all of the outputs and the exit path number.
(b) For Figures 19-6(a) and (b), trace the link paths and determine the outputs 
when X1=X3=1.
(c) Verify that the SM chart and state graph of Figure 19-7 are equivalent.
(d) Construct a timing chart for Figure 19-7(b) when the input sequence is 
X=0, 1, 1, 0.
(e) Work Problems 19.1, 19.2, and 19.3.
2. Study Section 19.2, Derivation of SM Charts.
(a) Using the SM chart of Figure 19-9 to determine when to subtract and when 
to shift for the binary divider of Figure 18-10, show the contents of the divi-
dend register at each time step when 28 is divided by 5.
(b) Compare the SM chart of Figure 19-10 with the state graph of Figure 18-9(c) 
and verify that in each state they will generate the same outputs when the inputs are the same.
(c) Compare the flowchart for the dice game (Figure 19-12) with the SM chart 
(Figure 19-13). Note that the Roll Dice box on the flowchart requires two states to implement on the SM chart. In the first state, the machine waits for the roll button to be pressed; in the second state, it generates a roll signal which lasts until the roll button is released. In state S
1 3 variables are tested; 
if they are all 0, Sp is generated so that the sum will be stored in the point 
register at the same time the transition from S1 to S4 occurs.
(d) Work Problems 19.4, 19.5, and 19.6.
3. Study Section 19.3, Realization of SM Charts.
(a) For Figure 19-7(b) find simplified equations for A+ and B  +.
(b) Verify Tables 19-1 and 19-2. For Table 19-2, why is Sp=1 only in row 4, 
and Win=1 in both rows 7 and 8?
(c) Expand row 16 of Table 19-2 to give the corresponding rows of the ROM table.
(d) Work Problems 19.7 , 19.8, 19.9, and 19.10.
662State Machine Design 
with SM Charts
Another name for a sequential circuit is an algorithmic state machine or simply a 
state machine. These names are often used when the sequential circuit is used to control a digital system that carries out a step-by-step procedure or algorithm. The state graphs in Figures 18-3, 18-8, 18-9, and 18-11 define state machines for control-ling adders, multipliers, and dividers. As an alternative to using state graphs, a special type of flowchart, called a state machine flowchart or SM chart, may be used to describe the behavior of a state machine. This unit describes the properties of SM charts and how they are used in the design of state machines.
19.1 State Machine Charts
Just as flowcharts are useful in software design, flowcharts are useful in the hardware design of digital systems. In this section we introduce a special type of flowchart called a state machine flowchart, or SM chart for short. SM charts are also called ASM (algorithmic state machine) charts. We will see that the SM chart offers sev-eral advantages. It is often easier to understand the operation of a digital system by inspection of the SM chart instead of the equivalent state graph. A given SM chart can be converted into several equivalent forms, and each form leads directly to a hardware realization.
An SM chart differs from an ordinary flowchart in that certain specific rules 
must be followed in constructing the SM chart. When these rules are followed, the SM chart is equivalent to a state graph, and it leads directly to a hardware realiza-tion. Figure 19-1 shows the three principal components of an SM chart. The state of the system is represented by a state box. The state box contains a state name, and it may contain an output list. A state code may be placed outside the box at the 
top. A  decision box is represented by a diamond-shaped symbol with true and false 
branches. The condition placed in the box is a Boolean expression that is evaluated 
to determine which branch to take. The conditional output box, which has curved ends, contains a conditional output list. The conditional outputs depend on both the state of the system and the inputs.
State Machine Design with SM Charts  663
An SM chart is constructed from SM blocks. Each SM block (Figure 19-2) con-
tains exactly one state box together with the decision boxes and conditional output 
boxes associated with that state. An SM block has exactly one entrance path and one or more exit paths. Each SM block describes the machine operation during the time that the machine is in one state. When a digital system enters the state associ-ated with a given SM block, the outputs on the output list in the state box become true. The conditions in the decision boxes are evaluated to determine which path (or paths) is (are) followed through the SM block. When a conditional output box is encountered along such a path, the corresponding conditional outputs become true. A path through an SM block from entrance to exit is referred to as a link path.
For the example of Figure 19-2, when state S
1 is entered, outputs Z1 and Z2 
become 1. If inputs X1 and X2 are both equal to 0, Z3 and Z4 are also 1, and at the 
end of the state time, the machine goes to the next state via exit path 1. On the other hand, if 
X1=1 and X3=0, the output Z5 is 1, and an exit to the next state will occur 
via exit path 3. 
A given SM block can generally be drawn in several different forms. Figure 19-3 
shows two equivalent SM blocks. In both Figures 19-3(a) and (b), the output Z2=1 
if X1=0; the next state is S2 if X2=0 and S3 if X2=1.FIGURE 19-1
Components of 
an SM Chart
© Cengage Learning 2014state_name/
Output List
(a) State boxConditional
Output List
(c) Conditional
output boxxxxOptional
State Code
(b) Decision boxCondition(True
branch)(False
branch) 10
FIGURE 19-2
Example of an 
SM Block
© Cengage Learning 2014S1/Z1 Z2
Z3 Z4
Z5One Entrance Path
One State
0Link
Path a
Link
Path b
0
12 3 n11
01
n exit pathsSM
Block
X1
X3
X2
664 Unit 19
The SM chart of Figure 19-4(a) represents a combinational circuit because there is 
only one state and no state change occurs. The output is Z1=1 if A+BC=1; or else 
Z1=0. Figure 19-4(b) shows an equivalent SM chart in which the input variables are 
tested individually. The output is Z1=1 if A=1 or if A=0, B =1, and C=1. Hence,
Z1=A  +  A ′BC=A  +  B C
which is the same output function realized by the SM chart of Figure 19-4(a).
Certain rules must be followed when constructing an SM block. First, for every 
valid combination of input variables, there must be exactly one exit path defined. 
This is necessary because each allowable input combination must lead to a single next state. Second, no internal feedback within an SM block is allowed. Figure 19-5 shows an incorrect and correct way of drawing an SM block with feedback.
As shown in Figure 19-6(a), an SM block can have several parallel paths 
which lead to the same exit path, and more than one of these paths can be active at the same time. For example, if 
X1=X2=1 and X3=0, the link paths marked FIGURE 19-3
Equivalent 
SM Blocks
© Cengage Learning 2014S1/Z1
S2/ S3/ S2/ S3/Z2
Z2 Z2X1
X201
01
(a)S1/Z1
X2
X1 X10
1
0011
(b)
FIGURE 19-4
Equivalent 
SM Charts for a 
Combinational 
Circuit
© Cengage Learning 2014S0/
Z1Z1A + BC
011
1
(a)S0/
A
C
B0
0
01
(b)
State Machine Design with SM Charts  665
with dashed lines are active, and the outputs Z1, Z2, and Z3 will be l. Although 
Figure 19-6(a) would not be a valid flowchart for a program for a serial computer, 
it presents no problems for a state machine implementation. The state machine can have a  multiple-output circuit that generates Z
1, Z2, and Z3 at the same time. 
Figure 19-6(b) shows a serial SM block, which is equivalent to Figure 19-6(a). In the serial block only one active link path between entrance and exit is possible.
For any combination of input values the outputs will be the same as in the 
equivalent parallel form. The link path for 
X1=X2=1 and X3=0 is shown with a 
dashed line, and the outputs encountered on this path are Z1, Z2, and Z3. Regardless 
of whether the SM block is drawn in serial or parallel form, all of the tests take place within one clock time.
A state graph for a sequential machine is easy to convert to an equivalent SM 
chart. The state graph of Figure 19-7(a) has both Moore and Mealy outputs. The equivalent SM chart has three blocks—one for each state. The Moore outputs 
(Za, Zb, and  Zc) are placed in the state boxes because they do not depend on the FIGURE 19-5
SM Block with 
Feedback
© Cengage Learning 2014S0/
X0
1
(a) IncorrectS0/
X0
1
(b) Correct
FIGURE 19-6
Equivalent  
SM Blocks
© Cengage Learning 2014
S0/Z1S0/Z1
Z21
01
010
0
(a) (b)X1
Z3X2
Z4Z2
X3X1
0Z3X2
0111
Z4X3
666 Unit 19
input. The Mealy outputs (Z1 and Z2) appear in conditional output boxes because 
they depend on both the state and input. In this example, each SM block has only 
one decision box because only one input variable must be tested. For both the state graph and SM chart, Z
c is always 1 in state S2. If X=0 in state S2, Z1=1 and the next 
state is S0. If X=1, Z2=1 and the next state is S2.
Figure 19-8 shows a timing chart for the SM chart of Figure 19-7 with an input 
sequence X=1, 1, 1, 0, 0, 0. In this example, all state changes occur immediately after 
the rising edge of the clock. Because the Moore outputs (Za, Zb, and  Zc) depend on the 
state, they can only change immediately following a state change. The Mealy  outputs FIGURE 19-7
Conversion 
of a State Graph 
to an SM Chart
© Cengage Learning 2014S0/Za
S1/Zb
Z2 Z101Link 100
1/0 1/0
0/00/0 1/Z2
0/Z101
11
(b) Equivalent SM chart (a) State graphX
S2/Zc01X
01Link 3Link 2
XS0
ZaS1
ZbS2
Zc
FIGURE 19-8
Timing Chart for 
Figure 19-7
© Cengage Learning 2014
Z2S0 S1 S2 S2 S0 S0
Z1ZcZbZaXStateClock
State Machine Design with SM Charts  667
(Z1 and Z2) can change immediately after a state change or an input change. In any 
case, all outputs will have their correct value during the active edge of the clock.
19.2 Derivation of SM Charts
The method used to derive an SM chart for a sequential control circuit is similar to 
that used to derive the state graph. First, we should draw a block diagram of the sys-tem we are controlling. Next, we should define the required input and output signals to and from the control circuit. Then, we can construct an SM chart that tests the input signals and generates the proper sequence of output signals.
In this section we will give several examples of SM charts. The first example is 
an SM chart for control of the parallel binary divider, as shown in Figure 18-10. As described in Section 18.3, binary division requires a series of subtract and shift oper-ations. Derivation of an SM chart to generate the proper sequence of subtract and shift signals is very similar to derivation of the state graph of Figure 18-11. For the SM chart of Figure 19-9, 
S0 is the starting state. In S0, the start signal (St) is tested, 
FIGURE 19-9
SM Chart for  
Binary Divider
© Cengage Learning 2014
010 10 100110
1St
C
CS0/
S2/S1/ Load
Sh
Su Sh
CS3/
Su Sh
CS4/
Su
CS5/
SuShV
668 Unit 19
and if St=1, the Load signal is turned on and the next state is S1. In S1, the compare 
signal (C) is tested. If C=1, the quotient would be larger than 4 bits, so an overflow 
signal (V=1) is generated and the state changes back to S0. If C=0, Sh becomes 1, 
so at the next clock the dividend is shifted to the left and the state changes to S2.  
C is tested again in state S2. If C=1, subtraction is possible, so Su becomes 1 and no 
state change occurs. If C=0, Sh=1, and the dividend is shifted as the state changes 
to S3. The action in states S3 and S4 is identical to that in state S2. In state S5 the next 
state is always S0, and C=1 causes subtraction to occur.
Next, we will derive the SM chart for the multiplier control of Figure 18-9(a). 
This control generates the required sequence of add and shift signals for a binary 
multiplier of the type shown in Figure 18-7. The counter counts the number of shifts and outputs K =1 just before the last shift occurs. The SM chart for the multiplier 
control (Figure 19-10) corresponds closely to the state graph of Figure 18-9(c). In state 
S0, when the start signal St is 1, Load is turned on and the next state is S1.  
In S1, the multiplier bit M is tested to determine whether to add or shift. If M =1, 
an add signal is generated and the next state is S2. If M =0, no addition is required, 
so a shift signal is generated and K is tested. If K=1, the circuit goes to the Done 
state, S3, at the time of the last shift; otherwise, the next state is S1. In S2 a shift signal 
is generated because a shift must always follow an add, and K is tested to determine 
the next state.
As a third example of SM chart construction, we will design an electronic 
dice game. Figure 19-11 shows the block diagram for the dice game. Two coun-ters are used to simulate the roll of the dice. Each counter counts in the sequence 1, 2, 3, 4, 5, 6, 1, 2, . . . . Thus, after the “roll” of the dice, the sum of the values in the two counters will be in the range 2 through 12.
FIGURE 19-10
SM Chart for 
Binary Multiplier
© Cengage Learning 2014
0100101
1St
M
KS0/
S1/
S3/Done KS2/ShLoad
Ad Sh
State Machine Design with SM Charts  669
The rules of the game are as follows:
1. After the first roll of the dice, the player wins if the sum is 7 or 11. He loses if 
the sum is 2, 3, or  12. Otherwise, the sum which he obtained on the first roll is 
referred to as his point, and he must roll the dice again.
2. On the second or subsequent roll of the dice, he wins if the sum equals his point, and he loses if the sum is 7. Otherwise, he must roll again until he finally wins or loses.
The inputs to the dice game come from two push buttons, Rb (roll button) and 
Reset. Reset is used to initiate a new game. When the roll button is pushed, the dice counters count at a high speed, so the values cannot be read on the display. When the  roll button is released, the values in the two counters are displayed and the game can proceed. Because the button is released at a random time, this  simulates 
a random roll of the dice. If the Win light or Lose light is not on, the player must push  the roll button again. We will assume that the push buttons are properly debounced and that the changes in Rb are properly synchronized with the clock. 
Methods for debouncing and synchronization were discussed previously.
Figure 19-12 shows a flowchart for the dice game. After rolling the dice, the sum 
is tested. If it is 7 or 11, the player wins; if it is 2, 3, or 12, he loses. Otherwise, the sum 
is saved in the point register, and the player rolls again. If the new sum equals the point, he wins; if it is 7, he loses. Otherwise, he rolls again. After winning or losing, he must push Reset to begin a new game.
The components for the dice game shown in the block diagram (Figure 19-11) 
include an adder which adds the two counter outputs, a register to store the point, test logic to determine conditions for win or lose, and a control circuit. The input signals to the control circuit are defined as follows:
D
7=1 if the sum  of the dice  is 7
D711=1 if the sum  of the dice  is 7 or 11 FIGURE 19-11
Block Diagram for 
Dice Game
© Cengage Learning 2014Display
Win
Lose1-to-6
Counter
Point
RegisterDisplay
Comparator1-to-6
Counter
ControlTest
LogicAdder
D2312
SpRb
Reset
EqRoll
SumD711D7Dice Game Module
670 Unit 19
   D2312=1 if the sum  of the dice  is 2, 3, or 12
      Eq=1 if the sum  of the dice  equals  the number  stored  in the point  register
      Rb=1 when  the roll button  is pressed
Reset =1 when  the reset  button  is pressed
The outputs from the control circuit are defined as follows:
   Roll =1 enables  the dice  counters
  Sp=1 causes  the sum  to be stored  in the point  register
  Win =1 turns  on the win light
Lose =1 turns  on the lose  lightFIGURE 19-12
Flowchart for  
Dice Game
© Cengage Learning 2014Roll Dice
Roll DiceStore sum in
point registerSum =
7 or 11
Sum =
Point
Sum = 7
ResetSum =
2, 3, or 12
Win
ResetLoseYN
NYNYNNYN
Y
Y
State Machine Design with SM Charts  671
We can now convert the flowchart for the dice game to an SM chart for the control 
circuit using the defined control signals. Figure 19-13 shows the resulting SM chart. The 
control circuit waits in state S0 until the roll button is pressed (Rb=1). Then, it goes to 
state S1, and the roll counters are enabled as long as Rb=1. As soon as the roll button FIGURE 19-13
SM Chart for 
Dice Game
© Cengage Learning 2014
Sp0
1
1
1
10
0
0
00
1
1
0
0
0
1101
1Rb
RollRb
D711
D2312
Rb
Eq
D7RbS0/
S1/Roll
S4/
S2/WinS5/
ResetS3/Lose
Reset
672 Unit 19
is released (Rb=0), D711 is tested. If the sum is 7 or 11, the circuit goes to state S2 and 
turns on the Win light; otherwise, D2312 is tested. If the sum is 2, 3, or  12, it goes to state 
S3 and turns on the Lose light; otherwise, the signal Sp  becomes 1, and the sum is stored 
in the point register. It then enters S4 and waits for the player to “roll the dice” again. 
In S5, after the roll button is released, if Eq =1, the sum equals the point and state S2 
is entered to indicate a win. If D7=1, the sum is 7 and S3 is entered to indicate a loss. 
Otherwise, the control returns to S4 so that the player can roll again. When in S2 or S3, 
the game is reset to S0 when the Reset button is pressed.
Instead of using an SM chart, we could construct an equivalent state graph from 
the flowchart. Figure 19-14 shows a state graph for the dice game controller. The state 
graph has the same states, inputs, and outputs as the SM chart. The arcs have been labeled consistently with the rules for proper alphanumeric state graphs given in Section 14.5. Thus, the arcs leaving state S
1 are labeled Rb, Rb ′D711, Rb ′D′711D2312, 
and Rb′D′711D′2312. With these labels, only one next state is defined for each combina-
tion of input values. Note that the structure of the SM chart automatically defines only one next state for each combination of input values.
FIGURE 19-14
State Graph for 
Dice Game 
Controller 
© Cengage Learning 2014Rb ′ /0
Rb/0
S1Rb ′D′ 711D2312/0
Rb ′ Eq ′D ′7/0Rb ′ Eq ′ D7/0 Rb ′Eq/0Rb ′/0
Rb/0
Rb/RollReset ′/0 Reset ′/0Reset /0 Reset /0
Rb ′D ′ 711D′ 2312/SpRb ′ D711/0Rb/RollS0
S2
Win
S4
S5S3
Lose
19.3 Realization of SM Charts
The methods used to realize SM charts are similar to the methods used to realize state graphs. As with any sequential circuit, the realization will consist of a combi-national subcircuit together with flip-flops for storing the state of the circuit (see Figure 13-17). In some cases, it may be possible to identify equivalent states in an SM chart and eliminate redundant states using the same method as was used for  reducing state tables. However, an SM chart is usually incompletely specified in the 
State Machine Design with SM Charts  673
sense that all inputs are not tested in every state, which makes the reduction proce-
dure more difficult. Even if the number of states in an SM chart can be reduced, it is not always desirable to do so because combining states may make the SM chart more difficult to interpret.
Before deriving next-state and output equations from an SM chart, a state assign-
ment must be made. The best way of making the assignment depends on how the SM chart is realized. If gates and flip-flops (or the equivalent PLD realization) are used, the guidelines for state assignment given in Section 15.8 may be useful.
As an example of realizing an SM chart, consider Figure 19-7(b). We have made 
the state assignment 
AB=00 for S0, AB=01 for S1, and AB=11 for S2. After a state 
assignment has been made, output and next-state equations can be read directly from the SM chart. Because the Moore output Z
a is 1 only in state 00, Za=A′B′. Similarly, 
Zb=A′  B and Zc=AB. The conditional output Z1=ABX ′ because the only link  
path through Z1 starts with AB=11 and takes the X=0 branch. Similarly,  
Z2=ABX.  There are three link paths (labeled link 1, link 2, and link 3), which ter-
minate in a state that has B=1. Link 1 starts with a present state AB=00, takes the 
X=1 branch, and terminates on a state in which B =1. Therefore, the next state of 
B(B+) equals 1 when A′B′X=1. Link 2 starts in state 01, takes the X=1 branch, and 
ends in state 11, so B+ has a term A′BX. Similarly, B+ has a term ABX from link 3. The 
next-state equation for B  thus has three terms corresponding to the three link paths:
B+=A′B′X
link 1+A′BX
link 2+ABX
link 3  
Similarly, two link paths terminate in a state with A=1, so
A+=A′BX  +  AB X
These output and next-state equations can be simplified with a Karnaugh map, using the unused state assignment 
(AB=10) as a don’t-care condition.
As illustrated, the next-state equation for a flip-flop Q can be derived from the 
SM chart as follows:
1. Identify all of the states in which Q =1.
2. For each of these states, find all of the link paths that lead into the state.
3. For each of these link paths, find a term that is 1 when the link path is followed. 
That is, for a link path from Si to Sj, the term will be 1 if the machine is in state Si 
and the conditions for exiting to Sj are satisfied.
4. The expression for Q+ (the next state of Q) is formed by ORing together the 
terms found in step 3.
Next, we will implement the multiplier control SM chart of Figure 19-10 using 
a PLA and two D flip-flops connected, as shown in Figure 19-15. The PLA has five inputs and six outputs. We will use a straight binary state assignment ( S
0=00, S1=01,
etc.). Each row in the PLA table (Table 19-1) corresponds to one of the link paths in the SM chart. Because S
0 has two exit paths, the table has two rows for present state 
S0. Because only St is tested in S0, M and K are don’t-cares as indicated by dashes. The 
first row corresponds to the St=0 exit path, so the next state is 00 and all outputs 
674 Unit 19
are 0. In the second row, St=1, so the next state is 01 and the other PLA outputs are 
1000. Because St is not tested in states S1, S2, and  S3, St is a don’t-care in the corre-
sponding rows. The outputs for each row can be filled in by tracing the corresponding 
link paths on the SM chart. For example, the link path from S1 to S2 passes through 
conditional output Ad when M=1, so Ad=1 in this row. Because S2 has a Moore 
output Sh, Sh=1 in both of the rows for which AB=10.
The SM chart for the dice game controller can be implemented using a PLA 
and three D flip-flops, as shown in Figure 19-16. The PLA has nine inputs and seven outputs, which are listed at the top of Table 19-2. In state 
ABC=000, the next 
state is A+B+C+=000 or 001, depending on the value of Rb. Because state 001 
has four exit paths, the PLA table has four corresponding rows. When Rb is 1, Roll 
is 1 and there is no state change. When Rb=0 and D711 is 1, the next state is 010. 
When Rb=0 and D2312=1, the next state is 011. For the link path from state 001 
to 100, Rb, D711,and D2312 are all 0, and Sp is a conditional output. This path cor-
responds to row 4 of the PLA table, which has Sp=1 and A+B+C+=100. In state 
010, the Win  signal is always on, and the next state is 010 or 000, depending on the FIGURE 19-15
Realization of 
Figure 19-10 
Using a PLA and 
Flip-Flops
© Cengage Learning 2014
D
D
ClockLoad
ShAd
A
+
A
BB+St
M
K
Done
PLA
TABLE 19-1
PLA Table for 
Multiplier Control
© Cengage Learning 2014Present 
StatePLA Inputs PLA Outputs
AB S tM K A+B+Load Sh Ad Done
S0 00 0 - - 0 0 0 0 0 0
00 1 - - 0 1 1 0 0 0
S1 01 - 0 0 0 1 0 1 0 001 - 0 1 1 1 0 1 0 001 - 1 - 1 0 0 0 1 0
S2 10 - - 0 0 1 0 1 0 0
10 - - 1 1 1 0 1 0 0
S3 11 - - - 0 0 0 0 0 1
State Machine Design with SM Charts  675
value of Reset.  Similarly, Lose is always on in state 011. In state 101, A+B+C+=010 
if Eq=1;  otherwise, A+B+C+=011 or 100, depending on the value of D7. States 
110 amd 111 are unused, so all inputs and outputs are don’t-cares in these states.
If a ROM is used instead of a PLA, the PLA table must be expanded to 29=512 
rows. To expand the table, the dashes in each row must be replaced with all possible 
combinations of 0’s and 1’s. For example, row 5 would be replaced with the following 8 rows:FIGURE 19-16
PLA Realization 
of Dice Game 
Controller
© Cengage Learning 2014
D
ClockA+B+
QC+
ABCEqD2312D7D711ResetRb
SpRollLoseWin
PLA
CKD
Q CKD
Q CK
TABLE 19-2 PLA Table for Dice Game
ABC Rb Reset D7D711 D2312 Eq A+B+C+Win Lose Roll Sp
1 000 0 – – – – – 000 0 0 0 0
2 000 1 – – – – – 001 0 0 0 03 001 1 – – – – – 001 0 0 1 04 001 0 – – 0 0 – 100 0 0 0 15 001 0 – – 0 1 – 011 0 0 0 06 001 0 – – 1 – – 010 0 0 0 07 010 – 0 – – – – 010 1 0 0 08 010 – 1 – – – – 000 1 0 0 09 011 – 1 – – – – 000 0 1 0 010 011 – 0 – – – – 011 0 1 0 011 100 0 – – – – – 100 0 0 0 012 100 1 – – – – – 101 0 0 0 013 101 0 – 0 – – 0 100 0 0 0 014 101 0 – 1 – – 0 011 0 0 0 015 101 0 – – – – 1 010 0 0 0 016 101 1 – – – – – 101 0 0 1 017 110 – – – – – – --- – – – –
18 111 – – – – – – --- – – – –© Cengage Learning 2014
676 Unit 19
The added entries have been printed in boldface.
The dice game controller can also be realized using a PAL. The required PAL 
equations can be derived from Table 19-2 using the method of map-entered vari-
ables (Section 6.5) or using a CAD program such as LogicAid. Figure 19-17 shows 
maps for A+, B+, and Win . Because A+, B+, C+, and Rb have assigned values in 
most of the rows of the table, these four variables are used on the map edges, and the remaining variables are entered within the map. E
1, E2, E3, and E4, on the maps 
represent the expressions given below the maps.
The resulting equations are
  A+ =A′B′C · Rb′D7′11D2′312 + AC ′ + A  · Rb + A  · D7′Eq′
  B+ =A′B′C · Rb′(D711+D2312)  + B · Reset ′ + AC  · Rb′(Eq + D7)
  C+ =B′ · Rb + A ′B′C · D7′11D2312 + BC  · Reset ′ + AC  · D7Eq′
 Win =BC′
Lose =BC
Roll =B′C · Rb
Sp    =A′B′C · Rb′D7′11D2′312 
(19-1)
These equations can also be derived using LogicAid or another CAD program. The 
entire dice game, including the control circuit, can be implemented using a small CPLD or FPGA. Implementation using VHDL is described in Section 20.4.001 0 0001 0 0110000
001 0 0001 1 0110000
001 0 0101 0 0110000
001 0 0101 1 0110000
001 0 1001 0 0110000
001 0 1001 1 0110000
001 0 1101 0 0110000
001 0 1101 1 0110000
FIGURE 19-17 Maps Derived from Table 19-2
R = Reset
E3 = D711 + D′711D2312 = D711 + D2312
E4 = Eq + Eq ′D7 = Eq + D7X 100 01 11 10
X 1
X 1
E100CRbAB
01
11
10 X E2R′ X00 01 11 10
R′ X
R′ X
E300CRbAB
01
1110 R′ X E
41 X00 01 11 10
1 XX00CRbAB
01
1110
A+B+
E1 = D′711D′2312
E2 = D′7Eq′WinX © Cengage Learning 2014
State Machine Design with SM Charts  677
This unit has illustrated one way of realizing an SM chart using a PLA or ROM. 
Alternative procedures are available which make it possible to reduce the size of the 
PLA or ROM by adding some components to the circuit. These methods are gener-ally based on transformation of the SM chart to different forms and encoding the inputs or outputs of the circuit.
Problems
19.1 Construct an SM block that has three input variables (D, E, F  ), four output vari-
ables (P, Q, R, S ), and two exit paths. For this block, output P is always 1, and Q  is 
1 iff D =1. If D  and F are 1 or if D and E  are 0, R=1 and exit path 2 is taken. If 
(D=0 and E =1) or (D =1 and F =0), S=1 and exit path 1 is taken.
19.2 Convert the state graph of Figure 13-11 to an SM chart.
19.3 Complete the following timing diagram for the SM chart of Figure 19-10. Assume 
St=1.
ShS0
AdKMStateClock
19.4 Solve Problem 18.5 using an SM chart instead of a state graph.
19.5 Work through Programmed Exercise 18.1 using an SM chart instead of a state graph.
19.6 Solve Problem 18.6 using an SM chart instead of a state graph.
19.7 (a)  For the SM chart of Figure 19-9, make the following state assignment for the 
flip-flops Q0, Q1, and Q2:
S0: 000;   S1: 001;   S2: 100;   S3: 101;   S4: 110;   S5: 111.
Derive the next-state and output equations by tracing link paths on the SM chart. Simplify the equations and, then, draw the circuit using D flip-flops and NAND gates.
678 Unit 19
(b) Repeat for the SM chart of Figure 19-10, using the following state assignment 
for flip-flops Q0 and Q1: S0: 00; S1: 01; S2: 11; S3: 10.
19.8 (a)  Write the next-state and output equations for the dice game by tracing link 
paths on the SM chart (Figure 19-13). Use a straight binary assignment.
(b) Design the block labeled “Test Logic” on Figure 19-11.
19.9 Realize the SM chart of Figure 19-7(b) using a PLA and two D flip-flops. Draw the 
block diagram and give the PLA table.
19.10 For the following SM chart:
(a) Draw a timing chart that shows the clock, the state (S0, S1, or S2), the inputs X1 
and X2, and the outputs. Assume that X3=0 and the input sequence for X1X2 
is 01, 00, 10, 11, 01, 10. Assume that all state changes occur on the rising edge of the clock, and the inputs change between clock pulses.
(b) Using a straight binary assignment, derive the next-state and output equa-
tions by tracing link paths. Simplify these equations using the don’t-care state 
(AB=11) and draw the corresponding circuit.
(c) Realize the chart using a PLA and D flip-flops. Give the PLA table.
(d) If a ROM is used instead of a PLA, what size ROM is required? Give the first 
five rows of the ROM table.
0
10
0
11
0
1
01X1
X3S0/
X1S2/Z1S1/Z3Z2 Z1
X2
X2Z3
19.11 Construct an SM block that has three input variables (A, B, and C), four outputs 
(W, X, Y, and Z), and two exit paths. For this block, output Z is always 1, and W is 1 
iff A and B  are both 1. If C=1 and A=0, Y=1 and exit path 1 is taken. If C=0 or 
A=1, X=1 and exit path 2 is taken.
State Machine Design with SM Charts  679
19.12 Convert the state graphs of Figures 14-4 and 14-6 to SM charts. Use conditional  
outputs for Figure 14-4.
19.13 Convert the state graph of Figure 13-15 to an SM chart. Test only one variable in each decision box. Try to minimize the number of decision boxes.
19.14 (a)  Construct an SM chart for a Moore sequential circuit with a single input and a 
single output such that the output is 1 if and only if the input has been 1 for at least three consecutive clock times.
(b) Use a one-hot state assignment for the sequential circuit and derive the next-
state and output equations.
(c) Make a state assignment for the sequential circuit using a minimum number of 
state variables and derive the next-state equation and output equations directly from the equations for the one-hot assignment.
(d) Simplify the next-state equations found in part (c).
19.15 (a) Construct an SM chart for the controller in Problem 18.21.
(b) Implement the controller using two D flip-flops and derive minimum two-level 
NAND-gate logic for the flip-flop input equations and the output equations. (Assign 00 to the initial state, 01 to the state reachable from the initial state, and 11 to the third state.)
(c) Implement the controller using a one-hot state assignment. Again use D flip-
flops and two-level NAND-gate logic for the flip-flop input equations and the output equations.
(d) Implement the controller using two D flip-flops with a 2-to-4 decoder connected 
to the D flip-flops outputs and two-level NAND-gate logic connected to the decoder outputs for the flip-flop input equations and the output equations. (Use the same 00, 01, 11 state assignment.)
19.16 Convert the state graph shown in Figure 18-8 to an SM chart.
19.17 Complete the following timing diagram for the SM chart of Figure 19-9.
SuShCStStateClock
S0 S1 S2 S2 S3 S3 S4
680 Unit 19
19.18 Realize the SM chart of Figure 19-10 using a PLA and two D flip-flops. Draw the block 
diagram and give the PLA table. Use the same state assignment as in Problem 19.7(b).
19.19 Work Problem 19.10 for the following SM chart and the input sequence X1X2X3 =
011, 101, 111, 010, 110, 101, 001.
19.20 The circuit below counts the number of 1’s in an input A. Assume A is available 
when a start signal s becomes 1; A is loaded into a parallel loading shift register. At 
the same time a value is loaded into an up counter C. After completing the count of 1’s, the controller generates a signal Done until s has returned to 0. (Note that the 
serial input to R, a
i, can be a constant value.)
(a) Specify the value to be loaded into C.
(b) Construct an SM chart for the controller.
As
CLKa0
DoneController
QLd
Up CounterC LC
CLKCnt IncC
CoutQLd8-bit Shift
RegisterR
LR
CLKSh SR8LR
SR
LC
IncC
a0
z8z
SinCinai
ai1
01
0
10
1
0
10X2
X3S0/
X1S2/Z1S1/Z1Z2 Z1
X1
X2Z3
State Machine Design with SM Charts  681
19.21 Redesign the controller of Problem 19.20 so that the circuit counts the number of 
“1 runs” in A rather than the number of 1’s. A “1 run” is 1 or more consecutive 1’s. 
For example, 11001011 contains three 1 runs, and 01110100 contains two 1 runs.
(a) Specify the value to be loaded into C.
(b) Construct an SM chart for the controller.
19.22 Modify the circuit of Problem 19.20 so that the zero detect circuit is connected to C rather than R; hence, 
z=1 when C contains 0. When s=1, the circuit computes the 
2’s complement of A and stores it in register R.
(a) What is the minimum length of C, and what value must initially be loaded into C?
(b) Construct an SM chart for the controller.
19.23 Make two modifications to the circuit in Problem 19.20. First make R a 9-bit regis-ter; when 
A is loaded, a 0 is appended to the left end of A. Second, move the zero 
detect circuit to the output of C, so z becomes 1 when C contains 0. When the circuit 
completes operation, A is in R with a parity bit appended to the left end so that the 
9 bits have odd parity.
(a) How many bits must C be, and what value must be loaded into C?
(b) Construct an SM chart for the controller.
19.24 Make two modifications to the circuit in Problem 19.20. First, move the zero detect circuit to the output of C, so 
z becomes 1 when C contains 0. Second, add an output 
ov to the controller. After loading A into R the circuit adds 3 to A leaving the sum in 
R; if the sum is incorrect and overflows, the controller makes ov =1.
(a) How many bits must C be, and what value must be loaded into C?
(b) Construct an SM chart for the controller.
19.25 A sequential circuit has an input (s) and two outputs (z1 and z2). When s changes 
from 0 to 1, the circuit repeats the following pattern 12 times: z1 z2=10, 01, i.e., z1 
is 1 for one clock period followed by z2 is 1 for one clock period repeated 12 times; 
otherwise, both z1 and z2 are 0. After the 24 output patterns, the circuit waits until 
s returns to 0, if it hasn’t already, and then the operation can repeat. The sequential 
circuit is to be designed in two parts: (1) a four-state controller and (2) a 4-bit parallel loading counter. The counter diagram is shown. When LDN is 0, the parallel inputs are loaded into the counter. When LDN is 1 and CE is 1, the counter increments. When LDN is 1 and CE is 0, the counter does not change state. The output TC is 1 when the counter value is decimal 15.
(a) Construct an SM chart for the controller. You need to specify the signals between 
the controller and the counter.
(b) Using a one-hot state assignment, write the next-state and output equations for 
the controller.
682 Unit 19
(c) Make a state assignment for the controller using two state variables. Assign 00 
to the initial state and make the other assignments so that only one variable 
changes during each state change. Derive the next-state and output equations for the controller.
ClkLD LDN4-Bit CounterCETCP3P2P1P0
Q3Q2Q1Q0
19.26 Work Problem 18.28, parts (a), (b), and (c), but use an SM chart instead of a state graph. For part (d), design the controller using a minimum number of D flip-flops, a decoder, and NAND gates.
19.27 The following circuit is a multiplier for 8-bit, unsigned (positive) numbers. When the start input 
(S) changes to 1, the multiplicand and multiplier are available on the input 
lines, and this signals the controller to begin the multiplication process. Upon com-pletion, the product is available in the lower 8 bits of the 9-bit PU  register  combined with the 8-bit PL register. Assume 
S remains 1 until the D signal is  generated. Then 
the circuit holds D and the product until S is returned to 0.
The data path portion of the circuit has the following components:
(a) 8-bit A register for holding the multiplicand
(b) 8-bit B register for holding the multiplier
(c) 9-bit PU register for accumulating the upper part of the product
(d) 8-bit PL register for the lower part of the product
(e) 8-bit adder with inputs from A reg and 8 bits of PU; sum and carry-out are inputs 
of PU reg; carry-in is 0
The control section contains a 3-bit counter (C) with an all 1’s detection circuit 
connected to its outputs. The inputs to the controller are S, the least significant bit of B
 (B0) and the output of the all 1’s detection circuit (C1). The outputs of the control-
ler are D, and all of the control signals for the registers. The control signals for the 
registers are
(a) LA, load A
(b) LB, load B
(c) SB, shift B right with B0 connected to the shift-in bit
(d) CC, clear C
(e) IC, increment C
(f  ) CP, clear PU and PL
(g) LPU, load PU
(h) SP, shift PU and PL right; the shift-in bit of PU is 0 and the shift-in bit of PL is the least significant bit of PU
Construct an SM chart for the controller using a minimum number of states. Do 
not modify the data path portion of the circuit.
State Machine Design with SM Charts  683
C Counter
All 1’s Detect3CC
IC
C1
ControllerS
DPU Reg (9-Bits)8
CP
LPUPL Reg
8A Reg8
CP
SPLAMultiplicand
Adder8 B0
coB Register8Multiplier
LB
8SP0 si sisiSB
ci 0
PU8
19.28 (a) Derive an SM chart for the Ultra-Slow Divider in Problem 18.30.
(b) Realize the SM chart in (a) using a PLA and D flip-flops.
19.29 (a) Derive an SM chart for the elevator controller in Problem 16.29.
(b) Realize the SM chart in (a) using a PLA and D flip-flops.
19.30 Derive an SM chart for the Thunderbird taillight controller in Problem 16.30.
19.31 (a) Derive the SM chart for the tape player controller of Problem 16.31.
(b) Realize the control circuit using a PLA and D flip-flops.
19.32 Convert the state graph of Figure 13-9 to an SM chart.
684VHDL for Digital System DesignUNIT
20
Objectives
1. Given a block diagram and a state graph for a digital system’s control unit of 
the type discussed in Unit 18, write behavioral VHDL code for the system. Use one clocked process.
2. Compile and simulate the VHDL code you wrote for Objective 1.
3. Write synthesizable VHDL code for the system using control signals. Use two processes, one for the combinational logic and one for updating registers.
4. Compile, simulate, and synthesize the VHDL code you wrote for Objective 3.
5. Write a VHDL test bench to test a VHDL module.
VHDL for Digital System Design  685
Study Guide
1. Study Section 20.1, VHDL Code for a Serial Adder.
(a) In Figure 20-1:
Which statements represent the full adder?
Why are concurrent statements used for the full adder instead of a clocked 
process?
Which VHDL statements are used to shift the X and Y register? Why are 
these statements in the clocked process?
(b) What change is required in the VHDL code if all register updates occur on 
the rising edge of the clock instead of the falling edge?
2. Study Section 20.2, VHDL Code for a Binary Multiplier.
(a) In Figure 20-2: Why are Mplier, Mcand, and ACC declared as type 
std_logic_vector instead of bit_vector?
After what state change does Done change from '1' to '0'?
When adding Mcand to ACC(7 downto 4), why is '0' concatenated to 
ACC(7 downto 4)? (line 29)
What does the notation when 2 ∣4∣6∣8 mean? (line 34)
(b) In Figure 20-3:
Why is the initial value of ACC “UUUUUUUUU”?
When should the product be read?
686 Unit 20
(c) If the signal X, of type std_logic_vector(8 downto 0), is “111001101” 
 initially, what is X after the execution of the following for loop? How long 
does it take?
for i in 5 downto 0 loop
  X <= X(7 downto 0) & X(8);
  wait for 10 ns;
end loop;
(d) In Figure 20-5, on lines 29 and 30, when i =2 and Done =‘1’, what are the 
values of Mcand and Mplier? What is the value of Product if the multiplier is working properly?
(e) In Figure 20-7:
Which statement represents the adder?
Why are Load, Ad, Sh, and Done set to '0' (line 22) before the case statement?
Write a single VHDL statement that will clear ACC(8 downto 4) and load 
ACC(3 downto 0) with Mplier, so that lines 39 and 40 can be replaced with 
a single line.
Why is addout loaded into ACC in the second process instead of the first 
process?
In Figure 20-2 we set Done <=
 '1' in a concurrent statement (line 42), and 
not after when 9 => on line 37 in the process. Why?
In Figure 20-7 line 33, we set Done <= '1' after when 9 =>, which is unlike 
what we did in Figure 20-2. Why is this correct in this case?
(f  ) In Figure 20-9:
When does the statement in line 22 execute?
If Sh = '1', which statements execute following a rising clock edge?
VHDL for Digital System Design  687
If the clock rises at t=10 ns, at what time are A, B, Count, and State 
updated? Explain why A and B are shifted as a unit even though the state-
ments for updating A and B execute in sequence (line 51).
(g) In Figure 20-10 at time = 60 ns, explain the contents of the registers after 
the rising clock edge. (Hint: Refer to Figure 18-9(c) to determine what hap-
pens in state 2 when K ='0'. Convert hexadecimal to binary and shift the 
binary before converting back to hexadecimal.) Repeat for time = 140 ns, noting that M ='1' before the rising clock edge.
(h) Read Appendix 
C, Tips for Writing Synthesizable VHDL Code.
(i) Work Problems 20.1, 20.2, 20.3, and 20.4.
3. Read Section 20.3, VHDL Code for a Binary Divider.
(a) In Figure 20-11:
If Dividend(8 downto 4) >= Divisor, what is the value of Subout(4)?
If Dividend(8 downto 4) < Divisor, what is the value of Subout(4)?Why is C equal to not Subout(4)?
(b) Work Problems 20.5, 20.6, and 20.7 .
4. Read Section 20.4, VHDL Code for a Dice Game Simulator.
Work Problem 20.8.
5. Read Section 20.5, Concluding Remarks.By looking at the VHDL code for the dice game, determine the minimum num-
ber of flip-flops required. Verify this against the value given in Table 20-1.
688In this chapter, we illustrate the use of VHDL in the design of digital systems. 
 Several of the examples are based on the multiplier and divider designs developed in Unit 18. We will use VHDL to describe a digital system at the behavioral level, so we can simulate the system to check out the algorithms used and to make sure that the sequence of operations is correct. We can then define the required control signals and the actions performed by these signals. Next, we write a VHDL descrip-tion of the system in terms of the control signals and verify its correct operation by simulation. We can then synthesize our design and download it to a CPLD or FPGA for final testing.
20.1 VHDL Code for a Serial Adder
First, we will write VHDL code that represents the serial adder with accumulator shown in Figure 18-1. The operation of the adder is explained in Section 18.1. In Figure 18-1, if 
Sh=1, the carry from the full adder is stored in the flip-flop at the 
same time the registers are shifted on the falling edge of the clock.
Figure 20-1 shows VHDL code for the serial adder. Provision for loading the X 
and Y registers and clearing the carry flip-flop (Ci) is not included in this code; how-
ever, the VHDL simulator can be used to initialize X,Y, and Ci for testing the code. 
The code is based on the state graph for the controller shown in Figure 18-3. We have used two processes to represent the state machine in a manner similar to the state machine model of Figure 17-17 . The first process (lines 18–28) executes whenever state or St changes, and it generates the NextState and Sh signals. The second process (lines 29–38) updates the state after the falling edge of the clock. At the same time, if 
Sh='1' the registers are shifted, and the carry is stored in the flip-flop (lines 33–36). 
The full adder is implemented using concurrent statements for the sum and carry (lines 15–16). This is appropriate because the full adder uses combinational logic that does not require a clock. Because std_logic and std_logic vectors are used in the code, the library and use statements (lines 1 and 2) are required. These statements could be omitted if bits and bit_vectors were used instead.VHDL for Digital System Design
VHDL for Digital System Design  689
1  library IEEE;
2  use IEEE.STD_LOGIC_1164.all;
3  entity serial is
4   Port (St: in std_logic;
5    Clk: in std_logic;
6    Xout: out std_logic_vector(3 downto 0));
7  end serial;
8  architecture Behavioral of serial is
9   signal X, Y: std_logic_vector(3 downto 0);
10   signal Sh: std_logic;
11   signal Ci, Ciplus: std_logic;
12   signal Sumi: std_logic;
13   signal State, NextState: integer range 0 to 3; -- 4 states
14   begin
15    Sumi <= X(0) xor Y(0) xor Ci; -- full adder
16    Ciplus <= (Ci and X(0)) or (Ci and Y(0)) or (X(0) and Y(0));
17    Xout <= X;
18   process (State, St)
19   begin
20    case State is
21     when 0 =>2 2       if St = ‘1’ then Sh <= ‘1’; NextState <= 1;
2 3       else Sh <= ‘0’; NextState <= 0; end if;
24     when 1 => Sh <= ‘1’; NextState <= 2;
25     when 2 => Sh <= ‘1’; NextState <= 3;
26     when 3 => Sh <= ‘1’; NextState <= 0;
27     end case;28   end process;
29   process (clk)
30    begin31    if clk’event and clk = ‘0’ then
32    State <= NextState; -- update state register
33     if Sh = ‘1’ then
3 4       X  <= Sumi & X(3 downto 1); -- shift Sumi into X register
35      Y <= Y (0) & Y(3 downto 1); -- rotate right Y register
36      Ci <= Ciplus; end if; -- store next carry
37     end if;38   end process;
39  end Behavioral;FIGURE 20-1
VHDL Code for 
Figure 18-1
© Cengage Learning 2014
690 Unit 20
20.2 VHDL Code for a Binary Multiplier
In Section 18.2, we designed a multiplier for unsigned binary numbers. In this section 
we will show several ways of writing VHDL code to describe the multiplier operation. As indicated in Figure 18-7 , 4 bits from the accumulator (ACC) and 4 bits from the multiplicand register are connected to the adder inputs; the 4 sum bits and the carry output from the adder are connected back to the accumulator. When an add signal 
(Ad  ) occurs, the adder outputs are loaded into the accumulator by the next clock 
pulse, thus, causing the multiplicand to be added to the accumulator. An extra bit at the left end of the product register temporarily stores any carry which is generated when the multiplicand is added to the accumulator. When a shift signal 
(Sh) occurs, 
all 9 bits of ACC are shifted right by the next clock pulse. See Section 18.2 for a more detailed explanation of the multiplier operation.
We will write a behavioral VHDL model for the multiplier (Figure 20-2) based 
on the block diagram of Figure 18-7 and the state graph of Figure 18-8. This model will allow us to check out the basic design of the multiplier and the multiplication algorithm before proceeding with a more detailed design. Because the control  circuit has ten states, we have declared an integer in the range 0 to 9 for the state  signal (line 12). The signal ACC represents the 9-bit accumulator output (line 13). 
-- This is a behavioral model of a multiplier for unsigned binary numbers. It multiplies a 4-bit-- multiplicand by a 4-bit multiplier to give an 8-bit product. The maximum number of clock-- cycles needed for a multiply is 10.
1  library IEEE;
2  use IEEE.STD_LOGIC_1164. ALL;
3  use IEEE.STD_LOGIC_ARITH. ALL;
4  use IEEE.STD_LOGIC_UNSIGNED. ALL;
5  entity mult4X4 is
6   port (Clk, St: in std_logic;
7   Mplier, Mcand : in std_logic_vector(3 downto 0);
8   Done: out std_logic;
9   Product: out std_logic_vector (7 downto 0));
10  end mult4X4;
11  architecture behave1 of mult4X4 is
12   signal State: integer range 0 to 9;
13   signal ACC: std_logic_vector(8 downto 0); -- accumulator
14   alias M: std_logic is ACC(0); -- M is bit 0 of ACC
15   begin
16    Product <= ACC (7 downto 0);
17    process (Clk)
18    begin19     if Clk’event and Clk = ‘1’ then --  executes on rising edge of clockFIGURE 20-2
Behavioral VHDL 
Code for Multiplier 
of Figure 18-7
© Cengage Learning 2014
VHDL for Digital System Design  691
The signals ACC, Mcand, and Mplier are declared as type std_logic_vector so that 
the overloaded “+” operator can be used for addition. The statement “alias M:  std_logic is ACC(0);” allows us to use the name M in place of ACC(0). The product is 
set equal to the lower 8 bits of ACC in a concurrent statement (line 16).
Because all register operations and state changes occur on the rising edge of 
the clock, we will use a process that executes when Clk changes. The case statement specifies the actions to be taken in each state. In state 0, if 
St='1' the multiplier is 
loaded into the accumulator at the same time the state changes to 1 (lines 21–26). From the state graph, we see that the same operations occur in states 1, 3, 5, and 7 . The notation “when 1 
| 3 | 5 | 7 =>” means when state is 1 or 3 or 5 or 7 , the state-
ments that follow will execute. When M ='1', the expression
'0' & ACC(7 downto  4)+Mcand
computes the adder output, which is loaded into ACC (lines 28–29). At the same time, the circuit goes to the next state in sequence (2, 4, 6, or 8). If M ='
0', ACC 
is shifted to the right by loading ACC with '0' concatenated with the upper 8 bits of ACC (line 31). At the same time the state changes to 3, 5, 7 , or 9 (the present state  + 2). In states 2, 4, 6, or 8 ACC is shifted to the right, and state changes to 
the next state in sequence (lines 34–36).
The Done signal needs to be turned on only in state 9. If we had used the statement 
“when 
9 => State <= 0; Done <= '1'”, Done would be turned on at the same time the 
State changed to 0. This is too late because we want Done to turn on when the State 20     case State is21     when 0 => --initial State
2 2       if St = ‘1’ then
23       ACC(8 downto 4) <= “00000”; -- clear upper ACC
24       ACC(3 downto 0) <= Mplier; -- load the multiplier
25       State <= 1;
2 6       end if;27     when 1 | 3 | 5 | 7 => -- “add/shift” State
2 8       if M = ‘1’ then -- Add multiplicand to ACC
29       ACC(8 downto 4) <= (‘0’& ACC(7 downto 4)) + Mcand;
30       State <= State + 1;
3 1       else ACC <= ‘0’ & ACC(8 downto 1); -- Shift accumulator right
32       State <= State + 2;
3 3       end if;34     when 2 | 4 | 6 | 8 => -- “shift” State
35       ACC <= ‘0’ & ACC(8 downto 1); -- Right shift
36       State <= State + 1;
37     when 9 => -- end of cycle
38       State <= 0;
39     end case;40     end if;41    end process;42    Done <= ‘1’ when State = 9 else ‘0’;
43   end behave1;FIGURE 20-2
(Continued)
692 Unit 20
becomes 9. Furthermore, if Done <= '1' were included in the clocked process, a synthe-
sizer would infer that we wanted to store Done in a flip-flop. Because we do not want 
to do this, we use a separate concurrent assignment statement. This statement is placed outside the process so that Done will be updated whenever the State changes.
Before continuing with the design, we will test the behavioral level VHDL code 
to make sure that the algorithm is correct and consistent with the hardware block diagram. At early stages of testing, we will want a step-by-step printout to verify the internal operations of the multiplier and to aid in debugging if required. When we think that the multiplier is functioning properly, we will only want to look at the final product output so that we can quickly test a large number of cases.
Figure 20-3 shows the command file and test results for multiplying 13 ×11. A clock 
is defined with a 20-ns period. The St signal is turned on at 2 ns and turned off one clock period later. By inspection of the state graph, the multiplication requires at most ten 
-- command ﬁle to test multiplierview listadd list Clk St State ACC Done Productforce St 1 2, 0 22force Clk 1 0, 0 10 –repeat 20force Mcand 1101force Mplier 1011run 200
ns delta Clk St State ACC done product
0 +1 1 U 0 UUUUUUUUU 0 UUUUUUUU
2 +0 1 1 0 UUUUUUUUU 0 UUUUUUUU
10 +0 0 1 0 UUUUUUUUU 0 UUUUUUUU
20 +2 1 1 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 1 0 1 1
22 +0 1 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 1 0 1 1
30 +0 0 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 0 1 0 1 1
40 +2 1 0 2 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
50 +0 0 0 2 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1
60 +2 1 0 3 0 0 1 1 0 1 1 0 1 0 0 1 1 0 1 1 0 1
70 +0 0 0 3 0 0 1 1 0 1 1 0 1 0 0 1 1 0 1 1 0 1
80 +2 1 0 4 1 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1 0 1
90 +0 0 0 4 1 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1 0 1
100 +2 1 0 5 0 1 0 0 1 1 1 1 0 0 1 0 0 1 1 1 1 0
110 +0 0 0 5 0 1 0 0 1 1 1 1 0 0 1 0 0 1 1 1 1 0
120 +2 1 0 7 0 0 1 0 0 1 1 1 1 0 0 1 0 0 1 1 1 1
130 +0 0 0 7 0 0 1 0 0 1 1 1 1 0 0 1 0 0 1 1 1 1
140 +2 1 0 8 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1
150 +0 0 0 8 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1
160 +2 1 0 9 0 1 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 1
170 +0 0 0 9 0 1 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 1
180 +0 1 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1
190 +0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1
200 +0 1 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 1 1 1FIGURE 20-3
Command File and 
Simulation Results 
for (13 by 11)
© Cengage Learning 2014
VHDL for Digital System Design  693
clocks, so the run time is set at 200 ns. The simulator output corresponds to the example 
given on page 600. Note that when Done = '1', the final product is 100011112=143.
To thoroughly test the multiplier, we need to run additional tests, including spe-
cial cases and limiting cases. Test values for the multiplicand and multiplier should include 0, maximum values, and smallest nonzero values. We will write VHDL code to test the multiplier by supplying a sequence of values for the multiplicand and mul-tiplier. VHDL code that is written to test another VHDL module is often referred to as a test bench. Figure 20-4 shows how the test bench is connected to the multiplier module. The test bench generates the Clk and St signals as well as supplying values of Mplier and Mcand to the Multiplier module. The Multiplier module, in turn, sends the Done signal and the Product values back to the test bench. Using the VHDL test bench is analogous to having a hardware tester sitting on a work bench and plugging in the multiplier module into a test socket to test it.
We will use a for loop within the test bench code. The syntax for a VHDL for 
loop statement is
  [loop-label:] for index in range loop
   sequential statements  end loop [loop-label];
The index is an integer variable that is defined only within the loop. This variable must not be explicitly declared because it is automatically declared by the compiler. 
When the loop is entered, the index is initialized to the first value in the range, and the sequential statements in the loop are executed. Then, the index is incremented (or decremented) to the next value, and the statements are executed again. This continues until the index equals the last value in the range, at which point the state-ments are executed for the last time and the loop exits. The for loop statement is a sequential statement that can be used within a process.
The VHDL code listing for the test bench is given in Figure 20-5. The test bench 
code is intended for simulation purposes only and does not have to be synthesizable. The port declaration has been omitted from the entity (lines 5–6) because we plan to use internal signals to connect the Multiplier to the test bench. The Multiplier module (mult4X4) is declared as a component within the architecture (lines 8–14). The multi-plicand and multiplier test values are placed in constant arrays dimensioned 1 to N (lines 16–18). Because we are using six pairs of values, the constant N is set to 6 (line 
15). The internal signals in the test bench are declared in lines 19–22. For convenience, we have used the same signal names as used in the component declaration, although we do not have to do this. At the start of the architecture body, we use a component instantiation statement to connect the Multiplier module to the test bench signals FIGURE 20-4
Test Bench for 
Multiplier
© Cengage Learning 2014Multiplier
Being
Tested
ProductDoneMcandMplierStClk
Test
Bench
694 Unit 20
(line 24). The port map lists the test signals in the same order as in the component 
port. The next statement generates a Clk signal with a half period of 10 ns.
The process contains a for loop that reads values from the multiplicand and mul-
tiplier arrays and then sets the start signal to '1' (lines 29–31). After the next rising clock edge, the start signal is turned off. Meanwhile, the multiplication is taking 1  library IEEE;
2  use IEEE.STD_LOGIC_1164. ALL;3  use IEEE.STD_LOGIC_ARITH. ALL;4  use IEEE.STD_LOGIC_UNSIGNED. ALL;
5  entity testmult is
6  end testmult;
7  architecture test1 of testmult is
8  component mult4X49  port (Clk: in std_logic;10   St: in std_logic;
11   Mplier, Mcand: in std_logic_vector(3 downto 0);
12   Product: out std_logic_vector(7 downto 0);
13   Done: out std_logic);
14  end component;
15  constant N: integer:= 6;
16  type arr is array(1 to N) of std_logic_vector(3 downto 0);
17  constant Mcandarr: arr:= (“1011”, “1101”, “0001”, “1000”, “1111”, “1101”);
18  constant Mplierarr: arr:= (“1101”, “1011”, “0001”, “1000”, “1111”,“0000”);
19  signal Clk: std_logic = ‘0’;
20  signal St, Done: std_logic;
21  signal Mplier, Mcand: std_logic_vector(3 downto 0);
22  signal Product: std_logic_vector(7 downto 0);
23  begin
24   mult1: mult4X4 port map(Clk, St, Mplier, Mcand, Product, Done);
25   Clk <= not Clk after 10 ns; -- clock has 20 ns period
26   process
27   begin
28    for i in 1 to N loop
29     Mcand <= Mcandarr(i);
30     Mplier <= Mplierarr(i);
31     St <= ‘1’;
32     wait until Clk = ‘1’ and Clk’event;
33     St <= ‘0’;
34     wait until Done = ‘1’ ;
35     wait until Clk = ‘1’ and Clk’event;
36    end loop;
37   end process;
38  end test1;FIGURE 20-5
Test Bench for 
Multiplier
© Cengage Learning 2014
VHDL for Digital System Design  695
place within the Multiplier module. When the multiplication is complete, the mul-
tiplier turns on the Done signal. Done is turned off at the same time the multiplier control goes back to S
0. The test bench process waits for Done = '1' and then waits 
for the next rising clock edge before looping back to read new values of Mcand and Mplier and restart the multiplication. After N times through the loop, the test is complete.
Figure 20-6 shows the command file for executing the test bench code and the 
simulator output. In the add list command line, “–NOtrigger Mplier Mcand product” together with “–Trigger done” causes the output to be displayed only when the Done signal changes. Without the –NOtrigger and –Trigger, the output would be displayed every time any signal on the list changed. We have annotated the simulator output to interpret the test results.
Next, we will model the same multiplier using two processes (see Figure 20-7). 
This model is based on Figures 17-16 and 17-17 . The first process represents the 
-- Command ﬁle to test multiplierview listadd list –NOtrigger Mplier Mcand product – Trigger donerun 1320 ns 
ns +delta mcand mplier product done
0 +0 U U U U U U U U UUUUUUUU U
0 +1 1 0 1 1 1 1 0 1 UUUUUUUU 0
150 +2 1 0 1 1 1 1 0 1 1 0 0 0 1 1 1 1 1 11 × 13 = 143
170 +2 1 0 1 1 1 1 0 1 1 0 0 0 1 1 1 1 0
330 +2 1 1 0 1 1 0 1 1 1 0 0 0 1 1 1 1 1 13 × 11 = 143
350 +2 1 1 0 1 1 0 1 1 1 0 0 0 1 1 1 1 0
470 +2 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 1 × 1 = 1
490 +2 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0
610 +2 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 8 × 8 = 64
630 +2 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0
810 +2 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 15 × 15 = 225
830 +2 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 0
930 +2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 13 × 0 = 0FIGURE 20-6
Command File and 
Simulation of 
Multiplier
© Cengage Learning 2014
FIGURE 20-7
Two-Process 
VHDL Model for 
Multiplier
© Cengage Learning 2014-- This is a behavioral model of a multiplier for unsigned binary numbers. It multiplies a 4-bit-- multiplicand by a 4-bit multiplier to give an 8-bit product. The maximum number of clock cycles-- needed for a multiply is 10.
1  library IEEE;
2  use IEEE.STD_LOGIC_1164. all;3  use IEEE.STD_LOGIC_ARITH. all;4  use IEEE.STD_LOGIC_UNSIGNED. all;
696 Unit 20
5  entity mult4X4 is
6   port (Clk, St: in std_logic;7    Mplier, Mcand: in std_logic_vector(3 downto 0);
8    Product: out std_logic_vector(7 downto 0);
9    Done: out std_logic);
10  end mult4X4;
11  architecture control_signals of mult4X4 is
12   signal State, Nextstate: integer range 0 to 9;13   signal ACC: std_logic_vector(8 downto 0); -- accumulator
14   alias M: std_logic is ACC(0); -- M is bit 0 of ACC
15   signal addout: std_logic_vector(4 downto 0); -- adder output including carry16   signal Load, Ad, Sh: std_logic;17   begin18    Product <= ACC(7 downto 0);
19    addout <= (‘0’ & ACC(7 downto 4)) + Mcand; 
       -- uses “+” operator from the ieee._std_logic_unsigned package20    process(State, St, M)21    begin22     Load <= ‘0’; Ad <= ‘0’; Sh <= ‘0’; Done <= ‘0’;
23     case State is24     when 0 =>2 5       if St = ‘1’ then Load <= ‘1’; Nextstate <= 1;
2 6       else Nextstate <= 0; end if;27     when 1 | 3 | 5 | 7 => -- “add/shift” State
2 8       if M = ‘1’ then Ad <= ‘1’; -- Add multiplicand
29      Nextstate <= State + 1;
3 0       else Sh <= ‘1’; Nextstate <= State + 2; end if;
31     when 2 | 4 | 6 | 8 => -- “shift” State
32      Sh <= ‘1’; Nextstate <= State + 1;
33     when 9 => Done <= ‘1’; Nextstate <= 0;
34     end case;35    end process;
36    process (Clk) -- Register update process
37    begin
38     if Clk‘event and Clk = ‘1’ then -- executes on rising edge of clock
3 9       if Load = ‘1’ then ACC(8 downto 4) <= “00000”;
40       ACC(3 downto 0) <= Mplier; end if; -- load the multiplier
4 1       if Ad = ‘1’ then ACC(8 downto 4) <= addout; end if;
4 2       if Sh = ‘1’ then  ACC <= ‘0’ & ACC(8 downto 1); end if;  
--Shift accumulator right
43       State <= Nextstate;
44     end if;45    end process;46  end control_signals;FIGURE 20-7
(Continued)
VHDL for Digital System Design  697
 combinational circuit that generates control signals and next-state information. 
The second process updates all of the registers on the rising edge of the clock. This model corresponds more closely to the actual hardware than the one-process model of Figure 20-2, and the control signals Ld, Sh, and Ad, as well as the adder output, appear explicitly in the code. The port declaration is the same for the two models, but the architectures are different.
Because the adder is a combinational circuit, we can define the adder output in 
a concurrent statement (line 19). This 5-bit output includes the 4 sum bits and the carry. It is efficient to represent the combinational part of the sequential control cir-cuit by a process with a case statement (lines 20–35). This process executes whenever State, 
St or M changes, and it computes the values of Nextstate, Load, Sh, Ad, and 
Done. The four control signals are set to '0' in line 22, and then they are set to '1' as required in the case statement. This technique avoids the necessity of setting these signals to '0' in each state and in each else clause where they are not set to '1'. At first glance, setting a signal to '0' and '1' at the same instant of time appears to be a conflict. However, when two sequential statements in a process both change the same signal at the same time, the value assigned by the second statement to execute overrides the value assigned by the first statement. The case statement determines the values of Nextstate and the control signals. For example, when state is 1, 3, 5, or 7 ,  if M ='1', the Ad signal is turned on and the Nextstate is the present state plus 1. 
However, no registers can change until the next active clock edge.
All register updates occur in the second process after the rising edge of Clk. If 
Load  = '1', Mplier is loaded into the lower ACC and the upper ACC is cleared (lines 
38–40). If Ad Ad ='1', the adder output is loaded into the upper ACC (line 41). If 
Sh='1' ACC is shifted to the right (line 42). The state register is always updated 
(line 43).
Because the entity is the same for both multipliers, we can use the same test 
bench to test the second multiplier as we did for the first one, and we should obtain the same test results.
Next, we will write VHDL code for a binary multiplier that multiplies two 8-bit 
numbers to give a 16-bit product. For the control circuit, we will use an add-shift control with a counter, as shown in Figure 18-9, instead of using a state graph with more states. Figure 20-8 shows the block diagram for the 
8×8 multiplier. This is of the same form 
FIGURE 20-8
Block Diagram for 
8 × 8 Binary 
Multiplier
© Cengage Learning 2014ClrSh Lin A (8:0)
A (7:0)A(0)
8-Bit
AdderAdd-Shift
ControlLd
Load0
9
8
8
Multiplicand8
Multiplier
St8ShAd
Clr 0Sh Lin B (7:0)Ld
ShLoad
AdLoad
Sh
KM = B(0)
ClrCt3-Bit CounterLoadCout
698 Unit 20
as Figure 18-7 except the ACC register has been split into two registers— A and B . 
A is the 9-bit accumulator register, and B  initially holds the 8-bit multiplier. When the 
multiplication is complete, the 16-bit product is in A(7 downto 0)& B. The controller 
generates signals Load, Sh, and Ad. The Load signal clears A, loads the multiplier 
into B, and clears the shift counter. The Sh signal shifts both A and B together and 
increments the counter. The Ad signal loads the adder outputs into A.
The VHDL code for the 8×8 multiplier (Figure 20-9) is based on the block 
 diagram of Figure 20-8 and the state graph of Figure 18-9(c). The entity and sig-nal declarations are similar to those used in the previous examples except for the 
1  library IEEE;
2  use IEEE.STD_LOGIC_1164. all;3  use IEEE.STD_LOGIC_ARITH. all;4  use IEEE.STD_LOGIC_UNSIGNED. all;
5  entity mult8X8 is
6   Port (Clk, St: in std_logic;7   Mplier, Mcand: in std_logic_vector(7 downto 0);
8   Done: out std_logic;
9   Product: out std_logic_vector(15 downto 0));
10  end mult8X8;
11  architecture Behavioral of mult8X8 is
12   signal State, NextState: integer range 0 to 3;13   signal count: std_logic_vector(2 downto 0) := “000”; -- 3-bit counter14   signal A: std_logic_vector(8 downto 0); -- accumulator
15   signal B: std_logic_vector(7 downto 0);16   alias M: std_logic is B(0); -- M is bit 0 of B
17   signal addout: std_logic_vector(8 downto 0);18   signal K, Load, Ad, Sh: std_logic;19   begin20    Product <= A(7 downto 0) & B; -- 16-bit product is in A and B
21    addout <= ‘0’ & A(7 downto 0) +  Mcand; -- adder output is 9 bits including carry
22    K <= ‘1’ when count = 7 else ‘0’;
23    process (St, State, K, M)24    begin25     Load <= ‘0’; Sh <= ‘0’; Ad <= ‘0’; Done <= ‘0’; 
        -- control signals are ‘0’ by default26     case State is27     when 0 =>2 8       if St = ‘1’ then Load <= ‘1’; NextState <= 1;
2 9       else NextState <= 0; end if;30     when 1 =>3 1       if M = ‘1’ then Ad <= ‘1’; NextState <= 2;
3 2       else if K = ‘0’ then Sh <= ‘1’; NextState <= 1;
3 3        else Sh <= ‘1’; NextState <= 3; end if;FIGURE 20-9
VHDL Code for 
Multiplier with 
Shift Counter
© Cengage Learning 2014
VHDL for Digital System Design  699
number of bits. The signal count in line 13 represents the 3-bit counter. Line 21 
implements the 8-bit adder using a concurrent statement, and line 22 sets K to 1 when the count is 7 . The first process (lines 23–40) represents the combinational  part of the state machine. It generates control signals Ad, Load, and Sh whenever  the inputs state, St, M, and K change.
To make sure that the code will synthesize properly, we have included an else 
clause in each if statement so that the NextState is properly defined, regardless whether the condition is TRUE or FALSE. For example, in lines 28–29 NextState is 1  
or 0 depending on the value of St. For simulation purposes, we could omit the else clause because a VHDL signal holds its value until it is explicitly changed. However, if we omitted the else clause, most synthesizers would generate an unnecessary latch.
The second process updates the registers on the rising edge of Clk. In lines 45–48, 
if Load = '1', the counter is cleared when the multiplier is loaded. In lines 50–53, if 
Sh='1', the counter is incremented when the A-B registers are shifted. In a clocked 
process, the if statements do not need else clauses because all registers hold their 
current values until changed.3 4       end if;35     when 2 =>3 6       if K = ‘0’ then Sh <= ‘1’; NextState <= 1;
3 7       else Sh <= ‘1’; NextState <= 3; end if;
38     when 3 =>39      Done <= ‘1’; NextState <= 0;
40     end case;41   end process;
42    process (Clk)
43    begin44     if Clk’event and Clk = ‘1’ then -- update registers on rising edge of Clk
4 5       if Load = ‘1’ then
4 6        A  <= “000000000”; Count <= “000”; -- clear A and counter
4 7        B  <= Mplier;
4 8       end if; -- load multiplier
4 9       if Ad = ‘1’ then A <= addout; end if;
5 0       if Sh = ‘1’ then
5 1        A  <= ‘0’ & A(8 downto 1); B <= A(0)& B(7 downto 1); 
           -- right shift A and B52       count <= count + 1; -- increment counter
53           -- uses “ +” operator from ieee_std_logic_unsigned package
5 4       end if;55      State <= NextState;
56      end if;
57     end process;
58  end Behavioral;FIGURE 20-9
(Continued)
700 Unit 20
Figure 20-10 shows a simulator command file used to test the multiplier with 
inputs 11 × 13. The A and B register values and the product are shown in hexadeci-
mal on the resulting waveforms. The current multiplier bit (M) is the same as b(0). Note that at time =240 ns, the state changes to 3, the Done signal is turned on, and 
the final product is the correct answer, 8F
16=14310.
20.3 VHDL Code for a Binary Divider
In Section 18.3 we designed a parallel divider for positive binary numbers that divides an 8-bit dividend by a 4-bit divisor to obtain a 4-bit quotient. Figure 20-11 shows VHDL code for the divider based on the block diagram of Figure 18-10 and FIGURE 20-10
Command File 
and Simulation of 
8 × 8 Multiplier
© Cengage Learning 2014
0 50 ns 100 ns 150 ns 200 ns 250 ns/mult8x8/product XXXX 000D 0586 02C3 0DC3 06E1 08F0 0478 023C 011E000 001 010 011 100 101 110 11101 21 2121 3
XXX 000 005 002 00D 006 008 004 002 001
XX 0D 86 C3 E1 F0 78 3C 1E 8F
/mult8x8/done/mult8x8/b/mult8x8/a/mult8x8/count/mult8x8/state/mult8x8/b(0)/mult8x8/st/mult8x8/clk
00B 011
11E1 0B0D 008F000
000add wave clk st state count a b done product
force st 1 2, 0 22force clk 1 0, 0 10 –repeat 20force mcand 00001011force mplier 00001101run 280
FIGURE 20-11
VHDL Code for 
Divider
© Cengage Learning 20141  library IEEE;
2  use IEEE.STD_LOGIC_1164. all;3  use IEEE.STD_LOGIC_ARITH. all;4  use IEEE.STD_LOGIC_UNSIGNED. all;
5  entity Divider is
6  Port (Dividend_in: in std_logic_vector(7 downto 0);7   Divisor: in std_logic_vector(3 downto 0);
VHDL for Digital System Design  701
8    St, Clk: in std_logic;
9    Quotient: out std_logic_vector(3 downto 0);
10   Remainder: out std_logic_vector(3 downto 0);
11   Overﬂow: out std_logic);
12  end Divider;
13  architecture Behavioral of Divider is
14  signal State, NextState: integer range 0 to 5;15  signal C, Load, Su, Sh: std_logic;16  signal Subout: std_logic_vector(4 downto 0);17  signal Dividend: std_logic_vector(8 downto 0);18  begin19   Subout <= Dividend(8 downto 4) – (‘0’ & divisor);
20   C <= not Subout (4);
21   Remainder <= Dividend(7 downto 4);
22   Quotient <= Dividend(3 downto 0);
23  State_Graph: process (State, St, C)
24   begin25    Load <= ‘0’; Overﬂow <= ‘0’; Sh <= ‘0’; Su <= ‘0’;
26   case State is27    when 0 =>28     if (St = ‘1’) then Load <= ‘1’; NextState <= 1;
29     else NextState <= 0; end if;30    when 1 =>31     if (C = ‘1’) then Overﬂow <= ‘1’; NextState <= 0;
32     else Sh <= ‘1’; NextState <= 2; end if;
33    when 2 | 3 | 4 =>34     if (C = ‘1’) then Su <= ‘1’; NextState <= State;
35     else Sh <= ‘1’; NextState <= State + 1; end if;
36    when 5 =>37     if (C = ‘1’) then Su <= ‘1’; end if;
38     NextState <= 0;
39   end case;40  end process State_Graph;
41  Update: process (Clk)
42   begin
43   if Clk’event and Clk = ‘1’ then -- rising edge of Clk
44    State <= NextState;
45    if Load = ‘1’ then Dividend <= ‘0’ & Dividend_in; end if;
46    if Su = ‘1’ then Dividend(8 downto 4) <= Subout; Dividend(0) <= ‘1’; end if;
47    if Sh = ‘1’ then Dividend <= Dividend(7 downto 0) & ‘0’; end if;
48   end if;49  end process update;50  end Behavioral;FIGURE 20-11
(Continued)
702 Unit 20
the state graph of Figure 18-11. A concurrent statement (line 19) computes the sub-
tracter output, subout, using an overloaded “−”operator. Then, line 20 computes C as the complement of the high order bit of the subtracter output (see Section 18.3 for justification).
The first process (lines 23–40) represents the combinational part of the sequen-
tial circuit. It computes the values of NextState and the control signals whenever state, St, or C changes. As in the other examples, line 24 sets the control signals to '0', and these signals are set to '1' as required within the case statement. The second process (lines 41–49) updates the state and dividend registers on the rising edge of the clock. If Ld ='1', the 9-bit dividend register is loaded with '0' followed by the 
8-bit dividend (line 45). If 
Su='1', the subtracter output is loaded into the upper 
part of the dividend register and the quotient bit is set to '1' (line 46). If Sh = '1', the dividend register is shifted left (line 47).
20.4 VHDL Code for a Dice Game Simulator
In this section we will write behavioral VHDL code for the dice game described in Section 19.2. The code in Figure 20-12 is based on the block diagram for the DiceGame Module in Figure 19-11 and the SM chart of Figure 19-13. The two coun-ters and the adder will be placed in a separate module, so the input to this module is the sum of the two counters, which represents the roll of the dice. This sum must be in the range 2 to 12 as declared in line 3. The Point register is a signal with the same range (line 8). We will use a two-process model for the dice game. The first process represents the combinational logic for the controller. Whenever the inputs Rb, Reset, Sum, or State change, this process computes new values for NextState, for the control signals (Sp and Roll), and for the outputs (Win and Lose). The case statement tests the state, and in each state nested if-then-else (or elsif) statements 
implement the conditional tests. In State 1 the Roll signal is turned on when Rb is 1. If all conditions test FALSE, Sp is set to 1, and the next state is 4. In the second process, the state is updated after the rising edge of the clock (line 38), and if Sp is 1, the sum is stored in the point register (line 39).
FIGURE 20-12
VHDL Code for Dice 
Game Controller
© Cengage Learning 20141  entity DiceGame is
2   port (Rb, Reset, Clk: in bit;3    Sum: in integer range 2 to 12;
4    Roll, Win, Lose: out bit);
5  end DiceGame;
6  architecture DiceBehave of DiceGame is
7   signal State, NextState: integer range 0 to 5;8   signal Point: integer range 2 to 12;9   signal Sp: bit;10  begin
VHDL for Digital System Design  703
To complete the VHDL implementation of the dice game we will add a module 
with two counters, which count from 1 to 6, and an adder as shown in Figure 20-13. 
The counters are initialized to 1 so that the sum of the two dice will always be in the range 2 through 12. When Cnt1 is in state 6, the next clock sets it to state 1, and Cnt2 is incremented (or Cnt2 is set to 1 if it is in state 6). The concurrent statement in line 19  
implements the adder.
The main module shown in Figure 20-14 connects the DiceGame and Coun-
ter modules together. The architecture starts with two component declarations (lines 6–14). The internal signals that connect the two modules, roll1 and sum1, are declared in lines 15 and 16. The two components are instantiated in lines 18 and 19. These statements connect the two components to each other and to the port signals.11   process(Rb, Reset, Sum, State)
12    begin
13     Sp <= ‘0’; Roll <= ‘0’; Win <= ‘0’; Lose <= ‘0’;
14     case State is
1 5       when 0 => if Rb = ‘1’ then NextState <= 1; else NextState <= 0; end if;
1 6       when 1 =>
1 7        if Rb = ‘1’ then Roll <= ‘1’; NextState <= 1;
1 8        elsif Sum = 7 or Sum = 11 then NextState <= 2;
1 9        elsif Sum = 2 or Sum = 3 or Sum = 12 then NextState <= 3;
2 0        else Sp <= ‘1’; NextState <= 4;
2 1        end if;
2 2       when 2 => Win <= ‘1’;
2 3        if Reset = ‘1’ then NextState <= 0; else NextState <= 2; end if;
2 4       when 3 => Lose <= ‘1’;
2 5        if Reset = ‘1’ then NextState <= 0; else NextState <= 3; end if;
2 6       when 4 => if Rb = ‘1’ then NextState <= 5; else NextState <= 4; end if;
2 7       when 5 =>
2 8        if Rb = ‘1’ then Roll <= ‘1’; NextState <= 5;
2 9         elsif Sum = Point then NextState <= 2;
3 0         elsif Sum = 7 then NextState <= 3;
3 1         else NextState <= 4;
3 2        end if;
33     end case;
34    end process;
35    process(Clk)
36    begin
37     if Clk’ event and Clk = ‘1’ then
38      State <= NextState;
3 9       if Sp = ‘1’ then Point <= Sum; end if;
40     end if;
41    end process;
42  end DiceBehave;FIGURE 20-12
(Continued)
704 Unit 20
1  entity Counter is
2  port(Clk, Roll: in bit;
3   Sum: out integer range 2 to 12);
4  end Counter;
5  architecture Count of Counter is
6  signal Cnt1,Cnt2: integer range 1 to 6 := 1;7  begin8   process (Clk)9   begin10    if Clk’event and Clk = ‘1’ then
11     if Roll = ‘1’ then
12      if Cnt1 = 6 then Cnt1 <= 1; else Cnt1 <= Cnt1 + 1; end if;13      if Cnt1 = 6 then1 4        if Cnt2 = 6 then Cnt2 <= 1; else Cnt2 <= Cnt2 + 1; end if;15      end if;16     end if;17    end if;18  end process;
19  Sum <= Cnt1 + Cnt2;
20  end Count;FIGURE 20-13
Counter Module 
for Dice Game
© Cengage Learning 2014
1  entity Game is
2   port (Rb, Reset, Clk: in bit;3    Win, Lose: out bit);
4  end Game;
5  architecture Play1 of Game is
6   component Counter7    port(Clk, Roll: in bit;8     Sum: out integer range 2 to 12);
9   end component;10   component DiceGame
11    port (Rb, Reset, Clk: in bit;12     Sum: in integer range 2 to 12;
13     Roll, Win, Lose: out bit);
14   end component;15  signal roll1: bit;
16  signal sum1: integer range 2 to 12;
17  begin
18   Dice: Dicegame port map(Rb, Reset, Clk, sum1, roll1, Win, Lose);
19   Count: Counter port map(Clk, roll1, sum1);
20  end Play1;FIGURE 20-14
Main Module for 
Dice Game
© Cengage Learning 2014
VHDL for Digital System Design  705
20.5 Concluding Remarks
Except for the test bench, all of the VHDL code in this chapter is synthesizable. 
The synthesis results depend on the target device and synthesizer that is used. Most synthesizers offer the choices of optimizing for area, for speed, or for something in between. Optimizing for area implies fewer macrocells or function generators are used, resulting in a smaller area used on the IC chip. Optimizing for speed means reducing the delay times along the various paths so that a higher clock speed may be used. This often results in using more components and a larger chip area.
Table 20-1 shows some typical synthesis results for five VHDL code examples 
from this chapter when the optimize for area option was chosen. Results shown here are for Xilinx CoolRunner CPLDs and for the Xilinx Spartan and Spartan II FPGAs. The Xilinx XST synthesizer was used for CoolRunner, and the FPGA Express synthesizer was used for Spartan. In all cases, the number of flip-flops is minimum and the same for the different devices. For CPLDs, the most important factors in determining the required chip area are the number of macrocells and the number of product terms, and the optimizer attempts to minimize these. For FPGAs, the optimizer attempts to reduce chip area by minimizing the required number of logic cells (CLBs, or slices). Each CLB or slice contains two four-input function gen-erators (also called lookup tables or LUTs) and two flip-flops. Most designs require more function generators than flip-flops, so a key factor in optimizing for area is to reduce the number of four-input function generators (LUTs).
In this text we have introduced the basic VHDL features needed to write syn-
thesizable code. In most examples, we have related the VHDL code to the actual hardware that it represents. In Unit 10, we used concurrent statements to represent combinational logic. In Unit 17 , we used sequential statements in a process to rep-resent sequential logic and also to represent combinational logic. In this chapter we wrote VHDL code to describe small synchronous digital systems based on their block diagrams and state graphs.
In the example of Figure 20-2, we wrote a behavioral model for a multiplier 
using a single process to update the state and the registers on the rising clock edge. When a single process is used, it is often necessary to add concurrent statements for the combinational outputs (the Done signal, for example) to assure proper timing. The two-process model, used in the example of Figure 20-7 , is closer to the actual 
TABLE 20-1 
Synthesis Results 
(Optimized for 
Area)DeviceMultiplier
Fig. 20-2Multiplier
Fig. 20-7Multiplier
Fig. 20-9Divider
Fig. 20-11Dice Game
Fig. 20-12 +
Flip-Flops 13 13  22 12 13
CoolRunner Macrocells 18 19  32 18 24
CPLD Product terms 63 61 108 70 72Spartan 4-Input LUTs 38 32  36 23 31
FPGA CLBs 20 18  19 14 16
Spartan II 4-Input LUTs 30 30  35 30 30
FPGA Slices 16 15  19 16 19© Cengage Learning 2014
706 Unit 20
hardware in that it explicitly generates control signals in a combinational process 
and then uses these signals to control register updates in a clocked process. We gen-erally prefer the two-process model because it introduces fewer timing problems. This is particularly important in large systems where the operation of a number of modules must be properly coordinated.
When writing VHDL code for synthesis, you must constantly keep in mind that 
you are designing hardware, not simply writing a computer program. Every VHDL statement that you write implies certain hardware. Poorly written VHDL code may result in excessive amounts of hardware when synthesized, and the hardware may malfunction because of timing problems. Simulation plays an important role in digi-tal design using VHDL. Functional simulation before synthesis is important to make sure that the hardware performs the intended functions and that the basic design is sound. However, just because the code simulates correctly does not mean that the code will synthesize and implement correctly. Review of the reports generated by the synthesizer may reveal problems such as generation of unintended latches. After the code is implemented, a timing simulation of the actual hardware is desirable. This type of simulation may reveal timing problems in the design, and it will help to determine the maximum clock speed. Debugging using a simulator is generally much easier than using the actual hardware because the internal signals within the hardware are generally not available for observation.
Appendix B summarizes the syntax for all VHDL statements used in the text. 
VHDL has many other features that are not discussed in this text. VHDL variables, as distinguished from signals, have not been introduced because VHDL code using variables may have timing problems when synthesized. Other useful features of VHDL include procedures, functions, attributes, generics, and generate. These fea-tures are described in references [1], [2], [3], [13], and [14].
Problems
20.1 In Figure 20-7 , if St changes from '0' to '1' at time 2 ns, and a rising edge of Clk occurs at 10 ns, in what sequence do the VHDL statements execute? (Hint: The first process executes more than one time.)
20.2 Write VHDL code for the 16-bit 2’s complementer described in Programmed  Exercise 18.1. Use two processes.
20.3 Modify the VHDL code of Figure 20-7 to implement the multiplier of Problem 18.5. You may refer to the answer to Problem 18.5 for the state graph of the control unit.
20.4 Write a test bench to test the BCD-to-excess-3 code converter of Table 17-2. Test all 10 BCD digits in order, using an input stream consisting of a single constant vec-tor (which should begin “000010000100 . . .”). Note that the order of bits is least 
VHDL for Digital System Design  707
 significant bit first, as in Section 16.2. (Table 16-3 is the same as Table 17-2, but with the 
states named dif ferently.) Define an expected output vector (“110000101010 . . .”). Set an error flag to '1' if the actual output does not match the expected output.
20.5 For the following VHDL code, draw a block diagram of the corresponding hardware and a state graph for the controller. If MplierData is 0101 and McandData is 1001 at the first clock edge when Start is 1, how many clock cycles will it take for Done to become 1, and what will the value of Product be when Done becomes 1?
  library IEEE;
  use IEEE.STD_LOGIC_1164.ALL;  use IEEE.STD_LOGIC_ARITH.ALL;  use IEEE.STD_LOGIC_UNSIGNED.ALL;
  entity olorin is
   Port ( Clk, Start: in std_logic;    McandData, MplierData: in std_logic_vector(3 downto 0);
    Done: out std_logic;
    Product: out std_logic_vector(7 downto 0));
  end olorin;
  architecture Behavioral of olorin is
   signal Init, K, Add: std_logic;   signal Sum, Accumulator: std_logic_vector(7 downto 0);   signal Mcand, Mplier: std_logic_vector(3 downto 0);   signal State, NextState: integer range 0 to 2;  begin   Sum <= Accumulator + Mcand;
   K  <= not Mplier(3) and not Mplier(2) and not Mplier(1) and not Mplier(0);
   Product <= Accumulator;
  process(State, Start, K)  begin   Init <= ‘0’; Add <= ‘0’; Done <= ‘0’;
   case state is   when 0 =>    if Start = ‘1’ then Init <= ‘1’; NextState <= 1;
    else NextState <= 0; end if;   when 1 =>    if K = ‘1’ then Done <= ‘1’; NextState <= 2;
    else Add <= ‘1’; NextState <= 1; end if;
   when 2 =>    if Start = ‘1’ then Done <= ‘1’; NextState <= 2;
    else NextState <= 0; end if;   end case;  end process;
708 Unit 20
20.6 A digital system consists of three registers and two adders, as shown in the follow-
ing figure. An input bus is used to load the registers in sequence A, B, and C. The 
sum  of  A, B, and C is then loaded into A. Write VHDL code that describes the 
system.  Process(Clk)  begin   if Clk’event and Clk = ‘1’ then
    State <= NextState;
    If Init = ‘1’ then  Mcand <= McandData; Mplier <= MplierData;  
Accumulator <= “00000000“; end if;
    If Add = ‘1’ then Accumulator <= Sum; Mplier <= Mplier – 1; end if;
   end if;  end process;  end Behavioral;
C (7:0)Adder
CK
CK8
9
8
8LdC
B (7:0)AdderControl
Circuit
CK8
8LdB
A (9:0)A (7:0)LdA
LdBSt
LdC
Ad
Z (9:0)
(Output)
X (7:0)
(Input)CK
0010
1010LdA
Ad01–/Ad LdA
–/LdC –/LdBSt/LdASt'/0
S1S0
S3
S2
20.7 Modify the VHDL code of Figure 20-11 to use a counter as in Figure 20-9. You may refer to the answer to Problem 18.6 for the state graph for the control unit.
20.8 Write a test bench for the DiceGame controller of Figure 20-12. Use the following test sequence for sum: 7 , 11, 2, 4, 7 , 5, 6, 7 , 6, 8, 9, 6.
20.9 Modify the VHDL code of Figure 20-11 to implement the divider of Problem 18.7 .
VHDL for Digital System Design  709
20.10 Consider the multiplier of Problem 18.28.
(a) Write VHDL code that describes the multiplier.
(b) Write a test bench that tests the code of part (a). The test cases should include at 
least the following: zero multiplier, maximum multiplier and maximum multipli-
cand, and maximum multiplier and zero multiplicand.
20.11 Repeat Problem 20.10 for the multiplier of Problem 18.29. In addition to the test cases listed in Problem 20.10, the test cases should include combinations of maxi-mum and minimum (signed) values of the multiplicand and multiplier.
Lab Design Problems
Each of these problems is designed to fit on a small CPLD or FPGA circuit board that has at least eight input switches, two pushbuttons, and eight LEDs. Carry out the following steps for your assigned digital system design problem:
1. Draw a block diagram of the system showing registers, adders, MUXes, and other components. Define the necessary control signals. Specify the sizes of registers, adders, etc. Provide an active-high asynchronous reset for your design.
2. Draw a state graph for the control circuit.
3. Based on the results of steps 1 and 2, write a behavioral VHDL description of the system. Use one clocked process to update the state and the registers as in Figure 20-2. Compile and simulate your code.
4. Based on the results of steps 1 and 2, write a VHDL description of the system using control signals and two processes as in Figure 20-7 . Use one combinational process to generate the next-state and control signals. Use a clocked process to update the state and other registers. Compile and simulate your code.
5. Synthesize your VHDL code from step 4, download it to a CPLD or FPGA board, test it, and then demonstrate its operation.
20.A Design a divider for unsigned binary numbers that will divide a 7-bit dividend by a 4-bit divisor to give a 3-bit quotient. Assume that the start signal (St) is 1 for exactly one clock time. When 
St=1, the dividend register should be loaded from the input 
bus. On the next clock cycle, the divisor register should be loaded from the same input bus. Then, if the quotient would require more than 3 bits, an overflow would occur, so V should be set to 1, and the controller should go back to the reset state. Otherwise, the controller should generate the appropriate sequence of shift and sub-tract signals and turn on a done signal when division is complete. Use an 8-bit divi-dend register and store the quotient in the lower 3 bits of the register.
20.B Same as 20.A, except use a 3-bit divisor and a 4-bit quotient. (An overflow would occur if the quotient would require more than 4 bits.)
20.C Same as 20.A, except use an 8-bit dividend, a 3-bit divisor, a 5-bit quotient, and a 9-bit dividend register. (An overflow would occur if the quotient would require more than 5 bits.)
710 Unit 20
20.D Same as 20.A, except use an 8-bit dividend, a 5-bit divisor, a 3-bit quotient, and a 
9-bit dividend register. (An overflow would occur if the quotient would require more than 3 bits.)
20.E Design a multiplier for unsigned binary numbers that will multiply a 3-bit multi-plicand by a 4-bit multiplier to give a 7-bit product. Assume that the start signal (St) is 1 for exactly one clock time. When 
St=1, the multiplier register should be 
loaded. After loading the multiplier, load the multiplicand into a separate register on the next clock, and then proceed with the multiplication. Both the multiplier and multiplicand should come from the same input bus. Inputs to this bus should come from switches on the FPGA board. Use an 8-bit accumulator register. The control-ler should generate the appropriate sequence of add and shift signals and turn on a done signal when multiplication is complete.
20.F Same as 20.E except use a 4-bit multiplicand, a 3-bit multiplier, and a 7-bit product.
20.G Same as 20.E except use a 5-bit multiplicand, a 3-bit multiplier, an 8-bit product, and a 9-bit accumulator.
20.H Same as 20.E except use a 3-bit multiplicand, a 5-bit multiplier, an 8-bit product, and a 9-bit accumulator.
20.I Design an 8-bit serial adder with accumulator for signed binary numbers similar to Figure 18-1, except provide for loading the registers and clearing the carry flip-flop. Represent signed negative numbers in 2’s complement. Assume that the start signal (St) is 1 for exactly one clock time. When 
St=1, the accumulator register should 
be parallel loaded from a bus. Then, at the next clock the addend register should be loaded from the same bus. When addition is completed, output a Done signal for one clock time. Output an overflow signal if a 2’s complement overflow occurs. Design the control circuit using a 3-bit counter and a state graph with four states.
20.J Same as 20.I except change 8-bit to 7-bit.
20.K Same as 20.I except design a serial subtracter instead of an adder.
20.L Same as 20.I except design a serial subtracter instead of an adder and change 8-bit to 7-bit.
20.M Design a divider for unsigned binary numbers that divides a 16-bit dividend by an 8-bit divisor to give an 8-bit quotient. Use a 17-bit dividend register and store the quotient in the lower 8 bits of the register. Also, use a 4-bit counter to count the number of shifts, together with a subtract-shift controller.
The following instructions only apply to 20. N, 20.O, 20.P and 20.Q:
1. Use an active-high asynchronous reset to reset the circuit at any time.
2. When you press start and then clock the circuit, the multiplicand should be loaded in some internal register.
VHDL for Digital System Design  711
3. On the next clock cycle, the multiplier should be loaded into another inter-
nal register.
4. Note that both the multiplicand and the multiplier should be loaded from the same 8 switches on the board. Use the least significant bits of the  
8 switches to enter the multiplicand and the multiplier.
5. Once they are loaded, the circuit should cycle through the states until the final answer is calculated.
6. Once the product is calculated, the state should not change, and a done sig-nal should be set to high (and remain high).
20.N Design a multiplier for unsigned binary numbers that will multiply a 6-bit multipli-cand by a 7-bit multiplier to give a 13-bit result. Assume that the start signal (St) is 1 for exactly one clock time. When 
St=1, the multiplier and multiplicand should be 
loaded in sequence. Use a 14-bit accumulator. The controller should generate the appropriate sequence of add and shift signals.
20.O Work Problem 20.N except use a 7-bit multiplicand and a 6-bit multiplier.
20.P Work Problem 20.N except use a 8-bit multiplicand and a 5-bit multiplier.
20.Q Work Problem 20.N except use a 5-bit multiplicand and a 8-bit multiplier.
20.R Design a divider for unsigned binary numbers that will divide a 6-bit dividend by a 4-bit divisor to give a 6-bit quotient. An asynchronous reset must be used to reset the circuit. Assume that the start signal (St) is 1 for exactly one clock cycle time. When St = 1, the dividend should be loaded from the input bus. On the next clock cycle 
the divisor should be loaded from the same input bus. Then if the divisor is 0, an overflow will occur, the V signal should be set and the controller should go back to the reset state. Otherwise, the controller should generate the appropriate sequence of shift and subtract signals and then turn on a done signal. Use an 11-bit dividend register and store the quotient in the lower bits. You may consult Problem 18.7 as a reference. You need to show only the quotient on the FPGA LEDs.
20.S Work Problem 20.R except use a 7-bit dividend and a 3-bit divisor to give a 7-bit quotient.
20.T Design an arithmetic unit that computes W =X*Y+
Z, where X, Y and Z are all 
4-bit unsigned numbers. X, Y and Z should be read sequentially from the same 
input bus. Assume that the start signal (St) is 1 exactly for one clock cycle. When St is '1', in the first clock cycle, the Multiplier 
(X  ) should be loaded from the bus. In 
the second clock cycle, the Multiplicand (Y ) should be loaded from the same bus. 
Finally, in the third clock cycle, Z (the term to be added) should be loaded. Then 
the state machine should multiply X  by Y. Use a 9-bit accumulator, and design the 
multiplier without using a counter. Use the overloaded addition operator to add. Use a second adder to add 
Z to X*Y and store the result in the accumulator using 
a fourth load signal.
712 Unit 20
20.U Same as Problem 20.T, except that X is a 5-bit number, Y is a 3-bit number, and Z is 
a 5-bit number. Use a 9-bit accumulator.
20.V Same as Problem 20.T, except that X is a 3-bit number, Y is a 5-bit number, and Z is 
a 5-bit number. Use a 9-bit accumulator.
20.W Same as Problem 20.T, except that X is a 6-bit number, Y is a 2-bit number, and Z is 
a 6-bit number. Use a 9-bit accumulator.
713MOS and CMOS LogicAPPENDIX
A
Most integrated circuits designed today use MOS or CMOS logic. MOS logic is 
based on the use of MOSFETs (metal-oxide-semiconductor field-effect transistors) as switching elements. Figure A-1 shows the symbols used to represent MOSFETs. The substrate (or body) is a thin slice of silicon. The gate is a thin metallic layer deposited on the substrate and insulated from it by a thin layer of silicon dioxide. A voltage applied to the gate is used to control the flow of current between the drain and source.
In normal operation of an n-channel MOSFET, shown in Figure A-1(a), a positive 
voltage 
(VDS) is applied between the drain and source. If the gate voltage (VGS) is 0, 
there is no channel between the drain and source and no current flows. When VGS is 
positive and exceeds a certain threshold, an n-type channel is formed between the 
drain and source, which allows current to flow from D  to S. Operation of a p-channel 
MOSFET is similar, except VDS and VGS are negative. When VGS assumes a negative 
value less than the threshold, a p-type channel is formed between drain and source, 
which allows current to flow from S to D .
The symbol in Figure A-1(c) may be used to represent either a p- or n-channel 
MOSFET. When this symbol is used, it is generally understood that the substrate is connected to the most positive circuit voltage for p-channel MOSFETs (or the most 
negative for n-channel). If the power supply voltage is V
DD, we will use positive logic 
FIGURE A-1
MOSFET Symbols
© Cengage Learning 2014
Gate
(G)
+
–VGS–VDS+
nSubstrate
Source
(S)
(a) n-channel MOSFETDrain
(D)
Gate
(G)
+
–VGS–VDS+
pSubstrate
Source
(S)SourceDrain
Gate
(b) p-channel MOSFETDrain
(D)
(c) General
MOSFET symbol
714 Appendix A
(0   volts =logic   0 and VDD  volts =logic   1) for n-channel MOS circuits and negative 
logic (VDD  volts =logic   0 and 0   volts =logic   1) for p-channel MOS circuits. Using 
this convention, a logic 1 applied to the gate will switch the MOSFET to the ON 
state (low resistance between drain and source), and a logic 0 will switch it to the OFF state (high resistance between drain and source).
Figure A-2(a) shows a MOS inverter. When a logic 0 is applied to the gate, the 
MOSFET is in a high-resistance or OFF state, and the output voltage is approxi-mately V
DD. When a logic 1 is applied to the gate, the MOSFET switches to a low-
resistance or ON state, the output is connected to ground, and the output voltage is approximately 0.
Thus, the operation of the MOSFET is analogous to the operation of a switch 
in Figure A-2(b) which is open when V
in is a logic 0 and closed when Vin is a logic 1. 
In Figure A-2(d), a second MOSFET serves as a load resistor. The geometry of this MOSFET and the gate voltage V
GG are chosen so that its resistance is high com-
pared with the ON resistance of the lower MOSFET so that the switching operation of Figure A-2(d) is essentially the same as Figure A-2(a).
As shown in Figure A-3, MOSFETs can be connected in parallel or series to form 
NOR or NAND gates. In Figure A-3(a), a logic 1 applied to 
A or B turns on the cor-
responding transistor and F becomes 0. Thus F′=A+B and F =(A+B)′, which 
is the NOR function. In Figure A-3(c), a logic 1 applied to the A and B inputs turns 
on both transistors and F becomes 0. In this case F ′=AB and F=(AB)′, which is 
the NAND function. More complex functions can be realized by using series-parallel combinations of MOSFETs. For example, the circuit of Figure A-3(e) performs the exclusive-OR function. The output of this circuit has a conducting path to ground, and F=
0 if A and B are both 1 or if A′ and B′ are both 1. Thus, F ′=AB +A′B′ and 
F=A′B+AB ′=A ⊕ B. A′ and B ′ are generated by inverters as in Figure A-2(d).
CMOS (complementary MOS) logic performs logic functions using a combina-
tion of p-channel and n-channel MOSFETs. Compared with TTL or other bipolar 
transistor technologies, CMOS has the advantage of much lower power consump-tion. Figure A-4(a) shows a CMOS inverter built from a p-channel and an n-channel 
MOSFET. When 0 volts (logic 0) is applied to the gate inputs, the p-channel transis-
tor 
(Q1) is on and the n-channel transistor (Q2) is off, so the output is +V(logic 1 ). 
When +V(logic 1 ) is applied to the gate inputs, Q1 is off and Q2 is on, so the output 
is 0 volts (logic 0).
FIGURE A-2
MOS Inverter
© Cengage Learning 2014VDD
Vout
Vin VinVinVout
(a)VDD
Vout
(b) (c)0
VDD≈ VDD
≈ 0VDD
Vout
VinVGG
(d)
MOS and CMOS Logic  715
In the remainder of this discussion we will use a bubble at the MOSFET gate 
input to indicate a p-channel transistor, which is turned on by a logic 0. No bubble 
at the gate input indicates an n-channel transistor, which is turned on by a logic 1. 
 Figure A-4(b) shows the CMOS inverter using this bubble notation. The switch ana-
log in Figure A-4(c) illustrates the operation of the inverter when the inverter input  is 0. Q
1 is on and Q2 is off as indicated by the closed and open switches. When the +V
Q1
(p-channel)
Q2
(n-channel)Vout
Vin
(a)+V
Q1
(p-channel)
Q2
(n-channel)Vout
VinVin = 0
(b)+V
Vout ≈ +V
(c)Vin = +V+V
Vout ≈ 0
(d)FIGURE A-3
MOS Gates
© Cengage Learning 2014VGG
VGGVDD VDD
A
A
BA
BBA BF = (A + B)′
F = (AB)′(a) MOS NOR gate
(c) MOS NAND gate(b) Switch analogF
F
(d) Switch analogVDD VDD VGG VDD
BA ′
AB ′
(e) MOS exclusive-OR gateF = A ⊕ B
FIGURE A-4
CMOS Inverter
© Cengage Learning 2014
716 Appendix A
input is +V (logic 1 ), Q1 is off and Q2 is on, as indicated by the open and closed 
switches in Figure A-4(d). The following table summarizes the operation:
VinVoutQ1Q2
0 +VON OFF
+V0 OFF ON
Figure A-5 shows a CMOS NAND gate. If A or B is 0 volts, then Q1 or Q2 is ON 
while Q3 or Q4 is off, and the output is +V. If A and B  are both +V, then Q3 and Q4 
are both ON while Q1 and Q2 are off, and the output is 0 volts. If 0 volts represents a 
logic 0 and +V represents a logic 1, this gate performs the NAND function, as indi-
cated by the truth table of Figure A-5(b).
FIGURE A-5
CMOS NAND Gate
© Cengage Learning 2014AB F Q1Q2Q3Q4
00 V ON ON OFF OFF
0 VV ON OFF OFF ON
V0 V OFF ON ON OFF
VV 0 OFF OFF ON ON
(b) Truth table+V
+++
++
++
Q1
Q3
Q4F
BAQ2
(a) Circuit diagram
FIGURE A-6
CMOS NOR Gate
© Cengage Learning 2014
F+V
Q1
Q2
Q3 Q4BAFigure A-6 shows a CMOS NOR gate. If A=1  (+V), Q1 is off and Q4 is on, F =0.  
Likewise, if B =1, Q2 is off and Q3 is on, so F=0. Because F =0 when A or B  is 1, 
F ′=A+B, and F =(A+B)′, which is the NOR function.
A p-channel and n-channel transistor pair can be connected to form a CMOS 
transmission gate (TG) as shown in Figure A-7 . The two enable inputs are normally 
complements so that when En =1, both transistors are enabled and a low  impedance 
path connects A and B . When En =0, points A and B  are disconnected. In other 
words, the transmission gate acts like a switch that is closed when En =1 and open 
MOS and CMOS Logic  717
when En=0. Two transistors are used because the p-channel transistor does a good 
job of transmitting a logic 1 and the n-channel transistor does a good job of transmit-
ting a logic 0.
The 2-to-1 multiplexer of Figure 9-1 can be constructed from two TGs and an 
inverter, as shown in Figure A-8. When A=0, the upper TG is enabled so that I0 is 
connected to F; when A=1, the lower TG is enabled so that I1 is connected to F.
A CMOS gated D latch, as shown in Figure A-9(a), is easily constructed using 
two TGs and two inverters. The switch analogs of Figures A-9(b) and (c) represent FIGURE A-7
CMOS Transmission 
Gate and Switch 
Analog
© Cengage Learning 2014En′
AB
En EnAB
FIGURE A-8
CMOS Multiplexer
© Cengage Learning 2014+V
I0
I1
AA′F
FIGURE A-9
CMOS Latch and 
Switch Analogs
© Cengage Learning 2014D
G
DQ′
Q
Q′
QCK′
CKTG1
TG1CK
CK
CK′CK′
TG2
TG2G = 1 G = 0(a)
(b)D Q′
QTG1
TG2
(c)
718 Appendix A
the TGs by switches. When G=1, CK=1 and TG1 is closed. Therefore, the latch is 
transparent, and D is transmitted through the inverters to the Q output. When G=0,  
TG2 is closed, and the data in the latch is stored in the closed loop of the two invert-
ers. That is, if Q=0, it is still 0 after going through the two inverters, and if Q =1, it 
is still 1 after going through the two inverters. Because TG1 is open, the data does not 
change when D  changes, and the latch holds the stored value of Q.
A CMOS falling-edge-triggered D flip-flop, similar to the type shown in 
 Figure 11 -19, can be constructed from two CMOS latches (Figure A-10(a)). The switch 
analogs of Figures A-10(b) and (c) illustrate the flip-flop operation. When Clock is 1, the input latch is transparent and the output latch holds the current value of 
Q. When 
Clock goes to 0, the input latch holds its value, which is transmitted through the  output latch to Q. Thus, Q can only change states following the falling edge of Clock.
The technology for implementing a CMOS integrated circuit continues to 
improve, resulting in smaller transistors, lower voltage levels, faster operation, and very high density logic. When no inputs are changing, the static power dissipation is very low. When the CMOS gates are switching, the power dissipation is proportional to the switching frequency. Thus, the power dissipation at a switching frequency of l00 MHz is ten times that at 10 MHz.
FIGURE A-10
Falling-Edge-
Triggered  
D Flip-Flop
© Cengage Learning 2014
Q′Q′
QQD
DCK′
CKCK
CK
CK′CK′CK
CK′CK′
CK
Clock = 1Clock
(a) Construction from two latches
(b) Switch analog for Clock = 1
Q′
QD
Clock = 0
(c) Switch analog for Clock = 0
719VHDL Language 
SummaryAPPENDIX
B
Reserved words are in boldface type. Square brackets enclose optional items. Curly 
brackets enclose items which are repeated zero or more times. A vertical bar (|) indicates or.Disclaimer: This VHDL summary is not complete and contains some special cases. Only VHDL statements used in this text are listed. For a complete description of VHDL syntax, refer to references [1] and [2].
entity declaration
entity entity-name is
 port(interface-signal-declaration);
end [entity] [entity-name];
interface-signal declaration
list-of-interface-signals: mode type [:= initial-value]{; list-of-interface-signals: mode type [:= initial-value]}
Note: A signal can be of mode in, out, inout, or buffer.
architecture declaration
architecture architecture-name of entity-name is
[declarations] -- declare internal signals herebegin architecture-bodyend [architecture] [architecture-name];
Note: The architecture body may contain component-instantiation statements,  
processes, assignment statements, procedure calls, etc.
integer type declaration
type type_name is range integer_range;
signal declaration
signal list-of-signal-names : type_name [:= initial_value ];
constant declaration
constant constant_name : type_name := constant_value;
720 Appendix B
alias declaration
alias identifier [:identifier-type] is item-name;
Note: Item-name can be a constant, signal, variable, file, type name, etc.
array type and object declaration
type array_type_name is array index_range of element_type;
signal | constant array_name: array_type_name [:= initial_values];
component declaration
component component-name [generic (list-of-generics-and-their types);]
 port (list-of-interface-signals-and-their-types);
end component;
component instantiation  (concurrent statement)
label: component-name  [ generic map (generic-association-list;)]
  port map (list-of-actual-signals);
Note: Use open if a component output has no connection.
signal assignment statement (sequential or concurrent statement)
signal < = [transport] expression [after delay_time];
Note: If concurrent, the signal value is recomputed every time a change occurs on the 
right-hand side. If [after delay-time] is omitted, the signal is updated after Δ time. If [transport] is omitted, an inertial delay is assumed. 
conditional assignment statement (concurrent statement only) 
signal < = expression1 when condition1
 else expression2 when condition2
 …
 [ else expression];
selected signal assignment statement (concurrent statement only)
with expression select signal < = expression1 [after delay_time1] when choice1,
 expression2 [after delay_time2] when choice2, … [expression [after delay_time] when others];
process statement (with sensitivity list)
[process-label:] process (sensitivity-list) [declarations] --signal declarations not allowedbegin sequential statementsend process [process-label];
Note: This form of process is executed initially and thereafter only when an item on the sensitivity list changes value. The sensitivity list is a list of signals. No wait state-ments are allowed.
VHDL Language Summary  721
process statement (without sensitivity list)
[process-label:] process
 [declarations] --signal declarations not allowedbegin sequential statementsend process [process-label];
Note: This form of process must contain one or more wait statements. It starts execu-tion immediately and continues until a wait statement is encountered.
wait statements
wait on sensitivity-list;
wait until Boolean-expression;wait for time-expression;
if statement (sequential statement only) 
if condition then  sequential statements{elsif condition then  sequential statements } -- 0 or more elsif clauses may be included[else sequential statements]end if;
case statement (sequential statement only) 
case expression is  when choice1 = > sequential statements  when choice2 = > sequential statements  …  [ when others = > sequential statements]
end case;
for loop statement  (sequential statement only) 
[loop-label:] for index in range loop     sequential statementsend loop [loop-label];
Note: You may use exit to exit the current loop.
report declaration
report string-expression
 [severity severity-level];
  VHDL Libraries and Packages
VHDL libraries and packages are used to extend the functionality of VHDL by defining types, functions, components, and overloaded operators. The syntax for libraries and packages is as follows:
library declaration
library list-of-library names;
722 Appendix B
use statement
use library_name.package_name.item;  (.item may be .all)
package declaration
package package-name is
  package declarationsend [package][package-name];
package body
package body package-name is  package body declarationsend [package body][package name];When working with bits and bit_vectors, you may use the following declarations:library BITLIB;use BITLIB.bit_pack.all;
The bit_pack package includes functions and components that work with signals of type bit and bit_vector. For example, the function call vec2int(A) converts a  bit_ vector A to an integer. The CD contains a complete listing of bit_pack.
When working with std_logic and std_logic_vectors, the following declarations 
are required:
library IEEE;use IEEE.std_logic_1164.all;
The std_logic_1164 package defines the types std_logic and std_logic_vector, a reso-lution function for these types, conversion functions, and overloaded operators for logic operations. It does not define overloaded operators for arithmetic operations.
In order to perform arithmetic operations on std_logic_vectors, you may add  
the declaration
use IEEE.std_logic_unsigned.all;
Although this package is found in the IEEE library, it was written by Synopsys and it is not an IEEE standard. This package treats std_logic_vectors as if they were unsigned numbers and provides overloaded arithmetic operators for +, −, *, =, /=, 
>, > =, <, and < =. For “+” and “−” if the left operand is a std_logic_vector, the right 
operand can be the same type, integer type, or std_logic type. For the comparison operators, the right operand can be a std_logic_vector or an integer. The function call CONV_INTEGER(A) converts a std_logic_vector A to an integer.
As an alternative to using std_logic_vectors and the overloaded operators 
defined in the std_logic_unsigned package, type unsigned may be used. Unsigned type is defined in the Synopsys package std_logic_arith and in the IEEE package numeric_std. To use the former, add the declaration
 use IEEE.std_logic_arith.all;
A vector of type unsigned is similar to a std_logic_vector in that it is an array of std_logic bits, but it has its own overloaded arithmetic operators. Operators for +, −,  
*, =, /=, >, > =, <, and < = are defined in the std_logic_arith package for  various 
 combinations of left and right operands. Unfortunately, logic operators AND, OR, and NOT are not defined for unsigned vectors in this package, so C < = A + B; 
VHDL Language Summary  723
works for unsigned vectors, but C < = A and B; is not allowed without calling type 
conversion functions. Some type conversion functions available in this package are 
as follows:
conv_integer(A) converts an unsigned vector A to an integerconv_std_logic_vector(A) converts an unsigned vector A to a std_logic_vectorconv_unsigned(B, N) converts an integer B to an unsigned vector of length N
Conversion of a std_logic_vector to unsigned is not defined.
The IEEE numeric_std package, which actually is an IEEE standard, overcomes 
a number of the deficiencies in the std_logic_arith package. The statement
use IEEE.numeric_std.all;
invokes this package. It defines unsigned type and overloaded operators for arith-metic and comparison operations in a way similar to the std_logic_arith package, but in addition it defines overloaded operators for logic operations on unsigned vectors. Useful conversion functions in the package include
TO_INTEGER(A) converts an unsigned vector A to an integerTO_UNSIGNED(B, N) converts an integer to an unsigned vector of length N
The only significant deficiency is that this package does not define an overloaded operator for adding a std_logic bit to an unsigned type. Thus, a statement of the form
sum < = A + B + carry;
is not allowed when carry is of type std_logic. The carry must be converted to an integer before it can be added to the unsigned vector A + B.
We have used the std_logic_unsigned package in many examples in this book 
because it is easy to use. For complex VHDL projects, we recommend using the numeric_std package. Most VHDL simulators and synthesizers work well with either package.
724Tips for Writing 
Synthesizable VHDL CodeAPPENDIX
C
One of our goals throughout this text is to write VHDL code that not only simulates 
correctly but also synthesizes correctly to implement hardware that works correctly. First and foremost, always remember that when you write VHDL code you are not writing a computer program; you are describing hardware. If you are designing a multiplier for binary numbers, do not simply write a program to multiply binary numbers. Instead think in terms of what registers are required and what sequence of operations on these registers will produce the desired result.
VHDL code that simulates correctly will not always implement correctly in 
hardware. A frequent cause of problems is the creation of unintended latches. Even though code simulates correctly, the presence of latches may cause timing problems when the code is actually implemented in hardware. After synthesizing your code, check the synthesis report to make sure no latches are present. If latches are present, check your code for the following:
1. Counters, shift registers, flip-flops, and other devices that change state in 
response to a clock edge must be updated only in a clocked process. The state of these devices should never be changed in a combinational process or in a con-current statement. All state changes for a given device must be specified within the same process.Example: count <= count + 1; should not appear in a combinational process.When this statement, which increments a counter, is placed in a clocked process, any statement that clears the counter must be placed in the same process.
2. If a combinational process sets control signals to '1' at various places in a case state-ment, all of these signals should be set to '0' before the start of the case statement.
3. For every if statement in a combinational process, check each signal that is 
assigned a value in the then clause. If such a signal is not assigned a value in 
step 2, then make sure that it is assigned a value in the else clause.Example: if St =  '1' then nextstate <=1; load <='1'; end if; will create a latch 
because nextstate is not defined when St =  '0'. To eliminate the latch write 
if St =  '1' then nextstate <= 1; load <= '1'; else nextstate <= 0; end if; This 
assumes that load is set to '0' in step (2).
Do not attempt to set the same signal to two different values in two different 
processes or in a process and in a concurrent statement.
Tips for Writing Synthesizable VHDL Code  725
A <='0'; is a concurrent statement, and A <= B; is another concurrent statement or 
a sequential statement in a process. These statements can attempt to set A to two 
different values at the same time. If A and B are bit signals, when you try to simu-late, you will get an error message that a signal has multiple drivers. That means a 
 conflict exists because A could be driven to '0' and to '1' at the same time. If A and B are std_logic, the conflict still exists, but you will not get the error message. Instead,  during simulation A will assume the value 'X' (unknown) if the simulator tries to set A to '0' and '1' at the same time. In both cases, the code will not synthesize properly because it does not correspond to any real hardware.
Also consider the following example:
-- Example of what NOT TO DO: output A is assigned values
-- in a concurrent statement and in a process.
entity two_drivers is
 port (B, clk, reset : in bit; A : out bit);
end two_drivers;architecture arch of two_drivers isbegin A <= '0' when reset = '0';
 process (clk)
 begin
  if clk'event and clk = '0' then   A  <= B; end if;
 end process;
end arch;
In this example, A is supposed to represent a flip-flop that is reset to '0' when the signal reset is '0' and set equal to B on the falling clock edge. Although this code has correct syntax, it will not simulate properly because the two statements that change A occur as a concurrent statement and also as a sequential statement in a process so that A has two drivers. If the signals are std_logic instead of bits, A will assume a value of 'X' at times during the simulation. The code will not synthesize because all statements that change the output of flip-flop A must be placed in the same process. This also would apply if A were a register or a counter.
Exercise
Change the preceding code so that the reset signal will work properly.
An easy way to write synthesizable VHDL code to perform arithmetic 
 operations is to represent binary numbers as std_logic_vectors so that over-loaded operators can be used. This is explained on pages 319 –320 of the text. Example
726 Appendix C
Overloaded + and – operators cannot be used with bit vectors. If you use over-
loaded operators with std_logic_vectors in your VHDL code, place the follow-
ing declarations at the start of your code:
library IEEE; -- this library contains several useful
--  packages
use IEEE.std_logic_1164.all; -- this package defines std_logic,
--  std_logic_vectors and logic--  operations on these types
use IEEE.std_logic_unsigned.all; -- this package defines overloaded
--  operators for std_logic_vectors
Remember that the VHDL operators +, –, and & have the same precedence and 
will be applied from left to right as they appear in a VHDL statement.
Thus A <= B + C&D; is treated as A <= (B+C)&D;
If you want to do concatenation first, you must use parentheses.A <= B + (C&D);
727Proofs of TheoremsAPPENDIX
D
  Finding Essential Prime Implicants
Section 5.4 presents a method for finding all of the essential prime implicants which 
is based on finding adjacent 1’s on a Karnaugh map. The validity of the method is based on the following theorem:
If a given minterm m
j of F and all of its adjacent minterms are covered by a sin-
gle term pj, then pj is an essential prime implicant of F.
Proof:
1. Assume pj is not a prime implicant. Then, it can be combined with another 
term pk to eliminate some variable xi and form another term which does 
not contain xi. Therefore, xi=0 in pj and xi=1 in pk, or vice versa. Then, 
pk covers a minterm mk which differs from mj only in the variable xi. This 
means that mk is adjacent to mj, but mk is not covered by pj. This contradicts 
the original assumption that all minterms adjacent to mj are covered by pj ; 
therefore, pj is a prime implicant.
2. Assume pj is not essential. Then, there is another prime implicant ph which 
covers mj. Because ph is not contained in pj, ph must contain at least one 
minterm which is adjacent to mj and not covered by pj. This is a contradic-
tion, so pj must be essential.
State Equivalence Theorem
The methods for determining state equivalence presented in Unit 15 are based  
on Theorem 15.1:
Two states p and q of a sequential network are equivalent if and only if for every 
single input x, the outputs are the same and the next states are equivalent.
Proof: We must prove both part 1, the “if” part of the theorem, and part 2, the “only if” part.
728 Appendix D
1. Assume that λ (p, x)=λ(q, x) and δ (p, x)≡δ(q, x) for every input x. Then, 
from Definition 15.1, for every input sequence X,
λ[δ(p, x), X]=λ[δ(q, x), X]
For the input sequence Y =x followed by X, we have
λ(p, Y)=λ(p, x) followed by λ[δ(p, x), X)]
λ(q, Y)=λ(q, x) followed by λ[δ(q, x), X)]
 Hence, λ(p, Y)=λ(q, Y) for every input sequence Y, and p≡q by  
Definition 15.1.
2. Assume that p≡q. Then, by Definition 15.1, λ (p, Y)=λ(q, Y) for every 
input sequence Y. Let Y =x followed by X. Then,
λ(p, x)=λ(q, x)  and λ[δ(p, x), X]=λ[δ(q, x), X]
for every sequence X. Hence, from Definition 15.1, δ (p, x)≡δ(q, x).
729Answers to Selected 
Study Guide Questions and ProblemsAPPENDIX
E
 UNIT 1 Study Guide Answers
2. (e) Two of the rows are: 1110   16 14 E
1111   17 15 F
3. (b) 
   11002−1012=[1×23+1×22+0×21+0×20]
−[ 1×22+0×21+1×20] note borrow from column 1
= [1×23+1×22+(0−1)×21+(10+0)×20]
− [ 1×22+ 0×21+ 1×20] note borrow from column 2
= [1×23+(1−1)×22+(10−1)×21+10×20]
− [ 1×22+ 0×21+ 1×20] note borrow from column  3
= [(1−1)×23+(10−0)×22+1×21+10×20]
− [ 1×22+0×21+1×20]
= [ 0×23+ 1×22+1×21+1×20]=1112
5. (f  ) sign & mag: − 0,  2’s comp: –  32,  1’s comp: –  31
(g) Overflow occurs when adding n -bit numbers and the result requires n+1 
bits for proper representation. You can tell that an overflow has occurred 
when the sum of two positive numbers is negative or the sum of two nega-tive numbers is positive.A carry out of the last bit position does not indicate that an overflow has 
occurred.
6. (a) BCD: 0001 1000 0111
excess-3: 0100 1011 1010
6-3-1-1: 0001 1011 1001
2-out-of-5: 00101 10100 10010
 UNIT 1 Answers to Problems
1.1 (a) 2F5.4016=001011110101.010000002
(b) 7B.2B16=01111011.001010112
(c) 164.E316=000101100100.111000112
(d) 427.816=010000100111.10002
730 Appendix E
1.2 (a) 7261.38=3761.410, EB1.616=3761.410
(b) 2635.68=1437.810, 59D.C16=1437.810
1.3 3252.10026
1.4 (a) 5B1.1C16 (b) 010110110001.000111002=2661.0708
(c) 112301.01304 (d) 3564.610
1.5 (a) Add: 11001. Subtract: 0101. Multiply: 10010110.
(b) Add: 1010011. Subtract: 011001. Multiply: 11000011110.
(c) Add: 111010. Subtract: 001110. Multiply: 1100011000.
1.6 (a) 1111
11110100
−1000111
10101101 (b) 111 11110110
−111101
0111001 (c) 11111 110110010
−111101
01110101
1.7 2’s complement:
(a) 010101
+   001011
100000 (b) 110010
+   100000
(1) 010010 (c) 100111
+   010010
111001
OVERFLOW! OVERFLOW!
(d) 110100
+   001101
(1)  000001 (e) 110101
+   101011
(1)  100000
1’s complement:(a) 010101
+
 001011
100000 (b)  not assigned  (c) 100110
+  010010
111000 
because −32 cannot  be represented 
OVERFLOW! in 6 bits
 (d) 110011
+
 001101
(1) 000000
+ 1
000001 (e) 110100
+ 101010
(1) 011110
+ 1
011111
   OVERFLOW!
1.8 For a word length of N, the range of 2’s complement numbers that can be repre-
sented is −2N−1 to 2N−1
 −  1.
So, for a word length of 8, the range is −27 to 27
 −  1, or − 128 to 127. Because 1’s 
complement has a “negative zero” (11111111) in addition to zero (00000000), the values that can be represented range from −
(27
 −  1) to 27
 −  1, or − 127 to 127.
1.9 Dec. 7-3-2-1 3 6 5 9
0 0000 0011 0111 0110 10101 0001 or   2 0010 0100   3 0011 or 0100    4 0101    5 0110    6 0111    
Answers to Selected Study Guide Questions and Problems  731
7 1000    
8 1001    9 1010    
 UNIT 2 Study Guide Answers
2. (d) 1; 0; 1; 1 (e) 1, 1; 0, 0; 0; 1
3. (a) four variables, 10 literals (d) F=(A′ B)′ (e) F=(A+B′)C
(f    ) Circuit should have two OR gates, three AND gates, and three inverters.
4. (b) A, 0, 0, A; A, 1,  A, 1
6. (c) Z=ABC
7 . (a)  Sum of products 
Neither 
Product of sums (Here, A and B ′ are each considered to be separate terms in 
the product.) Neither
(b) Fewer terms are generated.(c) D[A+B′
(C+E)]=D(A+B′) (A+C+E)
8. (a) AE+B′C′ +C′D  (b) C′DE+AB ′CD ′E
10. (a) a′+b+c  (b) ab ′c′d  (c) a(b′+c′)
(d) (a+b) (c′+d′)  (e) a′+b(c+d′)
 UNIT 2 Answers to Problems
2.1 (a) X(X′+Y  )=XX′ +XY=0+XY=XY
(b) X+XY=X(1+Y)=X(1)=X
(c) XY+XY ′=X(Y+Y′)=X(1)=X
(d) (A+B)(A+B′)=AA+AB ′+AB+BB′ =A+AB ′+AB+BB′
=A(1+B+B′)+0=A(1)=A
2.2 
=
(a)XYX
X=
(b)Y Y ZX X
ZX
2.3 (a) 1 (Law 5)
(b) CD+AB ′E (Law 8D) (technically, we also used Law 3D)
(c) AF (Uniting (1))  (d) C +D′B+A′ (Uniting (1))
(e) A′B+D (Absorption (2))  (f    ) A+BC+DE+F (Elimination (3))
2.4 (a) F=A+E+BCD  (one AND gate and one OR gate with three inputs)
(b) Y=A+B
2.5 (a) ACD ′+BE  (b) A′B′+A′D′+C′B′+C′D′
2.6 (a) (A+C′)(A+D′)(B+C′)(B+D′)  (b) X(W+Z)(W+Y)
(c) (A′+E)(B+E)(C+E)(A′+D+F )(B+D+F )(C+D+F )
732 Appendix E
(d) Z(W ′+X)(Q′+W ′+Y)  (e) (A′+D′)(C+D′)
(f  ) (A+B+D)(A+C+D)(A+B+E)(A+C+E)
2.7 
D
A
B
CE
F
(a)+U
X
Y
ZV
W
(b)+
2.8 (a) ABC+ABD ′  (b) A′B′+A′CD ′  (c) A′BC′
2.9 (a) F=A′B  (b) G=T′
 UNIT 3 Study Guide Answers
1. (b) (b′+d)(b+a)(b+c)  (a+d)(b+d)(a′+b′+c)
(c) w′y′+x′y′z′+xy+wyz
5. (b) A′B′C+BC′D′+AB ′D′+BCD
(c) Add BCD; eliminate A′BD, ABC
 UNIT 3 Answers to Problems
3.6 (a) WY ′X+WY ′Z′+W ′X′Y+W ′X′Z  (b) A′D+AC
3.7 (a) (C′+D)(C+D′+B′)
(b) (D′+A′+B′)(D′+C+B′)(D+A+C′)(D+A′+B)
3.8 F=(AB) ⊕ [(A≡D)+D]=A′+BD ′+B′D
3.9 No. Consider A=1, B=1, C=0 or A=1, B=0, C=1.
3.10 (a) W ′X+WY ′Z+WYZ ′  (b) BD+A′BC+AB ′+AC ′
(c) (A+C+D)(A′+C′+D′)(B+C′+D)
3.11 AE′+AC ′+B′+CD ′+D′E′
3.12 A′CD ′E+A′B′D′+ABCE +ABD =A′CD ′E+BCD ′E+A′B′D′+
ABCE +ABD =A′B′D′+ABD +BCD ′E
 UNIT 4 Study Guide Answers
2. (d) ab ′c′d  (e) a+b+c′+d′
(g) (a+b′+c)(a′+b+c′)(a′+b′+c)(a′+b′+c′)
3. (c) m0+m1+m3+m4=Σ m(0, 1, 3, 4 )M2M5M6M7=Π  M(2, 5, 6, 7 )
4. (b) m19  (c) A′BCD′E
(e) M19  (f  ) (A+B′+C′+D+E′)
5. (a) 65536
(d) (a0m0+a1m1+a2m2+a3m3)(b0m0+b1m1+b2m2+b3m3)=. . .=
a0b0m0+a1b1m1+a2b2m2+a3b3m3
(f  ) f=Π  M(2, 5, 6 )f ′=Σ m(2, 5, 6 )=Π  M(0, 1, 3, 4, 7 )
6. (b) Σ m(0, 5)+Σ d(1, 3, 4 )
Answers to Selected Study Guide Questions and Problems  733
 UNIT 4 Answers to Problems
4.1 (a) U: Safe unlocked, J: Mr. Jones present, E: Mr. Evans present, B: Normal 
business hours, S: Security guard present
U=(J+E)BS
(b)  O: Wear overshoes, A: You are outside, R: Raining heavily, S: Wearing suede 
shoes, M: Mother tells you to
O=ARS +M
(c)  L: Laugh at joke, F: It is funny, G: Good taste, O: Offensive, P: Told by professor
L=FGO ′+PO′
(d)  D: Elevator door opens, S: Elevator is stopped, F: Level with floor, 
T: Timer expired, B: Button pressed
D=SFT  ′+SFB
4.2 (a) Y=A′B′C′D′E′+AB ′C′D′E′+ABC ′D′E′ or  Y=C′
(b) Z=ABC ′D′E′+ABCD ′E′+ABCDE′  or  Z=BE ′
4.3 F1+F2=Σ m(0, 3, 4, 5, 6, 7); General rule: F1+F2 is the sum of all minterms 
which are present in either F1 or F2, because F1+F2=Σ  ai mi+Σ   bi mi=
Σ  (ai+bi)mi
4.4 (a) 16
(b) F(x, y)=0, x ′y′, x ′y,  x′, xy ′, y ′, x ′y+xy′, x ′+y′, xy, x ′y′+xy, y , x ′+y, 
x, x+y′, x+y, 1
4.5 
A B C D E F
00 0 1 1 X
00 1 X X 10 10XXX0 1 1 X X 1 or 1 1 X10 0 X 0 010 1 X X 11 10XXX1 1 1 X 0 0 or 0 X 0
4.6 (a) F=A′B′+AB(d1=1, d5=0)  (b) G=C(d2=0, d6=0)
4.7 (a) Σ  m (1,  2,  4)  (b) Π  M (0,  3,  5,  6,  7)
4.8 (a) F=A′B′C′D′+A′B′C′D+A′B′CD ′+A′B′CD+A′BC′D′+
A′BC′D+A′BCD ′+AB ′C′D′+AB ′C′D+ABC ′D′
F=Σ m(0, 1, 2, 3, 4, 5, 6, 8, 9, 12)
(b) F=(A+B′+C′+D′)(A ′+B+C′+D)(A ′+B+C′+D′)
(A′+B′+C+D′) (A′+B′+C′+D)(A ′+B′+C′+D′)
F=Π M(7,  10,  11,  13,  14,  15)
4.9 (a) F=Σ m(0, 1, 4, 5, 6)  (b) F=Π  M(2, 3, 7)
(c) F ′=Σ m(2, 3, 7)  (d) F ′=Π  M(0, 1, 4, 5, 6)
4.10 (a) F=Σ m(1, 4, 5, 6, 7, 10, 11)
(b) F=Π  M(0, 2, 3, 8, 9, 12, 13, 14, 15)
(c) F ′=Σ m(0, 2, 3, 8, 9, 12, 13, 14, 15)
(d) F ′=Π  M(1, 4, 5, 6, 7, 10, 11)
734 Appendix E
4.11 (a) di=xi ⊕ yi ⊕ bi
bi+ 1=bi xi ′+xi ′yi+bi yi
(b) di=si, bi+1 is the same as ci+1 with xi replaced by xi′
4.12 
 UNIT 5 Study Guide Answers
3. (d) 6,  10, 12, 15; 0, 12, 9, 10
(g) f1=a′b+bc ′+a′cd+ac ′d f2=b′c+cd+a′bd+ab ′d′
4. (a) a′b′d′, b′c′d′, ac′d′, ac′d, also a ′b′cd, and all the other minterms.
(b) AB′C′ and AC ′D are prime implicants.
5. (a) 4  (c) We cannot determine if B ′C′ is essential.
(f  ) Yes (i) A′D′ because of m4, B′D′ because of m10
6. (b) A′D′ is not essential because all of its minterms are covered by other prime 
implicants. BC′ is essential because of m13. B′CD is essential because of m11.
Minimum sum =B′CD+BC′ +BD ′+A′B′.
(d) A′C′+ACD +5AB or BC′ 6
8. (a) F=AB ′D′+B′D′E′+A′BDE  (b) 8,  16,  25,  26,  28
(d) P1+P2+P3+P4+BCDE +AC ′E
(f  ) AC′E′+A′DE+ACE +B′CE+(AB ′C or ADE ′ or ACD  or AB ′E′)xi′
xi′yi
bi
yi
bibi + 1xiyi dibi
FA
FAy3x3
z3
s3FA
FAy2x2
z2
s2FA
FAy1x1
z1
s1FA
FAy0x0
z0
s0C0 = 1C0 = 0
Answers to Selected Study Guide Questions and Problems  735
 UNIT 5 Answers to Problems
5.3 (a) f=bc ′+a′c′+ab ′c  (b) f=e′f ′+d′e′+d′f ′
(c) f=r′+t′  (d) f=y+x′z+xz′
5.4 (a)
(b) F=D′+B′C+AB
(c) F=(A+B′+D′)(B+C+D′)
5.5 (a)1
01
41
12100 01 11 10
8
0
10
51
130
9
1
30
71
151
11
100CDAB
01
11
10
21
61
141
10
 
C1C2X1X2 Z
00 0 0 0
00 0 1 100 1 0 100 1 1 101 0 0 001 0 1 101 1 0 101 1 1 010 0 0 010 0 1 010 1 0 010 1 1 111 0 0 111 0 1 011 1 0 011 1 1 1
(b) Z=C1′ X1′ X2+C1′ X1 X1′+C1 X1 X2+C1 C2 X1′X2′+5C1′ C2′ X2  or
C1′ C2′ X1   or C2′ X1 X26
5.6 (a) f=a′d+a′b′c′+b′cd+abd ′+5a′bc   or   bcd ′6
a′d→m5; a′b′c′→m0; b′cd→m11; abd ′→m12
(b) f=bd+a′c+b′d′+5a′b  or   a′d′6
bd→m13,  m15;  a′c→m3; b′d′→m8, m10
(c) f=c′d′+a′d′+b′
c′d′→m12; a′d′→m6; b′→m10, m11
5.8 (a) f=a′b c′+a c′d+b′c d′; f=(b′+c′)(c′+d′)(a+b+c)(a′+c+d)
(b) f=a′b′d+bc ′d′+cd; f=(b+d)(b′+d′)(a′+c)5(b′+c′)  or  (c′+d)6
736 Appendix E
5.10 (a) C′D′E′→m16, m24; A′CE′ →m14; ACE →m31; A′B′DE→m3
(b) A′B′DE, A′D′E′, CD ′E, A′CE′, ACE , A′B′C, B′CE,  C′D′E′, A′CD ′
5.11 f=(a+b+c+d) (a+b′+e′) (a′+d′+e) (a′+b+c′) (a+c+e′)
(c+d+e′) 5(a′+b′+c+d) or (a′+b′+c+e)6
5.12 (a) F=Π  M(0, 1, 9, 12, 13, 14)
F=(A+B+C+D)(A+B+C+D′)(A ′+B′+C+D)
(A′+B′+C+D′)(A ′+B′+C′+D)(A ′+B+C+D′)
(b) F′=A′B′C′+ABD ′+AC ′D
(c) F=(A+B+C) (A′+B′+D) (A′+C+D′)
5.13 F=A′C′+B′C+ACD ′+BC′D
Minterms m0,  m1,  m2,  m3,  m4,  m5,  m7,  m8,  m10, and m11 can be made don’t-cares 
individually and will not change the given expression.
 UNIT 6 Study Guide Answers
2. (f ) (2, 6)
3. (a) m0−a′b′c′(m0, m1)−a′b′
m1−a′b′c(m1, m5)−b′cprime
m5−ab ′c(m5, m7)−ac
m7−abc
(d) A′B′C′ and ABC are not prime implicants.
4. (b) a′c′d′,  bc ′,  ab ′c
5. (b) F=bd+a′b, F=bd+bc ′, F=bc ′+a′b, F=a′b+c′d
 UNIT 6 Answers to Problems
6.2 (a) a′c′d(1,  5)
b′c′d(1,  9)
a′bd (5,  7)
ab ′d(9,  11)
abd ′(12,  14)
bcd (7,  15)
acd (11,  15)
abc (14,  15)  (b) a′b′c′(0,  1)
b′c′d′(0,  8)
ab ′d′(8,  10)
acd ′(10,  14)
a′d (1,  3, 5, 7)
bc (6,  7, 14,  15)
6.3 (a) f=a′c′d+ab ′d+abd ′+bcd   or   f=b′c′d+a′bd+abd ′+acd
(b) f =a′d+bc+'a′b′c′ + ab ′d′
OR
b′c′d′ + acd ′
OR
b′c′d′ +ab ′d′ /
6.4 f=b′cd ′+bc ′+a′d+(a′b OR a′c) [1 other solution]
6.5 Prime implicants: ab,  c′d,  ac ′,  bc ′,  ad,  bd
F=ab+c′d  or  F=ab+ac ′ or   F=ab+ad   or   F=ac ′+ad   or   F=ac ′+bd   or
F=ad+bc ′
Answers to Selected Study Guide Questions and Problems  737
6.6 (a) F=A′B+A′C′D′+AB ′D+A′C′E+BCDE
(b) Z=A′B′+ABD +EB′C′+EA ′C+FAB +GBD  [several other solutions]
 UNIT 7 Study Guide Answers
1. (b) Z1: six gates, 13 inputs, four levels  Z2: five gates, 11 inputs, five levels
(d) 
2. (a) 0; 1; 1,1,1  ;0 ,  0, 0
6. (a) (1) No  (2) Yes  (3) No  (b) because C requires no gate
(c) five gates, 10 inputs; using common gate: four gates, nine inputs
(d) F1=a′cd+acd +ab ′c′;  F2=a′cd+bcd+a′bc ′+acd ′;
F3=bcd+acd+a′c′d
 UNIT 7 Answers to Problems
7 .1 (a) f=(a+b)(a ′+b′)(a+c+d′)(a ′+c′+d′)
OR  f=(a+b)(a ′+b′)(a+c+d′)(b+c′+d′)
OR  f=(a+b)(a ′+b′)(b ′+c+d′)(a ′+c′+d′)
OR  f =(a+b)(a′+b′)(b′+c+d′)(b+c′+d′)
(b) f=a′b(c+d′)+ab ′(c′+d′)
7 .2 (a) Z=(C′+E′)(AD +B)+A′D′E′  (four levels, 13 inputs)
(b) Z=(B(C+D)+A)(E+FG)    (four levels, 12 inputs)
7 .3 AND-OR: F=a′bd+ac ′d; OR-AND: F=d(a′+c′)(a+b)DA
B
C
F
GZ
E
a′
c′b
d
dFaNAND-NAND
a′
c′
F
d′a
bNOR-NORa
cb′
d′
d′Fa′a
cb′
d′
d′a′OR-NAND
a
c
F
d′a′
b′a
c
a′
b′AND-NORFNOR-OR
F
dNAND-AND
738 Appendix E
7 .4 F=BC′(A+D)+AB ′C  (three levels, four gates, 10 inputs)
7 .5 Z=(A+C+D)(A′+B′C′D′) (convert circuit to four NOR gates)
7 .6 Z=A(BC+D)+C′D (convert circuit to five NAND gates)
7 .7 Z=E(A+B(D+CF  )) (convert circuit to five NOR gates)
7 .8 (a)FB
A
B′A′
D′
CC′
A
B′
E Z
F′
GC′
D
A′
B
E′ Z
F
G′C
D′
(b)
7 .9 f1=acd ′+ad+a′b′d; f2=a′d′+a′b′d+acd ′ (six gates, 16 inputs)
7 .10 f1=ab ′d+b′cd+a′bd′f2=ab ′c+b′cd ′+bc ′d′+5ac ′d′ or ab ′d′6
f3=ab ′c+b′cd+a′bc (11  gates, 34  inputs)
7 .11 F1=(a+c)(a+b′) (a′+b′+c) (a′+b+c′)
F2=(a+c′) (b′+c+d) (a′+b′+c) (a′+b+c′) or
(a+c′) (a+b′+d) (a′+b′+c) (a′+b+c′)
(eight gates minimum, 23 gate inputs)
7 .12 f1=(a+b+c) (b′+d)f2=(a+b+c) (b′+c+d) (a′+c)
f3=(b′+c+d) (a+c) (b+c′)
7 .13 (a) R eplace all gates in the AND-OR circuit which corresponds to 
Equations (7-25(b)) with NAND gates. Invert the c input to the f2 output  
gate.
(b) Replace all gates in Answer 7 .12 with NOR.
Answers to Selected Study Guide Questions and Problems  739
 UNIT 8 Study Guide Answers
3. a′
b
f
g′
d′c′
e
ZV
0 510 15 20 25 30 35 40t (ns)4. (a) Factor out the expression such that the number of inputs on each gate is less 
than or equal to the maximum allowed. This will result in the addition of 
more levels of logic.
(b) Yes.(c) Even if the two-level expressions had common terms, most of these common 
terms would be lost when the expressions are factored.
5. (a) B
′ goes to 0 at 80 ns. Z goes to 1 at 50 ns and goes to 0 at 110 ns.
6. (a) y1 goes to 1 at 15 ns. y2 goes to 0 at 30 ns. Z goes to 1 at 25 ns and, then, goes 
to 0 at 40 ns.
(c) A pair of adjacent 1’s corresponding to a ′bc and abc  are not in the same loop 
in the Karnaugh map, but a′bc and a′bc ′ are both in a′b. Without the map, 
when b=c=1 and a  changes from 0 to 1, a′b may go to 0 before ac becomes 1.  
But when a =0, b=1, and c  changes from 1 to 0, a ′b remains 1.
(g) The application of DeMorgan’s laws to convert a circuit from one form to 
another will not introduce any hazards.
7 . (b) If G=0, gate 4 is faulty. If G=1, gate 1 is faulty.
 UNIT 8 Answers to Problems
8.1 
8.2 (a) F=A′C′D′+BC′D+AC (hazards are 1101 ↔1111 and 0100 ↔0101 [static 1]) 
OR F=(A′+C+D) (B+C+D′) (A+C′) (hazards are 0001↔ 0011 and 
1000  ↔ 1001 [static 0])
(b) F t=A′C′D′+BC′D+AC+A′BC′ +ABD
(c) F t=(A′+C+D) (B+C+D′) (A+C′) (A′+B+C) (A+B+D′)
8.3 (a) Glitch in output of G occurs between 6 ns and 7 ns (static 1 -hazard).
(b) Modified equation to avoid hazards: G =A′C′D+BC+A′BD
8.4 A=1   E=X
B=Z   F=0
C=X  G=0
D=1  H=X
8.5 Gate 3 is connected incorrectly or is malfunctioning.
740 Appendix E
 UNIT 9 Study Guide Answers
2. (a)
(b) Z=A′C′I0+A′CI1+AC ′I2+ACI3
(c) Before C changes, Z =I4, and after C changes, Z =I5.
(d) 
(e) MUX inputs: I0=B, I1=B′,  control =A
3. (f    ) AND-gate inputs are A′B′, A′B, AB ′, and AB
4. (a) Inputs BCD ; A=0
5. (b) 32  words  ×4 bits;  1024 ×8  (c) 16  words  ×5 bits;  16×10
6. (a) Four inputs, seven terms, three outputs
(b) Four inputs, four terms, three outputs
(c) I0
I1A
BI2
I30
1I0
I101
AZ01
ABCD F1F2F3
11 - - 1 0 1
1- 11 1 1 011 0 - 0 1 00- 11 0 1 1
(f   ) When ABC=010,   F0F1F2F3=0111.
8. (c) f=c′(d′+a)+c(a′b′+bd)
(d) G
a
b
fedcG00 G01 G10 G11
FG
fedcFG
fedcFG
fedcFG
Answers to Selected Study Guide Questions and Problems  741
 UNIT 9 Answers to Problems
9.1 (a)
I0
I1
BI2
AZ
(b)  (c)
AZI0
I1
I2
I3
BC
I4
I5
I6
I7
BCZ
ABI0
I1
C
I2
I3
C
I4
I5
C
I6
I7
C
Y4
4X
A4
4
X44Y
A44-Bit
SubtracterDifference
Bout9.2 
742 Appendix E
9.3 
9.4 (a)
(b) 
9.5 4 4
Y
4
4-Bit
SubtracterDifference
Bout4 4
X
4 4
X
4 4
YA
3-to-8
Line
Decoderm0
m1
m2
m3
m4
m5
m6X
Y
Cin
m7Sum
Cout
3-to-8
Line
Decoderm0
m1
m2
m3
m4
m5
m6X
Y
Cin
m7Sum
Cout
4-to-2
Priority
Encodery0
y1
y2
y3a
b
ca = y2 + y3
b = y1y2 + y3
c = y0 + y1 + y2 + y3′
Answers to Selected Study Guide Questions and Problems  743
9.6 
9.7 Block diagram for a Gray code adder:
Partial Truth Table
abcdefgh S3S2S1S0Cout
(0 + 0 = 0) 0 0 0 0 0 0 0 0 0 0 0 0 0
(1 + 2 = 3) 0 0 0 1 0 0 1 1 0 0 1 0 0(5 + 7 = 12) 1 1 1 0 1 0 1 1 0 0 1 1 1(8 + 9 = 17) 1 0 0 1 1 0 0 0 1 0 1 1 1
9.8 (a)4-to-2
Priority
EncoderEnA
EnB
EnC4-Bit
Adder
42
EnD4
44
Sum
Cout
444
ABCDE
28 × 5
ROMa
b
c
dS3
S2
S1
S0
CoutSum
(S3 is the most
significant bit)The size of the ROM
is 256 words × 5 bits.
N1
N2e
f
g
h
A
AB ′D
A′C ′
BC
C′D ′
AC
CDBCD
XYZ
744 Appendix E
(b) Truth Table for the ROM
A BCD XY Z
0000111
000111100100000011001010011101011110110100011110110001101001101101001010111111100110110100011101101111111
9.9 
X
Y
Difference
BoutBin
Answers to Selected Study Guide Questions and Problems  745
9.10 (a) A4=W ′+X′Y′ A3=WX′Y′     A2=W ′X+XZ+XY
A1=W ′Y+WXY ′Z′+YZ   A0=W ′Z+WXZ ′+X′Y′Z+WYZ′
W
X
Y
Z
W ′
X′Y ′
A4
WX ′Y ′
A3
W ′X
XZ
XYA2
W ′Y
WXY ′Z ′
YZA1
W ′Z
WXZ ′
X′Y ′Z
WYZ ′A0
(b) W X Y Z A4A3A2A1A0
0 --- 10000
- 0 0 - 1000010 0 - 0100001 -- 00100- 1 - 1 00100- 1 1 - 001000 - 1 - 0001011 0 0 00010- - 1 1 000100 -- 1 00001
(continued)
746 Appendix E
11 - 0 0 0001
-0 0 1 00 0 0 11- 1 0 00 0 0 1
9.11 (a) Not inverting, three AND gates. Inverting, F =ac+b′c′d, two AND gates.
(b) Not inverting, two AND gates. Inverting, F=ad+ac+bd+bc, four 
AND gates.
9.12 (b)
9.13 F=b′(ade ′+a′cd ′e)+b ((c′d′e+a′cd ′e)+ac ′de ′)
 UNIT 10 Study Guide Answers
1. (b) Both statements execute at 5 ns. C and D are updated at 5 +Δ  ns.
(c) M <= not M after 5 ns;
(d) A <= (not B and C) or (B and not C);
2. (a)
(b) F <= ‘1‘ when A&B = “00“ else ‘0‘ when A&B = “01“ else C;a
b
c
1
Sum
1
0M
5 1 01 52 02 5 t (ns)
B
A
CF0
1
Answers to Selected Study Guide Questions and Problems  747
(c) AB <=  A&B;
with AB select
 F <= ‘1‘ when “00“, ‘0‘ when “01“, C when “10“, C when “11“;
3. (c) Change all (3 downto 0) to (4 downto 0). Change (3 downto 1) to (4 downto 1).
Add another instance of a full adder –FA4: FullAdder port map (A(4), B(4), C(4), Co, S(4));Change Co in FA3 to C(4).
(f  ) architecture ckt of fig8_5 is
 signal G1: bit;
 begin G1 <= A and B after 20 ns;
 G2 <= G1 nor C after 20 ns;
end ckt;
5. (a) not (A&B xor  “10”) not (A&B) xor  “10”
(b) The given statement will keep executing over and over again.
7 . (a) A =‘1’,
 B=‘X’, C=‘0’, D=‘1’, E=‘X’, F=‘Z’
(b) If F is of type bit, compiler will log an error.
If F is std_logic, it will be 0 for 2 ns and, then, become X.
(c) Addout  10011, Sum  0011, Cout = 1(d) Addout <= (‘0‘ & A) + (“000“ & B);Sum <=  Addout(5 downto 0);Cout <=  Addout(6);
(e) 
 UNIT 10 Answers to Problems
10.1 (a) F <= not A and B and C; G <= D and not E; N <= F xor G; I <= not N;
(b) I <= not (( not A and B and C) xor (D and not E));
10.2 E
A
F
BD
G
C
A
BG
HI
F C
D
E
748 Appendix E
10.3 (a)      (b)
10.4 
entity quad_mux is
 port (X, Y: in bit_vector(3 downto 0);
  A: in bit;
  Z: out bit_vector(3 downto 0));
end quad_mux;architecture equations of quad_mux isbegin Z <= X when A = ‘0‘ else Y;
end equations;
10.5 
entity ROM is port (A, B, Cin: in bit;
  Sum, Cout: out bit);
end ROM;architecture table of ROM is type ROM8_2 is array(0 to 7) of bit_vector(1 downto 0);
 constant ROM1: ROM8_2 := (“00“, “01“, “01“, “10“, “01“, “10“, “10“,“11“);
 signal index: integer range 0 to 7;
 signal S: bit_vector(1 downto 0);
 begin
  index <= vec2int(A&B&Cin);
  S  <= ROM1(index);
  Sum <= S(0);
  Cout <= S(1);
end table;
10.6 (a) F=000001101
(b) The expression evaluates to TRUE.C
B
E
DAG
1F0
0
1C
D
E
B
DF
E
A
D
Answers to Selected Study Guide Questions and Problems  749
10.7 
entity average is
 port (a, b, c, d: in std_logic_vector(15 downto 0);
 f: out std_logic_vector(15 downto 0));
end average;architecture behavioral of average is signal sum: std_logic_vector(17 downto 0);
 begin
 sum <= (“00“ & a) + b + c + d;
 f <= sum (17 downto 2) + sum (1);
end behavioral;
10.8 
Bus <= A when EnA = ‘1‘ else “ZZZZ“;
Bus <= B when EnB = ‘1‘ else “ZZZZ“;
Bus <= C when EnC = ‘1‘ else “ZZZZ“;
Bus <= D when EnD = ‘1‘ else “ZZZZ“;
Addout <= ‘0‘ & E + Bus;Sum <= Addout(3 down to 0);Cout <= Addout(4);
10.9 (a)          (b)
 UNIT 11 Study Guide Answers
1. Left inverter has a 1 output; right inverter has a 0 output.
2. (b) P=Q=0  (c) S and R  cannot both be 1 simultaneously.
3. (c)A
B
FI0T1
T2
T3
T4A
B
I1
A
B
I2
A
B
I3I0
I1
I2
I3
ABF
sel <=  A&B;
with sel selectF <=  I0 when “00“, I1 when “01“,
 I2 when “10“, I3 when “11“;
QGD
750 Appendix E
4. (b) Q changes to 1 after first rising clock edge and back to 0 after third rising 
clock edge.
(d) Hold time violation ( D is not stable for 2 ns after second falling clock edge.)
(e) = 7 ns.
5. (c) For a rising-edge-triggered flip-flop, the value of the inputs is sensed at the 
rising edge of the clock, and inputs can change when the clock is low. For a 
master-slave flip-flop, if the inputs change when the clock is low, the flip-flop outputs may be incorrect.
6. (c)
7 . (b) Q changes its value at times 1 and 2.
8. (b)
(c) If 
CLK=1, it will produce a falling edge at the clock input of the D flip-flop, 
causing the output to change. If CLK=0, only the rising edge is affected, so 
the output does not change at the wrong time.En cannot be changed when the clock is 1.The flip-flops in Figures 11 -31(b) and (c) can only change on the falling edge of the clock.
(d) 
CK D CE ClrN Q+
xx x 0 0
xx 0 1 Q (no change)
↓ 01 1 0
↓ 11 1 1
0,1,↑ x1 1 Q (no change)
9. (b) S=Q′T, R=QT
Same as answer to Study Guide 6(c) except connect J and K and label it T.S
RQ
Q′CKJ
K
QPresetClearDClock
Answers to Selected Study Guide Questions and Problems  751
 UNIT 11 Answers to Problems
11.1 
11.2 (a) R=1 and H =0 cannot occur at the same time.
(b) 
RHQ Q+Q+=R+HQ
000 0
001 0010 0011 1100 X101 X110 1111 1
(c) 
11.3 zyx
0 1 02 03 04 05 06 07 08 09 0 1 0 0
PQHR
Q
50 100 150 200PRS
752 Appendix E
11.4 
11.5 Connect the clock directly to the input G1 and connect the clock to G2 through 
an inverter.
11.6 (a) Q+=SR′+R′Q  (b)
11.7 
11.8 D
GS
RQ
Q′
QPG2DClock = G1
S
RQ
Q′ClkS
R
QKJClock
DQCEDinClock
Answers to Selected Study Guide Questions and Problems  753
11.9 (a)
(b) 
11.10 (a)
(b)     (c)
 UNIT 12 Study Guide Answers
1. (a) G=0, H =249;  G=0, H =70; G=118, H=118;  G=91, H=118;
G=91, H=118
2. (b) S0 is 1 between the rising edges of clocks 10 and 11, and also 1 between the 
rising edges of clocks 14 and 16.Q2Q1ClockClrNQClockKJPreNClrN
DQ
Q′ ClkQ
J
K
TQ
Q′ ClkQ
DTQ
Q′ ClkQ
D
CE
754 Appendix E
Clock Cycle
NumberState of Shift Register when Clock = 1
Q7Q6Q5Q4Q3Q2Q1Q0
1 0000000 0
2 0000000 03 1000000 0
- ------- -
1 4 0000001 11 5 0000000 11 6 0000000 0
3. (b)
(d) 
(f  ) State 101 goes to 110, which goes to 011.
(g) State 001 goes to 100; 101 goes to 110, which goes to 011.
4. (e)
(k) F1=1 F2=0TATBTCABCClock
00001111
00110011
01010101
DADBDC
000
011
010 111 110100
Answers to Selected Study Guide Questions and Problems  755
 UNIT 12 Answers to Problems
12.1 
ClrNAdClock
12.2 
4-bit Parallel-In
Parallel-Out
Shift RegisterSISerial Out
Sh
Ld
Clock
00
01
10
11 D3
A
B
ClockSIQ3
DQ00
01
10
11 D2Q2
DQ00
01
10
11 D1Q1
DQ00
01
10
11 D0Q0
DQFor a right shift, Sh =1, Ld=0 or 1. For a left shift, Sh =0, Ld=1.
12.3 
12.4 (a)    (b)
D′
Clock
ABCD
TDD′
Clock
ABCD
DD
756 Appendix E
12.5 DD=D+=D′CBA +DC ′+DB ′+DA ′ DB=B+=B′A+BA ′
DC=C+=C′BA+CB′ +CA ′  DA=A+=A′
12.6 Uses three flip-flops: Q3 Q2 Q1
Many correct solutions are possible. One is:
D3=Q1+Q2Q3′ D2=Q2′Q3
D1=Q1′Q3′
12.7 (a) DC=CA+BA ′DB=C′+BA ′
DA=B′A′+CB+C′B′
If CBA=000, next state is 011.
(b)  TC=B′A′+C′A′TB=C′B′+CBA
TA=CB′ +CA ′+C′BA
If CBA=000, next state is 110.
12.8 (a) JC=A′JB=C′ JA=C
KC=B′A′KB=CA KA=CB′ +C′B
If CBA=000, next state is 110.
(b)  SC=BA ′SB=C′SA=CA ′
RC=B′A′RB=CA RA=CB′A+C′B
If CBA=000, next state is 010.
12.9 (a)
QQ+M N
00 0 X
01 1 X10 X 011 X 1
(b)  MC=B MB=C′A MA=C′
NC=A NB=C′ NA=C′+B
 UNIT 13 Study Guide Answers
2. (a) Mealy: output a function of both input and state
Moore: output a function of state only
(b) Before the active clock edge
After the active clock edge
When the flip-flops change stateWhen the flip-flops change state or when the inputs change
(c) Immediately preceding the active clock edge(d) Mealy: False outputs can appear when the state has changed to its next 
value, but the input has not yet changed.Moore: No false outputs occur because output is not a function of input.Changing the inputs at the same time the state change occurs will eliminate false outputs.No, because the output of the first Mealy circuit will still change to its final value before the active clock edge.
3. (a) Before the clock pulse
Q
+ means the state of flip-flop Q after the active clock edge (i.e., the next 
state of flip-flop Q ).000
001
100
010101110
Answers to Selected Study Guide Questions and Problems  757
(c) Mealy: output associated with transitions between states
Moore: output associated with state
(d) Present: Before the active clock edge
Next: after the clock pulse
(e) Output depends only on the state and not on the input.
4. (a) 1101 (c) 1001
(e) 
5. (a)
(c) 
6. (a)
(g) δ(S3,  1)=S2,  λ(S3,  1)=0,  δ(S1,  2)=S2,  λ(S1, 2)=3S2 S1 S0
,01
1
0
010
1S3
1
S2
0S0
0
S1
01
00
0
0
11
0
0
11
0ZdZ 10 01False outputs
ZS1 S0 S2S0 StateClock010
01X
False outputMealy Moore
ZS1 S0 S2S3 StateClock010
0 00 1X
Z2Z1
False output
758 Appendix E
 UNIT 13 Answers to Problems
13.2 
This is a Moore machine.
13.3 (a) A+=A(B′+X)+A′(BX ′+B′X)  B+=AB ′X+B(A′+X′)1
11
01
10
1101
011110
11101 0 11
00
01
01
0
0
10
0000
001100
010
,
S0 S3 S5 S6S1 S7 S2 S40
0
0
0
1
10
00
11
0
1
01
0
1
01
11
1
,0
01
10
1
0
1
0
1Present State Next State (A+B+)
AB x=0x=1 Z
00 00 10 0
01 11 01 0
11 01 10 1
10 10 11 0 This is a Moore machine.
(b) Z=(0)00101
(c) 
13.4 (a)
Q+
1Q+
2Q+
3 Z
Q1Q2Q3X=010 1
S00   0   0 001 001 0 1
S10   0   1 011 011 0 1
S20   1   0 100 101 1 0
S30   1   1 010 011 1 0
S41   0   0 001 001 0 1
S51   0   1 011 011 0 1
S61   1   0 100 101 1 0
S71   1   1 010 011 1 0ZBAXClock
Answers to Selected Study Guide Questions and Problems  759
(b)
(c)  From diagram:  0  1(0)  1  0  1
 From graph:  0  1  1  0  1 (same except for false output)(d)  Change input on falling edge 
of clock
13.5 (a) Mealy Machine
(b) 
A+B+C+Z
ABC X=0 X=1X=0X=1
000 011 010 1 0
001 000 100 1 0010 100 100 0 1011 010 000 0 1100 100 001 1 0
(c) ZQ3Q2Q1ClockX
False
000
010 011 100,
0010
1
0
10
01
11
0
1
01
00
1
0
01
1
(d) 
Z
00010CBAXClock
False outputs
 Correct output sequence: 00010
760 Appendix E
13.6 (a) 14 ns
(b) 
ZQ2Q1D2D1XClock0 ns 5 ns 10 ns 15 ns 20 ns 25 ns 30 ns 35 ns 40 ns
Correct output sequence: Z = 0101
0
00
0
0
11
01
1
1
10,1
0S0 S2
S1 S3
ClockManchesterRZNRZINRZBit sequence 1 0 001110(c) 
Next State Z
X=0 X=1 X=0X=1
S0 S2 S2 00
S1 S0 S3 00
S2 S3 S1 01
S3 S1 S3 11
 UNIT 14 Study Guide Answers
1. (b) last row: 11 10 01 0 1
(c) JA=BX ′KA=X ⊕ BJB=A+XKB=AZ =AB ′
8. (a)
Answers to Selected Study Guide Questions and Problems  761
9. (b) Change N to NS ′; add loop to S3: S′N′/0
NS= Z
00 01 10 11 00 01 10 11
S3S3S5S1S500 1 0
10. The output for the third input of X=1 is don’t care, since the third input can 
only be 0.
Z1Z2
X=0 X=1X=0 X=1
S0 S1 S3 00 00
S1 S1 S2 00 00
S2 S4 S3 10 00
S3 S4 S3 00 00
S4 S5 S2 01 00
S5 S5 S6 00 00
S6 S7 S6 00 00
S7 S5 S6 01 00X=010 1
S0 –S1 ––
S1 S2 S3 ––
S2 S0 –0 –
S3 S0 –1 –
 UNIT 14 Answers to Problems
14.4 
14.5 0
000
00
001
11
1
11
11
0,1S2
0S1
0S0
0
S3
0S8
0S5
0
S4
1S7
0S6
0
S0 S3
S1 S2S6
S7S4 S50
000
000
00
0
000
01
0
01
0
000
101
00
1
00 1
00
1
001
00
1
001
001
00
762 Appendix E
14.6 
X1X2=
00 01 10 11 Z
S0 S0 S1 S3 S2 0
S1 S0 S1 S3 S2 0
S2 S4 S1 S3 S2 0
S3 S4 S1 S3 S2 0
S4 S4 S5 S7 S6 1
S5 S0 S5 S7 S6 1
S6 S4 S5 S7 S6 1
S7 S0 S5 S7 S6 1
  (a 4-state solution is also possible)
14.7 (a)    (b)
S2 S1S0
0
00
0 1
01
01
10
1
0
00
00
00
00
00
0
0
1
0
00
0
1
01
01
01
0
1
01
11
01
0
1
0
S1 S2S5 S4S7 S8S6S3S0
14.8 
(a) X1X2= Z1Z2
00 01 10 11 00 01 10 11
S0 S1 S2 S3 S4 00 00 00 00
S1 S1 S2 S3 S4 00 10 10 10
S2 S1 S2 S3 S4 01 00 10 10
S3 S1 S2 S3 S4 01 01 00 10
S4 S1 S2 S3 S4 01 01 01 00
Answers to Selected Study Guide Questions and Problems  763
(b) 
NRZI
(Moore)NRZI
(Mealy)NRZClock
11 0 10010
False outputX1X2=
00 01 10 11 Z1Z2
S0 S1 S4 S7S10 00
S1 S1 S3 S6S9 00
S2 S1 S3 S6S9 01
S3 S2 S4 S6S9 10
S4 S2 S4 S6S9 00
S5 S2 S4 S6S9 01
S6 S2 S5 S7S9 10
S7 S2 S5 S7S9 00
S8 S2 S5 S7S9 01
S9 S2 S5 S8S10 10
S10 S2 S5 S8S10 00
14.9 
(a) X=0 1 X=0 1
S0 S0S1 01
S1 S1S0 10
X=0 1
S0 S0 S1 0
S1 S1 S0 1(b) 
(c, d)
14.10 
Next State Output (DEF )
000 001 010 011 100 101 110 111 000 001 010 011 100 101 110 111
S0S0S0S0S0S1S1S0S0100 100 100 100 010 010 001 001
S1S1S0S1S0S1S0S1S0110 000 110 000 101 000 101 000
For  S0:F or S1:
A′+AB+AB ′=A′+A=1 A′C′+AC ′+C=C′+C=1
A′·AB=0;  A′·AB ′=0; A′C′·AC ′=0;
AB·AB ′=0 A′C′·C=0;  AC ′·C=0
764 Appendix E
14.11 
x′
0
x′
0x
0x
0
–z
–z–z–zS0
S3S1
S4 S2S5
 UNIT 15 Study Guide Answers
2. (b) λ(p, 01 )=00   and  λ (q, 01 )=01; therefore, p ≢q
(c) No. You would have to try an infinite number of test sequences to be sure the 
circuits were equivalent.
(d) S2≡S3 iff S1≡S5 and S4≡S2. But S1≢S5 because the outputs are different. 
Therefore, S2≢S3.
3. (a)  (b) f≡g
a-d
b-fa-f
f d c b aa-d
b-ga-ga-g
b-fa-da-b
gfdcb  (c) a ≡c, b≡d, b≡e, d≡e
01 01
a ba 01
b bb 00
6. (a) 1) Some input sequences to the circuit may not occur and 2) the output may 
be observed at only some time periods.
(b) 
S0S3S2S1
S1 S2S1, S2
S0, S3
S1, S2
Maximal Compatibles: (S0, S1), (S1, S2), (S0, S3). (S0, S3) and (S1, S2) produce 
a two-state reduced table.
X = 01 0 1
(S0, S3)=S0 S1S001
(S1, S2)=S1 S1S010
Answers to Selected Study Guide Questions and Problems  765
(c) 
S0S3S2S1
S1 S2S1, S3
S0, S2
S0, S2X = 01 0 1
S0 – S1 ––
S1 S2 S3 ––
S2 S0 –0 –
S3 S0 –1 –
X = 01 0 1
(S0, S1, S2)=S0 S0S10–
(S0, S1, S3)=S1 S0S11–
(b)7 . (b) Z=X′AB ′+XA′BC′
8. (b) Interchanging columns or complementing columns does not affect circuit 
cost for symmetric flip-flops.
(c) Complementing columns (to make the first row all 0’s) does not change the 
cost of the circuit.
 (f   ) Numbering columns from left to right, column 3 is same as column 4, column 
2 is column 5 complemented, column 1 is column 6 complemented.
9. (e) D1=XQ1′+XQ3+Q2Q3′+X′Q1Q2′ or  D1=XQ1′+XQ2+Q2′Q3+X′Q1Q3′,
D2=Q3, D3=X′Q3+XQ2Q3′+(Q1′Q3 or Q1′Q2)
Z=XQ2Q3+X′Q2′Q3+X′Q2Q3′
(f  ) J1=X, K1=X′Q2Q3+XQ2′Q3′
11. (b) Q+
5=XQ2+X′YQ2+X′Q5
(c) Q2+=Q1M
Q3+=Q2K+Q1KM′
(d) Ad=Q1M
Done =Q3
 UNIT 15 Answers to Problems
15.1 (a)Maximal Compatibles: (S0, S1, S2), (S0, S1, S3)
Next State Output
Present State X=0X=1X=0X=1
A A C 10
B C F 00
C B A 00
F B F 10
Input 1 0 0
Output (from B)01 0
Output (from G)0 1 1
766 Appendix E
15.2 
Present 
StateNext  
State
Output X=0X=1
ac c 1
c d f 0
d f a 1
f c d 0
15.3 (a) No, states S2 and S4 have no corresponding states in Mr. Ipflop’s design.
(b) Because there is no way of reaching S2 and S4 by starting from S0, the two 
circuits would perform the same.
15.4 (a) D=X1′X2Q′+X1X2′Q′+X2′X3Q+X2X3′Q
(b)  S=X1′X2Q′+X1X2′Q′
R=X2′X3′Q+X2X3Q
15.5 (a) Only  one  assignment—000 001
011   OR   010   etc.
101 100
(b) 000 000 000 000 000 000 000 000 000 000
001 001 001 001 001 001 001 001 001 001 etc.
010 010 010 010 011 011 011 011 110 110
100 101 110 111 100 101 110 111 010 011
15.6 (a)        (b)
S1 S201
S4 S3
S6 S5
S700BC
Z = AA
01
11
10 S8S1 S801
S7 S5
S3 S4
S200BC
DA = A+ = A′B ′ + XA ′+ X ′AC ′
DB = B+ = etc.
DC = C+ = etc.A
01
1110 S
6
AC01
BE
F
D00Q2Q3Q1
01
111015.7 (a)
    (b) D1=XQ1
D2=Q1′Q3′+X′Q1′
D3=X′Q1′Q3′+XQ1′Q3+5XQ2′ or  Q2Q36
 Z=XQ1
Answers to Selected Study Guide Questions and Problems  767
15.8 (a) A=00,   B=01,   C=10,   D=11
(b) T1=X1′X2Q2′+X1′Q1Q2+X1Q1′Q2+X1X2′
T2=X1Q1′Q2′+X1Q1Q2
Z1=X1Q2, Z2=X1′Q1+Q1Q2′
15.9 
Q1Q2Q3
Assign S0 10 0
S1 01 0
ROM
24 Words
4 Bits Per Word
DD
ClockQ1
Q2Q1+
Q2+Z2Z1
X2X1D1=X′Q1+XY ′Q3
D2=XQ1+YQ3+X′Q2
D3=XQ2+X′Y′Q3
P=XQ1+Y′Q3+XQ2
S=X′Q1+XY ′Q3
 UNIT 16 Study Guide Answers
1. (a) Because the input sequences are listed in reverse order
2. (b) m leads, where 2m−1<n≤2m
3. (b) 64 words × 7 bits
(d)  Z=0,  D1=1,  D2=1,  D3=0;   Q1Q2Q3=110
8. (a) Yes
(c) Yes
9. (a) After the clock (when the state has just changed) and before the input is set 
to its new value, the output may be wrong (false output).
(b) No, because the output is always correct before the active clock edge
 UNIT 16 Answers to Problems
16.15 
X1X2Q1Q2Q1+Q2+Z1Z2
0 0001100
0 00100100 01011000 01110000 10010100 10101100 11000100 11110001 00001111 00110111 01001111 01101011 10000011 10111111 11001011 1110001
768 Appendix E
16.16 (a) Same as Figure 16-10 with ROM replaced by PLA.
(b) 
XABCZDADBDC
0– – – 0 1 0 0
0– – 0 0 0 1 0
–0 – 1 0 0 1 0– 01–0010–1 – – 0 0 0 1
1 –0–00010 10110001 0101000
16.17 (a)
0
0S0
0
0111
1S1
0
0S2
0S3
1
(b) ai+1=ai+xi bi=[ai′(xi bi)′]′   bi+1=xi bi  ′+xi  ′ bi=[(xi bi′)′(xi′ bi)′]′
z=an+1bn+1
(c) a1=b1=0, a2=0, b2=x1
(d) Similar to Figure 16-9 with one output
 UNIT 17 Study Guide Answers
1. (a) When a falling edge of CLK occurs
(b) Whenever there is a change in St or Q1 or V
(c) Statements S3 and S4 will execute
(d) The code represents a rising-edge-triggered D flip-flop with asynchronous, 
active-low clear and preset. Because ClrN has higher priority, Q will be set 
to ‘0’ when both ClrN and SetN are ‘0’.
(e) SN and R N override J and K, including at a clock edge. Q  will be ‘0’.
 (f   ) They will get the old value of Qint because of the 8-ns delay.
2. (a) entity register is
port (CLK, CLR, Ld: in bit; D: in bit_vector (3 downto 0); Q: out bit_vector (3 downto 0));
end register;
architecture eqn of register is
begin -- Given code hereend eqn;
(b) Q will change at time 10 + Δ ns
(c) On line 6 of the VHDL code, make this change—
elsif LS = ‘1’ then Q <= Q (2 downto 0) & Q (3);
Answers to Selected Study Guide Questions and Problems  769
(d) Change the indicated lines of code as shown—
line 3: process (ClrN, CLK)
lines 5 to 7: if ClrN = ‘0’ then Q <= “0000”;
    elsif CLK’event and CLK = ‘1’ then
      if En = ‘1’ then Q <= Q + 1;
(e) When Carry1 = ‘1’ and Qout2 = “1111”
 (f ) No overloaded “+” operator is defined for bit_vectors
(g) After the rising edge, Qout1 = “0000” and Qout2 = “1010”
(h)
Control Signals Next State
ClrN LdN PT Q+
3 Q+
2 Q+
1 Q+
0
X0 X D3 D2 D1 D0
X1 1 Present state + 1
0 1 0 0000
11 0 Q3 Q2 Q1 Q0
3. (a) process (A, B, D)
begin E <= (A and B) or D after 5 ns;
end process;
4. (a) Nextstate = S4 and Z = 1
(b) Because there are only seven states. Also, specifying the range restricts the 
number of bits used to represent the integer.
 When X changes to 1, Nextstate =2, and Z =
0. Then, when CLK changes to 1,  
State =2, Nextstate =4, and Z =1
(c) The glitch occurs because the change in state and change in the value of X 
a little while later causes process (State, X) to execute two times, thereby updating the value of Nextstate two times. This glitch does not affect the ‘state’ because the state will not be updated until the next positive clock edge.
(d) Because Q1, Q2, and Q3 must be updated only on the CLK edge, the other 
signals must not appear on the sensitivity list. The new values will be com-puted at 5 ns, and the values are updated at 15 ns.
(e) The statements of lines 13, 14, and 18 will execute.
 (f   ) ROM output = 1100
5. (a) Connect En to CE and A to D
(b) See Figure 11 -31(c) (change to rising-edge trigger)
(c) Use four D-CE flip-flops. Connect ASR to every CE input, D3 to Q3, D2 to Q3, 
D1 to Q2, and D0 to Q1. Label Q3 . . . Q0 as A(3) . . . A(0).
6. (a) processbegin A <= B or C;
 wait on B, C;
end process;
(b) 2 ns (Both sequential statements execute immediately with no delay.)
770 Appendix E
 UNIT 17 Answers to Problems
17 .1 Code to implement a T flip-flop
entity tff is
 port (t, clk, clrn: in bit;
      q, qn: out bit);
end tff;architecture eqn of tff issignal qint: bit; -- Internal value of qbeginq <= qint;qn <= not qint;process (clk, clrn)begin if clrn = ‘0’ then qint <= ‘0’;
 elsif clk’event and clk = ‘1’ then
  qint <= (t and not qint) or (not t and qint);
 end if;
end process;end eqn;
17 .2 Right-shift register with synchronous reset
entity rsr is Port (clk, clr, ld, rs, lin: in bit;
   d :  in bit_vector(3 downto 0);
   q :  out bit_vector(3 downto 0));
end rsr;
architecture eqn of rsr is
signal qint: bit_vector(3 downto 0);beginq <= qint;
process (clk)
begin if clk’event and clk = ‘1’ then
  if clr = ‘1’ then qint <= “0000”;
  elsif ld = ‘1’ then qint <= d;
  elsif rs = ‘1’ then qint <= lin & qint(3 downto 1);
  end if; end if;
end process;end eqn;
Answers to Selected Study Guide Questions and Problems  771
17 .3 (a) 4-bit binary up/down counter
entity updown is
 Port (clrn, clk, load, ent, enp, up: in std_logic;
   d :  in std_logic_vector(3 downto 0);
   q :  out std_logic_vector(3 downto 0);
   co: out std_logic);
end updown;
architecture eqn of updown is
signal qint: std_logic_vector(3 downto 0) := “0000”;beginq <= qint;co <= (qint(3) and qint(2) and qint(1) and qint(0) and ent and up)   or (not qint(3) and not qint(2) and not qint(1) and not qint(0)   and ent and not up);
process (clrn, clk)
begin if clrn = ’0’ then qint <= “0000”;
 elsif clk’event and clk = ’1’ then
 if load = ’0’ then qint <= d;
  elsif (ent and enp and up) = ’1’ then qint <= qint + 1;  elsif (ent and enp and not up) = ’1’ then qint <= qint – 1;  end if; end if;
end process;
end eqn;
17 .3 (b) 8-bit binary up/down counter. (For block diagram, connect the carry-out of 
the first counter to ENT of the second.)
entity updown8bit isPort (clrn, clk, load, ent, enp, up: in std_logic;     d :  in std_logic_vector(7 downto 0);
     q :  out std_logic_vector(7 downto 0);
     c o :  out std_logic);
end updown8bit;architecture structure of updown8bit iscomponent updown isPort (clrn, clk, load, ent, enp, up: in std_logic;     d :  in std_logic_vector(3 downto 0);
     q :  out std_logic_vector(3 downto 0);
     c o :  out std_logic);
end component;signal co1: std_logic;signal q1,q2: std_logic_vector(3 downto 0);
772 Appendix E
begin
 c1: updown port map (clrn, clk, load, ent, enp, up, d(3 downto 0),q1,co1);
 c2: updown port map (clrn, clk, load, co1, enp, up, d(7 downto 4),q2, co);
 q <= q2 & q1;
end structure;
17 .4 MUX with a and b as control inputs
entity mymux isPort (a, b, c, d: in bit;   z :  out bit);
end mymux;architecture eqn of mymux issignal sel: bit_vector(1 downto 0);beginsel <= a & b;process (a, b, c, d)begin case sel is
  when “00” => z <= not c or d;
  when “01” => z <= c;
  when “10” => z <= not c xor d;
  when “11” => z <= not d;
 end case;
end process;end eqn;
17 .5 Implements the state machine of Table 14-1
entity sm1 isPort (x, clk: in bit;   z :  out bit);
end sm1;architecture table of sm1 issignal State, Nextstate: integer range 0 to 2 := 0;beginprocess (State, x)begin case State is
 when 0 =>
  if x = ’0’ then Nextstate <= 0; else Nextstate <= 1; end if;  z  <= ‘0’;
 when 1 =>
  if x = ’0’ then Nextstate <= 2; else Nextstate <= 1; end if;  z  <= ‘0’;
Answers to Selected Study Guide Questions and Problems  773
 when 2 =>
  if x = ’0’ then Nextstate <= 0; z <= ‘0’;
  else Nextstate <= 1; z <= ‘1’; end if;
 end case;
end process;process (clk)beginif clk’event and clk = ’0’ then State <= Nextstate;
end if;end process;end table;
17 .6 (a) See Figure 13-17 , with m =2,
 n=2, and k =2.
(b) Implements the state machine of Table 13-4
library BITLIB;use BITLIB.bit_pack.all;entity sm isPort (x1, x2, clk: in bit; z1,z2: out bit);
end sm;architecture Behavioral of sm istype rom16_4 is array (0 to 15) of bit_vector(3 downto 0);-- Input is in the order X1 X2 Q1 Q2-- Output in order Q1 Q2 Z1 Z2constant myrom: rom16_4 :=  (“1100”, “0010”, “1100”, “1000”, “1010”, “0110”,“0010”, 
     “1000”, “0111”, “1011”, “0111”, “0101”, “0001”, “1111”, “0101”, “0001”);signal index: integer range 0 to 15;signal q1,q2: bit;signal rom_out: bit_vector(3 downto 0);beginindex <= vec2int(x1&x2&q1&q2);rom_out <= myrom(index);z1 <= rom_out(1);z2 <= rom_out(0);process(clk)begin if clk’event and clk = ’1’ then
  q1 <= rom_out(3);
  q2 <= rom_out(2);
 end if;
end process;end Behavioral;
774 Appendix E
17 .7 (a) There are two D-CE flip-flops. For each, CE =LdA +LdB.
 D1 =LdA  A1+LdA′  LdB  B1, D2 =LdA  A2+LdA′  LdB  B2.
(b)  CE does not change. For each D input, replace the gates with a 2-to-1 
MUX, with LdA as the control input, and B and A as the data inputs for 0 
and 1, respectively. (Alternately, use LdB as the control input, and swap A and B on the data inputs.)
17 .8 All statements execute at time = 20 ns
A becomes 1 at 35 ns (not the final value)B becomes 1 at 20 ns + Δ (not the final value)C becomes 1 at 30 nsD becomes 2 at 23 nsA becomes 5 at 35 ns (overrides the previous value)B becomes 7 at 20 ns + Δ (overrides the previous value)
 UNIT 18 Study Guide Answers
1. (a) X Y cisic+
i
t0 0110 0011 0 1 0
t1 1011 1001 0 0 1
t2 0101 1100 1 0 1
t3 0010 0110 1 1 0
t4 1001 0011 0 (0) (1)
(b) Y would fill up with 0’s from the left: 0011, 0001, 0000, 0000, 0000.
(c) S0 and Y0, no.
2. (a)
a d d0 00001101
1111
shift 0 11111101
shift 0 01111110
a d d0 00111111
1111
shift 1 00101111
a d d0 10010111
1111
shift 1 10000111
0 11000011
(b) 10, 6. (c) 10, 6. (d) 15 bits
 (f    )   Product register has 17 bits. Adder is 8 bits wide, multiplicand has 8 bits. 18 states. 
3-bit counter, K=1 when counter is in state 7 (1112), control graph unchanged.
3. (b) Change Y to 2’s complement by inverting each bit and adding 1 (by setting the 
carry input of the first full adder to 1). Also change C so that it is equal to the 
carry out of the last full adder.
(c) An overflow will occur if X8X7X6X5X4≥Y3Y2Y1Y0, because subtraction is 
possible but there is no place to store the quotient bit, since there are only 4 bits available to store the quotient.
 (f    ) To set the quotient bit to 1.
Answers to Selected Study Guide Questions and Problems  775
 UNIT 18 Answers to Problems
18.3 
Control
CircuitSI
Shx3
St
Clockx2x1x0
SI
CE DQ
ShShyx
d
b
x′yy x ′y3x4
y4 y2y1y0
Full
Adderx1
y2
x2
y1
Full
Adder x3
y1
Full
Adder x3
y2
Full
Adder x3
y3Full
Adderx1
y3x1Z1
Z2
Z3S4
0
S5
0S3
0S2
1S1
0
S6
C71
1C6 1C5 1
C4 1C3 1C2 10
01
1
1
1
1
0
1
111
Z4
Z5
Z6y1
x2
y2
Full
Adder x2
y318.4 
776 Appendix E
18.5         18.6
St′
0
St
Load–
Done
M ′
Sh
M ′
ShM ′
Sh
M ′
ShM
Ad
M
Ad
M
AdM
AdS4 S1
S3 S2S0 S5S0
(Stop)
S2S1
S3C′
0C
Su
K′C ′
ShKC ′
ShC
SuC
VSt′
0
St
Load
C′
Sh
18.7 (a) V=y0′y1′y2′y3′y4′=(y0+y1+y2+y3+y4)′
(b)         (c)
(0 0 1 0 1) Sh Su
000001101010
0000110100100001101000100011010000010000110001100001100010100011000100010000100101
remainder = 1 quotient = 5,
S0
S3S1 S5
S2 S4V
0
C′
0 C
SuSt′
0
StV ′
Sh
C′
ShC′
Sh
C′
ShC′
ShC
Su
C
Su
C
SuC
Su
(d) After five shifts, the division is complete.
18.8 (a) xin=K1′K2′a′+K1′K2b+K1K2′(a ⊕ b)+K1K2a
yin=K1′K2′b+K1′K2a+K1K2′·0 +K1K2·1
(b) Use the state graph of Figure 18-6(b), with nine states total.
(c) 
00
0110
11aa
b
a
k1k2xin000110
11b
a
10byin
Answers to Selected Study Guide Questions and Problems  777
 UNIT 19 Study Guide Answers
1. (b) Z1, Z2, Z4 (for both charts) (d)
2. (a)
000011100 C = 0, Sh
000111000 C = 0, Sh
001110000 C = 1, Su
000100001 C = 0, Sh
001000010 C = 0, Sh
010000100 C = 1, Su
000110101 (result)
3. (a) A+=BX B+=A′X+BX
 UNIT 19 Answers to Problems
19.1  19.2Z2Z1S0 S0 S1 S2 S0
ZcZbZaXStateClock
P
Q
S
R0 1
10
1
(1) (2)0D
EFS0/
S2/S1/
ZZZX
X
XS3/
ZX01
10
1001
778 Appendix E
19.3 
ShAdKMState S0 S1 S2 S1 S1 S2 S3Clock
19.4  19.5
S0/
St01
S1/
Sh AdM10
S4/
Sh AdM10
...S0/
S2/N01
X
X
KK
K1 0
1 00
11 0
0 10
1S1/
XZ
ZZ
Answers to Selected Study Guide Questions and Problems  779
19.6 
S0/
St
S1/
S2/01
C1
0
10C1 0
K
C0 1V
Sh
SuSh
Su
19.7 (a) Q+
0=Q0′Q1′Q2C′+Q0Q1′+Q0Q2′
Q+
1=Q0Q1′Q2C′+Q0Q1Q2′
Q+
2=Q0′Q1′Q2′St+Q0Q2′C′+Q0Q1′Q2C
Load =Q0′Q1′Q2′St, Su=Q0C, Sh =Q1′Q2C′+Q0Q2′C′, V=Q0′Q1′Q2C
 (These equations could be further simplified using don’t-cares.)
(b) Q+
0=Q0′Q1M+Q0′Q1M ′K+Q0Q1K
Q+
1=Q0′Q1′St+Q0′Q1M ′K′+Q0′Q1M+Q0Q1K′
Load =Q0′Q1′St, Sh=Q0Q1+Q0′Q1M ′, Ad =Q0′Q1M, Done =Q0Q1′
19.8 (a) A+=A′B′C·Rb′D7′11D2′312+AB ′C′+AB ′·Rb+AB ′Eq′D7′
B+=A′B′C·D711+A′B·Reset ′+AB ′C·Rb′Eq′D7′
C+=A′B′Rb+A′BC·Reset ′+B′C′Rb+AB ′C·Rb′Eq′D7
Roll =B′C·Rb  Sp=A′B′C·Rb′D7′11D2′312
Win=A′BC′    Lose =A′BC
 (These equations could be further simplified using don’t-cares.)
(b)  If the input from the adder is S3S2S1S0, then the equations realized by the 
test logic block are
D7=S2S1S0D711=S1S0(S2+S3)D2312=S3′S2′+S3S2
19.9 (a) A+=BX Za=A′B′Z1=ABX ′
B+=A′X+BX Zb=A′BZ2=ABX
Zc=AB
780 Appendix E
X A B A+B+ZaZbZcZ1Z2
1– 1 1100000
10 – 0100000
–00 0010000–01 0001000–11 0000100
011 0000010111 0000001
19.10 (a)
Z3Z2Z1X3X2X1StateClock
S0 S0 S1 S2 S1 S1 S2
(b) D1=Q1′X1′X2′X3+Q2X2′    D2=Q2′X1+Q1′Q2′X2′X3′+Q2X2
Z1=Q2′X1′+Q1    Z2=Q1′Q2′X1    Z3=Q1′X1′X2+Q2
(c) 
Q1Q2X1X2X3 D1D2Z1Z2Z3
001–– 010100001– 0010100001 1010000000 0110001–0– 1000101–1– 01001100–– 00100101–– 01100
(d) 25×5 ROM
Q1Q2X1X2X3 D1D2Z1Z2Z3
00000 0110 000001 1010 000010 0010 100011 0010 100100 0101 0
Answers to Selected Study Guide Questions and Problems  781
 UNIT 20 Study Guide Answers
1. (a) lines 15 and 16
The full adder is combinational logic.
Lines 34 and 35, which are in clocked process because it is a clocked register
(b) In line 31, change clk =‘0’ to clk =‘1’.
2. (a) So we can use the overloaded “ +” operator
The change from state 9 to state 0To make the result be 5 bitsLines 35 and 36 will execute when State is 2, 4, 6, or 8.
(b) ACC is uninitialized and is not loaded until 
St=‘1’ at a rising clock edge. 
When Done =1, i.e., in state 9, 160–180 ns.
(c) X=101111001, 60 ns
(d) Mcand =1101,  Mplier =1011, and product is 10001111 =143
(e) Line 19
To avoid having to set them to 0 in each case where they are not 1. When they are set to 1, it overrides line 22 because these are sequential statements. ACC
 <= “00000” & Mplier;
Because it is a clocked register that is updated on the rising clock edge.The process executes on the rising clock edge, and when state is 9 at the  rising clock edge, it is too late; the state is about to change to 0.The process of lines 20–34 is not clocked; it executes when State changes to 9.
(f   ) Whenever the value of count changes.
Lines 51 and 52.10
 ns+Δ.
Sequential statements execute in 0 time, so A and B update simultaneously.
(g) At time 60 ns, we are in state 2 when K =0, so Sh=1. So 
A=00B16=0000010112 shifts to the right to become 00516=0000001012. 
At time 140 ns, we are in state 1 and M =1, so Ad =1. So we add the mul-
tipicand, 0000010112, to A =00616=0000001102 to get 01116=0000100012.
3. (a) 0; 1
C should be 1 iff we can subtract, i.e., Dividend(8 downto 4) > Divisor.
 UNIT 20 Answers to Problems
20.1 First process executes at t =2 ns. Lines 22–25 execute.
Second process executes at t =10 ns. Lines 38–40 and 43 execute.
Because the state changes, first process executes again at 10 +  Δ ns. Lines 22–23 
and lines 27–30 execute.
20.2 
entity complementer is Port (clk, n: in std_logic;
 Regout: out std_logic_vector(15 downto 0));
end complementer;architecture Behavioral of complementer issignal State, NextState: integer range 0 to 2 := 0;signal count: std_logic_vector(3 downto 0) := ”0000“; --4-bit counter
782 Appendix E
signal X, Z, Sh: std_logic;
signal K: std_logic := ’0’;signal Reg: std_logic_vector(15 downto 0);begin  Regout <= Reg;
  X  <= Reg(0);
  K  <= ’1’ when count = “1111“ else ’0’;
  process (State, X, N, K)  begin    case State is    when 0 =>      if N = ’0’ then NextState <= 0; Sh <= ’0’; Z <= ’0’;
      elsif X = ’1’ then NextState <= 2; Sh <= ’1’; Z <= ’1’;    else NextState <= 1; Sh <= ’1’; Z <= ’0’; end if;    when 1 => Sh <= ’1’;     if K = ’1’ then NextState <= 0;        if X = ’1’ then Z <= ’1’;
        else Z <= ’0’; end if;     elsif X = ’0’ then NextState <= 1; Z <= ’0’;     else NextState <= 2; Z <= ’1’; end if;    when 2 => Sh <= ’1’;     if K = ’1’ then NextState <= 0;       if X = ’1’ then Z <= ’0’;       else Z <= ’1’; end if;     elsif X = ’0’ then NextState <= 2; Z <= ’1’;     else NextState <= 2; Z <= ’0’; end if;    end case;
  end process;  process (clk)  begin    if clk’event and clk = ’1’ then      if Sh = ’1’ then Reg <= Z & Reg(15 downto 1);      count <= count + 1; end if;
      State <= NextState;
    end if;  end process;end Behavioral;
20.4 
entity test isend test;architecture Behavioral of test iscomponent sm17_2 is Port (x,clk: in std_logic;
    z :  out std_logic);
end component;constant N: integer:= 40;
Answers to Selected Study Guide Questions and Problems  783
signal flag: std_logic:= ‘0’;
signal clk: std_logic:= ‘1’;signal x,z: std_logic;constant x_seq: std_logic_vector(1 to 40) :  =
              (“0000100001001100001010100110111000011001”);constant z_seq: std_logic_vector(1 to 40) :  =
              (“1100001010100110111000011001010111010011”);begin sm1: sm17_2 port map(x,clk,z);
 clk <= not clk after 10 ns; -- clock has 20 ns period
 process
 begin
  for i in 1 to N loop   x  <= x_seq(i);
   wait for 5 ns; -- wait for z to become stable   if z = z_seq(i) then flag <= ‘0’; else flag <= ‘1’; end if;
   wait until clk’event and clk = ‘1’;   wait for 5 ns;  end loop; end process;
end Behavioral;
20.5 
Ld
Clr Accumulator (7:0)
Adder
Mcand
(3:0)
McandDataAdd
Add
Done
InitInit
8
44
488
MplierDataClk
SumProduct
Ld Init
ClkDecLd Mplier (3:0)Down Counter
Add
Init
Clk
StartControl
Circuit
Start/Init
Start/Done
K/DoneStart ′/0Start ′/0
K′/AddK
S1 S2S0
784 Appendix E
20.6 
entity prob20_6 is
 Port (st, clk: in std_logic;
    X :  in std_logic_vector(7 downto 0);
    Z :  out std_logic_vector(9 downto 0));
end prob20_6;architecture Behavioral of prob20_6 is signal State, NextState: integer range 0 to 3 := 0;
 signal lda, ldb, ldc, ad: std_logic;
 signal B, C: std_logic_vector(7 downto 0);
 signal A: std_logic_vector(9 downto 0);
 signal sumAB: std_logic_vector(8 downto 0);
 signal sumABC: std_logic_vector(9 downto 0);
begin sumAB <= (“0“&A(7 downto 0)) + B;
 sumABC <= (“0“&sumAB) + C;
 Z <= A;
process (st, State)begin lda <= ‘0‘; ldb <= ‘0‘; ldc <= ‘0‘; ad <= ‘0‘;
 case State is
  when 0 =>   if st = ‘1‘ then lda <= ‘1‘; NextState <= 1;
   else NextState <= 0; end if;  when 1 =>   ldb <= ‘1‘; NextState <= 2;
  when 2 =>   ldc <= ‘1‘; NextState <= 3;
  when 3 =>   a d  <= ‘1‘; lda <= ‘1‘; NextState <= 0;
 end case;
end process;process(clk)begin if clk‘event and clk = ‘1‘ then
  if lda = ‘1‘ then
   if ad = ‘1‘ then A <= sumABC;
   else A <= (“00“ & X); end if;
  elsif ldb = ‘1‘ then B <= X;
  elsif ldc = ‘1‘ then C <= X;
  end if;  State <= NextState;
 end if;
end process;end Behavioral; 
785References
1. Ashenden Peter J. The Designer’s Guide to VHDL, 3rd ed. San Francisco:  
Morgan Kaufmann Publishers, 2008.
2. Bhasker, J. A Guide to VHDL Syntax. Upper Saddle River, NJ: Prentice-Hall, 1995.
3. Bhasker, J.  VHDL Primer,  3rd ed. Upper Saddle River, NJ: Prentice-Hall, 1999.
4. Brayton, Robert, et al. Logic Minimization Algorithms for VLSI Synthesis . 
Secaucus, NJ: Springer, 1984.
5. Givone, Donald D. Digital Principles and Design. New York: McGraw-Hill, 2003.
6. Katz, Randy H. and Gaetano Borriello. Contemporary Logic Design, 2nd ed. 
Upper Saddle River, NJ: Prentice Hall, 2004.
7. Mano, M. Morris and Michael D. Ciletti, Digital Design, 5th ed. Upper Saddle River, NJ: Prentice Hall, 2012.
8. Mano, M. Morris and Charles R. Kime. Logic and Computer Design Fundamentals,  
4th ed. Old Tappan, NJ: Pearson Prentice Hall, 2008.
9. Marcovitz, Alan B. Introduction to Logic Design , 3rd ed. New York: McGraw-
Hill, 2009.
10. McCluskey, Edward J. Logic Design Principles. Upper Saddle River, NJ: Prentice 
Hall, 1986.
11. Miczo, Alexander. Digital Logic Testing and Simulation, 2nd ed. New York:  
John Wiley & Sons, Ltd West Sussex, England, 2003.
12. Patt, Yale N. and Sanjay J. Patel. Introduction to Computing Systems: From Bits 
and Gates to C and Beyond, 3rd ed. New York: McGraw-Hill, 2013.
13. Roth, Charles H. Jr. and Lizy Kurian John. Digital Systems Design Using VHDL ,  
2nd ed. Toronto, Ontario: Cengage Learning, 2008.
14. Rushton, Andrew. VHDL for Logic Synthesis , 3rd ed. West Sussex, England:  
John Wiley & Sons, Ltd,  2011.
15. Wakerly, John F. Digital Design Principles & Practices , 4th ed. Upper Saddle 
River, NJ: Prentice Hall, 2006.
16. Weste, Neil and David Harris. CMOS VLSI Design: A Circuits and Systems 
Perspective, 4th ed. Boston: Addison-Wesley, 2010.
786 786Symbols
' ', VHDL bit values, 302" ", string literals, 314', complementation operation, 
37 , 39
--, VHDL comments, 302{}, clause repetitions, VHDL, 
306–307
+, inclusive OR operation, 
38–39, 43–46
<=, concurrent statement 
assignment operator, 299
·, AND operation, 38–39, 43–46
⊕, exclusive OR operation, 68–70
Δ, delta time delay, 321–322≡, equivalence operation, 69–70
A
Absorption theorems, 46–47 , 49Accumulator, 378–380, 629–633
parallel adder with, 378–380
serial adder with, 629–633
Active-low clear and preset 
inputs, 352–353
Adder design, 104–107 , 108–114, 
307–311, 320–321, 378–380, 
629–633, 688–689
accumulator with, 378–380, 
629–633
binary algebra for, 108–114
carry-lookahead, 111–114
design of, 108–114
full, 108–110
IEEE standard logic and, 
320–321
parallel, 108–110, 378–380registers for, 378–380, 629–631
serial, 629–633, 688–689
subtracter using, 110–111
truth tables created for, 104–107
VHDL code for, 688–689VHDL modules, 307–311, 
318–321
Addition
1’s Complement 19–202’s Complement 17–19Addresses, memory and, 271
After delay expressions, [ ], 
301–303, 305
Algorithmic state machine (ASM) 
charts, 662. See also State machine (SM) charts
Alphanumeric graph notation, 
476–478
American Standard Code for 
Information Interchange (ASCII) code, 23
AND operation (·), 38–39, 43–46AND-OR circuits, 200Architecture declaration, VHDL, 
306–308
Arithmetic operation circuits, 
626–659
binary divider, 637–643
binary multiplier, 633–637serial adder with accumulator, 
629–633
Arrays, 312–314
declaration of type, 312–313unconstrained types, 313–314string literals, " ", 314
Assignment operator (<=), 
 concurrent statements, 299
Assignment statements, 299–305
combinational circuits, 299–303conditional statements, 304–305concurrent statements, 
300–303, 305
multiplexers, 304–305VHDL signals, 299–303
Associative laws, 43–44, 46
Asynchronous clear and preset 
inputs, 353
Asynchronous sequential circuits, 
354–357
BBase, number systems, 9begin keyword, 306, 311, 590–591Behavioral description, 300Bi-directional I/O Pin VHDLBinary arithmetic, 12–15Binary-coded-decimal (BCD) 
representation, 21–22
Binary codes, 21–23
Binary counter, 384–389Binary divider design, 637–643, 
667–668, 700–702
Binary logical operators, 
VHDL, 315
Binary multiplier design, 
633–637 , 668, 690–700
Bit values ' ', VHDL, 302Boolean algebra, 29–86, 87–122
absorption theorems, 46–47 , 49
associative laws, 43–44, 46cancellation law, 76combinational logic design 
and, 96–97
commutative laws, 43, 46complementarity laws, 42, 46complementing expressions, 
52–53
consensus theorem, 47 , 49, 70–72conversion of English 
sentences to, 94–96
definition, 45–46DeMorgan’s laws, 45–46, 52–53distributive laws, 45, 46, 66–68don’t-care minterms, 103–104duality, 49elimination theorems, 
47–48, 49
expansion, 97–103expressions, 39–41, 49–52, 
66–68, 72–74
idempotent laws, 42, 46incompletely specified 
functions, 103–104
involution law, 42, 46laws of, 43–46maxterm functions, 97–103minterm functions, 97–103operations for, 37–39, 68–70simplification theorems for, 
46–49
subtracter design using, 
110–111
switching circuit design, 37–39, 
42–43switching devices and, 37–38
switching expressions, 72–74theorems for, 41–43, 46–49truth tables, 40–41, 96–97 , 
104–107
uniting theorems, 46–47 , 49valid equations, proof of,  
74–76
Boolean expressions, 39–41, 
49–53, 66–68, 72–74, 
139–140, 142–143, 152–153
adding redundant terms, 73
algebraic simplification of, 
72–74
combining terms, 72complement of, 52–53eliminating literals, 73eliminating terms, 73evaluation of, 40factoring using Karnaugh maps, 
152–153
inverse of, 52–53Karnaugh maps for, 139–140, 
142–143, 152–153
literals, 40multiplying out and factoring, 
49–52, 66–68
product of sums (POS), 50–51simplification of, 46–52, 
139–140, 142–143
sum of products (SOP), 
49–50, 51
switching expressions, 72–74truth tables and, 40–41
Boolean operations, 37–39, 
43–46, 68–70
AND (·), 38–39, 43–46associative laws, 43–44, 46commutative laws, 43, 46complementation ('), 37 , 39DeMorgan’s laws, 45–46distributive laws, 45, 46equivalence (≡), 69–70exclusive OR 
(⊕), 68–70
inclusive OR (+) operation, 
38–39, 43–46
inversion ('), 37 , 39
Borrowing process, 14–15Index
Index 787
Buffers, 265–268, 279
multiplexer (MUX) gate 
connections, 265–268
programmable array logic 
devices (PAL) gate 
connections, 279
Bus merger, 641–642
Bus splitter, 641–642
C
Cancellation law, 76Carry, 12
end-around, 19–20
flip-flop, 428, 630–632
Carry-lookahead adder, 111–114
case statement, 600–601Charts, see Prime implicants; 
Timing diagrams
Circuit design, 6–8Clause repetitions, {}, 306–307Clock enable, 354Clock skew, 434–435Clock speed, 434Clocked sequential circuits, 
412–452
general models for, 432–436
Mealy machine, 422–424, 
432–435
Moore machine, 421–424, 
435–436
Moore state graphs, 426–430parity checker, 419–421signal tracing, 421–424state tables, 425–432timing charts (diagrams), 
421–424, 430–432
transition tables, 425–432
Closed circuits, 43
CMOS logic, 713–718Code converter design, 549–552Code synthesis, VHDL, 608–611, 
705–706, 724–726
Combinational circuits, 7 , 96–97 , 
225–251, 299–303
behavioral description, 300
concurrent assignment 
statements, 300–303
dataflow description, 300gate delays, 232–235hazards in combinational logic, 
234–240
high-impedance (hi-Z) 
connections, 241
input/output value problems, 
241–242
limited gate fan-in design, 
230–232
logic design for, 96–97 , 229–230sequential circuits compared 
to, 7
signal delays, 301–303simulation of, 240–242testing of, 240–242timing diagrams for, 232–233
truth tables used for, 96–97VHDL description of, 299–303
Combinational logic design, 96–97
Comments (--), VHDL, 302Commutative laws, 43, 46Complementarity laws, 42, 46Complementation (') operation, 
37 , 39
Complementing expressions, 
52–53, 140
Complex programmable logic 
devices (CPLD), 260, 280–281, 559–563
Computer-aided design (CAD), 
184–185, 570–572
simplification of function 
 packages, 184–185
sequential circuit design using, 
570–572
Concurrent assignment state-
ments, VHDL, 300–303, 305
Condition, 662Conditional assignment state-
ments, VHDL, 304–305
Conditional output box, 662Configurable logic blocks 
(CLB), 282–283
Consensus term, 70Consensus theorem, 47 , 49, 
70–72, 140
Conversion, 1, 8–12, 94–96, 
210–214, 473–476, 665–666
Boolean equations from 
 English, 94–96
circuits using alternative gate 
symbols, 210–214
number systems, 1, 8–12
serial data code, 473–476state graph to SM chart, 665–666
Counters, 375–376, 383–398, 
596–599
binary, 384–389D flip-flops for design of, 
386–389, 393–395
J-K flip-flops for design of, 
395–402
Johnson, 383–384Karnaugh maps for, 386–387loadable, 388–389next-state maps for, 389–391other sequences for, 389–395registers with fixed sequences 
as, 383–384
ring, 383–384ripple, 385, 405self-starting, 392–393sequential logic modeling, 
596–599
shift-register, 384S-R flip-flops for design of, 
395–402state changes and, 375–376, 
383–384
T flip-flops for design of, 
384–386, 389–393
transition tables for, 385–386
twisted ring, 383–384
up-down, 387–388
VHDL processes for, 596–599
CPLD, 280–281, 559–562
Critical race, 356–357Cross-coupled form, 338–339Cyclic shift register, 594–596
D
D flip-flops, 346–348Data path, 682Data selector. See MultiplexerData transfer registers, 377–378Dataflow description, 300Debouncing, 341–342Decimal system conversions, 8–11Decision box, 662Declaration of VHDL type, 
312–313
Decoders, 268–270Decomposition of switching 
functions, 283–285
Delays, 232–235, 301–303, 305, 
321–322, 347–348
after delay expressions, [ ], 
301–303, 305
assignment statements for, 
301–303
combinational circuits, 
232–235, 301–303
delta (Δ) time, 321–322
flip-flops, 347–348hazards in combinational logic 
caused by, 234–235
ideal, 235
inertial, 234–235
multiplexers (MUX), 305parameters for, 347–348propagation, 232–233, 301, 347timing diagrams for, 232–233transport, 235VHDL signals and, 301–303, 
305, 321–322
Delta (Δ) time delay, 321–322
DeMorgan’s laws, 45–46, 52–53Dice game design, 668–672, 
674–676, 702–704
state graph for, 672
state machine (SM) charts for, 
668–672, 674–676
VHDL code for, 702–704
Digital system design, 684–712
binary divider, 700–702binary multiplier, 690–700
dice game, 702–704
serial adders, 688–689VHDL code for, 684–712
Digital systems, 6–8Diodes, 8
Disjoint window sequence 
detectors, 462–463
Distinct (nonequivalent) state 
assignment, 522–523
Distributive laws, 45, 46, 66–68Don’t cares, 103–104, 147–148, 
181–182
Karnaugh maps with, 147–148
Quine-McCluskey method for, 
181–182
simplification of, 147–148, 
181–182
truth tables with, 181–182values of, 103–104
Double throw switches, 342
Duality, 49Dynamic hazards, 234, 237–239
E
Edge-triggered flip-flops, 345, 
346–348
Electrically erasable 
 programmable ROM (EEPROM), 273, 274–275
Elimination theorems, 47–48, 49elsif clauses, 592Enable input, 264–265Encoders, 270–271end keyword, 306, 590–591End-around carry, 19–20Entity declaration, VHDL, 
306–308
Entrance path, 663Equivalence operation ( ≡), 69–70
Equivalent circuit design, 69–70Equivalent sequential circuits 
for state tables, 512–514
Equivalent state assignment, 
519–523
Equivalent states, 507–512Essential hazards, 355–365Essential prime implicants, 
146–148, 177–178, 216–217 , 727
defined, 146, 177
Karnaugh maps and, 146–148, 
214–217
minimum expression 
determined using, 146–148
multiple-output circuit 
realization and, 216–217
prime implicant chart selection 
of, 177–178
theorem proof, 727
Essential prime implicates, 149
Exclusive OR operation (⊕), 
68–70
Exclusive-NOR, 70Exit paths, 663Expansion using maxterm and 
minterm functions, 97–103
788 Index
F
Factoring an expression using 
Karnaugh maps, 152–153
False outputs, 424Feedback connections, 337Field-programmable gate arrays 
(FPGA), 230, 282–285, 563–565
Field-programmable logic arrays 
(FPLA), 278
Flip-flops, 345, 346–354, 375–402, 
517–518, 590–593
active-low real and preset inputs, 
352–353
asynchronous clear and preset 
inputs, 353
characteristic equation, 341, 
357–358
clock enable, 354
counter design using, 384–402D, 346–348, 386–389, 393–395edge-triggered, 345, 346–348input equations, 398–402, 
517–519
J-K, 350–351, 395–402latches and, 345master-slave, 345, 350, 351registers, 375–384required inputs for, 398–402sensitivity lists, 590–593sequential logic modeling, 
590–593
S-R, 349–350, 395–402state table derivation of, 517–519T, 351–352, 384–386, 389–393timing parameters for, 347–348VHDL process for, 590–593
Fraction conversion, 10–11
Full adder, 108–110Full subtracter, 110–111Functionally complete, 205
G
Gated latches, 342–345Gates, 39, 44, 68–70, 193–224, 
225–251, 265–268
AND and OR circuits, 200
AND design, 39, 44AND-OR circuit, 200buffers, 265–268combinational circuit design 
using, 225–251
delays, 232–235determination of number of, 
200–203
equivalence design, 69–70high-impedance (hi-Z) 
connections, 241, 266–267
inverters for, 210–214levels of, 199–200limited fan-in, 230–232multi-level circuit design using, 
193–224NAND design, 204–214, 217–218
NOR design, 204–214, 217–218OR design, 39, 44, 68–70OR-AND circuit, 200OR-AND-OR circuit, 200three-state (tri-state) buffers, 
266–268
tree diagram representation of, 
200–201
two-level circuit design using, 
206–209
Glitches, 239–240, 356, 424
Gray code, 22
H
Half adder, 85, 121, 328Hardware description language 
(HDL), 8, 281, 294–330.  See also VHDL
Hazards, 234–240, 354–357
asynchronous sequential circuits, 
354–357
circuit design for avoidance 
of, 239
combinational logic, 234–240
dynamic, 234, 237–239essential, 355–365glitches, 239–240, 356ideal delay, 235inertial delay, 234–235Karnaugh maps for, 235–239races, 356–357SOP expressions for, 237–238static-1, 234static-0, 234–236transport delay, 235
Heuristic procedures, 184–185
Hexadecimal conversion, 12High-impedance (hi-Z) 
 connections, 241, 266–267
Hold time, 347
I
Ideal delay, 235Idempotent laws, 42, 146IEEE standard logic, 318–321if statements, 590–592Implicant, defined, 144, 176.  
See also Prime Implicants
Implicate, defined, 149Incompletely specified functions, 
103–104. See also Don’t care minterms
Incompletely specified state 
tables, 478–479
Inertial delay, 234Input/output value problems, 
241–242
Integer conversion, 9–10Integrated circuits (IC), 
252–293, 571
buffers for, 265–268, 279computer-aided design (CAD) 
for, 571
decoders, 268–270
defined, 260encoders, 270–271field-programmable gate 
arrays (FPGA), 230, 282–285
large-scale integration circuits 
(LSI), 260
medium-scale integration 
(MSI) circuits, 260
multiplexers (MUX), 261–265programmable logic devices 
(PLD), 260, 275–281
read-only memory (ROM), 260, 
271–275
small-scale integration (SSI) 
circuits, 260
switching elements for, 272–274, 
275–277
switching functions and, 265, 
283–285
three-state (tri-state) buffers, 
266–268
very-large-scale integration 
(VLSI) circuits, 260
Inverse of expressions, 52–53
Inversion (') operation, 37 , 39
Inverters for circuit conversion, 
210–214
Involution law, 42, 46Iterative circuit design, 553–556
J
J-K flip flops, 350–351, 395–402
Johnson counter, 383–384
K
Karnaugh maps, 123–166, 
182–184, 214–217 , 235–239, 
386–387 , 524–528
combinational circuit hazards 
found using, 235–239
complements on, 140
consensus theorem on, 140counter design using, 386–387don’t cares in, 147–148essential prime implicants in, 
146–148, 214–217
factoring an expression using, 
152–153
five-variable, 149–151, 154four-variable, 141–149map-entered variable 
simplification, 182–184
minimum product-of-sums for, 
135–136
minimum sum-of-products for, 
134–135
minterms on, 138, 141, 144–149mirror-image, 154prime implicants from, 
144–149, 151product terms plotted on, 
138–139
Quine-McCluskey method use 
of, 182–184
simplified expressions found 
using, 139–140, 142–143
state assignment from, 524–528
switching functions, 134–136three-variable, 137–141two-level, multiple-output 
circuit design using, 214–217
two-variable, 136–137Veitch diagrams, 153
L
Language, VHDL, 719–723Large-scale integration circuits 
(LSI), 260
Latches, 338–345
cross-coupled form, 338–339
flip-flops and, 345gated, 342–345next-state (characteristic) 
equation for, 340–341
race condition, 343set-reset (S-R), 338–342switch debouncing, 341–344transparent, 344
Libraries, VHDL, 316–318
Link path, 663Literals, 40, 73Loadable counter, 388–389LogicAid, 131, 171, 228, 455, 547 , 
570, 676
Lookup table (LUT), 282–283Logic design, 6–7Logic equation generation and 
minimization, CAD for, 570
MManchester code, 473–476Map-entered variable 
 simplification, 182–184
Mask-programmable logic 
arrays, 278
Mask-programmable ROM, 
273–274
Master-slave flip-flops, 345, 
350, 351
Maxterm functions, 97–103
conversion with minterm forms, 
102–103
defined, 98
expansion, 97–104general functions, 100–103standard product of sums, 
98–100
Mealy state and transition 
tables, 428–430
Mealy state machine, 422–424, 
432–435, 457–460, 601–607
analysis of, 422–424, 435–436clock skew, 434–435
Index 789
clock speed, 434
false outputs, 424general model for, 432–435sequence detector design, 
457–460
timing charts for, 422–424VHDL model of, 601–607
Medium-scale integration (MSI) 
circuits, 260
Memory, 260, 271–275, 314, 
556–557
address, 271electrically  erasable 
 programmable ROM (EEPROM), 273, 274–275
mask-programmable ROM, 
273–274
programmable ROM (PROM), 
273, 274
read-only memory (ROM), 
260, 271–275, 556–557
sequential circuit design using, 
556–557
switching elements in, 272–274VHDL description of, 314
Metal-oxide- semiconductor 
field effect transistors, 
see MOSFET
Metastable state, 340Minimum clock period, 348Minimum product-of-sums, 
135–136, 143, 147 , 149
defined, 135
Karnaugh maps for, 143prime implicates for, 147 , 149procedure for, 135–136
Minimum sum-of-products, 
134–135, 137 , 139–141, 
144–149, 151, 167–192
defined, 134–135
Karnaugh maps for, 137 , 139–141 Petrick’s method, 179–181prime implicants for, 144–149, 151, 
173–176
procedure for, 135Quine-McCluskey method for, 
167–179
Minterm functions, 97–104, 136, 
138, 141, 144–149
conversion with maxterm forms, 
102–103
defined, 97don’t care, 103–104, 147expansion, 97–103four-variable Karnaugh map, 
141, 144–149
general functions, 100–103Karnaugh maps, 136, 138, 141, 
144–149
prime implicants for, 144–149standard sum of products, 
98–100
three-variable Karnaugh map, 
138, 141uniting theorem for, 136
Moore state graphs, 426–430
Moore state machine, 422–424, 
435–436, 460–462, 607–608
analysis of, 422–424, 435–436
general model for, 435–436sequence detector design, 
460–462
timing charts for, 422–424VHDL model of, 607–608
MOS logic, 713–718
MOSFETs, 713–718Multi-level circuits, 193–224
conversion using alternative 
gate symbols, 210–214
essential prime implicants for, 
216–217
inverters for, 210–214
Karnaugh maps for, 214–217multi-level design, 209–210multiple-output design, 217–218NAND design, 204–214, 217–218NOR design, 204–214, 217–218number of gates for, 200–203two-level design, 206–209two-level, multiple-output design, 
214–217
Multiple-output circuits, 214–218
essential prime implicants for, 
216–217
multiple-output design, 217–218NAND design, 204–214, 217–218NOR design, 204–214, 217–218two-level, multiple-output, 
214–217
Multiplexers (MUX), 261–265, 
304–305
conditional assignment 
statements, 304–305
logic design of integrated 
circuits (IC), 261–265
switching functions for, 265VHDL models for, 304–305
Multiplying out and factoring, 
49–52, 66–68
distributive laws for, 66–68expressions, 66–68product of sums (POS), 50–51sum of products (SOP), 
49–50, 51
theorems for, 49
N
NAND circuit design, 204–214, 
217–218
conversion using alternative 
gate symbols, 210–214
functionally complete logic 
sets, 205
inverters for, 210–214
multi-level, 209–210multiple-output, 217–218single-level, 204two-level, 206–209
two-level, multiple-output, 
214–217
Negative number  representa  tion, 
16–21
1’s complement, 19–21sign and magnitude, 162’s complement, 16–19
Next state, 340
Next-state (characteristic) 
 equations, 340–341, 357–358, 673
Next-state maps, 340–341, 
389–391, 517–519, 523–528
counters from, 389–391
flip-flop input equations from, 
517–519
next-state equations for, 340–341state assignments from, 523–528
Non-return-to-zero (NRZ) code, 
473–474
Non-return-to-zero-inverted 
(NRZI) code, 473
NOR circuit design, 204–214, 
217–218
conversion using alternative 
gate symbols, 210–214
functionally complete logic 
sets, 205
inverters for, 210–214multi-level, 209–210multiple-output, 217–218single-level, 204two-level, 206–209two-level, multiple-output, 
214–217
Normally closed (NC) 
 contacts, 37
Normally open (NO) contacts, 37
Number systems, 1–28
ASCII code, 23
binary arithmetic, 12–15binary codes, 21–23conversion and, 1, 8–12digital systems, 6–8negative representation, 16–211’s complement, 19–21overflow, 16, 18sign and magnitude, 162’s complement, 16–19
O
One-hot state assignment, 
528–530
1’s complement numbers, 19–21
Open circuits, 42–43
Operators, VHDL, 315–316OR-AND circuits, 200
OR-AND-OR circuits, 200
OR circuit design, 39, 44, 
68–70, 200
Order of operation ( ), 300Output list, 662Overflow, 16, 18–21
P
Packages, VHDL, 316–318Parallel adder, 108–110, 378–380
accumulator with, 378–380
design of, 108–110
Parallel switch circuits, 42–43
Parentheses ( ) for Boolean 
expressions, 39
Parity bit, 416Parity checker, 419–421PC board layout, CAD for, 
571–572
Petrick’s method, 179–181Present state, 340Prime implicants, 144–149, 151, 
173–184, 216–217
charts, 176–191
defined, 176don’t-cares and, 147–148, 
181–182
essential, 146–148, 177–178, 
216–217
Karnaugh maps for, 
144–149, 151
minimum sum-of-products from, 
144–149
multiple-output circuit 
 realization and, 216–217
Petrick’s method, 179–181Quine-McCluskey method for, 
173–176, 181–184
Prime implicates, 149
process keyword, 590–591Product of sums (POS), 50–51, 
98, 136–137
direct realization of, 51
minimum, 136–137multiplying out and factoring, 
50–51
standard (maxterm), 98
Product terms plotted on 
 Karnaugh maps, 138–139
Programmable array logic 
devices (PAL), 260, 278–280
Programmable logic arrays (PLA), 
260, 275–278, 557–559
Programmable logic devices 
(PLD), 260, 275–281, 
557–559, 570
computer-aided design (CAD) 
for, 570
complex programmable logic 
devices (CPLD), 260, 280–281
programmable array logic 
devices (PAL), 260, 278–280
programmable logic arrays 
(PLA), 260, 275–278, 557–559
sequential circuit design using, 
557–559
790 Index
Programmable ROM (PROM), 
273, 274
Propagation delay, 232–233, 347
Q
Quine-McCluskey method, 
167–192
don’t care simplification using, 
181–182
Karnaugh maps for, 182–184
prime implicants determined 
from, 173–176
prime implicant charts, 176–179
R
Race condition, 343Races, asynchronous sequential 
circuits, 356–357
Radix, number systems, 9Read-only memory (ROM), 260, 
271–275, 314, 556–557
Redundant state elimination, 
505–507
Redundant terms, adding, 73Registers, 375–384, 594–596
counters as, 383–384
cyclic shift, 594–596data transfers, 377–378parallel adder with 
accumulator using, 378–380
sequential logic modeling, 
594–596
serial in and out data, 381–382shift, 380–384VHDL processes for, 594–596
Relational operators, 
VHDL, 315
Relays, 8
Resolution functions, 319Ring counter, 383–384RZ code, 473
S
Schematic capture, CAD, 570Self-starting counter, 392–393Sensitivity list, 590–593Sequence detectors, 457–463Sequential circuits, 7–8, 336–369, 
370–411, 412–452, 453–496, 497–544, 545–584
asynchronous, 354–357
clocked, 412–452code converter design, 549–552complex design using state 
graphs and tables, 463–467
complex programmable logic 
devices (CPLD) used for, 559–563
computer-aided design (CAD) 
and, 570–572counters, 375–376, 383–398
design of, 545–584equivalent, 512–514essential hazards, 355–365feedback connections and, 337field-programmable gate 
arrays (FPGA) used for, 563–565
flip-flops, 345, 346–354, 
375–402
glitches, 356iterative circuit design, 553–556latches, 338–345Mealy machine, 422–424, 
432–435
Moore machine, 421–424, 
435–436
next-state (characteristic) 
equations for, 340–341, 354–355
parity checker, 419–421procedure for design of, 
548–549
programmable logic array 
(PLA) used for, 557–559
races, 356–357read-only memory (ROM) 
used for, 556–557
reduction of state tables, 
497–544
registers, 375–384sequence detector design, 
457–463
simulation and testing of, 
565–570
state assignment, 497–544state graphs and tables, 
453–496
transition tables, 425–432
Sequential logic modeling, 
585–625
begin and end keywords, 
590–591
case statement, 600–601code synthesis, 608–611counters, 596–599flip-flops, 590–593if statements, 590–592Mealy state machine, 601–607Moore state machine, 607–608process keyword, 590–591registers, 594–596VHDL for, 585–625wait statements, 611–613
Serial adder, 629–633, 688–689
accumulator with, 629–633VHDL code for, 688–689
Serial data code conversion, 
473–476
Serial in and out data, 381–382
Set-reset (S-R) latches, 338–344
gated, 342–344next-state (characteristic) 
equation for, 340–341
switch debouncing, 341–342
Setup time, 347
Shannon’s theorem, 284–285Shift operators, VHDL, 316Shift-register counter, 384Shift registers, 380–384Sign and magnitude numbers, 16Signal tracing, 421–424Signals, 299–305, 311–312
after delay expressions, [ ], 
301–303
assignment statements, 
299–305
combinational circuits, 299–303
constants and, 311–312declaration of, 311–312delays, 301–303, 305multiplexers, 304–305predefined, 311–312VHDL, 299–305, 311–312
Simplification of functions, 
46–52, 66–68, 70–74, 
123–166, 167–192
adding redundant terms, 73
Boolean algebra for, 46–52, 
66–68, 70–74
combining terms, 72computer-aided design (CAD) 
packages for, 184–185
consensus theorem, 70–72eliminating literals, 73eliminating terms, 73heuristic procedures for, 
184–185
incompletely specified 
functions, 181–182
Karnaugh maps, 123–166map-entered variables, 182–184minimum product-of-sums, 
135–136
minimum sum-of-products, 
134–135, 144–149, 167–192
multiplying out and factoring, 
49–52, 66–68
Petrick’s method, 179–181Quine-McCluskey method, 
167–192
SimUaid, CAD, 571
Simulations, 240–242, 565–570
combinational logic circuits, 
240–242
computer-aided design 
(CAD), 570
sequential circuits, 565–570
Single switch circuit, 42Single throw switches, 342Sliding window sequence detec-
tors, 462–463
SM blocks, 663–664SM Charts, See State Machine 
Charts
Small-scale integration (SSI) 
circuits, 260
Spikes, timing charts, 424
S-R flip-flops, 349–350, 395–402Standard product of sums, 
98–100. See also Maxterm
Standard sum of products, 
98–100. See also Minterm
State assignment, 519–544, 673
distinct (nonequivalent), 
522–523
equivalent, 519–523
guidelines for, 523–528Karnaugh maps for, 524–528next-state maps for, 523–528one-hot, 528–530state machine (SM) 
charts), 673
State box, 662
State code, 662State equivalence, 507–512, 
727–728
State graphs and tables, 420–421, 
425–432, 453–496, 497–544
alphanumeric graph notation, 
476–478
complex sequential circuit 
design using, 463–467
construction of transition tables, 
425–426
derivation of, 453–496
equivalent sequential circuits, 
512–514
equivalent states in, 507–512flip-flop input equations for, 
517–519
graph construction, 467–472incompletely specified, 478–479, 
514–516
Mealy state graphs, 428–430Moore state graphs, 426–430next-state maps and, 517–519, 
523–528
parity checker design using, 
420–421
reduction of, 497–544redundant state elimination, 
505–507
sequence detector design using, 
457–463
serial data code conversion 
using, 473–476
state assignment, 519–544symbolic state 
 representation, 425
table construction, 425–426transition tables and, 425–432
State machine (SM) charts, 
660–683
binary divider use of, 667–668binary multiplier use of, 668
Index 791
components of, 662–667
conversion of state graph to, 
665–666
derivation of, 667–672dice game use of, 668–672, 
674–676
next-state equation for, 673realization of, 672–677state assignment for, 673
Static hazards, 234–237
String literals, " ", 314Structural code, 300Subtracter design, 110–111Sum of products (SOP), 49–50, 
51, 98–100, 134–135, 144–149, 273–278
combinational circuit hazards 
found using, 237–238
direct realization of, 51
Karnaugh maps for, 134–135, 
144–149
minimum, 134–135, 144–149multiplying out and factoring, 
49–51
prime implicants, 144–149standard (minterm), 98–100
Switch debouncing, 341–342
Switching algebra, 37 . See also 
Boolean algebra
Switching circuits, 7–8, 37–39, 
42–43, 94–96
basic theorems for, 42–43
Boolean operations for, 37–39closed, 43combinational, 7conversion of English to 
Boolean equations, 94–96
design of, 37–39, 42–43, 94–96normally closed (NC) 
contacts, 37
normally open (NO) 
contacts, 37
open, 43parallel, 42–43sequential, 7–8
Switching devices, 8, 36–37
Boolean algebra and, 36–37diodes, 8relays, 8transistors, 8
Switching elements, 272–274, 
275–277
programmable logic arrays 
(PLA) use of, 275–277
read-only memory (ROM) use 
of, 272–274
Switching expressions, 72–74. 
See also Boolean 
expressions
Switching functions, 97–104, 
123–166, 167–197 , 265, 283–285algebraic simplification of, 
97–103
decomposition of, 283–285
don’t care minterms, 103–104field-programmable gate 
arrays (FPGA) and, 283–285
Karnaugh maps for, 123–166minimum forms of, 134–136minterm and maxterm 
 expansions, 97–103
multiplexer implementation 
and, 265
Quine-McCluskey method for, 
167–192
Shannon’s theorem for, 284–285
Synchronizer, 569–570
Synthesis tools, CAD, 571
T
T flip-flops, 351–352Testing, 240–242, 565–571
combinational logic circuits, 
240–242
computer-aided design 
(CAD), 571
sequential circuits, 565–570
Three-state (tri-state) buffers, 
266–268, 318–319
Three-state (tri-state) bus, 
267–268, 377–378
Time delay, 321–322Timing diagrams, 232–233, 
421–424, 430–432
combinational circuits, 232–233
construction and interpretation 
of, 430–432
false outputs, 424propagation delay and, 232–233sequential circuits, 421–424, 
430–432
Timing parameters, flip-flops, 
347–348
Transients
in output, 234
Transistors, 8
Transition tables, 385–386, 425–432Transmission gate, 716Transparent latch, 344, 346Transport delay, 235Tree diagram gate 
 representation, 200–201
Truth tables, 40–41, 44–45, 96–97 , 
104–107 , 181–182
adder design and, 104–107
associative law proof using, 44Boolean expressions and, 
40–41
creation of, 104–107combinational logic design 
using, 96–97
DeMorgan’s law proof 
using, 45distributive law proof using, 45
don’t care’s in, 181–182numeric values for, 104–106
Twisted ring counter, 383–384
Two-level circuit design, 206–209Two-level, multiple-output 
circuit design, 214–217
2’s complement numbers, 16–19
U
Unconstrained VHDL types, 
313–314
Uniting theorems, 46–47 , 49, 136Up-down counter, 387–388Unwanted latches (VHDL), 609
V
Valid equations, proof of, 74–76Variables, 40, 72–73, 95–96, 
97–103, 182–184
adding redundant terms, 73
assignment of, 95–96combining terms, 72eliminating literals, 73eliminating terms, 73Karnaugh map use of, 182–184literals as, 40, 97map-entered, 182–184minterm and maxterm 
expansions, 97–103
Quine-McCluskey 
simplification and, 182–184
Veitch diagrams, 153
Very high-speed integrated 
circuit (VHSIC), 299
Very-large-scale integration 
(VLSI) circuits, 260
Verilog HDL, 298, 571VHDL, 8, 294–330, 585–625, 
684–712, 719–726
adders and, 307–311, 320–321
after delay expressions, 
301–303, 305
arrays, 312–314assignment statements for, 
299–305
begin and end keywords, 306, 
311, 590–591
binary divider using, 700–702binary multiplier using, 
690–700
bit values ‘ ’, 302clause repetitions, {} , 306–307
code compilation and 
 simulation, 321–322
code applications, 684–712code synthesis, 608–611, 
705–706
combinational circuits 
described by, 299–303combinational logic modeling 
using, 599–601
comments (--), 302
concatenation (&), 315concurrent assignment 
 statements, 300–303, 305
conditional assignment 
 statements, 304–305
constants, 311–312counters modeled using, 
596–599
delays, 301–303, 305, 321–322dice game using, 702–704digital system design using, 
684–712
flip-flops modeled using, 
590–593
hardware language uses, 8, 281, 
298–288
IEEE standard logic and, 
318–321
language, 719–723libraries, 316–318modeling process, 585–625modules, 306–311multiplexers, models for, 
304–305
operators, 315–316packages, 316–318predefined types, 311–312read-only memory (ROM) 
described by, 314
registers modeled using, 596sensitivity list, 590–593sequential logic modeling 
using, 585–625
sequential machines modeled 
using, 601–608
serial adders using, 688–689signals, 299–305, 311–312structural code, 300wait statements, 611–613writing synthesizable code, 
724–726
VHDL modules, 306–311
adders, 307–311architecture declaration, 
306–308
entity declaration, 306–308simulation of, 308–311
W
wait statements, 611–613when others clause, 601
X
Xilinx CoolRuner CPLDs, 559Xilinx Virtex/Spartan II 
FPGA, 563
XOR (exclusive-OR), 68XNOR (exclusive-NOR), 70

Fundamentals
of Logic Design

This page intentionally left blank 
Charles H. Roth, Jr.
University of Texas at Austin
Larry L. Kinney
University of Minnesota, Twin Cities
Fundamentals
of Logic Design
Australia • Brazil • Japan • Korea • Mexico • Singapore • Spain • United Kingdom • United States
Director, Global Engineering Program:
Chris Carson
Senior Developmental Editor:
Hilda Gowans
Editorial Assistant:
Jennifer Dismore
Marketing Services Coordinator:
Lauren Bestos
Director, Content and Media Production:
Barbara Fuller-Jacobsen
Content Project Manager:
Cliff Kallemeyn
Production Service:
RPK Editorial Services, Inc.
Copyeditor:
Fred Dahl
Proofreader:
Harlan James
Indexer:
Ron Prottsman
Compositor:
Integra
Senior Art Director:
Michelle Kunkler
Internal Designer:
Carmela Periera
Cover Designer:
Andrew Adams
Cover Image:
© Shutterstock/guattie `ro boffi
Senior First Print Buyer:Doug Wilke 
Printed in the United States of America
1 2 3 4 5 6 7 12 11 10 09 08Fundamentals of Logic Design, Sixth Edition 
Charles H. Roth, Jr. and Larry L. Kinney© 2010 and 2004 Cengage LearningALL RIGHTS RESERVED. No part of this work covered by the
copyright herein may be reproduced, transmitted, stored, or used inany form or by any means—graphic, electronic, or mechanical,including but not limited to photocopying, recording, scanning,digitizing, taping, Web distribution, information networks, informationstorage and retrieval systems, or in any other manner—except as maybe permitted by the license terms herein.
For product information and technology assistance, contact us at
Cengage Learning Customer & Sales Support, 1-800-354-9706 .
For permission to use material from this text or product,
submit all requests online at www.cengage.com/permissions .
Further permissions questions can be emailed to
permissionrequest@cengage.com .
Library of Congress Control Number: 2009920814
Student Edition with CD:
ISBN-13: 978-0-495-47169-1ISBN-10: 0-495-47169-0
Student Edition:
ISBN-13: 978-0-495-66804-6ISBN-10: 0-495-66804-4
Cengage Learning
200 First Stamford Place, Suite 400Stamford, CT 06902USA
Cengage Learning is a leading provider of customized learning
solutions with office locations around the globe, including Singapore,the United Kingdom, Australia, Mexico, Brazil, and Japan. Locate yourlocal office at: international.cengage.com/region .
Cengage Learning products are represented in Canada by Nelson Education Ltd.
For your course and learning solutions, visit 
www.cengage.com/engineering .
Purchase any of our products at your local college store or at ourpreferred online store www.ichapters.com .
Introduction 1 Number Systems and Conversion 1
2 Boolean Algebra 27
3 Boolean Algebra (Continued) 56
Applications of Boolean Algebra 4 Minterm and Maxterm Expansions 83
5 Karnaugh Maps 116
6 Quine-McCluskey Method 159Multi-Level Gate Circuits 
7 NAND and NOR Gates 184Combinational Circuit Design 
8 and Simulation Using Gates 215Multiplexers, Decoders, and Programmable 
9 Logic Devices 242
Brief Contents
10 Introduction to VHDL 280
11 Latches and Flip-Flops 317
12 Registers and Counters 348
13 Analysis of Clocked Sequential Circuits 388
14 Derivation of State Graphs and Tables 427
Reduction of State Tables 15 State Assignment 466
16 Sequential Circuit Design 511
17 VHDL for Sequential Logic 549
18 Circuits for Arithmetic Operations 591
19 State Machine Design with SM Charts 623
20 VHDL for Digital System Design 646
A Appendices 675vi Brief Contents
viiPreface xv
How to Use This Book for Self-Study xix
Unit 1 Introduction 
Number Systems and Conversion
Objectives 1
Study Guide 2
1.1 Digital Systems and Switching Circuits 61.2 Number Systems and Conversion 81.3 Binary Arithmetic 121.4 Representation of Negative Numbers 16
Addition of 2’s Complement Numbers 17Addition of 1’s Complement Numbers 19
1.5 Binary Codes 21
Problems 23
Unit 2 Boolean Algebra
Objectives 27Study Guide 28
2.1 Introduction 342.2 Basic Operations 352.3 Boolean Expressions and Truth Tables 372.4 Basic Theorems 392.5 Commutative, Associative, and Distributive Laws 402.6 Simplification Theorems 422.7 Multiplying Out and Factoring 44
Contents
2.8 DeMorgan’s Laws 47
Problems 48Laws and Theorems of Boolean Algebra 55
Unit 3 Boolean Algebra (Continued)
Objectives 56Study Guide 57
3.1 Multiplying Out and Factoring Expressions 623.2 Exclusive-OR and Equivalence Operations 643.3 The Consensus Theorem 663.4 Algebraic Simplification of Switching Expressions 683.5 Proving Validity of an Equation 70
Programmed Exercises 73Problems 78
Unit 4 Applications of Boolean Algebra 
Minterm and Maxterm Expansions
Objectives 83
Study Guide 84
4.1 Conversion of English Sentences to Boolean Equations 904.2 Combinational Logic Design Using a Truth Table 924.3 Minterm and Maxterm Expansions 934.4 General Minterm and Maxterm Expansions 964.5 Incompletely Specified Functions 994.6 Examples of Truth Table Construction 1004.7 Design of Binary Adders and Subtracters 104
Problems 107
Unit 5 Karnaugh Maps
Objectives 116Study Guide 117
5.1 Minimum Forms of Switching Functions 1275.2 Two- and Three-Variable Karnaugh Maps 1295.3 Four-Variable Karnaugh Maps 1335.4 Determination of Minimum Expressions 
Using Essential Prime Implicants 136
5.5 Five-Variable Karnaugh Maps 1415.6 Other Uses of Karnaugh Maps 144viii Contents
5.7 Other Forms of Karnaugh Maps 146
Programmed Exercises 147Problems 152
Unit 6 Quine-McCluskey Method
Objectives 159Study Guide 160
6.1 Determination of Prime Implicants 1656.2 The Prime Implicant Chart 1686.3 Petrick’s Method 1716.4 Simplification of Incompletely Specified Functions 1736.5 Simplification Using Map-Entered Variables 1746.6 Conclusion 176
Programmed Exercise 177Problems 181
Unit 7 Multi-Level Gate Circuits 
NAND and NOR Gates
Objectives 184
Study Guide 185
7.1 Multi-Level Gate Circuits 1907.2 NAND and NOR Gates 1957.3 Design of Two-Level NAND- and NOR- Gate Circuits 1977.4 Design of Multi-Level NAND- and NOR- Gate Circuits 2007.5 Circuit Conversion Using Alternative Gate Symbols 2017.6 Design of Two-Level, Multiple-Output Circuits 204
Determination of Essential Prime Implicants for 
Multiple-Output Realization 206
7.7 Multiple-Output NAND- and NOR-Gate Circuits 208
Problems 208
Unit 8 Combinational Circuit Design 
and Simulation Using Gates
Objectives 215
Study Guide 216
8.1 Review of Combinational Circuit Design 2198.2 Design of Circuits with Limited Gate Fan-In 2208.3 Gate Delays and Timing Diagrams 222Contents ix
8.4 Hazards in Combinational Logic 224
8.5 Simulation and Testing of Logic Circuits 229
Problems 232Design Problems 236
Unit 9 Multiplexers, Decoders, and Programmable 
Logic Devices
Objectives 242
Study Guide 243
9.1 Introduction 2509.2 Multiplexers 2519.3 Three-State Buffers 2539.4 Decoders and Encoders 2569.5 Read-Only Memories 2599.6 Programmable Logic Devices 263
Programmable Logic Arrays 263Programmable Array Logic 266
9.7 Complex Programmable Logic Devices 2689.8 Field-Programmable Gate Arrays 270
Decomposition of Switching Functions 271Problems 274
Unit 10 Introduction to VHDL
Objectives 280Study Guide 281
10.1 VHDL Description of Combinational Circuits 28510.2 VHDL Models for Multiplexers 29010.3 VHDL Modules 292
Four-Bit Full Adder 294
10.4 Signals and Constants 29710.5 Arrays 29810.6 VHDL Operators 30110.7 Packages and Libraries 30210.8 IEEE Standard Logic 30410.9 Compilation and Simulation of VHDL Code 307
Problems 308Design Problems 313xContents
Unit 11 Latches and Flip-Flops
Objectives 317
Study Guide 318
11.1 Introduction 32211.2 Set-Reset Latch 32311.3 Gated D Latch 32711.4 Edge-Triggered D Flip-Flop 32811.5 S-R Flip-Flop 33111.6 J-K Flip-Flop 33211.7 T Flip-Flop 33311.8 Flip-Flops with Additional Inputs 33411.9 Summary 336
Problems 337Programmed Exercise 345
Unit 12 Registers and Counters
Objectives 348Study Guide 349
12.1 Registers and Register Transfers 354
Parallel Adder with Accumulator 356
12.2 Shift Registers 35812.3 Design of Binary Counters 36212.4 Counters for Other Sequences 367
Counter Design Using D Flip-Flops 370
12.5 Counter Design Using S-R and 
J-K Flip-Flops 371
12.6 Derivation of Flip-Flop Input 
Equations—Summary 374
Problems 378
Unit 13 Analysis of Clocked Sequential Circuits
Objectives 388Study Guide 389
13.1 A Sequential Parity Checker 39513.2 Analysis by Signal Tracing and Timing Charts 39713.3 State Tables and Graphs 401
Construction and Interpretation of Timing Charts 406Contents xi
13.4 General Models for Sequential Circuits 408
Programmed Exercise 412Problems 416
Unit 14 Derivation of State Graphs and Tables
Objectives 427Study Guide 428
14.1 Design of a Sequence Detector 43114.2 More Complex Design Problems 43514.3 Guidelines for Construction of State Graphs 43914.4 Serial Data Code Conversion 44414.5 Alphanumeric State Graph Notation 448
Programmed Exercises 449Problems 456
Unit 15 Reduction of State Tables 
State Assignment
Objectives 466
Study Guide 467
15.1 Elimination of Redundant States 47415.2 Equivalent States 47615.3 Determination of State Equivalence Using 
an Implication Table 478
15.4 Equivalent Sequential Circuits 48115.5 Incompletely Specified State Tables 48315.6 Derivation of Flip-Flop Input Equations 48415.7 Equivalent State Assignments 48715.8 Guidelines for State Assignment 49015.9 Using a One-Hot State Assignment 495
Problems 498
Unit 16 Sequential Circuit Design
Objectives 511Study Guide 512
16.1 Summary of Design Procedure for Sequential Circuits 51416.2 Design Example—Code Converter 51516.3 Design of Iterative Circuits 519
Design of a Comparator 519xii Contents
16.4 Design of Sequential Circuits Using ROMs and PLAs 522
16.5 Sequential Circuit Design Using CPLDs 52516.6 Sequential Circuit Design Using FPGAs 52916.7 Simulation and Testing of Sequential Circuits 53116.8 Overview of Computer-Aided Design 536
Design Problems 538Additional Problems 544
Unit 17 VHDL for Sequential Logic
Objectives 549Study Guide 550
17.1 Modeling Flip-Flops Using VHDL Processes 55417.2 Modeling Registers and Counters Using VHDL 
Processes 558
17.3 Modeling Combinational Logic Using VHDL 
Processes 563
17.4 Modeling a Sequential Machine 56517.5 Synthesis of VHDL Code 57217.6 More About Processes and Sequential Statements 575
Problems 577Simulation Problems 588
Unit 18 Circuits for Arithmetic Operations
Objectives 591Study Guide 592
18.1 Serial Adder with Accumulator 59418.2 Design of a Parallel Multiplier 59818.3 Design of a Binary Divider 602
Programmed Exercises 607Problems 612
Unit 19 State Machine Design with SM Charts
Objectives 623Study Guide 624
19.1 State Machine Charts 62519.2 Derivation of SM Charts 63019.3 Realization of SM Charts 635
Problems 640Contents xiii
Unit 20 VHDL for Digital System Design
Objectives 646
Study Guide 647
20.1 VHDL Code for a Serial Adder 65020.2 VHDL Code for a Binary Multiplier 65220.3 VHDL Code for a Binary Divider 66220.4 VHDL Code for a Dice Game Simulator 66420.5 Concluding Remarks 667
Problems 668Lab Design Problems 671
A Appendices
A MOS and CMOS Logic 675B VHDL Language Summary 681C Tips for Writing Synthesizable VHDL Code 686D Proofs of Theorems 689E Answers to Selected Study Guide 
Questions and Problems 691
References 747
Index 748xiv Contents
Contents xv
After studying this text, you should be able to apply switching theory to the solution of
logic design problems.This means that you will learn both the basic theory of switchingcircuits and how to apply it. After a brief introduction, you will study Boolean algebra,which is the basic mathematical tool needed to analyze and synthesize an importantclass of switching circuits. Starting from a problem statement, you will learn to designcircuits of logic gates that have a specified relationship between signals at the input andoutput terminals. Then you will study the logical properties of flip-flops, which serve asmemory devices in sequential switching circuits. By combining flip-flops with circuits oflogic gates, you will learn to design counters, adders, sequence detectors, and similar cir-cuits. You will also study the VHDL hardware description language and its applicationto the design of combinational logic, sequential logic, and simple digital systems.
The fifth edition offers a number of improvements over the fourth edition.Material
in the text has been reorganized to provide a better teaching sequence, and obsoletematerial has been removed. The chapter on latches and flip-flops has been rewritten.Greater emphasis is placed on the use of programmable logic devices (PLDs), includ-ing programmable gate arrays and complex PLDs. New exercises and problems havebeen added to every unit, and several sections have been rewritten to clarify the pres-entation. Three chapters on the VHDL hardware description language have beenadded, and more emphasis is placed on the role of simulation and computer-aideddesign of logic circuits.
This text is designed so that it can be used in either a standard lecture course or
in a self-paced course. In addition to the standard reading material and problems,study guides and other aids for self-study are included in the text.The content of thetext is divided into 20 study units. These units form a logical sequence so that mas-tery of the material in one unit is generally a prerequisite to the study of succeedingunits. Each unit consists of four parts. First, a list of objectives states precisely whatyou are expected to learn by studying the unit. Next, the study guide contains read-ing assignments and study questions.As you work through the unit, you should writeout the answers to these study questions. The text material and problem set that fol-low are similar to a conventional textbook. When you complete a unit, you should
review the objectives and make sure that you have met them.
Preface
xv
The study units are divided into three main groups.The first 9 units treat Boolean
algebra and the design of combinational logic circuits. Units 11 through 16, 18 and 19are mainly concerned with the analysis and design of clocked sequential logic cir-cuits, including circuits for arithmetic operations. Units 10, 17, and 20 introduce theVHDL hardware description language and its application to logic design.
Since the computer plays an important role in the logic design process, integra-
tion of computer usage into the first logic design course is very important. A com-puter-aided logic design program, called LogicAid, is included on the CD provided
with this textbook. LogicAid allows the student easily to derive simplified logic equa-
tions from minterms, truth tables, and state tables. This relieves the student of someof the more tedious computations and permits the solution of more complex designproblems in a shorter time. LogicAid also provides tutorial help for Karnaugh maps
and derivation of state graphs.
Several of the units include simulation or laboratory exercises. These exercises
provide an opportunity to design a logic circuit and then test its operation. TheSimUaid logic simulator, provided on the CD, may be used to verify the logic
designs. The lab equipment required for testing either can be a breadboard withintegrated circuit flip-flops and logic gates or a circuit board with a programmablelogic device. If such equipment is not available, the lab exercises can be simulatedwith SimUaid or just assigned as design problems. This is especially important for
Units 8, 16, and 20 because the comprehensive design problems in these units helpto review and tie together the material in several of the preceding units.
As integrated circuit technology continues to improve to allow more components
on a chip, digital systems continue to grow in complexity. Design of such complex sys-tems is facilitated by the use of a hardware description language such as VHDL.Thistext introduces the use of VHDL in logic design and emphasizes the relationshipbetween VHDL statements and the corresponding digital hardware. VHDL allowsdigital hardware to be described and simulated at a higher level before it is imple-mented with logic components. Computer programs for synthesis can convert aVHDL description of a digital system to a corresponding set of logic componentsand their interconnections. Even though use of such computer-aided design toolshelps to automate the logic design process, we believe that it is important to under-stand the underlying logic components and their timing before writing VHDL code.By first implementing the digital logic manually, students more fully can appreciatethe power and limitations of VHDL.
This text is written for a first course in the logic design of digital systems. It is writ-
ten on the premise that the student should understand and learn thoroughly certainfundamental concepts in a first course. Examples of such fundamental concepts arethe use of Boolean algebra to describe the signals and interconnections in a logic cir-cuit, use of systematic techniques for simplification of a logic circuit, interconnection
of simple components to perform a more complex logic function, analysis of a
sequential logic circuit in terms of timing charts or state graphs, and use of a controlcircuit to control the sequence of events in a digital system.
The text attempts to achieve a balance between theory and application. For this
reason, the text does not overemphasize the mathematics of switching theory; how-ever, it does present the theory that is necessary for understanding the fundamentalxvi Preface
concepts of logic design. After completing this text, the student should be prepared
for a more advanced digital systems design course that stresses more intuitive con-cepts like the development of algorithms for digital processes, partitioning of digitalsystems into subsystems, and implementation of digital systems using currently avail-
able hardware. Alternatively, the student should be prepared to go on to a more
advanced course in switching theory that further develops the theoretical conceptsthat have been introduced here.
Although the technology used to implement digital systems has changed signifi-
cantly since the first edition of this text was published, the fundamental principlesof logic design have not. Truth tables and state tables still are used to specify thebehavior of logic circuits, and Boolean algebra is still a basic mathematical tool forlogic design. Even when programmable logic devices are used instead of individualgates and flip-flops, reduction of logic equations is still desirable in order to fit theequations into smaller PLDs. Making a good state assignment is still desirable,because without a good assignment, the logic equations may require larger PLDs.
The text is suitable for both computer science and engineering students. Material
relating to circuit aspects of logic gates is contained in Appendix A so that thismaterial can conveniently be omitted by computer science students or other studentswith no background in electronic circuits. The text is organized so that Unit 6 on theQuine-McCluskey procedure may be omitted without loss of continuity. The threeunits on VHDL can be studied in the normal sequence, studied together after theother units, or omitted entirely.
Although many texts are available in the areas of switching theory and logic
design, this text was originally developed to meet the needs of a self-paced course inwhich students are expected to study the material on their own. Each of the units hasundergone extensive class testing in a self-paced environment and has been revisedbased on student feedback.
Study guides and text material have been expanded as required so that students
can learn from the text without the aid of lectures and so that almost all of the studentscan achieve mastery of all of the objectives. Supplementary materials were developedas the text was being written. An instructor’s manual is available that includes sugges-tions for using the text in a standard or self-paced course, quizzes on each of the units,and suggestions for laboratory equipment and procedures. The instructor’s manualalso contains solutions to problems, to unit quizzes, and to lab exercises.
To be effective, a book designed for self-study cannot simply be written. It must
be tested and revised many times to achieve its goals. I wish to express my apprecia-tion to the many professors, proctors, and students who participated in this process.Special thanks go to Dr. David Brown, who worked with me in teaching the self-paced course, and who made many helpful suggestions for improving the text. I amespecially grateful to graduate teaching assistant, Mark Story, who developed many
new problems and solutions for the fifth edition and who offered many suggestions
for improving the consistency and clarity of the presentation.
Charles H. Roth, Jr.Preface xvii
The major change in the sixth edition of the text is the addition of over 150 new prob-
lems and the modification of several of the fifth edition problems. Substantial new dis-cussion was added to the units on VHDL. Other topics receiving expanded discussionare hazards, latches and one-hot state assignments. In addition, the logic design andsimulation software  that accompanies the text has been updated and improved.
Larry L. Kinney Charles H. Roth, Jr.
Preface to the Sixth
Edition
xviii
If you wish to learn all of the material in this text to mastery level, the following
study procedures are recommended for each unit:
1.Read the Objectives of the unit. These objectives provide a concise summary of
what you should be able to do when you complete study of the unit.
2.Work through the Study Guide. After reading each section of the text, write out the
answers to the corresponding study guide questions.In many cases,blank spaces areleft in the study guide so that you can write your answers directly in this book. Bydoing this, you will have the answers conveniently available for later review. Thestudy guide questions generally will help emphasize some of the important pointsin each section or will guide you to a better understanding of some of the more dif-ficult points. If you cannot answer some of the study guide questions, this indicatesthat you need to study the corresponding section in the text more before proceed-ing.The answers to selected study guide questions are given in the back of this book;answers to the remaining questions generally can be found within the text.
3.Several of the units (Units 3, 5, 6, 11, 13, 14, and 18) contain one or more pro-
grammed exercises. Each programmed exercise will guide you step-by-stepthrough the solution of one of the more difficult types of problems encounteredin this text. When working through a programmed exercise, be sure to writedown your answer for each part in the space provided before looking at the an-swer and continuing with the next part of the exercise.
4.Work the assigned Problems at the end of the unit. Check your answers against
those at the end of the book and rework any problems that you missed.
5.Reread the Objectives of the unit to make sure that you can meet all of them. If
in doubt, review the appropriate sections of the text.
6.If you are using this text in a self-paced course, you will need to pass a readiness
test on each unit before proceeding with the next unit. The purpose of the readi-ness test is to make sure that you have mastered the objectives of one unit beforemoving on to the next unit.The questions on the test will relate directly to the ob-jectives of the unit, so that if you have worked through the study guide and writ-ten out answers to all of the study guide questions and to the problems assigned inthe study guide, you should have no difficulty passing the test.
How to Use This Book 
for Self-Study
xix
This page intentionally left blank 
Fundamentals
of Logic Design

Introduction 
Number Systems and Conversion
UNIT
1
Objectives
1.Introduction
The first part of this unit introduces the material to be studied later. Inaddition to getting an overview of the material in the first part of thecourse, you should be able to explain
a.The difference between analog and digital systems and why digital
systems are capable of greater accuracy
b.The difference between combinational and sequential circuits
c.Why two-valued signals and binary numbers are commonly used in
digital systems
2.Number systems and conversion
When you complete this unit, you should be able to solve the followingtypes of problems:
a.Given a positive integer, fraction, or mixed number in any base 
(2 through 16); convert to any other base. Justify the procedure usedby using a power series expansion for the number.
b.Add, subtract, multiply, and divide positive binary numbers. Explain
the addition and subtraction process in terms of carries and borrows.
c.Write negative binary numbers in sign and magnitude, 1’s comple-
ment, and 2’s complement forms. Add signed binary numbers using1’s complement and 2’s complement arithmetic. Justify the methodsused. State when an overflow occurs.
d.Represent a decimal number in binary-coded-decimal (BCD), 6-3-1-1
code, excess-3 code, etc. Given a set of weights, construct aweighted code.
1
1.Study Section 1.1, Digital Systems and Switching Circuits, and answer the fol-
lowing study questions:
(a) What is the basic difference between analog and digital systems?
(b) Why are digital systems capable of greater accuracy than analog systems?
(c) Explain the difference between combinational and sequential switching
circuits.
(d) What common characteristic do most switching devices used in digital
systems have?
(e) Why are binary numbers used in digital systems?
2.Study Section 1.2, Number Systems and Conversion. Answer the following study
questions as you go along:
(a) Is the first remainder obtained in the division method for base conversion
the most or least significant digit?
(b) Work through all of the examples in the text as you encounter them and
make sure that you understand all of the steps.
(c) An easy method for conversion between binary and hexadecimal is illus-
trated in Equation (1-1). Why should you start forming the groups of fourbits at the binary point instead of the left end of the number?
(d) Why is it impossible to convert a decimal number to binary on a digit-by-
digit basis as can be done for hexadecimal?2Unit 1
Study Guide
(e) Complete the following conversion table.
Binary Octal Decimal Hexadecimal
(base 2) (base 8) (base 10) (base 16)
00 0 0
1
10
11
100101
110
111
100010011010
1011
110011011110
1111
10000 20 16 10
(f) Work Problems 1.1, 1.2, 1.3, and 1.4.
3.Study Section 1.3, Binary Arithmetic.
(a) Make sure that you can follow all of the examples, especially the propaga-
tion of borrows in the subtraction process.
(b) To make sure that you understand the borrowing process, work out a
detailed analysis in terms of powers of 2 for the following example:
1100
/H11002101
111
4.Work Problems 1.5, 1.6, and 1.17(a).
5.Study Section 1.4, Representation of Negative Numbers.
(a) In digital systems, why are 1’s complement and 2’s complement commonly
used to represent negative numbers instead of sign and magnitude?Number Systems and Conversion 3
(b) State two different ways of forming the 1’s complement of an n-bit binary
number.
(c) State three different ways of forming the 2’s complement of an n-bit
binary number.
(d) If the word length is n/H110054 bits (including sign), what decimal number does
10002represent in sign and magnitude?
In 2’s complement?In 1’s complement?
(e) Given a negative number represented in 2’s complement, how do you
find its magnitude?
Given a negative number represented in 1’s complement, how do you
find its magnitude?
(f) If the word length is 6 bits (including sign), what decimal number does
100000
2represent in sign and magnitude?
In 2’s complement?In 1’s complement?
(g) What is meant by an overflow? How can you tell that an overflow has
occurred when performing 1’s or 2’s complement addition?
Does a carry out of the last bit position indicate that an overflow has
occurred?4Unit 1
(h) Work out some examples of 1’s and 2’s complement addition for various
combinations of positive and negative numbers.
(i) What is the justification for using the end-around carry in 1’s complement
addition?
(j) The one thing that causes the most trouble with 2’s complement numbers
is the special case of the negative number which consists of a 1 followed byall 0’s (1000 . . . 000). If this number is nbits long, what number does it rep-
resent and why? (It is not negative zero.)
(k) Work Problems 1.7 and 1.8.
6.Study Section 1.5, Binary Codes.
(a) Represent 187 in BCD code, excess-3 code, 6-3-1-1 code, and 2-out-of-5 code.
(b) Verify that the 6-3-1-1 code is a weighted code. Note that for some decimal
digits, two different code combinations could have been used. For example,either 0101 or 0110 could represent 4. In each case the combination withthe  smaller binary value has been used.
(c) How is the excess-3 code obtained?
(d) How are the ASCII codes for the decimal digits obtained? What is the rela-
tion between the ASCII codes for the capital letters and lowercase letters?
(e) Work Problem 1.9.
7.If you are taking this course on a self-paced basis, you will need to pass a readi-
ness test on this unit before going on to the next unit. The purpose of the readi-ness test is to determine if you have mastered the material in this unit and areready to go on to the next unit. Before you take the readiness test:
(a) Check your answers to the problems against those provided at the end of
this book. If you missed any of the problems, make sure that you under-stand why your answer is wrong and correct your solution.
(b) Make sure that you can meet all of the objectives listed at the beginning
of this unit.Number Systems and Conversion 5
Introduction 
Number Systems and Conversion
61.1 Digital Systems and Switching Circuits
Digital systems are used extensively in computation and data processing, control
systems, communications, and measurement. Because digital systems are capable ofgreater accuracy and reliability than analog systems, many tasks formerly done byanalog systems are now being performed digitally.
In a digital system, the physical quantities or signals can assume only discrete
values, while in analog systems the physical quantities or signals may vary con-tinuously over a specified range. For example, the output voltage of a digital sys-tem might be constrained to take on only two values such as 0 volts and 5 volts,while the output voltage from an analog system might be allowed to assume anyvalue in the range /H1100210 volts to /H1100110 volts.
Because digital systems work with discrete quantities, in many cases they can be
designed so that for a given input, the output is exactly correct. For example, if wemultiply two 5-digit numbers using a digital multiplier, the 10-digit product will becorrect in all 10 digits. On the other hand, the output of an analog multiplier mighthave an error ranging from a fraction of one percent to a few percent dependingon the accuracy of the components used in construction of the multiplier.Furthermore, if we need a product which is correct to 20 digits rather than 10, wecan redesign the digital multiplier to process more digits and add more digits to itsinput. A similar improvement in the accuracy of an analog multiplier would not bepossible because of limitations on the accuracy of the components.
The design of digital systems may be divided roughly into three parts—system
design, logic design, and circuit design. System design involves breaking the over-all system into subsystems and specifying the characteristics of each subsystem. For
example, the system design of a digital computer could involve specifying the num-ber and type of memory units, arithmetic units, and input-output devices as wellas the interconnection and control of these subsystems. Logic design involvesdetermining how to interconnect basic logic building blocks to perform a specificfunction. An example of logic design is determining the interconnection of logicgates and flip-flops required to perform binary addition. Circuit design involvesspecifying the interconnection of specific components such as resistors, diodes, and
transistors to form a gate, flip-flop, or other logic building block. Most contempo-
rary circuit design is done in integrated circuit form using appropriate computer-aided design tools to lay out and interconnect the components on a chip of silicon.This book is largely devoted to a study of logic design and the theory necessary forunderstanding the logic design process. Some aspects of system design are treatedin Units 18 and 20. Circuit design of logic gates is discussed briefly in Appendix A.
Many of a digital system’s subsystems take the form of a switching circuit
(Figure 1-1). A switching circuit has one or more inputs and one or more outputswhich take on discrete values. In this text, we will study two types of switchingcircuits—combinational and sequential. In a combinational circuit, the output val-ues depend only on the present value of the inputs and not on past values. In asequential circuit, the outputs depend on both the present and past input values. Inother words, in order to determine the output of a sequential circuit, a sequence ofinput values must be specified. The sequential circuit is said to have memorybecause it must “remember” something about the past sequence of inputs, while acombinational circuit has no memory. In general, a sequential circuit is composed ofa combinational circuit with added memory elements. Combinational circuits areeasier to design than sequential circuits and will be studied first.Number Systems and Conversion 7
Switching
CircuitInputs Outputs
...Z1
Z2...ZnX1
X2
XmFIGURE 1-1
Switching Circuit
The basic building blocks used to construct combinational circuits are logic gates.
The logic designer must determine how to interconnect these gates in order to convertthe circuit input signals into the desired output signals. The relationship between theseinput and output signals can be described mathematically using Boolean algebra. Units2 and 3 of this text introduce the basic laws and theorems of Boolean algebra and showhow they can be used to describe the behavior of circuits of logic gates.
Starting from a given problem statement, the first step in designing a combina-
tional logic circuit is to derive a table or the algebraic logic equations which describethe circuit outputs as a function of the circuit inputs (Unit 4). In order to designan economical circuit to realize these output functions, the logic equationswhich describe the circuit outputs generally must be simplified. Algebraic methodsfor this simplification are described in Unit 3, and other simplification methods(Karnaugh map and Quine-McCluskey procedure) are introduced in Units 5 and 6.Implementation of the simplified logic equations using several types of gates isdescribed in Unit 7, and alternative design procedures using programmable logicdevices are developed in Unit 9.
The basic memory elements used in the design of sequential circuits are called
flip-flops (Unit 11).These flip-flops can be interconnected with gates to form coun-ters and registers (Unit 12). Analysis of more general sequential circuits using
timing diagrams, state tables, and graphs is presented in Unit 13. The first step in
designing a sequential switching circuit is to construct a state table or graph whichdescribes the relationship between the input and output sequences (Unit 14).Methods for going from a state table or graph to a circuit of gates and flip-flops aredeveloped in Unit 15. Methods of implementing sequential circuits using program-mable logic are discussed in Unit 16. In Unit 18, combinational and sequentialdesign techniques are applied to the realization of systems for performing binaryaddition, multiplication, and division. The sequential circuits designed in this textare called synchronous sequential circuits because they use a common timing sig-nal, called a clock, to synchronize the operation of the memory elements.
Use of a hardware description language, VHDL, in the design of combinational
logic, sequential logic, and digital systems is introduced in Units 10, 17, and 20.VHDL is used to describe, simulate, and synthesize digital hardware. After writingVHDL code, the designer can use computer-aided design software to compile thehardware description and complete the design of the digital logic. This allows thecompletion of complex designs without having to manually work out detailed circuitdescriptions in terms of gates and flip-flops.
The switching devices used in digital systems are generally two-state devices,
that is, the output can assume only two different discrete values. Examples ofswitching devices are relays, diodes, and transistors. A relay can assume twostates—closed or open—depending on whether power is applied to the coil or not.A diode can be in a conducting state or a nonconducting state. A transistor can bein a cut-off or saturated state with a corresponding high or low output voltage. Ofcourse, transistors can also be operated as linear amplifiers with a continuousrange of output voltages, but in digital applications greater reliability is obtainedby operating them as two-state devices. Because the outputs of most switchingdevices assume only two different values, it is natural to use binary numbersinternally in digital systems. For this reason binary numbers and number systemswill be discussed first before proceeding to the design of switching circuits.
1.2 Number Systems and Conversion
When we write decimal (base 10) numbers, we use a positional notation; each digitis multiplied by an appropriate power of 10 depending on its position in the num-ber. For example,
953.78
10/H110059/H11003102/H110015/H11003101/H110013/H11003100/H110017/H1100310/H110021/H110018/H1100310/H110022
Similarly, for binary (base 2) numbers, each binary digit is multiplied by the appro-
priate power of 2:
1011.112/H110051/H1100323/H110010/H1100322/H110011/H1100321/H110011/H1100320/H110011/H110032/H110021/H110011/H110032/H110022
/H110058/H110010/H110012/H110011/H11001/H11001  /H11005 11/H1100511.75103
41
41
28Unit 1
Note that the binary point separates the positive and negative powers of 2 just as
the decimal point separates the positive and negative powers of 10 for decimalnumbers.
Any positive integer R(R/H110221) can be chosen as the radix orbase of a number sys-
tem. If the base is R,then Rdigits (0, 1, . . . , R/H110021) are used. For example, if R/H110058, then
the required digits are 0, 1, 2, 3, 4, 5, 6, and 7. A number written in positional nota-tion can be expanded in a power series in R.For example,
N/H11005(a
4a3a2a1a0.a/H110021a/H110022a/H110023)R
/H11005a4/H11003R4/H11001a3/H11003R3/H11001a2/H11003R2/H11001a1/H11003R1/H11001a0/H11003R0
/H11001a/H110021/H11003R/H110021/H11001a/H110022/H11003R/H110022/H11001a/H110023/H11003R/H110023
where aiis the coefficient of Riand 0 /H11349ai/H11349R/H110021. If the arithmetic indicated in the
power series expansion is done in base 10, then the result is the decimal equivalentofN.For example,
147.3
8/H110051/H1100382/H110014/H1100381/H110017/H1100380/H110013/H110038/H110021/H1100564/H1100132/H110017/H11001
/H11005103.37510
The power series expansion can be used to convert to any base. For example,
converting 14710to base 3 would be written as
14710/H110051/H11003(101)2/H11001(11) /H11003(101)1/H11001(21) /H11003(101)0
where all the numbers on the right-hand side are base 3 numbers. ( Note: In
base 3, 10 is 101, 7 is 21, etc.) To complete the conversion, base 3 arithmeticwould be used. Of course, this is not very convenient if the arithmetic is beingdone by hand. Similarly, if 147
10is being converted to binary, the calculation
would be
14710/H110051/H11003(1010)2/H11001(100) /H11003(1010)1/H11001(111) /H11003(1010)0
Again this is not convenient for hand calculation but it could be done easily in a
computer where the arithmetic is done in binary. For hand calculation, use thepower series expansion when converting from some base into base 10 .
For bases greater than 10, more than 10 symbols are needed to represent the
digits. In this case, letters are usually used to represent digits greater than 9. Forexample, in hexadecimal (base 16), Arepresents 10
10,Brepresents 1110,Crepre-
sents 1210,Drepresents 1310,Erepresents 1410, and Frepresents 1510. Thus,
A2F16/H1100510/H11003162/H110012/H11003161/H1100115/H11003160/H110052560 /H1100132/H1100115/H11005260710
Next, we will discuss conversion of a decimal integer to base Rusing the division
method. The base Requivalent of a decimal integer Ncan be represented as
N/H11005(anan/H110021···  a2a1a0)R/H11005anRn/H11001an/H110021Rn/H110021/H11001 · · · /H11001a2R2/H11001a1R1/H11001a0Number Systems and Conversion 9
If we divide NbyR,the remainder is a0:
/H11005anRn/H110021/H11001an/H110021Rn/H110022/H11001· · · /H11001a2R1/H11001a1/H11005Q1, remainder a0
Then we divide the quotient Q1byR:
/H11005anRn/H110022/H11001an/H110021Rn/H110023/H11001· · · /H11001a3R1/H11001a2/H11005Q2, remainder a1
Next we divide Q2byR:
/H11005anRn/H110023/H11001an/H110021Rn/H110024/H11001· · · /H11001a3/H11005Q3, remainder a2
This process is continued until we finally obtain an. Note that the remainder
obtained at each division step is one of the desired digits and the least significantdigit is obtained first.
Convert 53
10to binary.
Example
2
2 rem. /H110051/H11005a0
2 rem. /H110050/H11005a1
2 rem. /H110051/H11005a25310/H110051101012
2 rem. /H110050/H11005a3
2 rem. /H110051/H11005a4
0 rem. /H110051/H11005a5
Conversion of a decimal fraction to base Rcan be done using successive multi-
plications byR.A decimal fraction Fcan be represented as
F/H11005(.a/H110021a/H110022a/H110023· · · a/H11002m)R/H11005a/H110021R/H110021/H11001a/H110022R/H110022/H11001a/H110023R/H110023/H11001· · · /H11001a/H11002mR/H11002m
Multiplying by Ryields
FR/H11005a/H110021/H11001a/H110022R/H110021/H11001a/H110023R/H110022/H11001· · · /H11001a/H11002mR/H11002m/H110011/H11005a/H110021/H11001F1
where F1represents the fractional part of the result and a/H110021is the integer part.
Multiplying F1byRyields
F1R/H11005a/H110022/H11001a/H110023R/H110021/H11001· · · /H11001a/H11002mR/H11002m/H110012/H11005a/H110022/H11001F2/H208621/H208623/H208626/H2086213/H2086226/H2086253Q2
RQ1
RN
R10 Unit 1
Next, we multiply F2byR:
F2R/H11005a/H110023/H11001· · · /H11001a/H11002mR/H11002m/H110013/H11005a/H110023/H11001F3
This process is continued until we have obtained a sufficient number of digits. Note
that the integer part obtained at each step is one of the desired digits and the mostsignificant digit is obtained first.
Convert 0.625
10to binary.
Example
F/H11005.625 F1/H11005.250 F2/H11005.500
/H11003 2 /H11003 2 /H11003 2 .62510/H11005.1012
1.250 0.500 1.000
(a/H110021/H110051) ( a/H110022/H110050) ( a/H110023/H110051)
This process does not always terminate, but if it does not terminate, the result is
a repeating fraction.
Convert 0.710to binary.
Example
.7
2
(1).4
2
(0).8
2
(1).6
2
(1).2
2
(0).4 ←⎯ process starts repeating here because 0.4 was previously
2 obtained
(0).8 0.710/H110050.1 0110 0110 0110 . . .2
Conversion between two bases other than decimal can be done directly by using
the procedures given; however, the arithmetic operations would have to be carriedout using a base other than 10. It is generally easier to convert to decimal first andthen convert the decimal number to the new base.Number Systems and Conversion 11
Convert 231.34to base 7.
Example
231.34/H110052/H1100316/H110013/H110034/H110011/H11001/H11005 45.7510
7 .75
7 rem. 3 7
0 rem. 6 (5) .25 45.7510/H1100563.5151 . . .7
7
(1) .75
7
(5) .25
7
(1) .75
Conversion from binary to hexadecimal (and conversely) can be done by inspection
because each hexadecimal digit corresponds to exactly four binary digits (bits).Starting at the binary point, the bits are divided into groups of four, and each groupis replaced by a hexadecimal digit:
1001101.010111
2/H11005 0100 1101 0101 1100/H110054D.5C16 (1-1)4 D 5 C
As shown in Equation (1-1), extra 0’s are added at each end of the bit string as
needed to fill out the groups of four bits.
1.3 Binary Arithmetic
Arithmetic operations in digital systems are usually done in binary because designof logic circuits to perform binary arithmetic is much easier than for decimal. Binaryarithmetic is carried out in much the same manner as decimal, except the additionand multiplication tables are much simpler.
The addition table for binary numbers is
0/H110010/H110050
0/H110011/H110051
1/H110010/H110051
1/H110011/H110050 and carry 1 to the next column
Carrying 1 to a column is equivalent to adding 1 to that column./H20862  6/H20862453
412 Unit 1
¯ ¯¯ ¯ ¯ ¯ ¯ ¯·
Add 1310and 1110in binary.
Example
1111 ←⎯ carries
1310/H110051101
1110/H110051011
11000 /H110052410
The subtraction table for binary numbers is
0/H110020/H110050
0/H110021/H110051 and borrow 1 from the next column
1/H110020/H110051
1/H110021/H110050
Borrowing 1 from a column is equivalent to subtracting 1 from that column.
(a) 1←⎯ (indicates (b) 1111 ←⎯ borrows (c) 111←⎯ borrows
11101 a borrrow 10000 111001
/H1100210011 from the /H11002      11 /H11002    1011
1010 3rd column) 1101 101110
Note how the borrow propagates from column to column in the second exam-
ple. In order to borrow 1 from the second column, we must in turn borrow 1 fromthe third column, etc. An alternative to binary subtraction is the use of 2’s comple-ment arithmetic, as discussed in Section 1.4.
Binary subtraction sometimes causes confusion, perhaps because we are so used
to doing decimal subtraction that we forget the significance of the borrowingprocess. Before doing a detailed analysis of binary subtraction, we will review theborrowing process for decimal subtraction.
If we number the columns (digits) of a decimal integer from right to
left (starting with 0), and then we borrow 1 from column n,what we mean is that
we subtract 1 from column nand add 10 to column n/H110021. Because 1 /H1100310
n/H11005
10/H1100310n/H110021, the value of the decimal number is unchanged, but we can proceed
with the subtraction. Consider, for example, the following decimal subtractionproblem:
column 2 column 1
205
/H11002  18
187Number Systems and Conversion 13
←←⎯Examples
of Binary
Subtraction
A detailed analysis of the borrowing process for this example, indicating first a bor-
row of 1 from column 1 and then a borrow of 1 from column 2, is as follows:
205/H1100218/H11005[2/H11003102/H110010/H11003101/H110015/H11003100]
/H11002[1 /H11003101/H110018/H11003100]
note borrow from column 1
/H11005[2/H11003102/H11001(0/H110021)/H11003101/H11001(10/H110015)/H11003100]
/H11002[1 /H11003101/H11001 8/H11003100]
note borrow from column 2
/H11005[(2/H110021)/H11003102/H11001(10/H110010/H110021)/H11003101/H1100115/H11003100]
/H11002[1 /H11003101/H11001 8/H11003100]
/H11005[1/H11003102/H110018/H11003101/H11001 7/H11003100]/H11005187
The analysis of borrowing for binary subtraction is exactly the same, except that we
work with powers of 2 instead of powers of 10. Thus for a binary number, borrowing 1from column nis equivalent to subtracting 1 from column nand adding 2 (10
2) to col-
umn n/H110021. The value of the binary number is unchanged because 1 /H110032n/H110052/H110032n/H110021.
A detailed analysis of binary subtraction example (c) follows. Starting with the
rightmost column, 1 /H110021/H110050. To subtract in the second column, we must borrow
from the third column. Rather than borrow immediately, we place a 1 over the thirdcolumn to indicate that a borrow is necessary, and we will actually do the borrowingwhen we get to the third column. (This is similar to the way borrow signals mightpropagate in a computer.) Now because we have borrowed 1, the second columnbecomes 10, and 10 /H110021/H110051. In order to borrow 1 from the third column, we must
borrow 1 from the fourth column (indicated by placing a 1 over column 4). Column3 then becomes 10, subtracting off the borrow yields 1, and 1 /H110020/H110051. Now in col-
umn 4, we subtract off the borrow leaving 0. In order to complete the subtraction,we must borrow from column 5, which gives 10 in column 4, and 10 /H110021/H110051.
The multiplication table for binary numbers is
0/H110030/H110050
0/H110031/H110050
1/H110030/H110050
1/H110031/H110051
The following example illustrates multiplication of 13
10by 1110in binary:
1101
1011
1101
1101
0000
1101
10001111 /H110051431014 Unit 1
↓
↓ ↓↓
Note that each partial product is either the multiplicand (1101) shifted over the
appropriate number of places or is zero.
When adding up long columns of binary numbers, the sum of the bits in a sin-
gle column can exceed 112, and therefore the carry to the next column can be
greater than 1. For example, if a single column of bits contains five 1’s, thenadding up the 1’s gives 101
2, which means that the sum bit for that column is 1,
and the carry to the next column is 102. When doing binary multiplication, a com-
mon way to avoid carries greater than 1 is to add in the partial products one at atime as illustrated by the following example:
1111 multiplicand
1101 multiplier1111 first partial product
0000 second partial product
(01111) sum of first two partial products
1111 third partial product
(1001011) sum after adding third partial product
1111 fourth partial product
11000011 final product (sum after adding fourth partial product)
The following example illustrates division of 145
10by 1110in binary:
1101
1011 10010001
1011
1110
1011
1101 The quotient is 1101 with a remainder 
1011 of 10.
10
Binary division is similar to decimal division, except it is much easier because the
only two possible quotient digits are 0 and 1. In the above example, if we start bycomparing the divisor (1011) with the upper four bits of the dividend (1001), wefind that we cannot subtract without a negative result, so we move the divisorone place to the right and try again. This time we can subtract 1011 from 10010to give 111 as a result, so we put the first quotient bit of 1 above 10010. We thenbring down the next dividend bit (0) to get 1110 and shift the divisor right. Wethen subtract 1011 from 1110 to get 11, so the second quotient bit is 1. When webring down the next dividend bit, the result is 110, and we cannot subtract theshifted divisor, so the third quotient bit is 0. We then bring down the last divi-dend bit and subtract 1011 from 1101 to get a final remainder of 10, and the lastquotient bit is 1.Number Systems and Conversion 15
1.4 Representation of Negative Numbers
Up to this point we have been working with unsigned positive numbers. In most
computers, in order to represent both positive and negative numbers the first bit ina word is used as a sign bit, with 0 used for plus and 1 used for minus. Several rep-resentations of negative binary numbers are possible. The sign and magnitude sys-
tem is similar to that which people commonly use. For an n-bit word, the first bit is
the sign and the remaining n/H110021 bits represent the magnitude of the number. Thus
ann-bit word can represent any one of 2
n/H110021positive integers or 2n/H110021negative inte-
gers. Table 1-1 illustrates this for n/H110054. For example, 0011 represents /H110013 and 1011
represents /H110023. Note that 1000 represents minus zero in the sign and magnitude sys-
tem and /H110028 in the 2’s complement system.
The design of logic circuits to do arithmetic with sign and magnitude binary
numbers is awkward; therefore, other representations are often used. The 2’s com-plement and 1’s complement are commonly used because arithmetic units are easyto design using these systems. For the 2’s complement number system, a positivenumber, N,is represented by a 0 followed by the magnitude as in the sign and mag-
nitude system; however, a negative number, /H11002N,is represented by its 2’s comple-
ment, N*. If the word length is nbits, the 2’s complement of a positive integer Nis
defined as for a word length of nbits.
N*/H110052
n/H11002N (1-2)
For n/H110054,/H11002Nis represented by 16 /H11002Nas shown in Table 1-1. For example, /H110023 is
represented by 16 /H110023/H1100513/H1100511012.As is the case for sign and magnitude numbers,
all negative 2’s complement numbers have a 1 in the position furthest to the left(sign bit).
For the 1’s complement system a negative number, /H11002N,is represented by its 1’s
complement, . The 1’s complement of a positive integer Nis defined as
/H11005(2
n/H110021)/H11002N (1-3) NN16 Unit 1
PositiveNegative Integers
Integers Sign and 2’s Complement 1’s Complement
/H11001N (all systems) /H11002N Magnitude N* N–
/H110010 0000 /H110020 1000 —— 1111
/H110011 0001 /H110021 1001 1111 1110
/H110012 0010 /H110022 1010 1110 1101
/H110013 0011 /H110023 1011 1101 1100
/H110014 0100 /H110024 1100 1100 1011
/H110015 0101 /H110025 1101 1011 1010
/H110016 0110 /H110026 1110 1010 1001
/H110017 0111 /H110027 1111 1001 1000
/H110028 —— 1000 ——TABLE 1-1
Signed Binary 
Integers (word
length: n/H110054)
Note that 1111 represents minus zero, and /H110028 has no representation in a 4-bit
system. An alternate way to form the 1’s complement is to simply complement N
bit-by-bit by replacing 0’s with 1’s and 1’s with 0’s. This is equivalent to the defini-tion, Equation (1-3), because 2
n/H110021 consists of all 1’s, and subtracting a bit from 1
is the same as complementing the bit. No borrows occur in this subtraction. Forexample, if n/H110056 and N/H11005010101,
2
n/H110021/H11005111111
N/H11005010101
/H11005101010
From Equations (1-2) and (1-3).
N*/H110052n/H11002N/H11005(2n/H110021/H11002N)/H110011/H11005/H11001 1
so the 2’s complement can be formed by complementing Nbit-by-bit and then
adding 1. An easier way to form the 2’s complement of Nis to start at the right and
complement all bits to the left of the first 1. For example, if
N/H110050101100, then N*/H110051010100
From Equations (1-2) and (1-3),
N/H110052n/H11002N* and N/H11005(2n/H110021)/H11002
Therefore, given a negative integer represented by its 2’s complement ( N*), we can
obtain the magnitude of the integer by taking the 2’s complement of N*. Similarly,
to get the magnitude of a negative integer represented by its 1’s complement ( ),we can take the 1’s complement of .
In the 2’s complement system the number of negative integers which can be
represented is one more than the number of positive integers (not including 0). Forexample, in Table 1-1, 1000 represents /H110028, because a sign bit of 1 indicates a negative
number, and if N/H110058,N*/H1100510000 /H110021000 /H110051000. In general, in a 2’s complement
system with a word length of nbits, the number 100 . . . 000 (1 followed by n/H110021 0’s)
represents a negative number with a magnitude of
2
n/H110022n/H110021/H110052n/H110021
This special case occurs only for 2’s complement. However, /H110020 has no representa-
tion in 2’s complement, but /H110020 is a special case for 1’s complement as well as for the
sign and magnitude system.
Addition of 2’s Complement Numbers
The addition of n-bit signed binary numbers is straightforward using the 2’s comple-
ment system. The addition is carried out just as if all the numbers were positive, andany carry from the sign position is ignored. This will always yield the correct resultexcept when an overflow occurs. When the word length is nbits, we say that anN
NNNNNumber Systems and Conversion 17
overflow has occurred if the correct representation of the sum (including sign) requires
more than nbits. The different cases which can occur are illustrated below for n/H110054.
1.Addition of two positive numbers, sum /H110212n/H110021
/H110013 0011
/H110014 0100
/H110017 0111 (correct answer)
2.Addition of two positive numbers, sum /H113502n/H110021
/H110015 0101
/H110016 0110
1011 ←⎯ wrong answer because of overflow ( /H1100111 requires
5 bits including sign)
3.Addition of positive and negative numbers (negative number has greater magnitude)
/H110015 0101
/H110026 1010
/H110021 1111 (correct answer)
4.Same as case 3 except positive number has greater magnitude
/H110025 1011
/H110016 0110
/H110011 (1)0001 ←⎯ correct answer when the carry from the sign bit 
is ignored (this is notan overflow)
5.Addition of two negative numbers, ⏐sum⏐/H113492n/H110021
/H110023 1101
/H110024 1100
/H110027 (1)1001 ←⎯ correct answer when the last carry is ignored 
(this is notan overflow)
6.Addition of two negative numbers, ⏐sum⏐/H110222n/H110021
/H110025 1011
/H110026 1010
(1)0101 ←⎯ wrong answer because of overflow 
(/H1100211 requires 5 bits including sign)
Note that an overflow condition (cases 2 and 6) is easy to detect because in case 2
the addition of two positive numbers yields a negative result, and in case 6 the addi-tion of two negative numbers yields a positive answer (for four bits).
The proof that throwing away the carry from the sign bit always gives the cor-
rect answer follows for cases 4 and 5:
Case 4: /H11002A/H11001B(where B/H11022A)
A*/H11001B/H11005(2
n/H11002A)/H11001B/H110052n/H11001(B/H11002A)/H110222n18 Unit 1
Throwing away the last carry is equivalent to subtracting 2n, so the result is ( B/H11002A),
which is correct.
Case 5: /H11002A/H11002B(where A/H11001B/H113492n/H110021)
A*/H11001B*/H11005(2n/H11002A)/H11001(2n/H11002B)/H110052n/H110012n/H11002(A/H11001B)
Discarding the last carry yields 2n/H11002(A/H11001B)/H11005(A/H11001B)*, which is the correct rep-
resentation of /H11002(A/H11001B).
Addition of 1’s Complement Numbers
The addition of 1’s complement numbers is similar to 2’s complement except that
instead of discarding the last carry, it is added to the n-bit sum in the position fur-
thest to the right. This is referred to as an end-around carry. The addition of positive
numbers is the same as illustrated for cases 1 and 2 under 2’s complement. Theremaining cases are illustrated below ( n/H110054).
3.Addition of positive and negative numbers (negative number with greater
magnitude)
/H110015 0101
/H11002
6 1001
/H110021 1110 (correct answer)
4.Same as case 3 except positive number has greater magnitude
/H110025 1010
/H110016 0110
(1) 0000
1 (end-around carry)
0001 (correct answer, nooverflow)
5.Addition of two negative numbers, ⏐sum⏐/H110212n/H110021
/H110023 1100
/H110024 1011
(1) 0111
1 (end-around carry)
1000 (correct answer, nooverflow)
6.Addition of two negative numbers, ⏐sum⏐/H113502n/H110021
/H110025 1010
/H110026 1001
(1) 0011
1 (end-around carry)
0100 (wrong answer because of overflow)I⎯→I⎯→I⎯→Number Systems and Conversion 19
Again, note that the overflow in case 6 is easy to detect because the addition of two
negative numbers yields a positive result.
The proof that the end-round carry method gives the correct result follows for
cases 4 and 5:
Case 4: /H11002A/H11001B(where B/H11022A)
/H11001B/H11005(2n/H110021/H11002A)/H11001B/H110052n/H11001(B/H11002A)/H110021
The end-around carry is equivalent to subtracting 2nand adding 1, so the result is 
(B/H11002A), which is correct.
Case 5: /H11002A/H11002B(A/H11001B/H110212n/H110021)
/H11001/H11005 (2n/H110021/H11002A)/H11001(2n/H110021/H11002B)/H110052n/H11001[2n/H110021/H11002(A/H11001B)]/H110021
After the end-around carry, the result is 2n/H110021/H11002/H11005 which is the
correct representation for /H11002(A/H11001B).
The following examples illustrate the addition of 1’s and 2’s complement num-
bers for a word length of n/H110058:
1.Add /H1100211 and /H1100220 in 1’s complement.
/H1100111/H1100500001011 /H1100120/H1100500010100
taking the bit-by-bit complement,/H1100211 is represented by 11110100 and /H1100220 by 11101011
11110100 ( /H1100211)
11101011
/H11001(/H1100220)
(1) 11011111
1 (end-around carry)
11100000 /H11005/H11002 31
2.Add /H110028 and /H1100119 in 2’s complement
/H110018/H1100500001000
complementing all bits to the left of the first 1, /H110028, is represented by 11111000
11111000 ( /H110028)
00010011 /H1100119
00001011 /H11005/H11001 11
(discard last carry)
Note that in both cases, the addition produced a carry out of the furthest left
bit position, but there is no overflow because the answer can be correctly←(1)I⎯⎯→(A/H11001B) (A/H11001B)B AA20 Unit 1
represented by eight bits (including sign). A general rule for detecting overflow
when adding two n-bit signed binary numbers (1’s or 2’s complement) to get an
n-bit sum is:
An overflow occurs if adding two positive numbers gives a negative answer or if
adding two negative numbers gives a positive answer.
1.5 Binary Codes
Although most large computers work internally with binary numbers, the input-output equipment generally uses decimal numbers. Because most logic circuits onlyaccept two-valued signals, the decimal numbers must be coded in terms of binarysignals. In the simplest form of binary code, each decimal digit is replaced by itsbinary equivalent. For example, 937.25 is represented by
937.25
1001 0011 0111 . 0010 0101
This representation is referred to as binary-coded-decimal (BCD) or more explicitly
as 8-4-2-1 BCD. Note that the result is quite different than that obtained by convert-ing the number as a whole into binary. Because there are only ten decimal digits, 1010through 1111 are not valid BCD codes.
Table 1-2 shows several possible sets of binary codes for the ten decimal
digits. Many other possibilities exist because the only requirement for aNumber Systems and Conversion 21
8-4-2-1
Decimal Code 6-3-1-1 Excess-3 2-out-of-5 Gray 
Digit (BCD) Code Code Code Code
0 0000 0000 0011 00011 0000
1 0001 0001 0100 00101 00012 0010 0011 0101 00110 00113 0011 0100 0110 01001 0010
4 0100 0101 0111 01010 0110
5 0101 0111 1000 01100 11106 0110 1000 1001 10001 10107 0111 1001 1010 10010 10118 1000 1011 1011 10100 1001
9 1001 1100 1100 11000 1000TABLE 1-2
Binary Codes for
Decimal Digits/H6114/H6114/H6114/H6114/H6114
valid code is that each decimal digit be represented by a distinct combination
of binary digits. To translate a decimal number to coded form, each decimaldigit is replaced by its corresponding code. Thus 937 expressed in excess-3code is 1100 0110 1010. The 8-4-2-1 (BCD) code and the 6-3-1-1 code are exam-ples of weighted codes. A 4-bit weighted code has the property that ifthe weights are w
3,w2,w1, and w0, the code a3a2a1a0represents a decimal num-
berN,where
N/H11005w3a3/H11001w2a2/H11001w1a1/H11001w0a0
For example, the weights for the 6-3-1-1 code are w3/H110056,w2/H110053,w1/H11005l, and w0/H11005l.
The binary code 1011 thus represents the decimal digit
N/H110056/H110801/H110013/H110800/H110011/H110801/H110011/H110801/H110058
The excess-3 code is obtained from the 8-4-2-1 code by adding 3 (0011) to
each of the codes. The 2-out-of-5 code has the property that exactly 2 out of the5 bits are 1 for every valid code combination. This code has useful error-check-ing properties because if any one of the bits in a code combination is changeddue to a malfunction of the logic circuitry, the number of 1 bits is no longerexactly two. The table shows one example of a Gray code. A Gray code has theproperty that the codes for successive decimal digits differ in exactly one bit. Forexample, the codes for 6 and 7 differ only in the fourth bit, and the codes for9 and 0 differ only in the first bit. A Gray code is often used when translating an analog quantity, such as a shaft position, into digital form. In this case, a smallchange in the analog quantity will change only one bit in the code, which gives more reliable operation than if two or more bits changed at a time. TheGray and 2-out-of-5 codes are notweighted codes. In general, the decimal value
of a coded digit cannot be computed by a simple formula when a non-weighted
code is used.
Many applications of computers require the processing of data which contains
numbers, letters, and other symbols such as punctuation marks. In order to transmitsuch alphanumeric data to or from a computer or store it internally in a computer,each symbol must be represented by a binary code. One common alphanumericcode is the ASCII code (American Standard Code for Information Interchange).This is a 7-bit code, so 2
7(128) different code combinations are available to repre-
sent letters, numbers, and other symbols. Table 1-3 shows a portion of the ASCIIcode; the code combinations not listed are used for special control functions such as“form feed” or “end of transmission.”The word “ Start ” is represented in ASCII code
as follows:
1010011 1110100 1100001 1110010 1110100
Start22 Unit 1
Number Systems and Conversion 23
ASCII Code ASCII Code ASCII Code
Character A6A5A4A3A2A1A0 Character A6A5A4A3A2A1A0 Character A6A5A4A3A2A1A0
space 0 1 0 0 0 0 0 @ 1 0 0 0 0 0 0 ‘ 1 1 0 0 0 0 0
! 0100001 A 1000001 a 110000 1
“ 0100010 B 1000010 b 110001 0# 0100011 C 1000011 c 110001 1
$ 0100100 D 1000100 d 110010 0
% 0100101 E 1000101 e 110010 1
& 0100110 F 1000110 f 110011 0
/H11032 0100111 G 1000111 g 110011 1
( 0101000 H 1001000 h 110100 0
) 0101001 I 1001001 i 110100 1
* 0101010 J 1001010 j 110101 0
/H11001 0101011 K 1001011 k 110101 1
, 0101100 L 1001100 l 110110 0
/H11002 0101101 M 1001101 m 110110 1
. 0101110 N 1001110 n 110111 0/ 0101111 O 1001111 o 110111 1
0 0110000 P 1010000 p 111000 01 0110001 Q 1010001 q 111000 1
2 0110010 R 1010010 r 111001 0
3 0110011 S 1010011 s 111001 14 0110100 T 1010100 t 111010 05 0110101 U 1010101 u 111010 16 0110110 V 1010110 v 111011 0
7 0110111 W 1010111 w 111011 1
8 0111000 X 1011000 x 111100 09 0111001 Y 1011001 y 111100 1
: 0111010 Z 1011010 z 111101 0
; 0111011 [ 1011011 { 111101 1
/H11021 0111100 \ 1011100 ⏐ 1111100
/H11005 0111101 ] 1011101 } 111110 1
/H11022 0111110 ^ 1011110 ~ 111111 0
? 0 1 1 1 1 1 1 — 1 0 1 1 1 1 1 delete 1 1 1 1 1 1 1TABLE 1-3 ASCII Code
Problems
1.1 Convert to hexadecimal and then to binary:
(a) 757.2510 (b) 123.1710 (c) 356.8910 (d) 1063.510
1.2 Convert to octal. Convert to hexadecimal. Then convert both of your answers to
decimal, and verify that they are the same.(a) 111010110001.011
2 (b) 10110011101.112
1.3 Convert to base 6: 3BA.2514(do all of the arithmetic in decimal).
1.4 (a) Convert to hexadecimal: 1457.1110. Round to two digits past the hexadecimal point.
(b) Convert your answer to binary, and then to octal.(c) Devise a scheme for converting hexadecimal directly to base 4 and convert your
answer to base 4.
(d) Convert to decimal: DEC.A
16.
1.5 Add, subtract, and multiply in binary:
(a) 1111 and 1010 (b) 110110 and 11101 (c) 100100 and 10110
1.6 Subtract in binary. Place a 1 over each column from which it was necessary to borrow.
(a) 11110100 /H110021000111 (b) 1110110 /H11002111101 (c) 10110010 /H11002111101
1.7 Add the following numbers in binary using 2’s complement to represent negative num-
bers. Use a word length of 6 bits (including sign) and indicate if an overflow occurs.(a) 21 /H1100111 (b) ( /H1100214)/H11001(/H1100232) (c) ( /H1100225)/H1100118
(d) ( /H1100212)/H1100113 (e) ( /H1100211)/H11001(/H1100221)
Repeat (a), (c), (d), and (e) using 1’s complement to represent negative numbers.
1.8 A computer has a word length of 8 bits (including sign). If 2’s complement is used to
represent negative numbers, what range of integers can be stored in the computer?
If 1’s complement is used? (Express your answers in decimal.)
1.9 Construct a table for 7-3-2-1 weighted code and write 3659 using this code.
1.10 Convert to hexadecimal and then to binary.
(a) 1305.375
10 (b) 111.3310 (c) 301.1210 (d) 1644.87510
1.11 Convert to octal. Convert to hexadecimal. Then convert both of your answers to
decimal, and verify that they are the same.(a) 101111010100.101
2 (b) 100001101111.012
1.12 (a) Convert to base 3: 375.548(do all of the arithmetic in decimal).
(b) Convert to base 4: 384.7410.
(c) Convert to base 9: A52.A411(do all of the arithmetic in decimal).
1.13 Convert to hexadecimal and then to binary: 544.19.
1.14 Convert the decimal number 97.710into a number with exactly the same value rep-
resented in the following bases. The exact value requires an infinite repeating partin the fractional part of the number. Show the steps of your derivation.(a) binary (b) octal (c) hexadecimal (d) base 3 (e) base 5
1.15 Devise a scheme for converting base 3 numbers directly to base 9. Use your method
to convert the following number to base 9: 1110212.20211
324 Unit 1
1.16 Convert the following decimal numbers to octal and then to binary:
(a) 298363/64 (b) 93.70 (c) 190031/32 (d) 109.30
1.17 Add, subtract, and multiply in binary:
(a) 1111 and 1001 (b) 1101001 and 110110 (c) 110010 and 11101
1.18 Subtract in binary. Place a 1 over each column from which it was necessary to borrow.
(a) 10100100 /H1100201110011 (b) 10010011 /H1100201011001
(c) 11110011 /H1100210011110
1.19 Divide in binary:
(a) 11101001 /H11004101 (b) 110000001 /H110041110 (c) 1110010 /H110041001
Check your answers by multiplying out in binary and adding the remainder.
1.20 Divide in binary:
(a) 10001101 /H11004110 (b) 110000011 /H110041011 (c) 1110100 /H110041010
1.21 Assume three digits are used to represent positive integers and also assume the fol-
lowing operations are correct. Determine the base of the numbers. Did any of theadditions overflow?(a) 654 /H11001013/H11005000
(b) 024 /H11001043/H11001013/H11001033/H11005223
(c) 024 /H11001043/H11001013/H11001033/H11005201
1.22 What is the lowest number of bits (digits) required in the binary number approxi-
mately equal to the decimal number 0.6117
10so that the binary number has the
same or better precision?
1.23 Convert 0.363636. . .10to its exact equivalent base 8 number.
1.24 (a) Verify that a number in base bcan be converted to base b3by partitioning the
digits of the base bnumber into groups of three consecutive digits starting at the
radix point and proceeding both left and right and converting each group intoa base b
3digit. ( Hint: Represent the base bnumber using the power series
expansion.)
(b) Verify that a number in base b3can be converted to base bby expanding each
digit of the base b3number into three consecutive digits starting at the radix
point and proceeding both left and right.
1.25 Construct a table for 4-3-2-1 weighted code and write 9154 using this code.
1.26 Is it possible to construct a 5-3-1-1 weighted code? A 6-4-1-1 weighted code? Justify
your answers.
1.27 Is it possible to construct a 5-4-1-1 weighted code? A 6-3-2-1 weighte code? Justify
your answers.Number Systems and Conversion 25
1.28 Construct a 6-2-2-1 weighted code for decimal digits. What number does 1100 0011
represent in this code?
1.29 Construct a 5-2-2-1 weighted code for decimal digits. What numbers does 1110 0110
represent in this code?
1.30 Construct a 7-3-2-1 code for base 12 digits. Write B4A9 using this code.
1.31 (a) It is possible to have negative weights in a weighted code for the decimal digits,
e . g . ,8 ,4 , /H110022, and /H110021 can be used. Construct a table for this weighted code.
(b) If dis a decimal digit in this code, how can the code for 9 – dbe obtained?
1.32 Convert to hexadecimal, and then give the ASCII code for the resulting hexadecimal
number (including the code for the hexadecimal point):(a) 222.22
10 (b) 183.8110
1.33 Repeat 1.7 for the following numbers:
(a) ( /H1100210)/H11001(/H1100211) (b) ( /H1100210)/H11001(/H110026) (c) ( /H110028)/H11001(/H1100211)
(d) 11 /H110019 (e) ( /H1100211)/H11001(/H110024)
1.34 Because A /H11002B/H11005A/H11001(/H11002B), the subtraction of signed numbers can be accom-
plished by adding the complement. Subtract each of the following pairs of 5-bitbinary numbers by adding the complement of the subtrahend to the minuend.Indicate when an overflow occurs. Assume that negative numbers are representedin 1’s complement. Then repeat using 2’s complement.(a) 01001 (b) 11010 (c) 10110 (d) 11011 (e) 11100
/H11002
11010 /H1100211001 /H1100201101 /H1100200111 /H1100210101
1.35 Work Problem 1.34 for the following pairs of numbers:
(a) 11010 (b) 01011 (c) 10001 (d) 10101
/H1100210100 /H1100211000 /H1100201010 /H1100211010
1.36 (a) A /H11005101010 and B /H11005011101 are 1’s complement numbers. Perform the follow-
ing operations and indicate whether overflow occurs.
(i) A /H11001B (ii) A /H11002B
(b) Repeat Part (a) assuming the numbers are 2’s complement numbers.
1.37 (a) Assume the integers below are 1’s complement integers. Find the 1’s comple-
ment of each number, and give the decimal values of the original number andof its complement.
(i) 0000000 (ii) 1111111 (iii) 00110011 (iv) 1000000
(b) Repeat, assuming the numbers are 2’s complement numbers and finding the 2’s
complement of them.26 Unit 1
27
 27Objectives
A list of 15 laws and theorems of Boolean algebra is given on page 55 of this
unit. When you complete this unit, you should be familiar with and be ableto use any of the first 12 of these. Specifically, you should be able to:
1.Understand the basic operations and laws of Boolean algebra.
2.Relate these operations and laws to circuits composed of AND gates, OR
gates, and INVERTERS. Also relate these operations and laws to circuitscomposed of switches.
3.Prove any of these laws using a truth table.
4.Apply these laws to the manipulation of algebraic expressions including:
a.Multiplying out an expression to obtain a sum of products (SOP).
b.Factoring an expression to obtain a product of sums (POS).
c.Simplifying an expression by applying one of the laws.
d.Finding the complement of an expression.Boolean AlgebraUNIT
2
28 Unit 2
1.In this unit you will study Boolean algebra, the basic mathematics needed for the
logic design of digital systems. Just as when you first learned ordinary algebra, youwill need a fair amount of practice before you can use Boolean algebra effectively.However, by the end of the course, you should be just as comfortable with Booleanalgebra as with ordinary algebra. Fortunately, many of the rules of Boolean alge-bra are the same as for ordinary algebra, but watch out for some surprises!
2.Study Sections 2.1 and 2.2, Introduction and Basic Operations.
(a) How does the meaning of the symbols 0 and 1 as used in this unit differ
from the meaning as used in Unit 1?
(b) Two commonly used notations for the inverse or complement of Aare
andA′. The latter has the advantage that it is much easier for typists, print-
ers, and computers. (Have you ever tried to get a computer to print a barover a letter?) We will use A′for the complement of A.You may use either
notation in your work, but please do not mix notations in the same equa-tion. Most engineers use /H11001for OR and •(or no symbol) for AND, and we
will follow this practice. An alternative notation, often used bymathematicians, is 
/H11626for OR and /H11625for AND.
(c) Many different symbols are used for AND, OR, and INVERTER logic
blocks. Initially we will useAStudy Guide
......for
ANDfor
ORfor
INVERTER+
The shapes of these symbols conform to those commonly used in industrial
practice. We have added the /H11001and •for clarity. These symbols point in
the direction of signal flow.This makes it easier to read the circuit diagramsin comparison with the square or round symbols used in some books.
(d) Determine the output of each of the following gates:
1
110 10 11++
0 10 1 1 0 ++(e) Determine the unspecified inputs to each of the following gates if the out-
puts are as shown:
3.Study Section 2.3, Boolean Expressions and Truth Tables.
(a) How many variables does the following expression contain?
How many literals?
A′BC′D/H11001AB/H11001B′CD/H11001D′
(b) For the following circuit, if A/H11005B/H110050 and C/H11005D/H11005E/H110051, indicate the out-
put of each gate (0 or 1) on the circuit diagram:
C
D
B
EF A++
(c) Derive a Boolean expression for the circuit output.Then substitute A/H11005B/H110050
and C /H11005D/H11005E/H110051 into your expression and verify that the value of F
obtained in this way is the same as that obtained on the circuit diagram in (b).
(d) Write an expression for the output of the following circuit and complete
the truth table:
A
F =BFAB A /H11032 A/H11032B (A/H11032B)/H11032
ABC B /H11032 A/H11001B/H11032 C(A/H11001B/H11032)(e) When filling in the combinations of values for the variables on the left side
of a truth table, always list the combinations of 0’s and 1’s in binary order.For example, for a three-variable truth table, the first row should be 000,the next row 001, then 010, 011, 100, 101, 110, and 111. Write an expressionfor the output of the following circuit and complete the truth table:
BCA
F =F+
(f) Draw a gate circuit which has an output
Z/H11005[BC′/H11001F(E/H11001AD′)]′
(Hint: Start with the innermost parentheses and draw the circuit for AD′first.)Boolean Algebra 29
30 Unit 2
4.Study Section 2.4, Basic Theore ms.
(a) Prove each of the Theorems (2-4) through (2-8D) by showing that it is
valid for both X/H110050 and X/H110051.
(b) Determine the output of each of these gates:
A
A
A
AA′
A
A′
AA
0
AA
1
01A++++
(c) State which of the basic theorems was used in simplifying each of the fol-
lowing expressions:
(AB′/H11001C)/H110800/H110050 A(B/H11001C′)/H110011/H110051
(BC′/H11001A)(BC′/H11001A)/H11005BC′/H11001AX (Y′/H11001Z)/H11001[X(Y′/H11001Z)]′/H110051
(X′/H11001YZ)(X′/H11001YZ)′/H110050 D′(E′/H11001F)/H11001D′(E′/H11001F)/H11005D′(E′/H11001F)
5.Study Section 2.5, Commutative, Associative, and Distributive Laws.
(a) State the associative law for OR.
(b) State the commutative law for AND.(c) Simplify the following circuit by using the associative laws. Your answer
should require only two gates.
A
B
C
D
E
FG +
+
(d) For each gate determine the value of the unspecified input(s):
1
1
100 1 10
0
0+ +
(e) Using a truth table, verify the distributive law, Equation (2-11).
(f) Illustrate the distributive laws, Equations (2-11) and (2-11D), using AND
and OR gates.
(g) Verify Equation (2-3) using the second distributive law.
(h) Show how the second distributive law can be used to factor RS/H11001T′.
6.Study Section 2.6, Simplification Theore ms.
(a) By completing the truth table, prove that X Y′/H11001Y/H11005X/H11001Y.
XY X Y ′ XY/H11032/H11001YX /H11001Y
00
0110
11
(b) Which one of Theorems (2-12) through (2-14D) was applied to simplify
each of the following expressions? Identify Xand Yin each case.
(A/H11001B)(DE)′/H11001DE/H11005A/H11001B/H11001DE
AB′/H11001AB′C′D/H11005AB′
(A′/H11001B)(CD/H11001E′)/H11001(A′/H11001B)(CD/H11001E′)′/H11005A′/H11001B
(A/H11001BC′/H11001D′E)(A/H11001D′E)/H11005A/H11001D′EBoolean Algebra 31
32 Unit 2
A
B
CC Z
D+
+(c) Simplify the following circuit to a single gate:
(d) Work Problems 2.1, 2.2, 2.3, and 2.4.
7.Study Section 2.7, Multiplying Out and Factoring.
(a) Indicate which of the following expressions are in the product-of-sums
form, sum-of-products form, or neither:
AB′/H11001D′EF′/H11001G
(A/H11001B′C′)(A′/H11001BC)
AB′(C′/H11001D/H11001E′)(F′/H11001G)
X′Y/H11001WX(X′/H11001Z)/H11001A′B′C′
Your answer to this question should include one product-of-sums, one sum-
of-products, and two neither, not necessarily in that order.
(b) When multiplying out an expression, why should the second distributive
law be applied before the ordinary distributive law when possible?
(c) Factor as much as possible using the ordinary distributive law:
AD/H11001B′CD/H11001B′DE
Now factor your result using the second distributive law to obtain a prod-
uct of sums.
(d) Work Problems 2.5, 2.6, and 2.7.
8.Probably the most difficult part of the unit is using the second distributive law
for factoring or multiplying out an expression. If you have difficulty withProblems 2.5 or 2.6, or you cannot work them quickly, study the examples in
Section 2.7 again, and then work the following problems.
Multiply out:
(a) ( B′/H11001D/H11001E)(B′/H11001D/H11001A
)(AE/H11001C′)
Boolean Algebra 33
(b) ( A/H11001C′)(B′/H11001D)(C′/H11001D′)(C/H11001D)E
As usual, when we say multiply out, we do not mean to multiply out by brute
force, but rather to use the second distributive law whenever you can to cutdown on the amount of work required.
The answer to (a) should be of the following form: XX/H11001XX/H11001XXand (b) of the
form: XXX /H11001XXXXX, where each Xrepresents a single variable or its complement.
Now factor your answer to (a) to see that you can get back the original
expression.
9.Study Section 2.8, DeMorgan’s Laws.
10. Find the complement of each of the following expressions as indicated. In your
answer, the complement operation should be applied only to single variables.
(a) ( ab′c′)′/H11005
(b) ( a′/H11001b/H11001c/H11001d′)′/H11005
(c) ( a′/H11001bc)′/H11005
(d) ( a′b′/H11001cd)′/H11005
(e) [ a(b′/H11001c′d)]′/H11005
11. Because ( X′
)′/H11005X,if you complement each of your answers to 10, you should
get back the original expression. Verify that this is true.
(a)
(b)(c)(d)(e)
12. Given that F/H11005a′b/H11001b′c, F′/H11005
Complete the following truth table and verify that your answer is correct:
abc a /H11032bb /H11032ca /H11032b/H11001b/H11032c (a/H11001b/H11032)( b/H11001c/H11032) F/H11032
000
001010011100
101
110111
34 Unit 2
13. A fully simplified expression should have nothing complemented except the
individual variables. For example, F/H11005(X/H11001Y)′(W/H11001Z) is nota minimum prod-
uct of sums. Find the minimum product of sums for F.
14. Work Problems 2.8 and 2.9.
15. Find the dual of ( M/H11001N′)P′.
16. Review the first 12 laws and theorems on page 55. Make sure that you can recog-
nize when to apply them even if an expression has been substituted for a variable.
17. Reread the objectives of this unit. If you are satisfied that you can meet these
objectives, take the readiness test.
[Note: You will be provided with a copy of the theorem sheet (page 55)
when you take the readiness test this time. However, by the end of Unit 3,you should know all the theorems by memory.]
Boolean Algebra
2.1 Introduction
The basic mathematics needed for the study of the logic design of digital systems
is Boolean algebra. Boolean algebra has many other applications including set the-ory and mathematical logic, but we will restrict ourselves to its application toswitching circuits in this text. Because all of the switching devices which we will useare essentially two-state devices (such as a transistor with high or low output volt-age), we will study the special case of Boolean algebra in which all of the variablesassume only one of two values. This two-valued Boolean algebra is often referredto as switching algebra. George Boole developed Boolean algebra in 1847 and used
Boolean Algebra 35
it to solve problems in mathematical logic. Claude Shannon first applied Boolean
algebra to the design of switching circuits in 1939.
We will use a Boolean variable, such as XorY,to represent the input or output of
a switching circuit. We will assume that each of these variables can take on only twodifferent values. The symbols “0” and “1” are used to represent these two differentvalues. Thus, if Xis a Boolean (switching) variable, then either X/H110050 or X/H110051.
The symbols “0” and “1” used in Boolean algebra do not have a numeric value;
instead they represent two different states in a logic circuit and are the two valuesof a switching variable. In a logic gate circuit, 0 (usually) represents a range of lowvoltages, and 1 represents a range of high voltages. In a switch circuit, 0 (usually)represents an open switch, and 1 represents a closed circuit. In general, 0 and 1 canbe used to represent the two states in any binary-valued system.
2.2 Basic Operations
The basic operations of Boolean algebra are AND, OR, and complement (or inverse).The complement of 0 is 1, and the complement of 1 is 0. Symbolically, we write
0′/H110051 and 1 ′/H110050
where the prime ( ′) denotes complementation. If Xis a switching variable,
X′/H110051 if X/H110050 and X′/H110050 if X/H110051
An alternate name for complementation is inversion, and the electronic circuit
which forms the inverse of Xis referred to as an inverter. Symbolically, we repre-
sent an inverter by
where the circle at the output indicates inversion. If a logic 0 corresponds to a low
voltage and a logic 1 corresponds to a high voltage, a low voltage at the inverterinput produces a high voltage at the output and vice versa. Complementation issometimes referred to as the NOT operation because X/H110051 if X is not equal to 0.
The AND operation can be defined as follows:
0/H11080 0/H1100500  /H11080 1/H1100501  /H11080 0/H1100501  /H110801/H110051
where “ /H11080” denotes AND. (Although this looks like binary multiplication, it is not,
because 0 and 1 here are Boolean constants rather than binary numbers.) If we writethe Boolean expression C/H11005A/H11080B, then given the values of Aand B, we can deter-
mine Cfrom the following table:X X′
A B C /H11005A/H11080B
00 0
01 010 011 1
36 Unit 2
AB C /H11005A/H11001B
00 0
01 110 111 1
Note that C/H110051 iff A or B (or both) is 1, hence, the name OR operation. This type of
OR operation is sometimes referred to as inclusive-OR. A logic gate which per-forms the OR operation is represented by
A
BC = A + B +
X X = 0 → switch open
X = 1 → switch closed
A
1B T = 0 → open circuit between terminals 1 and 2
T = 1 → closed circuit between terminals 1 and 22The OR operation is also referred to as logical (or Boolean) addition. Electronic
circuits which realize inverters and AND and OR gates are described inAppendix A.
Next, we will apply switching algebra to describe circuits containing switches.We
will label each switch with a variable. If switch Xis open, then we will define the
value of Xto be 0; if switch Xis closed, then we will define the value of Xto be 1.
Now consider a circuit composed of two switches in a series. We will define the
transmission between the terminals as T/H110050 if there is an open circuit between the
terminals and T/H110051 if there is a closed circuit between the terminals.
Now we have a closed circuit between terminals 1 and 2 ( T/H110051) iff (if and only if)
switch Ais closed andswitch Bis closed. Stating this algebraically,
T/H11005A/H11080BNote that C/H110051 iff (if and only if) A and B are both 1, hence, the name AND oper-
ation. A logic gate which performs the AND operation is represented by
The dot symbol ( /H11080) is frequently omitted in a Boolean expression, and we will usu-
ally write ABinstead of A/H11080B.The AND operation is also referred to as logical (or
Boolean) multiplication.
The OR operation can be defined as follows:
0/H110010/H1100500 /H110011/H1100511 /H110010/H1100511 /H110011/H110051
where “ /H11001” denotes OR. If we write C/H11005A/H11001B,then given the values of Aand B,
we can determine Cfrom the following table:A
BC = A• B
Boolean Algebra 37
Next consider a circuit composed of two switches in parallel.
In this case, we have a closed circuit between terminals 1 and 2 iff switch Ais closed
orswitch Bis closed. Using the same convention for defining variables as above, an
equation which describes the behavior of this circuit is
T/H11005A/H11001B
Thus, switches in a series perform the AND operation and switches in parallel per-
form the OR operation.
2.3 Boolean Expressions and Truth Tables
Boolean expressions are formed by application of the basic operations to one ormore variables or constants. The simplest expressions consist of a single constant orvariable, such as 0, X,orY′. More complicated expressions are formed by combining
two or more other expressions using AND or OR, or by complementing anotherexpression. Examples of expressions are
AB′/H11001C (2-1)
[A(C/H11001D)]′/H11001BE (2-2)
Parentheses are added as needed to specify the order in which the operations are
performed. When parentheses are omitted, complementation is performed first fol-lowed by AND and then OR. Thus in Expression (2-1), B′is formed first, then AB′,
and finally AB′/H11001C.
Each expression corresponds directly to a circuit of logic gates. Figure 2-1 gives
the circuits for Expressions (2-1) and (2-2).A
B12
A
A
BB E
EAB′
(AB′+C)
(C+D)A(C+D)[ A(C+D)]′
[A(C+D)]′ + BE(a)
(b)CB
C
DB′
+++FIGURE 2-1
Circuits for
Expressions (2-1)
and (2-2)
38 Unit 2
An expression is evaluated by substituting a value of 0 or 1 for each variable. If
A/H11005B/H11005C/H110051 and D/H11005E/H110050, the value of Expression (2-2) is
[A(C/H11001D)]′/H11001BE/H11005[1(1 /H110010)]′/H110011/H110800/H11005[1(1)] ′/H110010/H110050/H110010/H110050
Each appearance of a variable or its complement in an expression will be referred
to as a literal. Thus, the following expression, which has three variables, has 10 literals:
ab′c/H11001a′b/H11001a′bc′/H11001b′c′
When an expression is realized using logic gates, each literal in the expression cor-
responds to a gate input.
A truth table (also called a table of combinations) specifies the values of a
Boolean expression for every possible combination of values of the variables in theexpression. The name truth table comes from a similar table which is used in sym-bolic logic to list the truth or falsity of a statement under all possible conditions. Wecan use a truth table to specify the output values for a circuit of logic gates interms of the values of the input variables. The output of the circuit in Figure 2-2(a)isF/H11005A′/H11001B.Figure 2-2(b) shows a truth table which specifies the output of the
circuit for all possible combinations of values of the inputs Aand B.The first two
columns list the four combinations of values of Aand B,and the next column gives
the corresponding values of A′. The last column, which gives the values of A′/H11001B,is
formed by ORing together corresponding values of A′and Bin each row.
+A
BF = A' + BA'
(a)FIGURE 2-2
Two-Input Circuit
and Truth TableAB A /H11032 F/H11005A/H11032/H11001B
00 1 1
01 1 110 0 011 0 1
ABC B /H11032 AB/H11032 AB/H11032/H11001CA /H11001CB /H11032/H11001C (A/H11001C)(B/H11032/H11001C)
000 1 0 0 0 1 0
001 1 0 1 1 1 1010 0 0 0 0 0 0
011 0 0 1 1 1 1
100 1 1 1 1 1 1101 1 1 1 1 1 1110 0 0 0 1 0 0111 0 0 1 1 1 1TABLE 2-1(b)
Next, we will use a truth table to specify the value of Expression (2-1) for all possible
combinations of values of the variables A, B, andC.On the left side of Table 2-1, we list
the values of the variables A, B, andC.Because each of the three variables can assume
the value 0 or 1, there are 2 /H110032/H110032/H110058 combinations of values of the variables. These
combinations are easily obtained by listing the binary numbers 000, 001, . . . , 111. In thenext three columns of the truth table, we compute B′,AB′, and AB′/H11001C,respectively.
Two expressions are equal if they have the same value for every possible com-
bination of the variables. The expression ( A/H11001C)(B′/H11001C) is evaluated using the
last three columns of Table 2-1. Because it has the same value as AB′/H11001Cfor all
eight combinations of values of the variables A,B, and C, we conclude
Boolean Algebra 39
AB′/H11001C/H11005(A/H11001C)(B′/H11001C) (2-3)
If an expression has nvariables, and each variable can have the value 0 or 1, the
number of different combinations of values of the variables is
2/H110032/H110032/H11003.../H110052n
Therefore, a truth table for an n-variable expression will have 2nrows.
2.4 Basic Theorems
The following basic laws and theorems of Boolean algebra involve only a single variable:
Operations with 0 and 1:
X/H110010/H11005X (2-4) X/H110801/H11005X (2-4D)
X/H110011/H110051 (2-5) X/H110800/H110050 (2-5D)
Idempotent laws
X/H11001X/H11005X (2-6) X/H11080X/H11005X (2-6D)
Involution law
(X′)′/H11005X (2-7)
Laws of complementarity
X/H11001X′/H110051 (2-8) X/H11080X′/H110050 (2-8D)
Each of these theorems is easily proved by showing that it is valid for both of the
possible values of X.For example, to prove X/H11001X′/H110051, we observe that if
X/H110050, 0 /H110010′/H110050/H110011/H110051, and if X/H110051, 1 /H110011′/H110051/H110010/H110051
Any expression can be substituted for the variable Xin these theorems. Thus,
by Theorem (2-5),
(AB′/H11001D)E/H110011/H110051
and by Theorem (2-8D),
(AB′/H11001D)(AB′/H11001D)′/H110050
We will illustrate some of the basic theorems with circuits of switches. As before,
0 will represent an open circuit or open switch, and 1 will represent a closed circuitor closed switch. If two switches are both labeled with the variable A,this means that
both switches are open when A/H110050 and both are closed when A/H110051. Thus the circuit
AA
/H20902
ntimes
can be replaced with a single switch:
A
40 Unit 2
which illustrates the theorem A/H11001A/H11005A.A switch in parallel with an open circuit is
equivalent to the switch alone
AA
=
(A + 0 = A)
while a switch in parallel with a short circuit is equivalent to a short circuit.
A
(A + 1 = 1)=
If a switch is labeled A′, then it is open when Ais closed and conversely. Hence,
Ain parallel with A′can be replaced with a closed circuit because one or the other
of the two switches is always closed.
A
A′
(A + A′ = 1)=
Similarly, switch Ain series with A′can be replaced with an open circuit (why?).
(A•A′ = 0)=AA ′
2.5 Commutative, Associative,
and Distributive Laws
Many of the laws of ordinary algebra, such as the commutative and associative laws,
also apply to Boolean algebra. The commutative laws for AND and OR, which fol-low directly from the definitions of the AND and OR operations, are
XY/H11005YX (2-9) X/H11001Y/H11005Y/H11001X (2-9D)This illustrates the theorem A/H11080A/H11005A.Similarly,
AA
A=
Boolean Algebra 41
AA
B
CBC=
(AB)C = ABC
(a)
AA
B
CBC=
(A + B) + C = A + B + C
(b)+++FIGURE 2-3
Associative Laws
for AND and ORThis means that the order in which the variables are written will not affect the result
of applying the AND and OR operations.
The associative laws also apply to AND and OR:
(XY)Z/H11005X(YZ)/H11005XYZ (2-10)
(X/H11001Y)/H11001Z/H11005X/H11001(Y/H11001Z)/H11005X/H11001Y/H11001Z (2-10D)
When forming the AND (or OR) of three variables, the result is independent of
which pair of variables we associate together first, so parentheses can be omitted asindicated in Equations (2-10) and (2-10D).
We will prove the associative law for AND by using a truth table (Table 2-2).
On the left side of the table, we list all combinations of values of the variables X,
Y,and Z.In the next two columns of the truth table, we compute XYand YZfor
each combination of values of X, Y, and Z.Finally, we compute ( XY)Zand X(YZ).
Because ( XY)Zand X(YZ) are equal for all possible combinations of values of the
variables, we conclude that Equation (2-10) is valid.
X Y Z XY YZ (XY)ZX (YZ)
000 0 0 0 0
001 0 0 0 0010 0 0 0 0011 0 1 0 0100 0 0 0 0
101 0 0 0 0
110 1 0 0 0111 1 1 1 1TABLE 2-2
Proof of Associative
Law for AND
Figure 2-3 illustrates the associative laws using AND and OR gates. In Figure 2-3(a)
two two-input AND gates are replaced with a single three-input AND gate. Similarly,in Figure 2-3(b) two two-input OR gates are replaced with a single three-input OR gate.
When two or more variables are ANDed together, the value of the result will be
1 iff all of the variables have the value 1. If any of the variables have the value 0, theresult of the AND operation will be 0. For example,
XYZ /H110051 iff X/H11005Y/H11005Z/H110051
42 Unit 2
When two or more variables are ORed together, the value of the result will be 1
if any of the variables have the value 1. The result of the OR operation will be 0 iffall of the variables have the value 0. For example,
X/H11001Y/H11001Z/H110050 iff X/H11005Y/H11005Z/H110050
Using a truth table, it is easy to show that the distributive law is valid:
X(Y/H11001Z)/H11005XY/H11001XZ (2-11)
In addition to the ordinary distributive law, a second distributive law is valid for
Boolean algebra but not for ordinary algebra:
X/H11001YZ/H11005(X/H11001Y)(X/H11001Z) (2-11D)
Proof of the second distributive law follows:
(X/H11001Y)(X/H11001Z)/H11005X(X/H11001Z)/H11001Y(X/H11001Z)/H11005XX/H11001XZ/H11001YX/H11001YZ
(by (2-11))
/H11005X/H11001XZ/H11001XY/H11001YZ/H11005X
/H110801/H11001XZ/H11001XY/H11001YZ
(by (2-6D) and (2-4D))
/H11005X(1/H11001Z/H11001Y)/H11001YZ/H11005X/H110801/H11001YZ/H11005X/H11001YZ
(by (2-11), (2-5), and (2-4D))
The ordinary distributive law states that the AND operation distributes over OR,
while the second distributive law states that OR distributes over AND. This secondlaw is very useful in manipulating Boolean expressions. In particular, an expression
likeA/H11001BC, which cannot be factored in ordinary algebra, is easily factored using the
second distributive law:
A/H11001BC/H11005(A/H11001B)(A/H11001C)
2.6 Simplification Theorems
The following theorems are useful in simplifying Boolean expressions:
XY/H11001XY′/H11005X (2-12) ( X/H11001Y)(X/H11001Y′)/H11005X (2-12D)
X/H11001XY/H11005X (2-13) X(X/H11001Y)/H11005X (2-13D)
(X/H11001Y′)Y/H11005XY (2-14) XY′/H11001Y/H11005X/H11001Y (2-14D)
In each case, one expression can be replaced by a simpler one. Because each
expression corresponds to a circuit of logic gates, simplifying an expression leads tosimplifying the corresponding logic circuit.
Boolean Algebra 43
Each of the preceding theorems can be proved by using a truth table, or they can
be proved algebraically starting with the basic theorems.
Proof of (2-13): X/H11001XY/H11005X/H110801/H11001XY/H11005X(1/H11001Y)/H11005X/H110801/H11005X
Proof of (2-13D): X(X/H11001Y)/H11005XX/H11001XY/H11005X/H11001XY/H11005X
(by (2-6D) and (2-13))
Proof of (2-14D): Y/H11001XY′/H11005(Y/H11001X)(Y/H11001Y′)/H11005(Y/H11001X)1/H11005Y/H11001X
(by (2-11 D) and (2-8))
The proof of the remaining theorems is left as an exercise.
We will illustrate Theorem (2-14D), using switches. Consider the following circuit:
Y
X Y′
Its transmission is T/H11005Y/H11001XY′because there is a closed circuit between the termi-
nals if switch Yis closed orswitch Xis closed and switch Y′is closed. The following
circuit is equivalent because if Yis closed ( Y/H110051) both circuits have a transmission
of 1; if Yis open ( Y′/H110051) both circuits have a transmission of X.
Y
X
The following example illustrates simplification of a logic gate circuit using one
of the theorems. In Figure 2-4, the output of circuit (a) is
F/H11005A(A′/H11001B)
By Theorem (2-14), the expression for Fsimplifies to AB.Therefore, circuit (a) can
be replaced with the equivalent circuit (b).
Any expressions can be substituted for Xand Yin the theorems.
Simp lifyZ/H11005A′BC/H11001A′
Example 1 This expression has the same form as (2-13) if we let X/H11005A′and Y/H11005BC.
Therefore, the expression simplifies to Z/H11005X/H11001XY/H11005X/H11005A′.A
BAFA
BF
(a) (b)+FIGURE 2-4
Equivalent Gate
Circuits
44 Unit 2
Simp lify Z /H11005[A/H11001B′C/H11001D/H11001EF] [A/H11001B′C/H11001(D/H11001EF)′]
Example 2
Substituting: Z /H11005[ X /H11001 Y ][ X /H11001 Y′]
Then, by (2-12D), the expression reduces to
Z/H11005X/H11005A/H11001B′C
Simp lify Z = ( AB/H11001C) (B′D/H11001C′E′)/H11001(AB/H11001C)′
Example 3
Substituting: Z/H11005 Y′ X /H11001 Y
By, (2-14D): Z/H11005X/H11001Y/H11005B′D/H11001C′E′/H11001(AB/H11001C)′
Note that in this example we let Y/H11005(AB/H11001C)′rather than ( AB/H11001C) in order to
match the form of (2-14D).
2.7 Multiplying Out and Factoring
The two distributive laws are used to multiply out an expression to obtain a sum-
of-products (SOP) form. An expression is said to be in sum-of-products form when
all products are the products of single variables. This form is the end result whenan expression is fully multiplied out. It is usually easy to recognize a sum-of-prod-ucts expression because it consists of a sum of product terms:
AB′/H11001CD′E/H11001AC′E′ (2-15)
However, in degenerate cases, one or more of the product terms may consist of a
single variable. For example,
ABC ′/H11001DEF G/H11001H (2-16)
and
A/H11001B′/H11001C/H11001D′E (2-17)
are still considered to be in sum-of-products form. The expression
(A/H11001B)CD/H11001EF
is not in sum-of-products form because the A/H11001Bterm enters into a product but is
not a single variable.
When multiplying out an expression, apply the second distributive law first when
possible. For example, to multiply out ( A/H11001BC)(A/H11001D/H11001E) let
X/H11005A, Y/H11005BC, Z/H11005D/H11001E
¸˝˛ ¸˝˛ ¸˝˛
¸˝˛ ¸˝˛ ¸˝˛ ¸˝˛
Boolean Algebra 45
Then
(X/H11001Y)(X/H11001Z)/H11005X/H11001YZ/H11005A/H11001BC(D/H11001E)/H11005A/H11001BCD /H11001BCE
Of course, the same result could be obtained the hard way by multiplying out the
original expression completely and then eliminating redundant terms:
(A/H11001BC)(A/H11001D/H11001E)/H11005A/H11001AD/H11001AE/H11001ABC /H11001BCD /H11001BCE
/H11005A(1/H11001D/H11001E/H11001BC)/H11001BCD /H11001BCE
/H11005A/H11001BCD /H11001BCE
You will save yourself a lot of time if you learn to apply the second distributive law
instead of doing the problem the hard way.
Both distributive laws can be used to factor an expression to obtain a product-
of-sums form. An expression is in product-of-su ms(POS) form when all sums are the
sums of single variables. It is usually easy to recognize a product-of-sums expressionsince it consists of a product of sum terms:
(A/H11001B′)(C/H11001D′/H11001E)(A/H11001C′/H11001
E′) (2-18)
However, in degenerate cases, one or more of the sum terms may consist of a single
variable. For example,
(A/H11001B)(C/H11001D/H11001E)F (2-19)
and
AB′C(D′/H11001E) (2-20)
are still considered to be in product-of-sums form, but ( A/H11001B)(C/H11001D)/H11001EFis not.
An expression is fully factored iff it is in product-of-sums form. Any expression not
in this form can be factored further.
The following examples illustrate how to factor using the second distributive law:
Factor A/H11001B′CD . This is of t he form X/H11001YZ whereX/H11005A,Y/H11005B′,a n d Z/H11005CD,s o
Example 1
A/H11001B′CD/H11005(X/H11001Y)(X/H11001Z)/H11005(A/H11001B′)(A/H11001CD)
A/H11001CDcan be factored again using the second distributive law, so
A/H11001B′CD/H11005(A/H11001B′)(A/H11001C)(A/H11001D)
Factor AB′/H11001C′D.
Example 2
AB′/H11001C′D/H11005(AB′/H11001C′)(AB′/H11001D)←note how X/H11001YZ/H11005(X/H11001Y)(X/H11001Z) was 
applied here
/H11005(A/H11001C′)(B′/H11001C′)(A/H11001D)(B′/H11001D)←the second distributive law was applied
again to each term
46 Unit 2
Factor C′D/H11001C′E′/H11001G′H.
Example 3
C′D/H11001C′E′/H11001G′H/H11005C′(D/H11001E′)/H11001G′H ←first apply the ordinary distribu-
tive law, XY/H11001XZ/H11005X(Y/H11001Z)
/H11005(C′/H11001G′H)(D/H11001E′/H11001G′H) ←then apply the second distribu-
tive law
/H11005(C′/H11001G′)(C′/H11001H)(D/H11001E′/H11001G′)(D/H11001E′/H11001H)←now identify X, Y, and Zin each
expression and complete the
factoring
As in Example 3, the ordinary distributive law should be applied before the second
law when factoring an expression.
A sum-of-products expression can always be realized directly by one or more AND
gates feeding a single OR gate at the circuit output. Figure 2-5 shows the circuits forEquations (2-15) and (2-17). Inverters required to generate the complemented vari-ables have been omitted.
A product-of-sums expression can always be realized directly by one or more
OR gates feeding a single AND gate at the circuit output. Figure 2-6 shows thecircuits for Equations (2-18) and (2-20). Inverters required to generate the comple-ments have been omitted.
The circuits shown in Figures 2-5 and 2-6 are often referred to as two-level cir-
cuits because they have a maximum of two gates in series between an input and thecircuit output.
AA
B′
C
D′
E
A
C′
E′B′
CD′
E++
AA
B′
C
D′
E
A
C′
E′B′
C D′
E++
++FIGURE 2-5
Circuits for
Equations (2-15)
and (2-17)
FIGURE 2-6
Circuits for
Equations (2-18)
and (2-20)
Boolean Algebra 47
2.8 DeMorgan’s Laws
The inverse or complement of any Boolean expression can easily be found by suc-
cessively applying the following theorems, which are frequently referred to asDeMorgan’s laws:
(X/H11001Y)′/H11005X′Y′ (2-21)
(XY)′/H11005X′/H11001Y′ (2-22)
We will verify these laws using a truth table:
X Y X ′Y′ X/H11001Y (X/H11001Y)′ X′Y′ XY (XY)′ X′/H11001Y′
0 0 1 1 0 1 1 0 1 1
0 1 1 0 1 0 0 0 1 11 0 0 1 1 0 0 0 1 1
1 1 0 0 1 0 0 1 0 0
DeMorgan’s laws are easily generalized to nvariables:
(X1/H11001X2/H11001X3/H11001.../H11001Xn)′/H11005X1′X2′X3′...Xn′ (2-23)
(X1X2X3...Xn)′/H11005X1′/H11001X2′/H11001X3′/H11001.../H11001Xn′ (2-24)
For example, for n/H110053,
(X1/H11001X2/H11001X3)′/H11005(X1/H11001X2)′X3′/H11005X1′X2′X3′
Referring to the OR operation as the logical sum and the AND operation as logical
product, DeMorgan’s laws can be stated as
The complement of the product is the sum of the complements.
The complement of the sum is the product of the complements.
To form the complement of an expression containing both OR and AND opera-
tions, DeMorgan’s laws are applied alternately.
To f ind the comp lement of ( A′/H11001B)C′,first app ly (2-22) an d then (2-21) .
Example 1
[(A′/H11001B)C′]′/H11005(A′/H11001B)′/H11001(C′)′/H11005AB′/H11001C
[(AB′/H11001C)D′/H11001E]′/H11005[(AB′/H11001C)D′]′E′ (by (2-21))
Example 2/H11005[(AB′/H11001C)′/H11001D]E′(by (2-22))
/H11005[(AB′)′C′/H11001D]E′ (by (2-21))
/H11005[(A′/H11001B)C′/H11001D]E′(by (2-22)) (2-25)
Note that in the final expressions, the complement operation is applied only to sin-
gle variables.
48 Unit 2
The inverse of F/H11005A′B/H11001AB′is
F′/H11005(A′B/H11001AB′)′/H11005(A′B)′(AB′)′/H11005(A/H11001B′)(A′/H11001B)
/H11005AA′/H11001AB/H11001B′A′/H11001BB′/H11005A′B′/H11001AB
We will verify that this result is correct by constructing a truth table for Fand F′:
A B A ′BA B ′ F/H11005A′B/H11001AB′ A′B′ AB F ′/H11005A′B′/H11001AB
0 0 0 0 0 1 0 1
0 1 1 0 1 0 0 01 0 0 1 1 0 0 01 1 0 0 0 0 1 1
In the table, note that for every combination of values of Aand Bfor which F/H110050,
F′/H110051; and whenever F/H110051,F′/H110050.
Given a Boolean expression, the dual is formed by replacing AND with OR, OR
with AND, 0 with 1, and 1 with 0. Variables and complements are left unchanged.The dual of AND is OR and the dual of OR is AND:
(XYZ . . . )
D/H11005X/H11001Y/H11001Z/H11001... ( X/H11001Y/H11001Z/H11001... )D/H11005XYZ . . . (2-26)
The dual of an expression may be found by complementing the entire expression and
then complementing each individual variable. For example, to find the dual of AB′/H11001C,
(AB′/H11001C)′/H11005(AB′)′C′/H11005(A′/H11001B)C′,s o( AB′/H11001C)D/H11005(A/H11001B′)C
The laws and theorems of Boolean algebra on page 55 are listed in dual pairs. For
example,Theorem 11 is ( X/H11001Y′)Y/H11005XYand its dual is XY′/H11001Y/H11005X/H11001Y(Theorem 11D).
Problems
2.1 Prove the following theorems algebraically:
(a)X(X′/H11001Y)/H11005XY (b)X/H11001XY/H11005X
(c)XY/H11001XY′/H11005X (d) ( A/H11001B)(A/H11001B′)/H11005A
2.2 Illustrate the following theorems using circuits of switches:
(a)X/H11001XY/H11005X (b)X/H11001YZ/H11005(X/H11001Y)(X/H11001Z)
In each case, explain why the circuits are equivalent.
2.3 Simplify each of the following expressions by applying oneof the theorems. State
the theorem used (see page 55).(a)X′Y′Z/H11001(X′Y′Z)′ (b) ( AB′/H11001CD)(B′E/H11001CD)
(c)ACF /H11001AC′F (d)A(C
/H11001D′B)/H11001A′
(e) ( A′B/H11001C/H11001D)(A′B/H11001D) (f) ( A/H11001BC)/H11001(DE/H11001F)(A/H11001BC)′
2.4 For each of the following circuits, find the output and design a simpler circuit hav-
ing the same output. ( Hint: Find the circuit output by first finding the output of each
gate, going from left to right, and simplifying as you go.)
Boolean Algebra 49
2.5 Multiply out and simplify to obtain a sum of products:
(a) ( A/H11001B)(C/H11001B)(D′/H11001B)(ACD ′/H11001E)
(b) ( A′/H11001B/H11001C′)(A′/H11001C′/H11001D)(B′/H11001D′)
2.6 Factor each of the following expressions to obtain a product of sums:
(a)AB/H11001C′D′ (b)WX/H11001WY′X/H11001ZYX
(c)A′BC/H11001EF/H11001DEF ′ (d)XYZ /H11001W′Z/H11001XQ′Z
(e)ACD ′/H11001C′D′/H11001A′C (f)A/H11001BC/H11001DE
(The answer to (f) should be the product of four terms, each a sum of three variables.)
2.7 Draw a circuit that uses only one AND gate and one OR gate to realize each of the
following functions:
(a) ( A/H11001B/H11001C/H11001D)(A/H11001B/H11001C/H11001E)(A/H11001B/H11001C/H11001F)
(b)WXYZ /H11001VXYZ /H11001UXYZ
2.8 Simplify the following expressions to a minimum sum of products.
(a) [( AB)′/H11001C′D]′ (b) [ A/H11001B(C′/H11001D)]′ (c) (( A/H11001B′)C)′(A/H11001B)(C/H11001A)′
2.9 Find Fand Gand simplify:
A
A
TTGPFB
R
T
R
SS(a)
(b)+
+++
+A
B
A
BBBA
AYE F
DB
C1
(a)
(b)+
+
++++
50 Unit 2
2.10 Illustrate the following equations using circuits of switches:
(a)XY/H11001XY′/H11005X (b) ( X/H11001Y′)Y/H11005XY
(c)X/H11001X′ZY/H11005X/H11001YZ (d) ( A/H11001B)C/H11001(A/H11001B)C′/H11005A/H11001B
(e) ( X/H11001Y)(X/H11001Z)/H11005X/H11001YZ (f)X(X/H11001Y)/H11005X
2.11 Simplify each of the following expressions by applying one of the theorems. State
the theorem used.(a) ( A′/H11001B′/H11001C)(A′/H11001B′/H11001C)′ (b)AB(C′/H11001D)/H11001B(
C′/H11001D)
(c)AB/H11001(C′/H11001D)(AB)′ (d) ( A′BF/H11001CD′)(A′BF/H11001CEG )
(e) [ AB′/H11001(C/H11001D)′/H11001E′F](C/H11001D) (f) A′(B/H11001C)(D′E/H11001F)′/H11001(D′E/H11001F)
2.12 Simplify each of the following expressions by applying one of the theorems. State
the theorem used.(a) ( X/H11001Y′Z)/H11001(X/H11001Y′Z)′
(b) [ W/H11001X′(Y/H11001Z
)][W′/H11001X′(Y/H11001Z)]
(c) ( V′W/H11001UX)′(UX/H11001Y/H11001Z/H11001V′W)
(d) ( UV′/H11001W′X)(UV′/H11001W′X/H11001Y′Z)
(e) ( W′/H11001X)(Y/H11001Z′)/H11001(W′/H11001X)′(Y/H11001Z′)
(f) ( V′/H11001U/H11001W)[(W/H11001X)/H11001Y/H11001UZ′]/H11001[(W/H11001X)/H11001UZ′/H11001Y]
2.13 For each of the following circuits, find the output and design a simpler circuit that
has the same output. ( Hint: Find the circuit output by first finding the output of each
gate, going from left to right, and simplifying as you go).
A
BF1
F2
AA
BB
CD
A
BF3(b)(a)
(c)+++
++++
Boolean Algebra 51
2.14 Draw a circuit that uses only one AND gate and one OR gate to realize each of the
following functions:(a)ABCF /H11001ACEF /H11001ACDF
(b) ( V/H11001W/H11001Y/H11001Z)(U/H11001W/H11001Y/H11001Z)(W/H11001X/H11001Y/H11001Z)
2.15 Use only DeMorgan’s relationships and Involution to find the complements of the
following functions:(a)f(A,B,C,D) = [A/H11001(BCD )′][(AD)′/H11001B(C′/H11001A)]
(b)f(A,B,C,D) = AB′C/H11001(A′/H11001B/H11001D)(ABD ′/H11001B′)
2.16 Using justthe definition of the dual of a Boolean algebra expression, find the duals
of  the following expressions:(a)f
(A,B,C,D) = [A/H11001(BCD )′][(AD)′/H11001B(C′/H11001A)]
(b)f(A,B,C,D) = AB′C/H11001(A′/H11001B/H11001D)(ABD ′/H11001B′)
2.17 For the following switching circuit, find the logic function expression describing the cir-
cuit by the three methods indicated, simplify each expression, and show they are equal.(a) subdividing it into series and parallel connections of subcircuits until single
switches are obtained
(b) finding all paths through the circuit (sometimes called tie sets ), forming an AND
term for each path and ORing the AND terms together 
(c) finding all ways of breaking all paths through the circuit (sometimes called cut
sets), forming an OR term for each cut set and ANDing the OR terms together.
2.18 For each of the following Boolean (or switching) algebra expressions, indicate
which, if any, of the following terms describe the expression: product term, sum-of-products, sum term, and product-of-sums. (More than one may apply.)(a)X′Y (b)XY′/H11001YZ
(c) ( X′/H11001Y)(WX /H11001Z) (d) X/H11001Z
(e) ( X′/H11001Y)(W/H11001 Z
)(X/H11001Y′/H11001Z′)A
BC
DZ
A
BC(d)+
++
B′A′
C
C′B
A
2.19 Construct a gate circuit using AND, OR, and NOT gates that corresponds one to
one with the following switching algebra expression. Assume that inputs are avail-able only in uncomplemented form. (Do not change the expression.)
(WX′/H11001Y)[(W/H11001Z)′/H11001XYZ ′)]
2.20 For the following switch circuit:
(a) derive the switching algebra expression that corresponds one to one with the
switch circuit.
(b) derive an equivalent switch circuit with a structure consisting of a parallel
connection of groups of switches connected in series. (Use 9 switches.)
(c) derive an equivalent switch circuit with a structure consisting of a series
connection of groups of switches connected in parallel. (Use 6 switches.)
2.21 In the following circuit, F/H11005(A′/H11001B)C. Give a truth table for Gso that His as spec-
ified in its truth table. If Gcan be either 0 or 1 for some input combination, leave
its value unspecified.
2.22 Factor each of the following expressions to obtain a product of sums:
(a)A′B′/H11001A′CD/H11001A′DE′ (b)H′I′/H11001JK
(c)A′BC/H11001A′B′C/H11001CD′ (d)A′B′/H11001(CD′/H11001E)
(e)A′B′C/H11001
B′CD′/H11001EF′ (f)WX′Y/H11001W′X′/H11001W′Y′
2.23 Factor each of the following expressions to obtain a product of sums:
(a)W/H11001U′YV (b)TW/H11001UY′/H11001V
(c)A′B′C/H11001B′CD′/H11001B′E′ (d)ABC /H11001ADE ′/H11001ABF ′
2.24 Simplify the following expressions to a minimum sum of products. Only individual
variables should be complemented.(a) [( XY′)′/H11001(X′/H11001Y)′Z] (b) ( X/H11001(Y′(Z/H11001W)′)′)′
(c) [( A′/H11001B′)′/H11001
(A′B′C)′/H11001C′D]′ (d) ( A/H11001B)CD/H11001(A/H11001B)′52 Unit 2
+A F
GB
C
A
B
CHB′A′
C
A C′D
AB C H
00 0 0
00 1 1
01 0 1
01 1 110 0 010 1 111 0 0
11 1 1
Boolean Algebra 53
2.25 For each of the following functions find a sum-of-products expression for F′.
(a)F(P,Q,R,S) = ( R′/H11001PQ)S
(b)F(W,X,Y,Z) = X/H11001YZ(W/H11001X′)
(c)F(A,B,C,D) = A′/H11001B′/H11001ACD
2.26 Find F,G, and H, and simplify:
A
B
A
W
X
Y
ZB
CBC F
G
H(a)
(b)
(c)
++++
2.27 Draw a circuit that uses two OR gates and two AND gates to realize the following
function:
F/H11005(V/H11001W/H11001X)(V/H11001X/H11001Y)(V/H11001Z)
2.28 Draw a circuit to realize the function:
F/H11005ABC /H11001A′BC/H11001AB′C/H11001ABC ′
(a) using one OR gate and three AND gates. The AND gates should have 
two inputs.
(b) using two OR gates and two AND gates. All of the gates should have 
two inputs.
2.29 Prove the following equations using truth tables:
(a) ( X/H11001Y)(X′/H11001Z) = XZ/H11001X′Y
(b) ( X/H11001Y)(Y/H11001Z)(X′/H11001Z) = (X/H11001Y)(X′/H11001Z)
(c)XY/H11001YZ/H11001X′Z=XY/H11001X′Z
(d) ( A/H11001C)(AB/H11001C′) = AB/H11001AC′
(e)W′X Y /H11001WZ = (W′/H11001Z)(W/H11001XY)
(Note: Parts (a), (b), and (c) are theorems that will be introduced in Unit 3.)
2.30 Show that the following two gate circuits realize the same function.54 Unit 2
XY+X
Zf+ F
f+
f+
f+Y
Z
G(a)
(b)
Boolean Algebra 55
Laws and Theorems of Boolean Algebra
Operations with 0 and 1:
1.X/H110010/H11005X 1D. X/H110801/H11005X
2.X/H110011/H1100512 D . X/H110800/H110050
Idempotent laws:
3.X/H11001X/H11005X 3D. X/H11080X/H11005X
Involution law:
4. (X′)′/H11005X
Laws of complementarity:
5.X/H11001X′/H1100515 D . X/H11080X′/H110050
Commutative laws:
6.X/H11001Y/H11005Y/H11001X 6D. XY/H11005YX
Associative laws:
7. (X/H11001Y)/H11001Z/H11005X/H11001(Y/H11001Z)7 D . ( XY)Z/H11005X(YZ)/H11005XYZ
/H11005X/H11001Y/H11001Z
Distributive laws:
8.X(Y/H11001Z)/H11005XY/H11001XZ 8D. X/H11001YZ/H11005(X/H11001Y)(X/H11001Z)
Simplification theorems:
9.XY/H11001XY′/H11005X 9D. ( X/H11001Y)(X/H11001Y′)/H11005X
10.X/H11001XY/H11005X 10D. X(X/H11001Y)/H11005X
11. ( X/H11001Y′)Y/H11005XY 11D. XY′/H11001Y/H11005X/H11001Y
DeMorgan’s laws:
12. ( X/H11001Y/H11001Z/H11001... )′/H11005X′Y′Z′... 1 2 D . ( XYZ ... )′/H11005X′/H11001Y′/H11001Z′/H11001...
Duality:
13. ( X/H11001Y/H11001Z/H11001... )D/H11005XYZ ... 1 3 D . ( XYZ ... )D/H11005X/H11001Y/H11001Z/H11001...
Theorem for multiplying out and factoring:
14. ( X/H11001Y)(X′/H11001Z)/H11005XZ/H11001X′Y 14D. XY/H11001X′Z/H11005(X/H11001Z)(X′/H11001Y)
Consensus theorem:
15.XY/H11001YZ/H11001X′Z/H11005XY/H11001X′Z 15D. ( X/H11001Y)(Y/H11001Z)(X′/H11001Z)
/H11005(X/H11001Y) (X′/H11001Z)
56
Boolean Algebra (Continued)
Objectives
When you complete this unit, you should know from memory and be able to use
any of the laws and theorems of Boolean algebra listed at the end of Unit 2.Specifically, you should be able to
1.Apply these laws and theorems to the manipulation of algebraic expres-
sions including:
a.Simplifying an expression.
b.Finding the complement of an expression.
c.Multiplying out and factoring an expression.
2.Prove any of the theorems using a truth table or give an algebraic proof
if appropriate.
3.Define the exclusive-OR and equivalence operations. State, prove, and use
the basic theorems that concern these operations.
4.Use the consensus theorem to delete terms from and add terms to a
switching expression.
5.Given an equation, prove algebraically that it is valid or show that it is
not valid.UNIT
3
Boolean Algebra (Continued) 57
1.Study Section 3.1, Multiplying Out and Factoring Expressions.
(a) List three laws or theorems which are useful when multiplying out or factor-
ing expressions.
(b) Use Equation (3-3) to factor each of the following:
ab/H11032c/H11001bd/H11005
abc/H11001(ab)/H11032d/H11005
(c) In the following example, first group the terms so that (3-2) can be applied
two times.
F1/H11005(x/H11001y/H11032/H11001z)(w/H11032/H11001x/H11032/H11001y)(w/H11001x/H11001y/H11032)(w/H11032/H11001y/H11001z/H11032)
After applying (3-2), apply (3-3) and then finish multiplying out by using
(3-1).
If we did not use (3-2) and (3-3) and used only (3-1) on the original F1
expression, we would generate many more terms:
F1/H11005(w/H11032x/H11001w/H11032y/H11032/H11001w/H11032z/H11001/H11001 x/H11032y/H11032/H11001x/H11032z/H11001xy/H11001/H11001 yz)
( /H11001w/H11032x/H11001w/H11032y/H11032/H11001wy/H11001xy/H11001/H11001 wz/H11032/H11001xz/H11032/H11001y/H11032z/H11032)
/H11005(w/H11032x/H11001w/H11032xy/H11032/H11001w/H11032xz/H11001···  /H11001yzy/H11032z/H11032)
49 terms in all
This is obviously a very inefficient way to proceed! The moral to this story
is to first group the terms and apply (3-2) and (3-3) where possible.
(d) Work Programmed Exercise 3.1.Then work Problem 3.6, being careful not
to introduce any unnecessary terms in the process.
(e) In Unit 2 you learned how to factor a Boolean expression, using the two
distributive laws. In addition, this unit introduced use of the theorem
XY/H11001X/H11032Z/H11005(X/H11001Z)(X/H11032/H11001Y)
in the factoring process. Careful choice of the order in which these laws
and theorems are applied may cut down the amount of work required toyy/H11032 ww/H11032yy/H11032 xx/H11032Study Guide
¯˚˚˚˚˚˚˚˘˚˚˚˚˚˚˙
58 Unit 3
factor an expression. When factoring, it is best to apply Equation (3-1)
first, using as Xthe variable or variables which appear most frequently.
Then Equations (3-2) and (3-3) can be applied in either order, dependingon circumstances.
(f) Work Programmed Exercise 3.2. Then work Problem 3.7.
2.Checking your answers:
A good way to partially check your answers for correctness is to substitute 0’s
or 1’s for some of the variables. For example, if we substitute A/H110051 in the first
and last expression in Equation (3-5), we get
1 · C/H110010 · BD/H11032/H110010 · BE/H110010 · C/H11032DE/H11005(1/H11001B/H11001C/H11032)(1/H11001B/H11001D)
· (1/H11001B/H11001E)(1/H11001D/H11032/H11001E)(0/H11001C)
C/H110051 · 1 · 1 · 1 · C✓
Similarly, substituting A/H110050,B/H110050 we get
0/H110010/H110010/H11001C/H11032DE/H11005(0/H11001C/H11032)(0/H11001D)(0/H11001E)(D/H11032/H11001E)(1/H11001C)
/H11005C/H11032DE✓
Verify that the result is also correct when A
/H110050 and B/H110051.
3.The method which you use to get your answer is very important in this
unit. If it takes you two pages of algebra and one hour of time to work aproblem that can be solved in 10 minutes with three lines of work, you havenot learned the material in this unit! Even if you get the correct answer,your work is not satisfactory if you worked the problem by an excessivelylong and time-consuming method. It is important that you learn to solvesimple problems in a simple manner—otherwise, when you are asked tosolve a complex problem, you will get bogged down and never get theanswer. When you are given a problem to solve, do not just plunge in, butfirst ask yourself, “What is the easiest way to work this problem?” Forexample, when you are asked to multiply out an expression, do not just mul-tiply it out by brute force, term by term. Instead, ask yourself, “How can Igroup the terms and which theorems should I apply first in order to reducethe amount of work?” (See Study Guide Part 1.) After you have worked outProblems 3.6 and 3.7, compare your solutions with those in the solutionbook. If your solution required substantially more work than the one in thesolution book, rework the problem and try to get the answer in a morestraightforward manner.
4.Study Section 3.2, Exclusive-OR and Equivalence Operations.
(a) Prove Theorems (3-8) through (3-13). You should be able to prove these
both algebraically and by using a truth table.
(b) Show that ( xy/H11032/H11001x/H11032y)/H11032/H11005xy/H11001x/H11032y/H11032. Memorize this result.
(c) Prove Theorem (3-15).
(d) Show that ( x≡0)/H11005x/H11032,(x≡x)/H110051, and ( x≡y)/H11032/H11005(x≡y/H11032).
(e) Express ( x≡y)/H11032in terms of exclusive OR.
(f) Work Problems 3.8 and 3.9.
5.Study Section 3.3, The Consensus Theorem. The consensus theorem is an impor-
tant method for simplifying switching functions.
(a) In each of the following expressions, find the consensus term and 
eliminate it:
abc/H11032d/H11001a/H11032be/H11001bc/H11032de
(a/H11032/H11001b/H11001c)(a/H11001d)(b/H11001c/H11001d)
ab/H11032c/H11001a/H11032bd/H11001bcd/H11032/H11001a/H11032bc
(b) Eliminate two terms from the following expression by applying the con-
sensus theorem:
A/H11032B/H11032C/H11001BC/H11032D/H11032/H11001A/H11032CD/H11001AB/H11032D/H11032/H11001BCD /H11001AC/H11032D/H11032
(Hint: First, compare the first term with each of the remaining terms to
see if a consensus exists, then compare the second term with each of theremaining terms, etc.)Boolean Algebra (Continued) 59
60 Unit 3
(c) Study the example given in Equations (3-22) and (3-23) carefully. Now let
us start with the four-term form of the expression (Equation 3-22):
A/H11032C/H11032D/H11001A/H11032BD/H11001ABC /H11001ACD /H11032
Can this be reduced directly to three terms by the application of the con-
sensus theorem? Before we can reduce this expression, we must add anoth-er term. Which term can be added by applying the consensus theorem?
Add this term, and then reduce the expression to three terms. After this
reduction, can the term which was added be removed? Why not?
(d) Eliminate two terms from the following expression by applying the dual
consensus theorem:
(a/H11032/H11001c/H11032/H11001d)(a/H11032/H11001b/H11001c)(a/H11001b/H11001d)(a/H11032/H11001b/H11001d)(b/H11001c/H11032/H11001d)
Use brackets to indicate how you formed the consensus terms. ( Hint: First,
find the consensus of the first two terms and eliminate it.)
(e) Derive Theorem (3-3) by using the consensus theorem.
(f) Work Programmed Exercise 3.3. Then work Problem 3.10.
6.Study Section 3.4, Algebraic Simplification of Switching Expressions.
(a) What theorems are used for:
Combining terms?
Eliminating terms?Eliminating literals?Adding redundant terms?Factoring or multiplying out?
(b) Note that in the example of Equation (3-27), the redundant term WZ/H11032
was added and then was eliminated later after it had been used toeliminate another term. Why was it possible to eliminate WZ/H11032in this
example?
Boolean Algebra (Continued) 61
If a term has been added by the consensus theorem, it may not always
be possible to eliminate the term later by the consensus theorem. Why?
(c) You will need considerable practice to develop skill in simplifying switching
expressions. Work through Programmed Exercises 3.4 and 3.5.
(d) Work Problem 3.11.
(e) When simplifying an expression using Boolean algebra, two frequently
asked questions are(1) Where do I begin?(2) How do I know when I am finished?
In answer to (1), it is generally best to try simple techniques such as combiningterms or eliminating terms and literals before trying more complicated things suchas using the consensus theorem or adding redundant terms. Question (2) is gener-ally difficult to answer because it may be impossible to simplify some expressionswithout first adding redundant terms. We will usually tell you how many terms toexpect in the minimum solution so that you will not have to waste time trying tosimplify an expression which is already minimized. In Units 5 and 6, you will learnsystematic techniques which will guarantee finding the minimum solution.
7.Study Section 3.5, Proving Validity of an Equation.
(a) When attempting to prove that an equation is valid, is it permissible to add
the same expression to both sides? Explain.
(b) Work Problem 3.12.
(c) Show that (3-33) and (3-34) are true by considering both x/H110050 and x/H110051.
(d) Given that a/H11032(b/H11001d/H11032)/H11005a/H11032(b/H11001e/H11032), the following “proof” shows that d/H11005e:
a/H11032(b/H11001d/H11032)/H11005a/H11032(b/H11001e/H11032)
a/H11001b/H11032d/H11005a/H11001b/H11032e
b/H11032d/H11005b/H11032e
d/H11005e
State two things that are wrong with the “proof.” Give a set of values for
a, b, d, and ethat demonstrates that the result is incorrect.
8.Reread the objectives of this unit. When you take the readiness test, you will
be expected to know from memory the laws and theorems listed at the end ofUnit 2. Where appropriate, you should know them “forward and backward”;that is, given either side of the equation, you should be able to supply theother. Test yourself to see if you can do this. When you are satisfied that youcan meet the objectives, take the readiness test.
Boolean Algebra (Continued)
In this unit we continue our study of Boolean algebra to learn additional methods
for manipulating Boolean expressions. We introduce another theorem for multi-plying out and factoring that facilitates conversion between sum-of-products andproduct-of-sums expressions. These algebraic manipulations allow us to realize aswitching function in a variety of forms. The exclusive-OR and equivalence opera-tions are introduced along with examples of their use. The consensus theorem pro-vides a useful method for simplifying an expression. Then methods for algebraicsimplification are reviewed and summarized. The unit concludes with methods forproving the validity of an equation.
3.1 Multiplying Out and Factoring Expressions
Given an expression in product-of-sums form, the corresponding sum-of-prod-ucts expression can be obtained by multiplying out, using the two distributivelaws:
X(Y/H11001Z)/H11005XY/H11001XZ (3-1)
(X/H11001Y)(X/H11001Z)/H11005X/H11001YZ (3-2)
In addition, the following theorem is very useful for factoring and multiplying out:
(X/H11001Y)(X/H11032/H11001Z)/H11005XZ/H11001X/H11032Y (3-3)
Note that the variable that is paired with Xon one side of the equation is paired with
X/H11032on the other side, and vice versa.
Proof:IfX/H110050, (3-3) reduces to Y(1/H11001Z)/H110050/H110011 · YorY/H11005Y.
IfX/H110051, (3-3) reduces to (1 /H11001Y)Z/H11005Z/H110010 · YorZ/H11005Z.
Because the equation is valid for both X/H110050 and X/H110051, it is always valid.
The following example illustrates the use of Theorem (3-3) for factoring:
AB/H11001A/H11032C/H11005(A/H11001
C)(A/H11032/H11001B)¯˚˚˚˚˚˙
¯˚˚˚˙
¯˙¯˙
62
Boolean Algebra (Continued) 63
Note that the theorem can be applied when we have two terms, one which contains
a variable and another which contains its complement.
Theorem (3-3) is very useful for multiplying out expressions. In the following
example, we can apply (3-3) because one factor contains the variable Q,and the
other factor contains Q/H11032.
(Q/H11001AB/H11032)(C/H11032D/H11001Q/H11032)/H11005QC/H11032D/H11001Q/H11032AB/H11032
If we simply multiplied out by using the distributive law, we would get four terms
instead of two:
(Q/H11001AB/H11032)(C/H11032D/H11001Q/H11032)/H11005QC/H11032D/H11001QQ/H11032/H11001AB/H11032C/H11032D/H11001AB/H11032Q/H11032
Because the term AB/H11032C/H11032Dis difficult to eliminate, it is much better to use (3-3)
instead of the distributive law.
In general, when we multiply out an expression, we should use (3-3) along with
(3-1) and (3-2). To avoid generating unnecessary terms when multiplying out, (3-2)and (3-3) should generally be applied before (3-1), and terms should be grouped toexpedite their application.
(A/H11001B/H11001C/H11032)(A/H11001B/H11001D)(A/H11001B/H11001E)(A/H11001D/H11032/H11001E)(A
/H11032/H11001C)
Example
/H11005(A/H11001B/H11001C/H11032D)(A/H11001B/H11001E)[AC/H11001A/H11032(D/H11032/H11001E)]
/H11005(A/H11001B/H11001C/H11032DE)(AC/H11001A/H11032D/H11032/H11001A/H11032E)
/H11005AC/H11001ABC /H11001A/H11032BD/H11032/H11001A/H11032BE/H11001A/H11032C/H11032DE (3-4)
What theorem was used to eliminate ABC ? (Hint: letX/H11005AC.)
In this example, if the ordinary distributive law (3-1) had been used to multiply
out the expression by brute force, 162 terms would have been generated, and 158 of
these terms would then have to be eliminated.¯˚˚˚˚˚˚˙
¯˚˚˚˚˚˙
¯˚˚˙ ¯˚˚˚˚˚˚˚˙
¯˚˚˚˚˚˚˚˚˙
T
b
/H6114 /H6114 /H6114
¯˚˚˚˚˚˚˚˚˙/H6114/H6114
The same theorems that are useful for multiplying out expressions are useful for
factoring. By repeatedly applying (3-1), (3-2), and (3-3), any expression can be con-verted to a product-of-sums form.
AC/H11001A/H11032BD/H11032/H11001A/H11032BE/H11001A/H11032C/H11032DE
/H11005AC/H11001A/H11032(BD/H11032/H11001BE/H11001C/H11032DE)
XZ X /H11032 Y
/H11005(A/H11001BD/H11032/H11001BE/H11001C/H11032DE)(A/H11032/H11001C)
/H11005[A/H11001C/H11032DE/H11001B(D/H11032/H11001E)](A/H11032/H11001C)
XY ZExample of 
Factoring ¯˚˚˚˘˚˚˚˙/H20902
¯˘˙ ¯˚˘˚˙
64 Unit 3
XY X /H17053Y
00 0
01 1
10 111 0/H11005(A/H11001B/H11001C/H11032DE)(A/H11001/H11001 D/H11032/H11001E)(A/H11032/H11001C)
/H11005(A/H11001B/H11001C/H11032)(A/H11001B/H11001D)(A/H11001B/H11001E)(A/H11001D/H11032/H11001E)(A/H11032/H11001C) (3-5)
This is the same expression we started with in (3-4).
3.2 Exclusive-OR and Equivalence Operations
The exclusive-OR operation ( /H17053) is defined as follows:
0/H170530/H1100500  /H170531/H110051
1/H170530/H1100511  /H170531/H110050
The truth table for X/H17053YisC/H11032DE
From this table, we can see that X/H17053Y/H110051 iff X/H110051 or Y/H110051, but notboth. The
ordinary OR operation, which we have previously defined, is sometimes calledinclusive OR because X/H11001Y/H110051 iff X/H110051 or Y/H110051, or both.
Exclusive OR can be expressed in terms of AND and OR. Because X
/H17053Y/H110051
iffXis 0 and Yis 1 or Xis 1 and Yis 0, we can write
X/H17053Y/H11005X/H11032Y/H11001XY/H11032 (3-6)
The first term in (3-6) is 1 if X/H110050 and Y/H110051; the second term is 1 if X/H110051 and
Y/H110050. Alternatively, we can derive Equation (3-6) by observing that X/H17053Y/H110051 iff
X/H110051 or Y/H110051and X and Yare not both 1. Thus,
X/H17053Y/H11005(X/H11001Y)(XY)/H11032/H11005(X/H11001Y)(X/H11032/H11001Y/H11032)/H11005X/H11032Y/H11001XY/H11032 (3-7)
In (3-7), note that ( X Y)/H11032/H110051 if Xand Yare not both 1.
We will use the following symbol for an exclusive-OR gate:
+ +XX
YY
Boolean Algebra (Continued) 65
X≡YX
YThe following theorems apply to exclusive OR:
X/H170530/H11005X (3-8)
X/H170531/H11005X/H11032 (3-9)
X/H17053X/H110050 (3-10)
X/H17053X/H11032/H110051 (3-11)
X/H17053Y/H11005Y/H17053X(commutative law) (3-12)
(X/H17053Y)/H17053Z/H11005X/H17053(Y/H17053Z)/H11005X/H17053Y/H17053Z(associative law) (3-13)
X(Y/H17053Z)/H11005XY/H17053XZ(distributive law) (3-14)
(X/H17053Y)/H11032/H11005X/H17053Y/H11032/H11005X/H11032/H17053Y/H11005XY/H11001X/H11032Y/H11032 (3-15)
Any of these theorems can be proved by using a truth table or by replacing X/H17053Y
with one of the equivalent expressions from Equation (3-7). Proof of the distribu-tive law follows:
XY
/H17053XZ/H11005XY(XZ)/H11032/H11001(XY)/H11032XZ/H11005XY(X/H11032/H11001Z/H11032)/H11001(X/H11032/H11001Y/H11032)XZ
/H11005XYZ /H11032/H11001XY/H11032Z
/H11005X(YZ/H11032/H11001Y/H11032Z)/H11005X(Y/H17053Z)
The equivalence operation ( ≡) is defined by
(0≡0)/H110051( 0 ≡1)/H110050 (3-16)
(1≡0)/H110050( 1 ≡1)/H110051
The truth table for X≡Yis
XY X ≡Y
00 1
01 010 0
11 1
From the definition of equivalence, we see that ( X≡Y)/H110051 iff X/H11005Y.Because
(X≡Y)/H110051 iff X/H11005Y/H110051 or X/H11005Y/H110050, we can write
(X≡Y)/H11005XY/H11001X/H11032Y/H11032 (3-17)
Equivalence is the complement of exclusive-OR:
(X/H17053Y)/H11032/H11005(X/H11032Y/H11001XY/H11032)/H11032/H11005(X/H11001Y/H11032)(X/H11032/H11001Y)
/H11005XY/H11001X/H11032Y/H11032/H11005(X≡Y) (3-18)
Just as for exclusive-OR, the equivalence operation is commutative and associative.
We will use the following symbol for an equivalence gate:
66 Unit 3
+X
Y+(X Y)′ = (X≡Y)Because equivalence is the complement of exclusive-OR, an alternate symbol for
the equivalence gate is an exclusive-OR gate with a complemented output:
The equivalence gate is also called an exclusive-NOR gate.
In order to simplify an expression which contains AND and OR as well as
exclusive OR and equivalence, it is usually desirable to first apply (3-6) and (3-17)
to eliminate the /H17053and ≡operations. As an example, we will simplify
F/H11005(A/H11032B≡C)/H11001(B/H17053AC/H11032)
By (3-6) and (3-17),
F/H11005[(A/H11032B)C/H11001(A/H11032B)/H11032C/H11032]/H11001[B/H11032(AC/H11032)/H11001B(AC/H11032)/H11032]
/H11005A/H11032BC/H11001(A/H11001B/H11032)C/H11032/H11001AB/H11032C/H11032/H11001B(A/H11032/H11001C)
/H11005B(A/H11032C/H11001A/H11032/H11001C)/H11001C/H11032(A/H11001B/H11032/H11001AB/H11032)/H11005B(A/H11032/H11001C)/H11001C/H11032(A/H11001B/H11032)
When manipulating an expression that contains several exclusive-OR or equiv-
alence operations, it is useful to note that
(XY/H11032/H11001X/H11032Y)/H11032/H11005XY/H11001X/H11032Y/H11032 (3-19)
For example,
A/H11032/H17053B/H17053C/H11005[A/H11032B/H11032/H11001(A/H11032)/H11032B]/H17053C
/H11005(A/H11032B/H11032/H11001AB)C/H11032/H11001(A/H11032B/H11032/H11001AB)/H11032C (by (3-6))
/H11005(A/H11032B/H11032/H11001AB)C/H11032/H11001(A/H11032B/H11001AB/H11032)C (by (3-19))
/H11005A/H11032B/H11032C/H11032/H11001ABC /H11032/H11001A/H11032BC/H11001AB/H11032C
3.3 The Consensus Theorem
The consensus theorem is very useful in simplifying Boolean expressions. Given an
expression of the form XY/H11001X/H11032Z/H11001YZ, the term YZis redundant and can be elim-
inated to form the equivalent expression XY/H11001X/H11032Z.
The term that was eliminated is referred to as the consensus term . Given a pair
of terms for which a variable appears in one term and the complement of that vari-able in another, the consensus term is formed by multiplying the two original termstogether, leaving out the selected variable and its complement. For example, theconsensus of abanda/H11032cisbc;the consensus of abdandb/H11032de/H11032is (ad)(de/H11032)/H11005ade/H11032.T he
consensus of terms ab/H11032dand a/H11032bd/H11032is 0.
The consensus theorem can be stated as follows:
XY/H11001X/H11032Z/H11001YZ/H11005XY/H11001X/H11032Z (3-20)
Proof:
XY/H11001X/H11032Z/H11001YZ/H11005XY/H11001X/H11032Z/H11001(X/H11001X/H11032)YZ
/H11005(XY/H11001XYZ )/H11001(X/H11032Z/H11001X/H11032YZ)
/H11005XY(1/H11001Z)/H11001X/H11032Z(1/H11001Y)/H11005XY/H11001X/H11032Z
The consensus theorem can be used to eliminate redundant terms from Boolean
expressions. For example, in the following expression, b/H11032cis the consensus of a/H11032b/H11032and
ac,andabis the consensus of acandbc/H11032, so both consensus terms can be eliminated:
a/H11032b/H11032/H11001ac/H11001bc/H11032/H11001b/H11032c/H11001ab/H11005a/H11032b/H11032/H11001ac/H11001bc/H11032
The brackets indicate how the consensus terms are formed.
The dual form of the consensus theorem is
(X/H11001Y)(X/H11032/H11001Z)(Y/H11001Z)/H11005(X/H11001Y)(X/H11032/H11001Z) (3-21)
Note again that the key to recognizing the consensus term is to first find a pair of terms,
one of which contains a variable and the other its complement. In this case, the con-sensus is formed by adding this pair of terms together leaving out the selected variableand its complement. In the following expression, ( a/H11001b/H11001d/H11032) is a consensus term and
can be eliminated by using the dual consensus theorem:
(a/H11001b/H11001c/H11032)(a/H11001b/H11001d/H11032)(b/H11001c/H11001d/H11032)/H11005(a/H11001b/H11001c/H11032)(b/H11001c/H11001d/H11032)
The final result obtained by application of the consensus theorem may depend
on the order in which terms are eliminated.
A/H11032C/H11032D/H11001A/H11032BD/H11001/H11001 ABC /H11001ACD /H11032 (3-22)
Example
First, we eliminate BCD as shown. (Why can it be eliminated?)
Now that BCD has been eliminated, it is no longer there, and it cannot be used
to eliminate another term. Checking all pairs of terms shows that no additionalterms can be eliminated by the consensus theorem.
Now we start over again:
A/H11032C/H11032D/H11001/H11001 BCD /H11001/H11001 ACD /H11032 (3-23)
This time, we do not eliminate BCD; instead we eliminate two other terms by the
consensus theorem. After doing this, observe that BCD can no longer be eliminat-
ed. Note that the expression reduces to four terms if BCD is eliminated first, but
that it can be reduced to three terms if BCD is not eliminated.
Sometimes it is impossible to directly reduce an expression to a minimum number
of terms by simply eliminating terms. It may be necessary to first add a term using theconsensus theorem and then use the added term to eliminate other terms. For example,
consider the expression
F/H11005ABCD /H11001B/H11032CDE /H11001A/H11032B/H11032/H11001BCE /H11032ABC
A/H11032BDBCDBoolean Algebra (Continued) 67
TT
¸˚˚˛T
68 Unit 3
If we compare every pair of terms to see if a consensus term can be formed, we find
that the only consensus terms are ACDE (from ABCD and B/H11032CDE ) and A/H11032CE/H11032
(from A/H11032B/H11032and BCE /H11032). Because neither of these consensus terms appears in the
original expression, we cannot directly eliminate any terms using the consensus the-orem. However, if we first add the consensus term ACDE toF, we get
F/H11005ABCD /H11001B/H11032CDE /H11001A/H11032B/H11032/H11001BCE /H11032/H11001ACDE
Then, we can eliminate ABCD and B/H11032CDE using the consensus theorem, and F
reduces to
F/H11005A/H11032B/H11032/H11001BCE /H11032/H11001ACDE
The term ACDE is no longer redundant and cannot be eliminated from the final
expression.
3.4 Algebraic Simplification 
of Switching Expressions
In this section we review and summarize methods for simplifying switching expres-
sions, using the laws and theorems of Boolean algebra. This is important becausesimplifying an expression reduces the cost of realizing the expression using gates.Later, we will learn graphical methods for simplifying switching functions, but wewill learn algebraic methods first. In addition to multiplying out and factoring, threebasic ways of simplifying switching functions are combining terms, eliminatingterms, and eliminating literals.
1.Combining terms. Use the theorem XY/H11001XY/H11032/H11005Xto combine two terms. For
example,
abc/H11032d/H11032/H11001abcd /H11032/H11005abd/H11032 [X/H11005abd/H11032,Y/H11005c] (3-24)
When combining terms by this theorem, the two terms to be combined should con-
tain exactly the same variables, and exactly one of the variables should appear com-plemented in one term and not in the other. Because X/H11001X/H11005X,a given term may
be duplicated and combined with two or more other terms. For example,
ab/H11032c/H11001abc/H11001a/H11032bc/H11005ab/H11032c/H11001abc/H11001abc/H11001a/H11032bc/H11005ac/H11001bc
The theorem still can be used, of course, when XandYare replaced with more com-
plicated expressions. For example,
(a/H11001bc)(d/H11001e/H11032)/H11001a/H11032(b/H11032/H11001c/H11032)(d/H11001e/H11032)/H11005d/H11001e/H11032
[X
/H11005d/H11001e/H11032,Y/H11005a/H11001bc, Y /H11032/H11005a/H11032(b/H11032/H11001c/H11032)]
2.Eliminating terms. Use the theorem X/H11001XY/H11005Xto eliminate redundant terms
if possible; then try to apply the consensus theorem ( XY/H11001X/H11032Z/H11001YZ/H11005XY/H11001
X/H11032Z) to eliminate any consensus terms. For example,
a/H11032b/H11001a/H11032bc/H11005a/H11032b [X/H11005a/H11032b]
a/H11032bc/H11032/H11001bcd/H11001a/H11032bd/H11005a/H11032bc/H11032/H11001bcd [X/H11005c, Y /H11005bd, Z /H11005a/H11032b] (3-25)
3.Eliminating literals. Use the theorem X/H11001X/H11032Y/H11005X/H11001Yto eliminate redundant
literals. Simple factoring may be necessary before the theorem is applied.
A/H11032B/H11001A/H11032B/H11032C/H11032D/H11032/H11001ABCD /H11032/H11005A/H11032(B/H11001B/H11032C/H11032D/H11032)/H11001ABCD /H11032
Example/H11005A/H11032(B/H11001C/H11032D/H11032)/H11001ABCD /H11032
/H11005B(A/H11032/H11001ACD /H11032)/H11001A/H11032C/H11032D/H11032
/H11005B(A/H11032/H11001CD/H11032)/H11001A/H11032C/H11032D/H11032
/H11005A/H11032B/H11001BCD /H11032/H11001A/H11032C/H11032D/H11032 (3-26)
The expression obtained after applying steps 1, 2, and 3 will not necessarily
have a minimum number of terms or a minimum number of literals. If it does notand no further simplification can be made using steps 1, 2, and 3, the deliberateintroduction of redundant terms may be necessary before further simplificationcan be made.
4.Adding redundant terms. Redundant terms can be introduced in several ways
such as adding xx/H11032, multiplying by ( x/H11001x/H11032), adding yztoxy/H11001x/H11032z,or adding xy
tox.When possible, the added terms should be chosen so that they will combine
with or eliminate other terms.
WX /H11001XY/H11001X/H11032Z/H11032/H11001WY/H11032Z/H11032 (add WZ/H11032by consensus theorem)
Example/H11005WX /H11001XY/H11001X/H11032Z/H11032/H11001WY/H11032Z/H11032/H11001WZ/H11032 (eliminate WY/H11032Z/H11032)
/H11005WX /H11001XY/H11001X/H11032Z/H11032/H11001WZ/H11032 (eliminate WZ/H11032)
/H11005WX /H11001XY/H11001X/H11032Z/H11032 (3-27)Boolean Algebra (Continued) 69
The following comprehensive example illustrates the use of all four methods:
A/H11032B/H11032C/H11032D/H11032/H11001A/H11032BC/H11032D/H11032/H11001A/H11032BD/H11001/H11001 ABCD /H11001ACD /H11032/H11001B/H11032CD/H11032 A/H11032BC/H11032D
Example
/H11005A/H11032C/H11032D/H11032/H11001BD(A /H11032/H11001AC) /H11001ACD /H11032/H11001B/H11032CD/H11032
/H11005A/H11032C/H11032D/H11032/H11001A/H11032BD/H11001BCD /H11001ACD /H11032/H11001B/H11032CD/H11032¯˚˚˚˘˚˚˙
¯˚˘˚ ˙① A/H11032C/H11032D/H11032
/H11001ABC➃➁
➂
70 Unit 3
(A/H11032+ B/H11032/H11001C/H11032)(A/H11032/H11001B/H11032/H11001C)(B /H11032/H11001C)(A /H11001C)(A /H11001B/H11001C)
Example
/H11005(A/H11032/H11001B/H11032)(B/H11032/H11001C)(A/H11001C)/H11005(A/H11032/H11001B/H11032)(A/H11001C) (3-29)¯˚˚˚˘˚˚˚˚˙
➀ (A/H11032/H11001B/H11032)➁What theorems were used in steps 1, 2, 3, and 4?/H11005A/H11032C/H11032D/H11032/H11001A/H11032BD/H11001/H11001 /H11001 B/H11032CD/H11032/H11001ABC
/H11005A/H11032C/H11032D/H11032/H11001A/H11032BD/H11001B/H11032CD/H11032/H11001ABC (3-28)ACD /H11032 BCD ¯˚˚˚˚˚˚˘˚˚˚˚˚˚˙
consensus BCD
¯˚˘˚˙
If the simplified expression is to be left in a product-of-sums form instead of a
sum-of-products form, the duals of the preceding theorems should be applied.
What theorems were used in steps 1, 2, and 3?
In general, there is no easy way of determining when a Boolean expression has a
minimum number of terms or a minimum number of literals. Systematic methods forfinding minimum sum-of-products and minimum product-of-sums expressions will bediscussed in Units 5 and 6.
3.5 Proving Validity of an Equation
Often we will need to determine if an equation is valid for all combinations of valuesof the variables. Several methods can be used to determine if an equation is valid:
1.Construct a truth table and evaluate both sides of the equation for all combi-
nations of values of the variables. (This method is rather tedious if the numberof variables is large, and it certainly is not very elegant.)
2.Manipulate one side of the equation by applying various theorems until it is
identical with the other side.
3.Reduce both sides of the equation independently to the same expression.
4.It is permissible to perform the same operation on both sides of the equation pro-
vided that the operation is reversible. For example, it is all right to complementboth sides of the equation, but it is notpermissible to multiply both sides of the
equation by the same expression. (Multiplication is not reversible because divi-
sion is not defined for Boolean algebra.) Similarly, it is notpermissible to add
the same term to both sides of the equation because subtraction is not definedfor Boolean algebra.consensus ACD /H11032
➂
To prove that an equation is notvalid, it is sufficient to show one combination of
values of the variables for which the two sides of the equation have different values.When using method 2 or 3 above to prove that an equation is valid, a useful strat-egy is to
1.First reduce both sides to a sum of products (or a product of sums).
2.Compare the two sides of the equation to see how they differ.
3.Then try to add terms to one side of the equation that are present on the other side.
4.Finally try to eliminate terms from one side that are not present on the other.
Whatever method is used, frequently compare both sides of the equation and let the
difference between them serve as a guide for what steps to take next.
Show that
Example 1
A/H11032BD/H11032/H11001BCD /H11001ABC /H11032/H11001AB/H11032D/H11005BC/H11032D/H11032/H11001AD/H11001A/H11032BC
Starting with the left side, we first add consensus terms, then combine terms, and
finally eliminate terms by the consensus theorem.Boolean Algebra (Continued) 71
A/H11032BD/H11032/H11001BCD /H11001ABC /H11032/H11001AB/H11032D
/H11005A/H11032BD/H11032/H11001BCD /H11001ABC /H11032/H11001AB/H11032D/H11001BC/H11032D/H11032/H11001A/H11032BC/H11001ABD
(add consensus of A/H11032BD/H11032and ABC /H11032)
(add consensus of A/H11032BD/H11032and BCD )
(add consensus of BCD and ABC /H11032)
/H11005AD/H11001A/H11032BD/H11032/H11001BCD /H11001ABC /H11032/H11001BC/H11032D/H11032/H11001A/H11032BC/H11005BC/H11032D/H11032/H11001AD/H11001A/H11032BC
(eliminate consensus of BC/H11032D/H11032and AD)
(eliminate consensus of AD and A/H11032BC)
(eliminate consensus of BC/H11032D/H11032and A/H11032BC) (3-30)
Show that the following equation is valid:
Example 2A/H11032BC/H11032D/H11001(A/H11032/H11001BC)(A/H11001C/H11032D/H11032)/H11001BC/H11032D/H11001A/H11032BC/H11032
/H11005ABCD /H11001A/H11032C/H11032D/H11032/H11001ABD /H11001ABCD /H11032/H11001BC/H11032D
First, we will reduce the left side:
A/H11032BC/H11032D/H11001(A/H11032/H11001BC)(A/H11001C/H11032D/H11032)/H11001BC/H11032D/H11001A/H11032BC/H11032
(eliminate A/H11032BC/H11032Dusing (2-13))
/H11005(A/H11032/H11001BC)(A/H11001C/H11032D/H11032)/H11001BC/H11032D/H11001A/H11032BC/H11032
(multiply out using (3-3))
/H11005ABC /H11001A/H11032C/H11032D/H11032/H11001BC/H11032D/H11001A/H11032BC/H11032
(eliminate A/H11032BC/H11032by consensus)
/H11005ABC /H11001A/H11032C/H11032D/H11032/H11001BC/H11032D
72 Unit 3
Now we will reduce the right side:
/H11005ABCD /H11001A/H11032C/H11032D/H11032/H11001ABD /H11001ABCD /H11032/H11001BC/H11032D
(combine ABCD and ABCD /H11032)
/H11005ABC /H11001A/H11032C/H11032D/H11032/H11001ABD /H11001BC/H11032D
(eliminate ABD by consensus)
/H11005ABC /H11001A/H11032C/H11032D/H11032/H11001BC/H11032D
Because both sides of the original equation were independently reduced to the
same expression, the original equation is valid.
As we have previously observed, some of the theorems of Boolean algebra are
not true for ordinary algebra. Similarly, some of the theorems of ordinary algebraarenottrue for Boolean algebra. Consider, for example, the cancellation law for
ordinary algebra:
Ifx/H11001y/H11005x/H11001z, then y/H11005z (3-31)
The cancellation law is nottrue for Boolean algebra. We will demonstrate this by
constructing a counterexample in which x/H11001y/H11005x/H11001zbuty/H11014z.Letx/H110051,y/H110050,
z/H110051. Then,
1/H110010/H110051/H110011 but 0/H110141
In ordinary algebra, the cancellation law for multiplication is
Ifxy/H11005xz, then y/H11005z (3-32)
This law is valid provided x/H110140.
In Boolean algebra, the cancellation law for multiplication is also notvalid
when x/H110050. (Let x/H110050,y/H110050,z/H110051; then 0 · 0 /H110050 · 1, but 0 /H110141). Because x/H110050
about half of the time in switching algebra, the cancellation law for multiplicationcannot be used.
Even though Statements (3-31) and (3-32) are generally false for Boolean alge-
bra, the converses
Ify/H11005z, then x/H11001y
/H11005x/H11001z (3-33)
Ify/H11005z, then xy/H11005xz (3-34)
are true. Thus, we see that although adding the same term to both sides of a
Boolean equation leads to a valid equation, the reverse operation of canceling orsubtracting a term from both sides generally does not lead to a valid equation.Similarly, multiplying both sides of a Boolean equation by the same term leads toa valid equation, but not conversely. When we are attempting to prove that anequation is valid, it is notpermissible to add the same expression to both sides of
the equation or to multiply both sides by the same expression, because these oper-ations are not reversible.
Programmed Exercise 3.1
Cover the answers to this exercise with a sheet of paper and slide it down as you
check your answers. Write your answer in the space provided before looking at thecorrect answer.
The following expression is to be multiplied out to form a sum of products:
(A/H11001B/H11001C/H11032)(A/H11032/H11001B/H11032/H11001D)(A/H11032/H11001C/H11001D/H11032)(A/H11001C/H11032/H11001D)
First, find a pair of sum terms which have two literals in common and apply the sec-
ond distributive law. Also, apply the same law to the other pair of terms.
Answer (A/H11001C/H11032/H11001BD)[A/H11032/H11001(B/H11032/H11001D)(C/H11001D/H11032)]
(Note: This answer was obtained by using ( X/H11001Y)(X/H11001Z)/H11005X/H11001YZ.)
Next, find a pair of sum terms which have a variable in one and its complement in
the other. Use the appropriate theorem to multiply these sum terms together with-out introducing any redundant terms. Apply the same theorem a second time.
Answer (A/H11001C/H11032/H11001BD)(A/H11032/H11001B/H11032D/H11032/H11001CD)/H11005A(B/H11032D/H11032/H11001CD)/H11001A/H11032(C/H11032/H11001BD) or 
A(B/H11032/H11001D)(C/H11001D/H11032)/H11001A/H11032(C/H11032/H11001BD)/H11005A(B/H11032D/H11032/H11001CD)/H11001A/H11032(C/H11032/H11001BD)
(Note: This answer was obtained using ( X/H11001Y)(X/H11032/H11001Z)/H11005XZ/H11001X/H11032Y.)
Complete the problem by multiplying out using the ordinary distributive law.
Final Answer AB/H11032D/H11032/H11001ACD /H11001A/H11032C/H11032/H11001A/H11032BD
Programmed Exercise 3.2
Cover the answers to this exercise with a sheet of paper and slide it down as you
check your answers. Write your answer in the space provided before looking at thecorrect answer.
The following expression is to be factored to form a product of sums:
WXY /H11032/H11001W/H11032X/H11032Z/H11001WY/H11032Z/H11001W/H11032YZ/H11032
First, factor as far as you can using the ordinary distributive law.Boolean Algebra (Continued) 73
Answer WY/H11032(X/H11001Z)/H11001W/H11032(X/H11032Z/H11001YZ/H11032)
Next, factor further by using a theorem which involves a variable and its comple-
ment. Apply this theorem twice.
Answer (W/H11001X/H11032Z/H11001YZ/H11032)[W/H11032/H11001Y/H11032(X/H11001Z)]
/H11005[W/H11001(X/H11032/H11001Z/H11032)(Y/H11001Z)][W/H11032/H11001Y/H11032(X/H11001Z)]
or WY/H11032(X/H11001Z)/H11001W/H11032(X/H11032/H11001Z/H11032)(Y/H11001Z)
/H11005[W/H11001(X/H11032/H11001Z/H11032)(Y/H11001Z)][W/H11032/H11001Y/H11032(X/H11001Z)]
[Note: This answer was obtained by using AB/H11001A/H11032C/H11005(A/H11001C)(A/H11032/H11001B).]
Now, complete the factoring by using the second distributive law.
Final answer (W/H11001X/H11032/H11001Z/H11032)(W/H11001Y/H11001Z)(W/H11032/H11001Y/H11032)(W/H11032/H11001X/H11001Z)
Programmed Exercise 3.3
Cover the answers to this exercise with a sheet of paper and slide it down as you
check your answers. Write your answer in the space provided before looking at thecorrect answer.
The following expression is to be simplified using the consensus theorem:
AC/H11032/H11001AB/H11032D/H11001A/H11032B/H11032C/H11001A/H11032CD/H11032/H11001B/H11032C/H11032D/H11032
First, find all of the consensus terms by checking all pairs of terms.
Answer The consensus terms are indicated.
A/H11032B/H11032D/H11032
AC/H11032/H11001AB/H11032D/H11001A/H11032B/H11032C/H11001A/H11032CD/H11032/H11001B/H11032C/H11032D/H11032
B/H11032CD A /H11032B/H11032D/H11032
AB/H11032C/H11032 74 Unit 3
Can the original expression be simplified by the direct application of the con-
sensus theorem?
Answer No, because none of the consensus terms appears in the original expression.
Now add the consensus term B/H11032CDto the original expression. Compare the added
term with each of the original terms to see if any consensus exists. Eliminate asmany of the original terms as you can.
AnswerBoolean Algebra (Continued) 75
AC/H11032/H11001AB/H11032D/H11001A/H11032B/H11032C/H11001A/H11032CD/H11032/H11001B/H11032C/H11032D/H11032/H11001B/H11032CD¸˚˚˚˚˚˚˚˚˝˚˚˚˚˚˚˚˚˛
¯˚˚˚˘˚˚˚˙(AB/H11032D)
(A/H11032B/H11032C)
Now that we have eliminated two terms, can B/H11032CDalso be eliminated? What is the
final reduced expression?
Answer No, because the terms used to form B/H11032CDare gone. Final answer is
AC/H11032/H11001A/H11032CD/H11032/H11001B/H11032C/H11032D/H11032/H11001B/H11032CD
Programmed Exercise 3.4
Keep the answers to this exercise covered with a sheet of paper and slide it down as
you check your answers.
Problem: The following expression is to be simplified
ab/H11032cd/H11032e/H11001acd/H11001acf/H11032gh/H11032/H11001abcd /H11032e/H11001acde /H11032/H11001e/H11032h/H11032
State a theorem which can be used to combine a pair of terms and apply it to com-
bine two of the terms in the above expression.
Answer Apply XY/H11001XY/H11032/H11005Xto the terms ab/H11032cd/H11032eand abcd /H11032e,which reduces the 
expression to
acd/H11032e/H11001acd/H11001acf/H11032gh/H11032/H11001acde /H11032/H11001e/H11032h/H11032
76 Unit 3
Now state a theorem (other than the consensus theorem) which can be used to elim-
inate terms and apply it to eliminate a term in this expression.
Answer Apply X/H11001X Y /H11005Xto eliminate acde /H11032. (What term corresponds to X?) The result is
acd/H11032e/H11001acd/H11001acf/H11032gh/H11032/H11001e/H11032h/H11032
Now state a theorem that can be used to eliminate literals and apply it to elimi-
nate a literal from one of the terms in this expression. ( Hint : It may be necessary
to factor out some common variables from a pair of terms before the theorem canbe applied.)
Answer Use X/H11001X/H11032Y/H11005X/H11001Yto eliminate a literal from acd/H11032e.To do this, first factor ac
out of the first two terms: acd/H11032e/H11001acd/H11005ac(d/H11001d/H11032e). After eliminating d/H11032, the
resulting expression is
ace/H11001acd/H11001acf/H11032gh/H11032/H11001e/H11032h/H11032
(a) Can any term be eliminated from this expression by the direct application of the
consensus theorem?
(b) If not, add a redundant term using the consensus theorem, and use this redun-
dant term to eliminate one of the other terms.
(c) Finally, reduce your expression to three terms.
Answer (a) No(b) Add the consensus of aceand e/H11032h/H11032:
ace/H11001acd/H11001acf/H11032gh/H11032/H11001e/H11032h/H11032/H11001ach/H11032
Now eliminate acf/H11032gh/H11032(byX/H11001XY/H11005X)
ace/H11001acd/H11001e/H11032h/H11032/H11001ach/H11032
(c) Now eliminate ach/H11032by the consensus theorem. The final answer is
ace/H11001acd/H11001e/H11032h/H11032
Programmed Exercise 3.5
Keep the answers to this exercise covered with a sheet of paper and slide it down as
you check your answers.
Z/H11005(A/H11001C/H11032/H11001F/H11032/H11001G)(A/H11001C/H11032/H11001F/H11001G)(A/H11001B/H11001C/H11032/H11001D/H11032/H11001G)
(A/H11001C/H11001E/H11001G)(A/H11032/H11001B/H11001G)(B/H11001C/H11032/H11001F/H11001G)
This is to be simplified to the form
(X/H11001X/H11001X)(X/H11001X/H11001X)(X/H11001X/H11001X)
where each Xrepresents a literal.
State a theorem which can be used to combine the first two sum terms of Zand
apply it. ( Hint: The two sum terms differ in only one variable.)
Answer (X/H11001Y)(X/H11001Y/H11032)/H11005X
Z/H11005(A/H11001C/H11032/H11001G)(A/H11001B/H11001C/H11032/H11001D/H11032/H11001G)(A/H11001C/H11001E/H11001G)(A/H11032/H11001B/H11001G)
(B/H11001C/H11032/H11001F/H11001G)
Now state a theorem (other than the consensus theorem) which can be used to
eliminate a sum term and apply it to this expression.
Answer X(X/H11001Y)/H11005X
Z/H11005(A/H11001C/H11032/H11001G)(A/H11001C/H11001E/H11001G)(A/H11032/H11001B/H11001G)(B/H11001C/H11032/H11001F/H11001G)
Next, eliminate one literal from the second term, leaving the expression oth-
erwise unchanged. ( Hint :This cannot be done by the direct application of one the-
orem; it will be necessary to partially multiply out the first two sum terms beforeeliminating the literal.)
Answer (A/H11001C/H11032/H11001G)(A/H11001C/H11001E/H11001G)/H11005A/H11001G/H11001C/H11032(C/H11001E)/H11005A/H11001G/H11001C/H11032E
Therefore,
Z/H11005(A/H11001C/H11032/H11001G)(A/H11001E/H11001G)(A/H11032/H11001B/H11001G)(B/H11001C/H11032/H11001F/H11001G)Boolean Algebra (Continued) 77
78 Unit 3
(a) Can any term be eliminated from this expression by the direct application of the
consensus theorem?
(b) If not, add a redundant sum term using the consensus theorem, and use this
redundant term to eliminate one of the other terms.
(c) Finally, reduce your expression to a product of three sum terms.
Answer (a) No(b) Add B/H11001C/H11032/H11001G(consensus of A/H11001C/H11032/H11001Gand A/H11032/H11001B/H11001G).
Use X(X/H11001Y)/H11005X,where X/H11005B/H11001C/H11032/H11001G,to eliminate B/H11001C/H11032/H11001F/H11001G.
(c) Now eliminate B/H11001C/H11032/H11001Gby consensus. The final answer is
Z/H11005(A/H11001C/H11032/H11001G) (A/H11001E/H11001G) (A/H11032/H11001B/H11001G)
Problems
3.6 In each case, multiply out to obtain a sum of products: (Simplify where possible.)
(a) ( W/H11001X/H11032/H11001Z/H11032) (W/H11032/H11001Y/H11032) (W/H11032/H11001X/H11001Z/H11032) (W/H11001X/H11032) (W/H11001Y/H11001Z)
(b) ( A/H11001B/H11001C/H11001D) (A/H11032/H11001B/H11032/H11001C/H11001D/H11032) (A/H11032/H11001C) (A/H11001D) (B/H11001C/H11001D)
3.7 Factor to obtain a product of sums. (Simplify where possible.)
(a)BCD /H11001C/H11032D/H11032/H11001B/H11032C/H11032D/H11001CD
(b)A/H11032C/H11032D/H11032/H11001ABD /H11032/H11001A/H11032CD/H11001B/H11032D
3.8 Write an expression for Fand simplify.
F
+A
DDBA
+
3.9 Is the following distributive law valid? A/H17053BC/H11005(A/H17053B)(A/H17053C) Prove your answer.
3.10 (a) Reduce to a minimum sum of products (three terms):
(X/H11001W) (Y/H17053Z)/H11001XW/H11032
(b) Reduce to a minimum sum of products (four terms):
(A/H17053BC)/H11001BD/H11001ACD
(c) Reduce to a minimum product of sums (three terms):
(A/H11032/H11001C/H11032/H11001D/H11032) (A/H11032/H11001B/H11001C/H11032) (A/H11001B/H11001D) (A/H11001C/H11001D)
Boolean Algebra (Continued) 79
3.11 Simplify algebraically to a minimum sum of products (five terms):
(A/H11001B/H11032/H11001C/H11001E/H11032) (A/H11001B/H11032/H11001D/H11032/H11001E) (B/H11032/H11001C/H11032/H11001D/H11032/H11001E/H11032)
3.12 Prove algebraically that the following equation is valid:
A/H11032CD/H11032E/H11001A/H11032B/H11032D/H11032/H11001ABCE /H11001ABD /H11005A/H11032B/H11032D/H11032/H11001ABD /H11001BCD /H11032E
3.13 Simplify each of the following expressions:
(a)KLMN /H11032/H11001K/H11032L/H11032MN /H11001MN/H11032
(b)KL/H11032M/H11032/H11001MN/H11032/H11001LM/H11032N/H11032
(c) ( K/H11001L/H11032)(K/H11032/H11001L/H11032/H11001N)(L/H11032/H11001M/H11001N/H11032)
(d) ( K/H11032/H11001L/H11001M/H11032/H11001N)(K/H11032/H11001M/H11032/H11001N/H11001R)(K/H11032/H11001M/H11032/H11001N/H11001R/H11032)KM
3.14 Factor to obtain a product of sums:
(a)K/H11032L/H11032M/H11001KM/H11032N/H11001KLM /H11001LM/H11032N/H11032(four terms)
(b)KL/H11001K/H11032L/H11032/H11001L/H11032M/H11032N/H11032/H11001LMN /H11032 (four terms)
(c)KL/H11001K/H11032L/H11032M/H11001L/H11032M/H11032N/H11001LM/H11032N/H11032 (four terms)
(d)K/H11032M/H11032N/H11001KL/H11032N/H11032/H11001K/H11032MN/H11032/H11001LN (four terms)
(e)WXY /H11001WX/H11032Y/H11001WYZ /H11001XYZ /H11032 (three terms)
3.15 Multiply out to obtain a sum of products:
(a) ( K/H11032/H11001M/H11032/H11001N)(K/H11032/H11001M)(L/H11001M/H11032/H11001N/H11032)(K/H11032/H11001L/H11001M)(M/H11001N) (three terms)
(b) ( K/H11032/H11001L/H11032/H11001M/H11032)(K/H11001M/H11001N/H11032)(K/H11001L)(K/H11032/H11001N)(K/H11032/H11001M/H11001N)
(c) ( K/H11032/H11001L/H11032/H11001M)(K/H11001N/H11032)(K/H11032/H11001L/H11001N/H11032)(K/H11001L)(K/H11001M/H11001N/H11032)
(d) ( K/H11001L/H11001M)(K/H11032/H11001L/H11032/H11001N/H11032)(K/H11032/H11001L/H11032/H11001M/H11032)(K/H11001L/H11001N)
(e) ( K/H11001L/H11001M)(K/H11001M/H11001N)(K/H11032/H11001L/H11032/H11001M/H11032)(K/H11032/H11001M/H11032/H11001N/H11032)
3.16 Eliminate the exclusive-OR, and then factor to obtain a minimum product of sums:
(a) ( KL/H17053M)/H11001M/H11032N/H11032
(b)M/H11032(K/H17053N/H11032)/H11001MN /H11001K/H11032N
3.17 Algebraically prove identities involving the equivalence (exclusive-NOR) operation:
(a)x/H110130/H11005x/H11032
(b)x/H110131/H11005x
(c)x/H11013x/H110051
(d)x/H11013x/H11032/H110050
(e)x/H11013y/H11005y/H11013x
(f) ( x/H11013y)/H11013z/H11005x/H11013(y/H11013z)
(g) ( x/H11013y)/H11032/H11005x/H11032/H11013y/H11005x/H11013y/H11032
3.18 Algebraically prove identities involving the exclusive-OR operation:
(a)x/H170530/H11005x
(b)x/H170531/H11005x/H11032
(c)x/H17053x/H110050
(d)x/H17053x/H11032/H110051
(e)x/H17053y/H11005y/H17053x
(f) ( x/H17053y)/H17053z/H11005x/H17053(y/H17053z)
(g) ( x/H17053y)/H11032/H11005x/H11032/H17053y/H11005x/H17053y/H11032
80 Unit 3
3.19 Algebraically prove the following identities:
(a)x/H11001y/H11005x/H17053y/H17053xy
(b)x/H11001y/H11005x/H11013y/H11013xy
3.20 Algebraically prove or disprove the following distributive identities:
(a)x(y/H17053z)/H11005xy/H17053xz
(b)x/H11001(y/H17053z)/H11005(x/H11001y)/H17053(x/H11001z)
(c)x(y/H11013z)/H11005xy/H11013xz
(d)x/H11001(y/H11013z)/H11005(x/H11001y)/H11013(x/H11001z)
3.21 Simplify each of the following expressions using only the consensus theorem (or its
dual):(a)BC/H11032D/H11032/H11001ABC /H11032/H11001AC/H11032D/H11001AB/H11032D/H11001A/H11032BD/H11032(reduce to three terms)
(b)W/H11032Y/H11032/H11001WYZ /H11001XY/H11032Z/H11001WX/H11032Y(reduce to three terms)
(c) ( B/H11001C/H11001D)(A/H11001B/H11001C)(A/H11032/H11001C/H11001D)(B/H11032/H11001C/H11032/H11001D/H11032)
(d)W
/H11032XY/H11001WXZ /H11001WY/H11032Z/H11001W/H11032Z/H11032
(e)A/H11032BC/H11032/H11001BC/H11032D/H11032/H11001A/H11032CD/H11001B/H11032CD/H11001A/H11032BD
(f) ( A/H11001B/H11001C)(B/H11001C/H11032/H11001D)(A/H11001B/H11001D)(A/H11032/H11001B/H11032/H11001D/H11032)
3.22 Factor Z/H11005ABC /H11001DE/H11001ACF /H11001AD/H11032/H11001AB/H11032E/H11032and simplify it to the form ( X/H11001
X) (X/H11001X)(X/H11001X/H11001X/H11001X) (where each Xrepresents a literal). Now express Z
as a minimum sum of products in the form:
XX/H11001XX/H11001XX/H11001XX
3.23 Repeat Problem 3.22 for F/H11005A/H11032B/H11001AC/H11001BC/H11032D/H11032/H11001BEF /H11001BDF.
3.24 Factor to obtain a product of four terms and then reduce to three terms by applying
the consensus theorem: X/H11032Y/H11032Z/H11032/H11001XYZ
3.25 Simplify each of the following expressions:
(a)xy/H11001x/H11032yz/H11032/H11001yz
(b) ( xy/H11032/H11001z)(x/H11001y/H11032)z
(c)xy/H11032/H11001z/H11001(x/H11032/H11001y)z/H11032
(d)a/H11032d(b/H11032/H11001c)/H11001a/H11032d/H11032(b/H11001c/H11032)/H11001(b/H11032/H11001c)(b/H11001c/H11032)
(e)w/H11032x/H11032/H11001x/H11032y/H11032/H11001yz/H11001w/H11032z/H11032
(f)A/H11032BCD /H11001A/H11032BC/H11032D/H11001B/H11032EF/H11001CDE /H11032G/H11001A/H11032DEF /H11001A/H11032B/H11032EF(reduce to a sum
of three terms)
(g) [( a/H11032/H11001d/H11032/H11001b/H11032c)(b/H11001d/H11001ac/H11032)]/H11032/H11001b/H11032c/H11032d/H11032/H11001a/H11032c/H11032d(reduce to three terms)
3.26 Simplify to a sum of three terms:
(a)A/H11032C/H11032D/H11032/H11001AC/H11032/H11001BCD /H11001A/H11032CD/H11032/H11001A/H11032BC/H11001AB/H11032C/H11032
(b)A/H11032B/H11032C/H11032/H11001ABD /H11001A/H11032C/H11001A/H11032CD/H11032/H11001AC/H11032D/H11001AB/H11032C/H11032
3.27 Reduce to a minimum sum of products:
F/H11005WXY /H11032/H11001(W/H11032Y/H11032≡X)/H11001(Y/H17053WZ).
Boolean Algebra (Continued) 81
3.28 Determine which of the following equations are always valid (give an algebraic
proof):(a)a/H11032b/H11001b/H11032c/H11001c/H11032a/H11005ab/H11032/H11001bc/H11032/H11001ca/H11032
(b) ( a/H11001b)(b/H11001c)(c/H11001a)/H11005(a/H11032/H11001b/H11032)(b/H11032/H11001c/H11032)(c/H11032/H11001a/H11032)
(c)abc/H11001ab/H11032c/H11032/H11001b/H11032cd/H11001bc/H11032d/H11001ad/H11005abc/H11001ab/H11032c/H11032/H11001b/H11032cd/H11001bc/H11032d
(d)xy/H11032/H11001x/H11032z/H11001yz/H11032/H11005x/H11032y/H11001xz/H11032/H11001y/H11032z
(e) ( x
/H11001y)(y/H11001z)(x/H11001z)/H11005(x/H11032/H11001y/H11032)(y/H11032/H11001z/H11032)(x/H11032/H11001z/H11032)
(f)abc/H11032/H11001ab/H11032c/H11001b/H11032c/H11032d/H11001bcd/H11005ab/H11032c/H11001abc/H11032/H11001ad/H11001bcd/H11001b/H11032c/H11032d
3.29 The following circuit is implemented using two half-adder circuits. The expressions
for the half-adder outputs are S/H11005A/H17053Bwhere /H17053represents the exclusive-OR
function, and C/H11005AB. Derive simplified sum-of-products expressions for the circuit
outputs SUM and Co. Give the truth table for the outputs.
3.30 The output of a majority circuit is 1 if a majority (more than half) of its inputs
are equal to 1, and the output is 0 otherwise. Construct a truth table for a three-input majority circuit and derive a simplified sum-of-products expression forits output.
3.31 Prove algebraically:
(a) ( X/H11032/H11001Y/H11032)(X≡ Z)/H11001(X/H11001Y)(X
/H17053Z)/H11005(X/H17053Y)/H11001Z/H11032
(b) ( W/H11032/H11001X/H11001Y/H11032)(W/H11001X/H11032/H11001Y)(W/H11001Y/H11032/H11001Z)/H11005X/H11032Y/H11032/H11001WX /H11001XYZ /H11001W/H11032YZ
(c)ABC /H11001A/H11032C/H11032D/H11032/H11001A/H11032BD/H11032/H11001ACD /H11005(A/H11032/H11001C)(A/H11001D/H11032)(B/H11001C/H11032/H11001D)
3.32 Which of the following statements are always true? Justify your answers.
(a) If A/H11001B/H11005C,then AD/H11032/H11001BD/H11032/H11005CD/H11032
(b) If A/H11032B/H11001A/H11032C/H11005A/H11032D,then B/H11001C/H11005D
(c) If A/H11001B/H11005C,then A/H11001B/H11001D/H11005C/H11001D
(d) If A/H11001B/H11001C/H11005C/H11001D, then A/H11001B/H11005D
3.33 Find all possible terms that could be added to each expression using the consensus
theorem. Then reduce to a minimum sum of products.(a)A/H11032C/H11032/H11001BC/H11001AB/H11032/H11001A/H11032BD/H11001B/H11032C/H11032D/H11032/H11001ACD /H11032
(b)A/H11032C/H11032D/H11032/H11001BC/H11032D/H11001AB/H11032C/H11032/H11001A/H11032BC
3.34 Simplify the following expression to a sum of two terms and then factor the result
to obtain a product of sums: abd/H11032f/H11032/H11001b/H11032cegh /H11032/H11001abd/H11032f/H11001acd/H11032e/H11001b/H11032ce
3.35 Multiply out the following expression and simplify to obtain a sum-of-products
expression with three terms: ( a/H11001c
)(b/H11032/H11001d)(a/H11001c/H11032/H11001d/H11032)(b/H11032/H11001c/H11032/H11001d/H11032)CoA
BS
CA
BS
C
CiYX SUM
82 Unit 3
3.36 Factor and simplify to obtain a product-of-sums expression with four terms:
abc/H11032/H11001d/H11032e/H11001ace/H11001b/H11032c/H11032d/H11032
3.37 (a) Show that x/H17053y/H11005(x/H11013y)/H11032
(b) Realize a/H11032b/H11032c/H11032/H11001a/H11032bc/H11001ab/H11032c/H11001abc/H11032using only two-input equivalence gates.
83Applications of Boolean Algebra
Minterm and Maxterm Expansions
UNIT
4
83Objectives
1.Given a word description of the desired behavior of a logic circuit, write
the output of the circuit as a function of the input variables. Specify thisfunction as an algebraic expression or by means of a truth table, as isappropriate.
2.Given a truth table, write the function (or its complement) as both a
minterm expansion (standard sum of products) and a maxterm expansion(standard product of sums). Be able to use both alphabetic and decimalnotation.
3.Given an algebraic expression for a function, expand it algebraically to
obtain the minterm or maxterm form.
4.Given one of the following: minterm expansion for F,minterm expansion
for F/H11032, maxterm expansion for F,or maxterm expansion for F/H11032, find any of
the other three forms.
5.Write the general form of the minterm and maxterm expansion of a func-
tion of nvariables.
6.Explain why some functions contain don’t-care terms.
7.Explain the operation of a full adder and a full subtracter and derive logic
equations for these modules. Draw a block diagram for a parallel adderor subtracter and trace signals on the block diagram.
84 Unit 4
In the previous units, we placed a dot (•) inside the AND-gate symbol, a plus sign
(/H11001) inside the OR-gate symbol, and a /H17053inside the Exclusive-OR. Because you are
now familiar with the relationship between the shape of the gate symbol and thelogic function performed, we will omit the •, /H11001, and /H17053and use the standard gate
symbols for AND, OR, and Exclusive-OR in the rest of the book.
1.Study Section 4.1, Conversion of English Sentences to Boolean Equations.
(a) Use braces to identify the phrases in each of the following sentences:
(1) The tape reader should stop if the manual stop button is pressed,
if an error occurs, or if an end-of-tape signal is present.
(2) He eats eggs for breakfast if it is not Sunday and
he has eggs in the refrigerator.
(3) Addition should occur iff an add instruction is given and
the signs are the same, or if a subtract instruction is given andthe signs are not the same.
(b) Write a Boolean expression which represents each of the sentences in (a).
Assign a variable to each phrase, and use a complemented variable to rep-resent a phrase which contains “not”.
(Your answers should be in the form F/H11005S/H11032E,F/H11005AB/H11001SB/H11032, and 
F/H11005A/H11001B/H11001C, but not necessarily in that order.)
(c) If Xrepresents the phrase “ Nis greater than 3”, how can you represent the
phrase “ Nis less than or equal to 3”?
(d) Work Problems 4.1 and 4.2.
2.Study Section 4.2, Combinational Logic Design Using a Truth Table. Previously,
you have learned how to go from an algebraic expression for a function to atruth table; in this section you will learn how to go from a truth table to an alge-braic expression.
(a) Write a product term which is 1 iff a/H110050,b/H110050, and c/H110051.
(b) Write a sum term which is 0 iff a/H110050,b/H110050, and c/H110051.
(c) Verify that your answers to (a) and (b) are complements.Study Guide
Applications of Boolean Algebra Minterm and Maxterm Expansions 85
(d) Write a product term which is 1 iff a/H110051,b/H110050,c/H110050, and d/H110051.
(e) Write a sum term which is 0 iff a/H110050,b/H110050,c/H110051, and d/H110051.
(f ) For the given truth table, write Fas a sum of four 
product terms which correspond to the four 1’s of F.
(g) From the truth table write Fas a product of four sum 
terms which correspond to the four 0’s of F.
(h) Verify that your answers to both (f) and (g) reduce to 
F/H11005b/H11032c/H11032/H11001a/H11032c.
3.Study Section 4.3, Minterm and Maxterm Expansions.
(a) Define the following terms:
minterm (for nvariables)
maxterm (for nvariables)
(b) Study Table 4-1 and observe the relation between the values of A,B, and
Cand the corresponding minterms and maxterms.
IfA/H110050, then does AorA/H11032appear in the minterm?
In the maxterm?IfA/H110051, then does AorA/H11032appear in the minterm?
In the maxterm?
What is the relation between minterm, m
i, and the corresponding
maxterm, Mi?
(c) For the table given in Study Guide Question 2(f), write the minterm
expansion for Finm-notation and in decimal notation.
For the same table, write the maxterm expansion for FinM-notation and
in decimal notation.
Check your answers by converting your answer to 2(f) to m-notation and
your answer to 2(g) to M-notation.a b c F
0 0 0 1
0 0 1 1
0 1 0 00 1 1 11 0 0 1
1 0 1 0
1 1 0 01 1 1 0
86 Unit 4
(d) Given a sum-of-products expression, how do you expand it to a standard
sum of products (minterm expansion)?
(e) Given a product-of-sums expression, how do you expand it to a standard
product of sums (maxterm expansion)?
(f ) In Equation (4-11), what theorems were used to factor fto obtain the
maxterm expansion?
(g) Why is the following expression not a maxterm expansion?
f(A,B,C,D)/H11005(A/H11001B/H11032/H11001C/H11001D)(A/H11032/H11001B/H11001C/H11032)(A/H11032/H11001B/H11001C/H11001D/H11032)
(h) Assuming that there are three variables ( A,B,C), identify each of the
following as a minterm expansion, maxterm expansion, or neither:
(1)AB/H11001B/H11032C/H11032 (2) ( A/H11032/H11001B/H11001C/H11032)(A/H11001B/H11032/H11001C)
(3)A/H11001B/H11001C (4) ( A/H11032/H11001B)(B/H11032/H11001C)(A/H11032/H11001C)
(5)A/H11032BC/H11032/H11001AB/H11032C/H11001ABC (6)AB/H11032C/H11032
Note that it is possible for a minterm or maxterm expansion to have only
one term.
4.(a) Given a minterm in terms of its variables, the procedure for conversion to
decimal notation is
(1) Replace each complemented variable with a _____ and replace each
uncomplemented variable with a _____.
(2) Convert the resulting binary number to decimal.
(b) Convert the minterm AB/H11032C/H11032DEto decimal notation.
(c) Given that m13is a minterm of the variables A,B,C,D, and E, write the
minterm in terms of these variables.
(d) Given a maxterm in terms of its variables, the procedure for conversion
to decimal notation is
(1) Replace each complemented variable with a _____ and replace each
uncomplemented variable with a _____.
(2) Group these 0’s and 1’s to form a binary number and convert to decimal.
(e) Convert the maxterm A/H11032/H11001B/H11001C/H11001D/H11032/H11001E/H11032to decimal notation.
(f) Given that M13is a maxterm of the variables A,B,C,D, and E, write the
maxterm in terms of these variables.
(g) Check your answers to (b), (c), (e), and (f) by using the relation Mi/H11005mi/H11032.
(h) Given f(a,b,c,d,e)/H11005/H9016 M(0, 10, 28), express fin terms of a,b,c,d, and e.
(Your answer should contain only five complemented variables.)
Applications of Boolean Algebra Minterm and Maxterm Expansions 87
5.Study Section 4.4, General Minterm and Maxterm Expansions. Make sure that
you understand the notation here and can follow the algebra in all of the equa-tions. If you have difficulty with this section, ask for help before you take the
readiness test.
(a) How many different functions of four variables are possible?
(b) Explain why there are functions of nvariables.
(c) Write the function of Figure 4-1 in the form of Equation (4-13) and show
that it reduces to Equation (4-3).
(d) For Equation (4-19), write out the indicated summations in full for the
case n/H110052.
(e) Study Tables 4-3 and 4-4 carefully and make sure you understand why
each table entry is valid. Use the truth table for fand f/H11032(Figure 4-1) to
verify the entries in Table 4-4. If you understand the relationshipbetween Table 4-3 and the truth table for fand f/H11032, you should be able to
perform the conversions without having to memorize the table.
(f) Given that f(A,B,C)/H11005m(0, 1, 3, 4, 7)
The maxterm expansion for fis ______________________________________
The minterm expansion for f/H11032is _____________________________________
The maxterm expansion for f/H11032is _____________________________________
(g) Work Problem 4.3 and 4.4.
6. Study Section 4.5, Incompletely Specified Functions.
(a) State two reasons why some functions have don’t-care terms.
(b) Given the following table, write the minterm expansion
forZin decimal form.
(c) Write the maxterm expansion in decimal form.
(d) Work Problems 4.5 and 4.6./H90182
2n
A B C Z
000 1
001 X
010 0011 X100 X101 1
110 0
111 0
88 Unit 4
7.Study Section 4.6, Examples of Truth Table Construction. Finding the truth
table from the problem statement is probably the most difficult part of theprocess of designing a switching circuit. Make sure that you understand howto do this.
8.Work Problems 4.7 through 4.10.
9.Study Section 4.7, Design of Binary Adders.
(a) For the given parallel adder, show the 0’s and 1’s at the full adder
(FA) inputs and outputs when the following unsigned numbers are added:11/H1100114/H1100525. Verify that the result is correct if C
4S3S2S1S0is taken as a 
5-bit sum. If the sum is limited to 4 bits, explain why this is an overflowcondition.
(b) Review Section 1.4, Representation of Negative Numbers. If we use the 2’s
complement number system to add ( /H110025)/H11001(/H110022), verify that the FA inputs
and outputs are exactly the same as in Part (a). However, for 2’s comple-ment, the interpretation of the results is quite different. After discardingC
4, verify that the resultant 4-bit sum is correct, and therefore no overflow
has occurred.
(c) If we use the 1’s complement number system to add ( /H110025)/H11001(/H110022), show
the FA inputs and outputs on the diagram below before the end-aroundcarry is added in. Assume that C
0is initially 0. Then add the end-around
carry ( C4) to the rightmost FA, add the new carry ( C1) into the next cell,
and continue until no further changes occur. Verify that the resultingsum is the correct 1’s complement representation of /H110027.
FA FA FA FAC4C0FA FA FA FAC4 C0S3 S2 S1 S0
Applications of Boolean Algebra Minterm and Maxterm Expansions 89
10. (a) Work the following subtraction example. As you subtract each column,
place a 1 over the next column if you have to borrow, otherwise place a 0.For each column, as you compute x
i/H11002yi/H11002bi, fill in the corresponding val-
ues of bi/H110011and diin the truth table. If you have done this correctly, the
resulting table should match the full subtracter truth table (Table 4-6).
←borrows
1 1 0 0 0 1 1 0 ←X
/H110020 1 0 1 1 0 1 0 ←Y
←difference
(b) Work Problems 4.11 and 4.12.
11. Read the following and then work Problem 4.13 or 4.14 as assigned:
When looking at an expression to determine the required number of gates, keepin mind that the number of required gates is generally notequal to the number
of AND and OR operations which appear in the expression. For example,
AB/H11001CD/H11001EF(G/H11001H)
contains four AND operations and three OR operations, but it only requires
three AND gates and two OR gates:
12. Simulation Exercise. (Must be completed before you take the readiness test.)
One purpose of this exercise is to acquaint you with the simulator that you willbe using later in more complex design problems. Follow the instructions on theUnit 4 lab assignment sheet.
13. Reread the objectives of this unit. Make sure that you understand the difference
in the procedures for converting maxterms and minterms from decimal to alge-braic notation.When you are satisfied that you can meet the objectives, take thereadiness test. When you come to take the readiness test, turn in a copy of yoursolution to assigned simulation exercise.A
B
C
D
E
F G
Hxiyibi bi/H110011di
000
001
010011100101
110
111
Applications of Boolean Algebra
Minterm and Maxterm Expansions
In this unit you will learn how to design a combinational logic circuit starting
with a word description of the desired circuit behavior. The first step is usually totranslate the word description into a truth table or into an algebraic expression.Given the truth table for a Boolean function, two standard algebraic forms of thefunction can be derived—the standard sum of products (minterm expansion) andthe standard product of sums (maxterm expansion). Simplification of either ofthese standard forms leads directly to a realization of the circuit using AND andOR gates.
4.1 Conversion of English Sentences 
to Boolean Equations
The three main steps in designing a single-output combinational switching circuit are
1. Find a switching function that specifies the desired behavior of the circuit.
2. Find a simplified algebraic expression for the function.
3. Realize the simplified function using available logic elements.
For simple problems, it may be possible to go directly from a word description of the
desired behavior of the circuit to an algebraic expression for the output function. Inother cases, it is better to first specify the function by means of a truth table and thenderive an algebraic expression from the truth table.
Logic design problems are often stated in terms of one or more English sentences.
The first step in designing a logic circuit is to translate these sentences into Booleanequations. In order to do this, we must break down each sentence into phrases andassociate a Boolean variable with each phrase. If a phrase can have a value of true orfalse, then we can represent that phrase by a Boolean variable. Phrases such as “shegoes to the store” or “today is Monday” can be either true or false, but a commandlike “go to the store” has no truth value. If a sentence has several phrases, we will markeach phrase with a brace. The following sentence has three phrases:
Mary watches TV if it is Monday night and she has finished her homework.
¯˚˚˘˚˚˙ ¯˚˚˘˚˚˙ ¯˚˚ ˚˚ ˚˘˚ ˚ ˚˚˚˙
90
Applications of Boolean Algebra Minterm and Maxterm Expansions 91
The “if” and “and” are not included in any phrase; they show the relationships among
the phrases.
We will define a two-valued variable to indicate the truth or falsity of each phrase:
F/H110051 if “Mary watches TV” is true; otherwise, F/H110050.
A/H110051 if “it is Monday night” is true; otherwise, A/H110050.
B/H110051 if “she has finished her homework” is true; otherwise B/H110050.
Because Fis “true” if Aand Bare both “true”, we can represent the sentence
byF/H11005A/H11080B
The following example illustrates how to go from a word statement of a problem
directly to an algebraic expression which represents the desired circuit behavior. Analarm circuit is to be designed which operates as follows:
The alarm will ring iff the alarm switch is turned on and the door is not closed,
or it is after 6 
P.M. and the window is not closed.
The first step in writing an algebraic expression which corresponds to the above
sentence is to associate a Boolean variable with each phrase in the sentence. Thisvariable will have a value of 1 when the phrase is true and 0 when it is false. We willuse the following assignment of variables:
The alarm will ring iff the alarm switch is on and
the door is not closed or it is after 6 
P.M. and
the window is not closed.
This assignment implies that if Z/H110051, the alarm will ring. If the alarm switch is
turned on, A/H110051, and if it is after 6 P.M.,C/H110051. If we use the variable Bto represent
the phrase “the door is closed”, then B/H11032represents “the door is not closed”. Thus,
B/H110051 if the door is closed, and B/H11032/H110051 (B/H110050) if the door is not closed. Similarly,
D/H110051 if the window is closed, and D/H11032/H110051 if the window is not closed. Using this
assignment of variables, the above sentence can be translated into the followingBoolean equation:
Z/H11005AB/H11032/H11001CD/H11032
This equation corresponds to the following circuit:
A
B
DCZ¯˚˚˘˚˚˚˙
D/H11032¯˚˚˘˚˚˙
C¯˚˚˘˚˚˚˙
B/H11032¯˚˚˚˘˚˚˚˙
A¯˚˚˘˚˚˙
Z
92 Unit 4
In this circuit, Ais a signal which is 1 when the alarm switch is on, Cis a signal from
a time clock which is 1 when it is after 6 P.M.,Bis a signal from a switch on the door
which is 1 when the door is closed, and similarly Dis 1 when the window is closed.
The output Zis connected to the alarm so that it will ring when Z/H110051.
4.2 Combinational Logic Design 
Using a Truth Table
The next example illustrates logic design using a truth table. A switching circuit has
three inputs and one output, as shown in Figure 4-1(a). The inputs A,B, and Crep-
resent the first, second, and third bits, respectively, of a binary number N.The out-
put of the circuit is to be f/H110051 if N/H113500112and f/H110050 if N/H110210112. The truth table for
fis shown in Figure 4-1(b).
A
B
Cf
(a)FIGURE 4-1
Combinational
Circuit with Truth
TableABC f f /H11032
000 0 1
001 0 1010 0 1011 1 0
100 1 0
101 1 0110 1 0111 1 0
(b)
Next, we will derive an algebraic expression for ffrom the truth table by using
the combinations of values of A,B, and Cfor which f/H110051. The term A/H11032BCis 1 only
ifA/H110050,B/H110051, and C/H110051. Similarly, the term AB/H11032C/H11032is 1 only for the combination
100, AB/H11032Cis 1 only for 101, ABC /H11032is 1 only for 110, and ABC is 1 only for 111. ORing
these terms together yields
f/H11005A/H11032BC/H11001AB/H11032C/H11032/H11001AB/H11032C/H11001ABC /H11032/H11001ABC (4-1)
This expression equals 1 if A,B, and Ctake on any of the five combinations of val-
ues 011, 100, 101, 110, or 111. If any other combination of values occurs, fis 0
because all five terms are 0.
Equation (4-1) can be simplified by first combining terms and then eliminating A/H11032:
f/H11005A/H11032BC/H11001AB/H11032/H11001AB/H11005A/H11032BC/H11001A/H11005A/H11001BC (4-2)
Equation (4-2) leads directly to the following circuit:
B
CAf
Applications of Boolean Algebra Minterm and Maxterm Expansions 93
Instead of writing fin terms of the 1’s of the function, we may also write fin terms
of the 0’s of the function. The function defined by Figure 4-1 is 0 for three combina-tions of input values. Observe that the term A/H11001B/H11001Cis 0 only if A/H11005B/H11005C/H110050.
Similarly, A/H11001B/H11001C/H11032is 0 only for the input combination 001, and A/H11001B/H11032/H11001C is 0
only for the combination 010. ANDing these terms together yields
f/H11005(A/H11001B/H11001C)(A/H11001B/H11001C/H11032)(A/H11001B/H11032/H11001C) (4-3)
This expression equals 0 if A,B, and Ctake on any of the combinations of values
000, 001, or 010. For any other combination of values, fis 1 because all three terms
are l. Because Equation (4-3) represents the same function as Equation (4-1) theymust both reduce to the same expression. Combining terms and using the seconddistributive law, Equation (4-3) simplifies to
f/H11005(A/H11001B)(A/H11001B/H11032/H11001C)/H11005A/H11001B(B/H11032/H11001C)/H11005A/H11001BC (4-4)
which is the same as Equation (4-2).
Another way to derive Equation (4-3) is to first write f/H11032as a sum of products,
and then complement the result. From Figure 4-1, f/H11032
is1 for input combinations
ABC /H11005000, 001, and 010, so
f/H11032/H11005A/H11032B/H11032C/H11032/H11001A/H11032B/H11032C/H11001A/H11032BC/H11032
Taking the complement of f/H11032yields Equation (4-3).
4.3 Minterm and Maxterm Expansions
Each of the terms in Equation (4-1) is referred to as a minterm. In general, a minterm
ofnvariables is a product of nliterals in which each variable appears exactly once in
either true or complemented form, but not both. (A literal is a variable or its comple-
ment.) Table 4-1 lists all of the minterms of the three variables A,B, and C.Each
minterm has a value of 1 for exactly one combination of values of the variables A,B,
andC.Thus if A/H11005B/H11005C/H110050,A/H11032B/H11032C/H11032/H110051; if A/H11005B/H110050 and C/H110051,A/H11032B/H11032C/H110051; and
so forth. Minterms are often written in abbreviated form— A/H11032B/H11032C/H11032is designated m0,
A/H11032B/H11032Cis designated ml, etc. In general, the minterm which corresponds to row iof the
truth table is designated mi(iis usually written in decimal).
TABLE 4-1
Minterms and
Maxterms for
Three VariablesRow No. ABC Minterms Maxterms
0 000 A/H11032B/H11032C/H11032 /H11005m0 A/H11001B/H11001C /H11005M0
1 001 A/H11032B/H11032C/H11005m1 A/H11001B/H11001C/H11032  /H11005 M1
2 010 A/H11032BC/H11032  /H11005m2 A/H11001B/H11032/H11001C/H11005M2
3 011 A/H11032BC /H11005m3 A/H11001B/H11032/H11001C/H11032 /H11005M3
4 100 AB/H11032C/H11032  /H11005m4 A/H11032/H11001B/H11001C/H11005M4
5 101 AB/H11032C/H11005m5 A/H11032/H11001B/H11001C/H11032  /H11005 M5
6 110 ABC /H11032  /H11005 m6 A/H11032/H11001B/H11032/H11001C/H11005M6
7 111 ABC /H11005m7 A/H11032/H11001B/H11032/H11001C/H11032 /H11005M7
94 Unit 4
When a function fis written as a sum of minterms as in Equation (4-1), this is
referred to as a minterm expansion or a standard sum of products.1Iff/H110051 for row i
of the truth table, then mimust be present in the minterm expansion because mi/H110051
only for the combination of values of the variables corresponding to row i of the table.Because the minterms present in fare in one-to-one correspondence with the 1’s of f
in the truth table, the minterm expansion for a function f isunique. Equation (4-1) can
be rewritten in terms of m-notation as
f(A,B,C)/H11005m
3/H11001m4/H11001m5/H11001m6/H11001m7 (4-5)
This can be further abbreviated by listing only the decimal subscripts in the form
f(A,B,C)/H11005 m(3, 4, 5, 6, 7) (4-5a)
Each of the sum terms (or factors) in Equation (4-3) is referred to as a maxterm.
In general, a maxterm of nvariables is a sum of nliterals in which each variable
appears exactly once in either true or complemented form, but not both. Table 4-1lists all of the maxterms of the three variables A,B, and C.Each maxterm has a value
of 0 for exactly one combination of values for A,B, and C.Thus, if A/H11005B/H11005C/H110050,
A/H11001B/H11001C/H110050; if A/H11005B/H110050 and C/H110051,A/H11001B/H11001C/H11032/H110050; and so forth. Maxterms
are often written in abbreviated form using M-notation. The maxterm which corre-
sponds to row iof the truth table is designated M
i. Note that each maxterm is the
complement of the corresponding minterm, that is, Mi/H11005m/H11032i.
When a function fis written as a product of maxterms, as in Equation (4-3),
this is referred to as a maxterm expansion orstandard product of sums. Iff/H110050 for
row iof the truth table, then Mimust be present in the maxterm expansion
because Mi/H110050 only for the combination of values of the variables corresponding
to row iof the table. Note that the maxterms are multiplied together so that if any
one of them is 0, fwill be 0. Because the maxterms are in one-to-one correspon-
dence with the 0’s of fin the truth table, the maxterm expansion for a function f is
unique. Equation (4-3) can be rewritten in M-notation as
f(A,B,C)/H11005M0M1M2 (4-6)
This can be further abbreviated by listing only the decimal subscripts in the form
f(A,B,C)/H11005 M(0, 1, 2) (4-6a)
where /H9016means a product.
Because if f/H110141 then f/H110050, it follows that if miisnotpresent in the minterm
expansion of f, then Miis present in the maxterm expansion. Thus, given a minterm
expansion of an n-variable function fin decimal notation, the maxterm expansion is
obtained by listing those decimal integers (0 /H11349i/H113492n/H110021) not in the minterm list.
Using this method, Equation (4-6a) can be obtained directly from Equation (4-5a)./H9016/H9018
1Other names used in the literature for standard sum of products are canonical sum of products and
disjunctive normal form. Similarly, a standard product of sums may be called a canonical product ofsums or a conjunctive normal form.
Applications of Boolean Algebra Minterm and Maxterm Expansions 95
Given the minterm or maxterm expansions for f, the minterm or maxterm expan-
sions for the complement of fare easy to obtain. Because f/H11032is 1 when fis 0, the minterm
expansion for f/H11032contains those minterms not present in f.Thus, from Equation (4-5),
f/H11032/H11005m0/H11001m1/H11001m2/H11005 m(0, 1, 2) (4-7)
Similarly, the maxterm expansion for f/H11032contains those maxterms not present in f.
From Equation (4-6),
f/H11032/H11005/H9016  M(3, 4, 5, 6, 7) /H11005M3M4M5M6M7 (4-8)
Because the complement of a minterm is the corresponding maxterm, Equation
(4-8) can be obtained by complementing Equation (4-5):
f/H11032/H11005(m3/H11001m4/H11001m5/H11001m6/H11001m7)/H11032/H11005m/H110323m/H110324m/H110325m/H110326m/H110327/H11005M3M4M5M6M7
Similarly, Equation (4-7) can be obtained by complementing Equation (4-6):
f/H11032/H11005(M0M1M2)/H11032/H11005M/H110320/H11001M/H110321/H11001M/H110322/H11005m0/H11001m1/H11001m2
A general switching expression can be converted to a minterm or maxterm
expansion either using a truth table or algebraically. If a truth table is constructedby evaluating the expression for all different combinations of the values of thevariables, the minterm and maxterm expansions can be obtained from the truthtable by the methods just discussed. Another way to obtain the minterm expan-sion is to first write the expression as a sum of products and then introduce themissing variables in each term by applying the theorem X/H11001X/H11032/H110051.
Find the minterm expansion of f(a,b,c,d) /H11005a/H11032(b/H11032/H11001d)/H11001acd/H11032.
Example
f/H11005a/H11032b/H11032/H11001a/H11032d/H11001acd/H11032
/H11005a/H11032b/H11032(c/H11001c/H11032)(d/H11001d/H11032)/H11001a/H11032d(b/H11001b/H11032)(c/H11001c/H11032)/H11001acd/H11032(b/H11001b/H11032)
/H11005a/H11032b/H11032c/H11032d/H11032/H11001a/H11032b/H11032c/H11032d/H11001a/H11032b/H11032cd/H11032/H11001a/H11032b/H11032cd/H11001/H11001
/H11001a/H11032bc/H11032d/H11001a/H11032bcd/H11001abcd /H11032/H11001ab/H11032cd/H11032 (4-9)
Duplicate terms have been crossed out, because X/H11001X/H11005X.This expression can
then be converted to decimal notation:
f/H11005a/H11032b/H11032c/H11032d/H11032/H11001a/H11032b/H11032c/H11032d/H11001a/H11032b/H11032cd/H11032/H11001a/H11032b/H11032cd/H11001a/H11032bc/H11032d/H11001a/H11032bcd/H11001abcd /H11032/H11001ab/H11032cd/H11032
0 0 0 0 0 0 0 1 0 0 10 0 0 11 0 10 1 0 111 1110 10 10
f/H11005 m(0, 1, 2, 3, 5, 7, 10, 14) (4-10)
The maxterm expansion for fcan then be obtained by listing the decimal integers
(in the range 0 to 15) which do not correspond to minterms of f:
f/H11005/H9016  M(4, 6, 8, 9, 11, 12, 13, 15)/H9018a/H11032b/H11032cd a/H11032b/H11032c/H11032d/H9018
An alternate way of finding the maxterm expansion is to factor fto obtain a
product of sums, introduce the missing variables in each sum term by using XX/H11032/H11005
0, and then factor again to obtain the maxterms. For Equation (4-9),
f/H11005a/H11032(b/H11032/H11001d)/H11001acd/H11032
/H11005(a/H11032/H11001cd/H11032)(a/H11001b/H11032/H11001d)/H11005(a/H11032/H11001c)(a/H11032/H11001d/H11032)(a/H11001b/H11032/H11001d)
/H11005(a/H11032/H11001bb/H11032/H11001c/H11001dd/H11032)(a/H11032/H11001bb/H11032/H11001cc/H11032/H11001d/H11032)(a/H11001b/H11032/H11001cc/H11032/H11001d)
/H11005(a/H11032/H11001bb/H11032/H11001c/H11001d)(a/H11032/H11001bb/H11032/H11001c/H11001d/H11032)
(a/H11032/H11001bb/H11032/H11001c/H11032/H11001d/H11032)(a/H11001b/H11032/H11001cc/H11032/H11001d)
/H11005(a/H11032/H11001b/H11001c/H11001d)(a/H11032/H11001b/H11032/H11001c/H11001d)(a/H11032/H11001b/H11001c/H11001d/H11032)(a/H11032/H11001b/H11032/H11001c/H11001d/H11032)
1000 1100 1001 1101
(a/H11032/H11001b/H11001c/H11032/H11001d/H11032)(a/H11032/H11001b/H11032/H11001c/H11032/H11001d/H11032)(a/H11001b/H11032/H11001c/H11001d)(a/H11001b/H11032/H11001c/H11032/H11001d)
1011 1111 0100 0110
/H11005/H9016 M(4, 6, 8, 9, 11, 12, 13, 15) (4-11)
Note that when translating the maxterms to decimal notation, a primed variable is
first replaced with a 1 and an unprimed variable with a 0.
Because the terms in the minterm expansion of a function Fcorrespond one-to-
one with the rows of the truth table for which F/H110051, the minterm expansion of Fis
unique. Thus, we can prove that an equation is valid by finding the minterm expan-
sion of each side and showing that these expansions are the same.
Show that a/H11032c/H11001b/H11032c/H11032/H11001ab/H11005a/H11032b/H11032/H11001bc/H11001ac/H11032.
Example We will find the minterm expansion of each side by supplying the missing
variables. For the left side,
a/H11032c(b/H11001b/H11032)/H11001b/H11032c/H11032(a/H11001a/H11032)/H11001ab(c/H11001c/H11032)
/H11005a/H11032bc/H11001a/H11032b/H11032c/H11001ab/H11032c/H11032/H11001a/H11032b/H11032c/H11032/H11001abc/H11001abc/H11032
/H11005m3/H11001m1/H11001m4/H11001m0/H11001m7/H11001m6
For the right side,
a/H11032b/H11032(c/H11001c/H11032)/H11001bc(a/H11001a/H11032)/H11001ac/H11032(b/H11001b/H11032)
/H11005a/H11032b/H11032c/H11001a/H11032b/H11032c/H11032/H11001abc/H11001a/H11032bc/H11001abc/H11032/H11001ab/H11032c/H11032
/H11005ml/H11001m0/H11001m7/H11001m3/H11001m6/H11001m4
Because the two minterm expansions are the same, the equation is valid.
4.4 General Minterm and Maxterm Expansions
Table 4-2 represents a truth table for a general function of three variables. Each ai
is a constant with a value of 0 or 1. To completely specify a function, we must assign
values to all of the ai’s. Because each aican be specified in two ways, there are 28(a/H11032/H11001bb/H11032/H11001c/H11001d/H11032)96 Unit 4
Applications of Boolean Algebra Minterm and Maxterm Expansions 97
ways of filling the Fcolumn of the truth table; therefore, there are 256 different
functions of three variables (this includes the degenerate cases, Fidentically equal
to 0 and Fidentically equal to 1). For a function of nvariables, there are 2nrows in
the truth table, and because the value of Fcan be 0 or 1 for each row, there are 
possible functions of nvariables.
From Table 4-2, we can write the minterm expansion for a general function of
three variables as follows:
F/H11005a0m0/H11001a1m1/H11001a2m2/H11001···  /H11001a7m7/H11005 (4-12)
Note that if ai/H110051, minterm miis present in the expansion; if ai/H110050, the correspon-
ding minterm is not present. The maxterm expansion for a general function of threevariables is
F/H11005(a
0/H11001M0)(a1/H11001M1)(a2/H11001M2)  ···  ( a7/H11001M7)/H11005 (4-13)
Note that if ai/H110051,ai/H11001Mi/H110051, and Midrops out of the expansion; however, Mi
is present if ai/H110050.
From Equation (4-13), the minterm expansion of F/H11032is
(4-14)
Note that all minterms which are not present in Fare present in F/H11032.
From Equation (4-12), the maxterm expansion of F/H11032is
(4-15)
Note that all maxterms which are not present in Fare present in F/H11032. Generalizing
Equations (4-12), (4-13), (4-14), and (4-15) to nvariables, we have
(4-16) F/H11005/H208582n/H110021
i/H110050aimi/H11005/H90162n/H110021
i/H110050(ai/H11001Mi)F/H11032/H11005/H20900/H208587
i/H110050aimi/H20901/H11032
/H11005/H90167
i/H110050(a/H11032i/H11001m/H11032i)/H11005/H90167
i/H110050(a/H11032i/H11001Mi)F/H11032/H11005/H20900/H90167
i/H110050(ai/H11001Mi)/H20901/H11032
/H11005/H208587
i/H110050a/H11032iM/H11032i/H11005/H208587
i/H110050ai/H11032mi/H90167
i/H110050(ai/H11001Mi)/H208587
i/H110050aimi22nABC F
000 a0
001 a1
010 a2
011 a3
100 a4
101 a5
110 a6
111 a7TABLE 4-2
General Truth Table
for Three Variables
98 Unit 4
DESIRED FORM
Minterm Maxterm Minterm Maxterm
Expansion Expansion Expansion Expansion
ofF ofF ofF/H11032 ofF/H11032
Minterm ____________ maxterm nos. list minterms maxterm nos.
Expansion are those nos. not present are the same 
ofF not on the in F as minterm 
minterm list nos. of F
forF
Maxterm minterm nos. ____________ minterm nos. list maxterms 
Expansion are those nos. are the same not present 
ofF not on the as maxterm in F
maxterm list nos. of F
forFTABLE 4-3
Conversion of
Forms
GIVEN FORM(4-17)
Given two different minterms of nvariables, miand mj, at least one variable
appears complemented in one of the minterms and uncomplemented in the other.Therefore, if i/H11014j,m
imj/H110050. For example, for n/H110053,m1m3/H11005(A/H11032B/H11032C)(A/H11032BC)/H110050.
Given minterm expansions for two functions
(4-18)
the product is
(4-19)
Note that all of the cross-product terms ( i/H11014j) drop out so that f1f2contains only
those minterms which are present in both f1and f2. For example, if
f1/H11005/H9018m(0, 2, 3, 5, 9, 11) and f2/H11005/H9018m(0, 3, 9, 11, 13, 14)
f1f2/H11005/H9018m(0, 3, 9, 11)
Table 4-3 summarizes the procedures for conversion between minterm and
maxterm expansions of Fand F/H11032, assuming that all expansions are written as lists
of decimal numbers. When using this table, keep in mind that the truth table forann-variable function has 2
nrows so that the minterm (or maxterm) numbers
range from 0 to 2n/H110021. Table 4-4 illustrates the application of Table 4-3 to the
three-variable function given in Figure 4-1./H11005/H208582n/H110021
i/H110050aibimi     ( because mimj/H110050 unless i/H11005j)f1f2/H11005/H20898/H208582n/H110021
i/H110050aimi/H20899/H20898/H208582n/H110021
j/H110050bjmj/H20899/H11005/H208582n/H110021
i/H110050/H208582n/H110021
j/H110050aibjmimjf2/H11005/H208582n/H110021
j/H110050bjmj f1/H11005/H208582n/H110021
i/H110050aimiF/H11032/H11005/H208582n/H110021
i/H110050a/H11032imi/H11005/H90162n/H110021
i/H110050(a/H11032i/H11001Mi)
Applications of Boolean Algebra Minterm and Maxterm Expansions 99
4.5 Incompletely Specified Functions
A large digital system is usually divided into many subcircuits. Consider the follow-
ing example in which the output of circuit N1drives the input of circuit N2.
Let us assume that the output of N1does not generate all possible combinations of
values for A,B, and C.In particular, we will assume that there are no combinations
of values for w,x,y, and zwhich cause A,B, and Cto assume values of 001 or 110.
Hence, when we design N2, it is not necessary to specify values of FforABC /H11005001
or 110 because these combinations of values can never occur as inputs to N2.F o r
example, Fmight be specified by Table 4-5.
The X’s in the table indicate that we don’t care whether the value of 0 or 1 is
assigned to Ffor the combinations ABC /H11005001 or 110. In this example, we don’t care
what the value of Fis because these input combinations never occur anyway. The func-
tion Fis then incompletely specified. The minterms A/H11032B/H11032CandABC /H11032are referred to as
don’t-care minterms, since we don’t care whether they are present in the function or not.w
N1A
B
CN2x
y
zFDESIRED FORM
Minterm Maxterm Minterm Maxterm
Expansion Expansion Expansion Expansion
off off off/H11032 off/H11032
f/H11005
/H9018 m(3, 4, 5, 6, 7) ____________ /H9016M(0, 1, 2) /H9018 m(0, 1, 2) /H9016M(3, 4, 5, 6, 7)
f/H11005
/H9016 M(0, 1, 2) /H9018 m(3, 4, 5, 6, 7) ____________ /H9018 m(0, 1, 2) /H9016 M(3, 4, 5, 6, 7)TABLE 4-4
Application of
Table 4.3
GIVEN FORM
ABC F
000 1
001 X
010 0
011 1100 0101 0
110 X
111 1TABLE 4-5
Truth Table with
Don’t-Cares
100 Unit 4
When we realize the function, we must specify values for the don’t-cares. It is
desirable to choose values which will help simplify the function. If we assign thevalue 0 to both X’s, then
F/H11005A/H11032B/H11032C/H11032/H11001A/H11032BC/H11001ABC /H11005A/H11032B/H11032C/H11032/H11001BC
If we assign 1 to the first X and 0 to the second, then
F/H11005A/H11032B/H11032C/H11032/H11001A/H11032B/H11032C/H11001A/H11032BC/H11001ABC /H11005A/H11032B/H11032/H11001BC
If we assign 1 to both X’s, then
F/H11005A/H11032B/H11032C/H11032/H11001A/H11032B/H11032C/H11001A/H11032BC/H11001ABC /H11032/H11001ABC /H11005A/H11032B/H11032/H11001BC/H11001AB
The second choice of values leads to the simplest solution.
We have seen one way in which incompletely specified functions can arise, and
there are many other ways. In the preceding example, don’t-cares were presentbecause certain combinations of circuit inputs did not occur. In other cases, all inputcombinations may occur, but the circuit output is used in such a way that we do notcare whether it is 0 or 1 for certain input combinations.
When writing the minterm expansion for an incompletely specified function, we
will use mto denote the required minterms and dto denote the don’t-care
minterms. Using this notation, the minterm expansion for Table 4-5 is
F/H11005/H9018 m(0, 3, 7) /H11001/H9018d(1, 6)
For each don’t-care minterm there is a corresponding don’t-care maxterm. For exam-
ple, if F/H11005X (don’t-care) for input combination 001,
m1is a don’t-care minterm and
M1is a don’t-care maxterm.We will use Dto represent a don’t-care maxterm, and we
write the maxterm expansion of the function in Table 4-5 as
F/H11005/H9016  M(2, 4, 5) • /H9016D(1, 6)
which implies that maxterms M2,M4, and M5are present in Fand don’t-care max-
terms Mland M6are optional.
4.6 Examples of Truth Table Construction
We will design a simple binary adder that adds two 1-bit binary numbers, aandb,t o
Example 1 give a 2-bit sum. The numeric values for the adder inputs and output are as follows:
ab Sum
0 0 00 (0 /H110010/H110050)
0 1 01 (0 /H110011/H110051)
1 0 01 (1 /H110010/H110051)
1 1 10 (1 /H110011/H110052)
Applications of Boolean Algebra Minterm and Maxterm Expansions 101
We will represent inputs to the adder by the logic variables Aand Band the 2-bit
sum by the logic variables Xand Y, and we construct a truth table:
AB X Y
00 0 0
01 0 1
10 0 1
11 1 0
Because a numeric value of 0 is represented by a logic 0 and a numeric value of 1
by a logic l, the 0’s and 1’s in the truth table are exactly the same as in the previoustable. From the truth table,
X/H11005AB and Y/H11005A/H11032B/H11001AB/H11032/H11005A⊕B
Example 2An adder is to be designed which adds two 2-bit binary numbers to give a 3-bit bina-
ry sum. Find the truth table for the circuit. The circuit has four inputs and three out-puts as shown:
TRUTH TABLE:
N1 N2 N3
AB CD XYZ
00 00 000
00 01 001
00 10 010
00 11 01101 00 00101 01 01001 10 011
01 11 100
10 00 01010 01 01110 10 100
10 11 101
11 00 01111 01 10011 10 10111 11 110
Inputs AandBtaken together represent a binary number N1. Inputs CandDtaken
together represent a binary number N2. Outputs X,Y, and Ztaken together repre-
sent a binary number N3, where N3/H11005N1/H11001N2(/H11001of course represents ordinary
addition here).
In this example we have used A,B,C, and Dto represent both numeric values
and logic values, but this should not cause any confusion because the numeric andA X
YZB
C
DN1
N2N3¸˝˛ ¸˝˛ ¸˝˛
102 Unit 4
F/H11005/H9018 m(2, 6, 10, 13, 14, 15)
/H11005A/H11032B/H11032CD/H11032/H11001A/H11032BCD /H11032/H11001AB/H11032CD/H11032/H11001ABCD /H11032/H11001ABC /H11032D/H11001ABCD
/H11005A/H11032CD/H11032/H11001ACD /H11032/H11001ABD /H11005CD/H11032/H11001ABD¯˚˚˚˙ ¯˚˚˚ ˙ ¯˚˚ ˚˙
¯˚˚˙logic values are the same. In forming the truth table, the variables were treated like
binary numbers having numeric values. Now we wish to derive the switching func-
tions for the output variables. In doing so, we will treat A,B,C,D,X,Y, and Zas
switching variables having nonnumeric values 0 and 1. (Remember that in this casethe 0 and 1 may represent low and high voltages, open and closed switches, etc.)
From inspection of the table, the output functions are
X(A,B,C,D)/H11005/H9018  m(7, 10, 11, 13, 14, 15)
Y(A,B,C,D)/H11005/H9018 m(2, 3, 5, 6, 8, 9, 12, 15)
Z(A,B,C,D)/H11005/H9018 m(l, 3, 4, 6, 9, 11, 12, 14)
Example 3Design an error detector for 6-3-1-1 binary-coded-decimal digits. The output ( F) is
to be 1 iff the four inputs ( A,B,C,D) represent an invalid code combination.
The valid 6-3-1-1 code combinations are listed in Table 1-2. If any other com-
bination occurs, this is not a valid 6-3-1-1 binary-coded-decimal digit, and the cir-cuit output should be F/H110051 to indicate that an error has occurred. This leads to
the following truth table:
ABCD F
0000 0
0001 0
0010 1
0011 00100 00101 00110 1
0111 0
1000 01001 01010 1
1011 0
1100 01101 11110 11111 1
The corresponding output function is
Applications of Boolean Algebra Minterm and Maxterm Expansions 103
The realization using AND and OR gates is
Example 4The four inputs to a circuit ( A,B,C,D) represent an 8-4-2-1 binary-coded-decimal
digit. Design the circuit so that the output ( Z) is 1 iff the decimal number repre-
sented by the inputs is exactly divisible by 3. Assume that only valid BCD digitsoccur as inputs.
The digits 0, 3, 6, and 9 are exactly divisible by 3, so Z/H110051 for the input combi-
nations ABCD /H110050000, 0011, 0110, and 1001. The input combinations 1010, 1011,
1100, 1101, 1110, and 1111 do not represent valid BCD digits and will never occur,
soZis a don’t-care for these combinations. This leads to the following truth table:
ABCD Z
0000 1
0001 0
0010 0
0011 10100 00101 00110 1
0111 0
1000 01001 11010 X
1011 X
1100 X1101 X1110 X1111 X
The corresponding output function is
Z/H11005/H9018 m(0, 3, 6, 9) /H11001/H9018 d(10, 11, 12, 13, 14, 15)
In order to find the simplest circuit which will realize Z, we must choose some of the
don’t-cares (X’s) to be 0 and some to be 1. The easiest way to do this is to use a
Karnaugh map as described in Unit 5.C
A
BF
DD'
104 Unit 4
4-bit
Parallel
Adder
A3B3A2B2A1B1A0B0S3
C4 C0S2 S1 S0FIGURE 4-2
Parallel Adder
for 4-Bit Binary
Numbers
FIGURE 4-3
Parallel Adder
Composed of Four
Full AddersFull
Adder
A3 B3S3
C40
11
1Full
Adder
A2 B2S2
C31
00
0Full
Adder
A1 B1S1
C21
11
1Full
Adder
A0 B0S0
C10
1
end-around carr y for 1's complement1C0
0
14.7 Design of Binary Adders and Subtracters
In this section, we will design a parallel adder that adds two 4-bit unsigned binary
numbers and a carry input to give a 4-bit sum and a carry output (see Figure 4-2).One approach would be to construct a truth table with nine inputs and five outputsand then derive and simplify the five output equations. Because each equationwould be a function of nine variables before simplification, this approach would bevery difficult, and the resulting logic circuit would be very complex.A better methodis to design a logic module that adds two bits and a carry, and then connect four ofthese modules together to form a 4-bit adder as shown in Figure 4-3. Each of themodules is called a full adder. The carry output from the first full adder serves as the
carry input to the second full adder, etc.
In the example of Figure 4-3, we perform the following addition:
10110 (carries)
1011
/H110011011
10110
The full adder to the far right adds A0/H11001B0/H11001C0/H110051/H110011/H110010 to give a sum
of 102, which gives a sum S0/H110050 and a carry out of C1/H110051. The next full adder adds
A1/H11001B1/H11001C1/H110051/H110011/H110011/H11005112, which gives a sum S1/H110051 and a carry C2/H110051. The
carry continues to propagate from right to left until the left cell produces a finalcarry of C
4/H110051.
Applications of Boolean Algebra Minterm and Maxterm Expansions 105
Figure 4-4 gives the truth table for a full adder with inputs X,Y, and Cin. The out-
puts for each row of the table are found by adding up the input bits ( X/H11001Y/H11001Cin) and
splitting the result into a carry out ( Ci/H110011) and a sum bit ( Si). For example, in the 101 row
1/H110010/H110011/H11005102, so Ci/H110011/H110051 and Si/H110050. Figure 4-5 shows the implementation of the full
adder using gates.The logic equations for the full adder derived from the truth table are
Sum /H11005X/H11032Y/H11032Cin/H11001X/H11032YC/H11032in/H11001XY/H11032C/H11032in/H11001XYCin
/H11005X/H11032(Y/H11032Cin/H11001YC/H11032in)/H11001X(Y/H11032C/H11032in/H11001YCin) (4-20)
/H11005X/H11032(Y⊕Cin)/H11001X(Y⊕Cin)/H11032/H11005X⊕Y⊕Cin
Cout/H11005X/H11032YCin/H11001XY/H11032Cin/H11001XYC /H11032in/H11001XYCin
/H11005(X/H11032YCin/H11001XYCin)/H11001(XY/H11032Cin/H11001XYCin)/H11001(XYC /H11032in/H11001XYCin) (4-21)
/H11005YCin/H11001XCin/H11001XY
Note that the term XYCinwas used three times in simplifying Cout. Figure 4-5 shows
the logic circuit for Equations (4-20) and (4-21).
FIGURE 4-5
Implementation of
Full Adder
y
cincincoutx
x
yy
x
cinSumXYCin Cout Sum
00 0 0 0
00 1 0 101 0 0 101 1 1 010 0 0 1
10 1 1 0
11 0 1 011 1 1 1FIGURE 4-4
Truth Table for a
Full AdderFull
AdderSumX
Y
CinCout
Although designed for unsigned binary numbers, the parallel adder of Figure 4-3
can also be used for signed binary numbers with negative numbers expressed incomplement form.When 2’s complement is used, the last carry ( C
4) is discarded, and
there is no carry into the first cell. Because C0/H110050, the equations for the first cell
may be simplified to
S0/H11005A0⊕B0and C1/H11005A0B0
When 1’s complement is used, the end-around carry is accomplished by connecting
C4to the C0input, as shown by the dashed line in Figure 4-3.
When adding signed binary numbers with negative numbers expressed in com-
plement form, the sign bit of the sum is wrong when an overflow occurs. That is, anoverflow has occurred if adding two positive numbers gives a negative result, oradding two negative numbers gives a positive result. We will define a signal Vthat is
106 Unit 4
FIGURE 4-6
Binary Subtracter
Using Full Adders
Full
Adder
B4′′′′S4
A4 B4 A3 B3 A2 B2 A1 B1Full
Adder
B3S3
Full
Adder
B2S2
Full
Adder
B1S1
c2c1 = 1c3 c4c5
(Ignore last
carr y)1 when an overflow occurs. For Figure 4-3, we can use the sign bits of A,B, and S(the
sum) to determine the value of V:
V/H11005A3/H11032B3/H11032S3/H11001A3B3S3/H11032 (4-22)
If the number of bits is large, a parallel binary adder of the type shown in Figure
4-4 may be rather slow because the carry generated in the first cell might have topropagate all of the way to the last cell. Other types of adders, such as a carry-look-ahead adder,
2may be used to speed up the carry propagation.
Subtraction of binary numbers is most easily accomplished by adding the com-
plement of the number to be subtracted. To compute A/H11002B, add the complement
ofBtoA.This gives the correct answer because A/H11001(/H11002B)/H11005A/H11002B.Either 1’s or
2’s complement is used depending on the type of adder employed.
The circuit of Figure 4-6 may be used to form A/H11002Busing the 2’s complement
representation for negative numbers. The 2’s complement of Bcan be formed by
first finding the 1’s complement and then adding 1. The 1’s complement is formedby inverting each bit of B, and the addition of 1 is effectively accomplished by put-
ting a 1 into the carry input of the first full adder.
2See, for example, J. F., Wakerly, Digital Design Principles and Practices, 4th ed (Prentice Hall, 2006).A/H110050110 ( /H110016)
ExampleB/H110050011 ( /H110013)
The adder output is 0110 ( /H110016)
/H110011100 (1’s complement of 3)
/H11001 1 (first carry input)
(1) 0011 /H110053/H110056/H110023
Alternatively, direct subtraction can be accomplished by employing a full sub-
tracter in a manner analogous to a full adder.A block diagram for a parallel subtracterwhich subtracts Yfrom Xis shown in Figure 4-7.The first two bits are subtracted in the
rightmost cell to give a difference d
1, and a borrow signal ( b2/H110051) is generated if it is
necessary to borrow from the next column.A typical cell (cell i) has inputs xi,yi, and bi,
and outputs bi/H110011anddi. An input bi/H11005 1 indicates that we must borrow 1 from xiin that
cell, and borrowing 1 from xiis equivalent to subtracting 1 from xi. In cell i, bits biand
Applications of Boolean Algebra Minterm and Maxterm Expansions 107
yiare subtracted from xito form the difference di, and a borrow signal ( bi/H110011/H110051) is gen-
erated if it is necessary to borrow from the next column.
Table 4-6 gives the truth table for a binary full subtracter. Consider the follow-
ing case, where xi/H110050,yi/H110051 and bi/H110051:
Column i Column i
Before After 
Borrow Borrow
xi 01 0
/H11002bi /H110021 /H110021
/H11002yi /H110021 /H110021
di 0( bi/H110011/H110051)
Note that in column i, we cannot immediately subtract yiand bifrom xi. Hence, we
must borrow from column i/H110011. Borrowing 1 from column i/H110011 is equivalent to set-
ting bi/H110011to 1 and adding 10 (210) to xi. We then have di/H1100510/H110021/H110021/H110050. Verify that
Table 4-6 is correct for the other input combinations and use it to work out severalexamples of binary subtraction.
Problems
4.1 Represent each of the following sentences by a Boolean equation.
(a) The company safe should be unlocked only when Mr. Jones is in the office or
Mr. Evans is in the office, and only when the company is open for business, andonly when the security guard is present.Full
Subtracterbn + 1 bndn
xn ynFull
Subtracter
Cell ibi + 1 bidi
xi yiFull
Subtracterb3 b2b1= 0d2
x2 y2Full
Subtracterd1
x1 y1
xiyibi bi/H110011di
000 0 0
001 1 1
010 1 1011 1 0100 0 1101 0 0
110 0 0
111 1 1TABLE 4-6
Truth Table for
Binary Full
SubtracterFIGURE 4-7
Parallel Subtracter
108 Unit 4
(b) You should wear your overshoes if you are outside in a heavy rain and you are
wearing your new suede shoes, or if your mother tells you to.
(c) You should laugh at a joke if it is funny, it is in good taste, and it is not offensive
to others, or if it is told in class by your professor (regardless of whether it isfunny and in good taste) and it is not offensive to others.
(d) The elevator door should open if the elevator is stopped, it is level with the
floor, and the timer has not expired, or if the elevator is stopped, it is level withthe floor, and a button is pressed.
4.2 A flow rate sensing device used on a liquid transport pipeline functions as follows.
The device provides a 5-bit output where all five bits are zero if the flow rate is lessthan 10 gallons per minute. The first bit is 1 if the flow rate is at least 10 gallonsper minute; the first and second bits are 1 if the flow rate is at least 20 gallons perminute; the first, second, and third bits are 1 if the flow rate is at least 30 gallons perminute; and so on. The five bits, represented by the logical variables A,B,C,D, and
E, are used as inputs to a device that provides two outputs Yand Z.
(a) Write an equation for the output Yif we want Yto be 1 iff the flow rate is less
than 30 gallons per minute.
(b) Write an equation for the output Zif we want Zto be 1 iff the flow rate is at
least 20 gallons per minute but less than 50 gallons per minute.
4.3 Given F
1/H11005/H9018  m(0, 4, 5, 6) and F2/H11005/H9018  m(0, 3, 6, 7) find the minterm expression for 
F1/H11001F2. State a general rule for finding the expression for F1/H11001F2given the
minterm expansions for F1and F2. Prove your answer by using the general form of
the minterm expansion.
4.4 (a) How many switching functions of two variables ( xand y) are there?
(b) Give each function in truth table form and in reduced algebraic form.
4.5 A combinational circuit is divided into two subcircuits N1and N2as shown. The
truth table for N1is given. Assume that the input combinations ABC /H11005110 and
ABC /H11005010 never occur. Change as many of the values of D,E, and Fto don’t-cares
as you can without changing the value of the output Z.
N1N2
A
B
CD
E
F ZABC DEF
000 110
001 001
010 011
011 111100 100101 101
110 010
111 000
Applications of Boolean Algebra Minterm and Maxterm Expansions 109
4.6 Work (a) and (b) with the following truth table:
ABC FG
000 1 0
001 X 1010 0 X011 0 1100 0 0101 X 1110 1 X111 1 1
(a) Find the simplest expression for F, and specify the values of the don’t-cares that
lead to this expression.
(b) Repeat (a) for G.(Hint: Can you make Gthe same as one of the inputs by prop-
erly choosing the values for the don’t-care?)
4.7 Each of three coins has two sides, heads and tails. Represent the heads or tails sta-
tus of each coin by a logical variable ( Afor the first coin, Bfor the second coin, and
Cfor the third) where the logical variable is 1 for heads and 0 for tails. Write a logic
function F(A,B,C) which is 1 iff exactly one of the coins is heads after a toss of the
coins. Express F
(a) as a minterm expansion.(b) as a maxterm expansion.
4.8 A switching circuit has four inputs as shown. Aand Brepresent the first and second
bits of a binary number N
1.CandDrepresent the first and second bits of a binary num-
berN2. The output is to be 1 only if the product N1/H11003N2is less than or equal to 2.
(a) Find the minterm expansion for F.
(b) Find the maxterm expansion for F.
Express your answers in both decimal notation and algebraic form.
4.9 Given: F(a,b,c)/H11005abc/H11032/H11001b/H11032.
(a) Express Fas a minterm expansion. (Use m-notation.)
(b) Express Fas a maxterm expansion. (Use M-notation.)
(c) Express F/H11032as a minterm expansion. (Use m-notation.)
(d) Express F/H11032as a maxterm expansion. (Use M-notation.)A
FB
C
DN1
N2
110 Unit 4
4.10 Work Problem 4.9 using:
F(a,b,c,d)/H11005(a/H11001b/H11001d) (a/H11032/H11001c) (a/H11032/H11001b/H11032/H11001c/H11032) (a/H11001b/H11001c/H11032/H11001d/H11032)
4.11 (a) Implement a full subtracter using a minimum number of gates.
(b) Compare the logic equations for the full adder and full subtracter. What is the
relation between siand di? Between ci/H110011and bi/H110011?
4.12 Design a circuit which will perform the following function on three 4-bit numbers:
(X3X2X1X0/H11001Y3Y2Y1Y0)/H11002Z3Z2Z1Z0
It will give a result S3S2S1S0, a carry, and a borrow. Use eight full adders and any other
type of gates. Assume that negative numbers are represented in 2’s complement.
4.13 A combinational logic circuit has four inputs ( A,B,C, and D) and one output Z.
The output is 1 iff the input has three consecutive 0’s or three consecutive 1’s. Forexample, if A/H110051,B/H110050,C/H110050, and D/H110050, then Z/H110051, but if A/H110050,B/H110051,C/H110050,
and D/H110050, then Z/H110050. Design the circuit using one four-input OR gate and four
three-input AND gates.
4.14 Design a combinational logic circuit which has one output Zand a 4-bit input
ABCD representing a binary number. Zshould be 1 iff the input is at least 5, but is
no greater than 11. Use one OR gate (three inputs) and three AND gates (with nomore than three inputs each).
4.15 A logic circuit realizing the function fhas four inputs A, B, C , and D. The three
inputs A, B , and Care the binary representation of the digits 0 through 7 with A
being the most-significant bit. The input Dis an odd-parity bit, i.e., the value of D
is such that A, B, C , and Dalways contain an odd number of 1’s. (For example, the
digit 1 is represented by ABC /H11005001 and D/H110050, and the digit 3 is represented by
ABCD /H110050111.) The function fhas value 1 if the input digit is a prime number. (A
number is prime if it is divisible only by itself and 1; 1 is considered to be primeand 0 is not.)(a) List the minterms and don’t-care minterms of fin algebraic form.
(b) List the maxterms and don’t-care maxterms of fin algebraic form.
4.16 A priority encoder circuit has four inputs, x
3,x2,x1, and x0. The circuit has three out-
puts: z, y1, and y0. If one of the inputs is 1, zis 1 and y1andy0represent a 2-bit, bina-
ry number whose value equals the index of the highest numbered input that is 1. Forexample, if x
2is 1 and x3is 0, then the outputs are z/H110051 and y1/H110051 and y0/H110050. If all
inputs are 0, z/H110050 and y1and y0are don’t-cares.
(a) List in decimal form the minterms and don’t-care minterms of each output.(b) List in decimal form the maxterms and don’t-care maxterms of each output.
4.17 The 9’s complement of a decimal digit d(0 to 9) is defined to be 9 /H11002d. A logic
circuit produces the 9’s complement of an input digit where the input and output
Applications of Boolean Algebra Minterm and Maxterm Expansions 111
digits are represented in BCD. Label the inputs A, B, C , and D, and label the out-
puts W, X, Y and Z.
(a) Determine the minterms and don’t-care minterms for each of the outputs.(b) Determine the maxterms and don’t-care maxterms for each of the outputs.
4.18 Repeat Problem 4.17 for the case where the input and output digits are represented
using the 4-2-2-1 weighted code. (If only one weight of 2 is required for decimal dig-its less than 5, select the rightmost 2. In addition, select the codes so that W/H11005A/H11032,
X/H11005B/H11032,Y/H11005C/H11032, and Z/H11005D/H11032. (There are two possible codes with these restrictions.)
4.19 Each of the following sentences has two possible interpretations depending on
whether the AND or OR is done first. Write an equation for each interpretation.(a) The buzzer will sound if the key is in the ignition switch, and the car door is
open, or the seat belts are not fastened.
(b) You will gain weight if you eat too much, or you do not exercise enough, and
your metabolism rate is too low.
(c) The speaker will be damaged if the volume is set too high, and loud music is
played, or the stereo is too powerful.
(d) The roads will be very slippery if it snows, or it rains, and there is oil on the road.
4.20 A bank vault has three locks with a different key for each lock. Each key is
owned by a different person. To open the door, at least two people must inserttheir keys into the assigned locks. The signal lines A,B, and Care 1 if there is a
key inserted into lock 1, 2, or 3, respectively. Write an equation for the variable Z
which is 1 iff the door should open.
4.21 A paper tape reader used as an input device to a computer has five rows of holes as
shown. A hole punched in the tape indicates a logic 1, and no hole indicates a logic 0.As each hole pattern passes under the photocells, the pattern is translated into logicsignals on lines A,B,C,D, and E. All patterns of holes indicate a valid character with
two exceptions.A pattern consisting of none of the possible holes punched is not usedbecause it is impossible to distinguish between this pattern and the unpunched spacebetween patterns. An incorrect pattern punched on the tape is erased by punching allfive holes in that position. Therefore, a valid character punched on the tape will haveat least one hole but will not have all five holes punched.(a) Write an equation for a variable Zwhich is 1 iff a valid character is being read.
(b) Write an equation for a variable Ywhich is 1 iff the hole pattern being read has
holes punched only in rows Cand E.
Photocells
Variables
A
B
C
D
E
112 Unit 4
4.22 A computer interface to a line printer has seven data lines that control the move-
ment of the paper and the print head and determine which character to print. Thedata lines are labeled A,B,C,D,E,F, and G, and each represents a binary 0 or 1.
When the data lines are interpreted as a 7-bit binary number with line Abeing
the most significant bit, the data lines can represent the numbers 0 to 127
10.T h e
number 1310is the command to return the print head to the beginning of a line,
the number 1010means to advance the paper by one line, and the numbers 3210to
12710represent printing characters.
(a) Write an equation for the variable Xwhich is 1 iff the data lines indicate a com-
mand to return the print head to the beginning of the line.
(b) Write an equation for the variable Ywhich is 1 iff there is an advance paper
command on the data lines.
(c) Write an equation for the variable Zwhich is 1 iff the data lines indicate a print-
able character. ( Hint: Consider the binary representations of the numbers 0–31
and 32–127 and write the equation for Zwith only two terms.)
4.23 Given F1/H11005/H9016 M(0, 4, 5, 6) and F2/H11005/H9016 M(0, 4, 7), find the maxterm expansion for F1F2.
State a general rule for finding the maxterm expansion of F1F2given the maxterm
expansions of F1and F2.
Prove your answer by using the general form of the maxterm expansion.
4.24 Given F1/H11005/H9016 M(0, 4, 5, 6) and F2/H11005/H9016 M(0, 4, 7), find the maxterm expansion
forF1/H11001F2.
State a general rule for finding the maxterm expansion of F1/H11001F2, given the max-
term expansions of F1and F2.
Prove your answer by using the general form of the maxterm expansion.
4.25 Four chairs are placed in a row:
Each chair may be occupied (1) or empty (0). Give the minterm and maxterm
expansion for each logic function described.(a)F(A,B,C,D) is 1 iff there are no adjacent empty chairs.
(b)G(A,B,C,D) is 1 iff the chairs on the ends are both empty.
(c)H(A,B,C,D) is 1 iff at least three chairs are full.
(d)J(A,B,C,D) is 1 iff there are more people sitting in the left two chairs than in
the right two chairs.
4.26 Four chairs ( A, B, C , and D) are placed in a circle: Anext to B, B next to C, C next
toD, and Dnext to A. Each chair may be occupied (1) or empty (0). Give the
minterm and maxterm expansion for each of the following logic functions:(a)F(A, B, C, D ) is 1 iff there are no adjacent empty chairs.
(b)G(A, B, C, D ) is 1 iff there are at least three adjacent empty chairs.A B C D
Applications of Boolean Algebra Minterm and Maxterm Expansions 113
(c)H(A, B, C, D ) is 1 iff at least three chairs are full.
(d)J(A, B, C, D ) is 1 iff there are more people sitting in chairs Aand Bthan chairs
Cand D.
4.27 Given f(a, b, c )/H11005a(b/H11001c/H11032).
(a) Express fas a minterm expansion (use m-notation).
(b) Express fas maxterm expansion (use M-notation).
(c) Express f/H11032as a minterm expansion (use m-notation).
(d) Express f/H11032as a maxterm expansion (use M-notation).
4.28 Work Problem 4.27 using f(a, b, c, d )/H11005acd/H11001bd/H11032/H11001a/H11032c/H11032d/H11001ab/H11032cd/H11001a/H11032b/H11032cd/H11032.
4.29 Find both the minterm expansion and maxterm expansion for the following func-
tions, using algebraic manipulations :
(a)f(A, B, C, D )/H11005AB/H11001A/H11032CD
(b)f(A, B, C, D )/H11005(A/H11001B/H11001D/H11032)(A/H11032/H11001C)(C/H11001D)
4.30 Given F/H11032(A,B,C,D)/H11005/H9018  m(0, 1, 2, 6, 7, 13, 15).
(a) Find the minterm expansion for F(both decimal and algebraic form).
(b) Find the maxterm expansion for F(both decimal and algebraic form).
4.31 Repeat Problem 4.30 for F/H11032(A,B,C,D)/H11005/H9018 m(1, 2, 5, 6, 10, 15).
4.32 Work parts (a) through (d) with the given truth table.
ABC F1F2F3F4
00 0 1101
00 1 X00001 0 01X001 1 001110 0 0111
10 1 X010
11 0 0XXX11 1 1X1X
(a) Find the simplest expression for F1, and specify the values for the don’t-cares
that lead to this expression.
(b) Repeat for F2.
(c) Repeat for F3.
(d) Repeat for F4.
114 Unit 4
4.34 Work Problem 4.7 for the following logic functions:
(a)G1(A,B,C) is 1 iff all the coins landed on the same side (heads or tails).
(b)G2(A,B,C) is 1 iff the second coin landed on the same side as the first coin.
4.35 A combinational circuit has four inputs ( A,B,C,D) and three outputs ( X,Y,Z).
XYZ represents a binary number whose value equals the number of 1’s at the input.
For example if ABCD /H110051011, XYZ /H11005011.
(a) Find the minterm expansions for X,Y, and Z.
(b) Find the maxterm expansions for Yand Z.
4.36 A combinational circuit has four inputs ( A,B,C,D) and four outputs ( W,X,Y,Z).
WXYZ represents an excess-3 coded number whose value equals the number of 1’s
at the input. For example, if ABCD /H110051101, WXYZ /H110050110.
(a) Find the minterm expansions for X,Y, and Z.
(b) Find the maxterm expansions for Yand Z.
4.37 A combinational circuit has four inputs ( A,B,C,D), which represent a binary-
coded-decimal digit. The circuit has two groups of four outputs— S,T,U,V, and
W,X,Y,Z.Each group represents a BCD digit. The output digits represent a
decimal number which is five times the input number. For example, if ABCD /H11005
0111, the outputs are 0011 0101. Assume that invalid BCD digits do not occuras inputs.(a) Construct the truth table.(b) Write down the minimum expressions for the outputs by inspection of the truth
table. ( Hint: Try to match output columns in the table with input columns.)
4.38 Work Problem 4.37 where the BCD outputs represent a decimal number that is 1
more than four times the input number. For example, if ABCD /H110050011, the outputs
are 0001 0011.
4.39 Design a circuit which will add a 4-bit binary number to a 5-bit binary number. Use
five full adders. Assume negative numbers are represented in 2’s complement.(Hint: How do you make a 4-bit binary number into a 5-bit binary number, with-
out making a negative number positive or a positive number negative? Try writingN1N2
A
B
CD
E
FZABC DEF
00 0 110
00 1 010
01 0 001
01 1 00010 0 01010 1 001
11 0 001
11 1 1014.33 Work Problem 4.5 using the following circuits and truth table.Assume that the input
combinations of ABC /H11005011 and ABC /H11005110 will never occur.
/H11032/H11001 01 ab •01 ab
01 001 ab 00000
10 11111 101 ab
ab aa 1a1 a0aa 0
ba bb 11 bb 0b0bdown the representation for /H110023 as a 3-bit 2’s complement number, a 4-bit 2’s com-
plement number, and a 5-bit 2’s complement number. Recall that one way to findthe 2’s complement of a binary number is to complement allbits to the left of
the first 1.)
4.40 A half adder is a circuit that adds two bits to give a sum and a carry. Give the truth
table for a half adder, and design the circuit using only two gates. Then design a cir-cuit which will find the 2’s complement of a 4-bit binary number. Use four halfadders and any additional gates. ( Hint: Recall that one way to find the 2’s comple-
ment of a binary number is to complement allbits, and then add 1.)
4.41 (a) Write the switching function f(x, y)/H11005x/H11001yas a sum of minterms and as a prod-
uct of maxterms.
(b) Consider the Boolean algebra of four elements {0, 1, a, b} specified by the
following operation tables and the Boolean function f(x, y)/H11005ax/H11001bywhere a
andbare two of the elements in the Boolean algebra. Write f(x, y) in a sum-of-
minterms form.
(c) Write the Boolean function of part (b) in a product-of-maxterms form.(d) Give a table of combinations for the Boolean function of Part (b). ( Note :T h e
table of combinations has 16 rows, not just 4.)
(e) Which four rows of the table of combinations completely specify the function
of Part (b)? Verify your answer.Applications of Boolean Algebra Minterm and Maxterm Expansions 115
4.42 (a) If m1and m2are minterms of nvariables, prove that m1/H11001m2/H11005m1/H17053m2.
(b) Prove that any switching function can be written as the exclusive-OR sum of
products where each product does not contain a complemented literal.[Hint : Start with the function written as a sum of minterms and use Part (a).]
Karnaugh Maps
116UNIT
5
Objectives
1.Given a function (completely or incompletely specified) of three to five
variables, plot it on a Karnaugh map. The function may be given inminterm, maxterm, or algebraic form.
2.Determine the essential prime implicants of a function from a map.
3.Obtain the minimum sum-of-products or minimum product-of-sums form
of a function from the map.
4.Determine all of the prime implicants of a function from a map.
5.Understand the relation between operations performed using the map
and the corresponding algebraic operations.
In this unit we will study the Karnaugh (pronounced “car-no”) map. Just about any
type of algebraic manipulation we have done so far can be facilitated by using the
map, provided the number of variables is small.
l.Study Section 5.1, Minimum Forms of Switching Functions .
(a) Define a minimum sum of products.
(b) Define a minimum product of sums.
2.Study Section 5.2, Two- and Three-Variable Karnaugh Maps .
(a) Plot the given truth table on the map. Then, loop two pairs of 1’s on the
map and write the simplified form of F.Karnaugh Maps 117
Study Guide
P Q F
0 0 1
0 1 11 0 01 1 101
0QP
FF =1
Now simplify Falgebraically and verify that your answer is correct.
(b) F(a,b,c) is plotted below. Find the truth table for F.
a b c F
0 0 0
0 0 10 1 00 1 1
1 0 0
1 0 11 1 01 1 10 101
1 1
0 1
100bc
Fa
01
1110
0
118 Unit 5
(c) Plot the following functions on the given Karnaugh maps:
F2(R,S,T)/H11005/H9016  M(2, 3, 4, 7) F1(R,S,T)/H11005/H9018 m(0, 1, 5, 6)
01
00
01
111001
00
01
1110
01
00yzx
01
1110Why are the two maps the same?
(d) Plot the following function on the given map:
Donotmake a minterm expansion or a truth table before plotting.f(x,y,z)/H11005z/H11032/H11001x/H11032z/H11001yz
(e) For a three-variable map, which squares are “adjacent” to square 2?
__________
(f) What theorem is used when two terms in adjacent squares are combined?
(g) What law of Boolean algebra justifies using a given 1 on a map in two
or more loops?
In each case, change the looping on the map so that the minimum solution
is obtained.
(i) Work Problem 5.3.
( j) Find two different minimum sum-of-products expressions for the function
G, which is plotted below.Karnaugh Maps 119
3.Study Section 5.3, Four-Variable Karnaugh Maps .
(a) Note the locations of the minterms on three- and four-variable maps
[Figures 5-3(b) and 5-10]. Memorize this ordering. This will save you a lotof time when you are plotting Karnaugh maps.
This ordering is valid only for the order of the variables given. If we label
the maps as shown below, fill in the locations of the minterms:
00 01 11 10
00ABCD
01
111000 01 11 10
0ABC
11 101
1
1 1
100bc
Ga
01
11101 101
1
1 1
100bc
GG =
G =a
01
1110101
1
100bc
f = ab′ + abc g  = a′ + aba
01
1110101
1
1 1
100bca
01
1110
1(h) Each of the following solutions is not minimum.
120 Unit 5
(c) Plot the following functions on the given maps:
(2)f (w,x,y,z)/H11005x/H11032z/H11032/H11001y/H11032z/H11001w/H11032xz/H11001wyz/H11032(1)f (w,x,y,z)/H11005/H9018 m(0, 1, 2, 5, 7, 8, 9, 10, 13, 14)1 100 01 11 10
1 1 1
1 100cdab
01
1110
1F =
F =(b) Given the following map, write the minterm and maxterm expansions for Fin
decimal form:
00 01 11 10
00yzwx
01
11
1000 01 11 10
00yzwx
01
11
10
100 01 11 10
1 1
1 100cdab
01
1110
1a′b′c′d + ab′c′d = b′c′d
[The term b′c′d can be read directl y from the
map because it spans the first and last columns
(b′) and because it is in the second row ( c′d).]Your answers to (1) and (2) should be the same.
(d) For a four-variable map, which squares are adjacent to square 14? ________ 
To square 8? __________
(e) When we combine two adjacent 1’s on a map, this corresponds to applying
the theorem xy/H11032/H11001xy/H11005xto eliminate the variable in which the two terms
differ.Thus, looping the two 1’s as indicated on the following map is equiv-alent to combining the corresponding minterms algebraically:
(For each part you should have looped two groups of four 1’s and two
groups of two 1’s).Write down the minimum sum-of-products expression for f
1and f2from
these maps.
f1/H11005__________________________________________________
f2/H11005__________________________________________________
(h) Why is it not possible to combine three or six minterms together rather
than just two, four, eight, etc.?Loop the other four 1’s on the map and state the algebraic equivalent.
(g) For each of the following maps, loop a minimum number of terms which
will cover all of the 1’s.Karnaugh Maps 121
1 100 01
f1 f211 10
1 1 1
1 100cdab
01
11
10 1100 01 11 10
1
1 1 1 1
100cdab
01
11
10 1Loop two other pairs of adjacent 1’s on this map and state the algebraic
equivalent of looping these terms. Now read the loops directly off themap and check your algebra.
(f ) When we combine four adjacent 1’s on a map (either four in a line or four
in a square) this is equivalent to applying xy/H11001xy/H11032/H11005xthree times:
a′b′cd + a′b′cd′ + ab′cd + ab′cd′ = a′b′c + ab′c = b′c100 01 11 10
1
1 1 1
100cdab
01
1110
1 1
122 Unit 5
100 01 11 10
1 1 1
1 100CDAB
01
1110
1 1(i) Note the procedure for deriving the minimum product of sums from the
map.You will probably make fewer mistakes if you write down f/H11032as a sum
of products first and then complement it, as illustrated by the example inFigure 5-14.
( j) Work Problems 5.4 and 5.5.
4.Study Section 5.4, Determination of Minimum Expressions Using Essential
Prime Implicants .
(a) For the map of Figure 5-15, list three implicants of Fother than those which
are labeled.
For the same map, is ac/H11032d/H11032a prime implicant of F?
Why or why not?
(b) For the given map, are any of the circled 
terms prime implicants?
Why or why not?
5.Study Figure 5-18 carefully and then answer the following questions for the 
given map:
(a) How many 1’s are adjacent to m
0?
(b) Are all these 1’s covered by a single 
prime implicant?
(c) From your answer to (b), can you 
determine whether B/H11032C/H11032is essential?
(d) How many 1’s are adjacent to m9?
(e) Are all of these 1’s covered by a single 
prime implicant?
(f) From your answer to (e), is B/H11032C/H11032essential?
(g) How many 1’s are adjacent to m7?
(h) Why is A/H11032Cessential?
(i) Find two other essential prime implicants and tell which minterm makes
them essential.1
01
4100 01 11 10
8
1
11
9
1
31
7
100CDAB
01
1110
21
61
10
6.(a) How do you determine if a prime implicant is essential using a Karnaugh
map?
(b) For the following map, why is A/H11032B/H11032notessential?
Why is BD/H11032essential?
IsA/H11032D/H11032essential? Why?
IsBC/H11032essential? Why?
IsB/H11032CDessential? Why?
Find the minimum sum of products.
(c) Work Programmed Exercise 5.1.
(d) List all 1’s and X’s that are adjacent to 10.
Why is A/H11032C/H11032an essential prime implicant?
List all 1’s and X’s adjacent to 115.10 14 11200 01 11 10
8
X1 15 X13 9
3 X7 115 11100CDAB
01
1110
2 6 X14 10Karnaugh Maps 123
1 1 100 01 11 10
1 1 1
1 1
100CDAB
01
1110
1 1
124 Unit 5
Based on this list, why can you not find an essential prime implicant that
covers 115?
Does this mean that there is no essential prime implicant that covers 115?
What essential prime implicant covers 111?
Can you find an essential prime implicant that covers 112? Explain.
Find two prime implicants that cover 112.
Give two minimum expressions for F.
(e) Work Problem 5.6.
(f) If you have a copy of the LogicAid program available, use the Karnaugh
map tutorial mode to help you learn to find minimum solutions fromKarnaugh maps. This program will check your work at each step to makesure that you loop the terms in the correct order. It also will check yourfinal answer. Work Problem 5.7 using the Karnaugh map tutor.
7.(a) In Example 4, page 103, we derived the following function:
Plot Zon the given map using X’s to represent don’t-care terms.Z/H11005/H9018 m(0, 3, 6, 9) /H11001/H9018 d (10, 11, 12, 13, 14, 15)
00 01 11
Z10
00CDAB
01
11
10
(b) Show that the minimum sum of products is
Which four don’t-care minterms were assigned the value 1 when forming
your solution?Z/H11005A/H11032B/H11032C/H11032D/H11032/H11001B/H11032CD/H11001AD /H11001BCD /H11032
(b) On a five-variable map (Figure 5-21), what are the five minterms adja-
cent to minterm 24?
(c) Work through all of the examples in this section carefully and make sure
that you understand all of the steps.
(d) Two minimum solutions are given for Figure 5-24. There is a third mini-
mum sum-of-products solution. What is it?
(e) Work Programmed Exercise 5.2.(c) Show that the minimum product of sums for Zis
Which one don’t-care term of Zwas assigned the value 1 when forming
your solution?
(d) Work Problem 5.8.
8.Study Section 5.5, Five-Variable Karnaugh Maps .
(a) The figure below shows a three-dimensional five-variable map. Plot the 1’s
and loops on the corresponding two-dimensional map, and give the mini-mum sum-of-products expression for the function.Z/H11005 (B/H11032/H11001C) (B/H11032/H11001D/H11032) (A/H11032/H11001D)(A/H11001C/H11001D/H11032)(B/H11001C/H11032/H11001D)Karnaugh Maps 125
0000
00
01
11
1001 11 10
01 11 10
00
1
0DE
ABC
01
11
10DE
A = 1
F =A = 0BC
11
11
1111
126 Unit 5
0 4 1200 01 11 10
8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 14XX 1
X 1
X 1
11 XX1
111 X
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26(f)
Find the three 1’s and X’s adjacent to 118. Can these all be looped with a
single loop?Find the 1’s and X’s adjacent to 1
24. Loop the essential prime implicant
that covers 124.
Find the 1’s and X’s adjacent to 13. Loop the essential prime implicant that
covers 13.
Can you find an essential prime implicant that covers 122? Explain.
Find and loop two more essential prime implicants.
Find three ways to cover the remaining 1 on the map and give the corre-sponding minimum solutions.
(g) If you have the LogicAid program available, work Problem 5.9, using the
Karnaugh map tutor.
9.Study Section 5.6, Other Uses of Karnaugh Maps . Refer to Figure 5-8 and note
that a consensus term exists if there are two adjacent, but nonoverlapping primeimplicants. Observe how this principle is applied in Figure 5-26.
10. Work Problems 5.10, 5.11, 5.12, and 5.13 When deriving the minimum solution
from the map, always write down the essential prime implicants first. If you do not,
it is quite likely that you will not get the minimum solution. In addition, make sureyou can find allof the prime implicants from the map [see Problem 5.10(b)].
11. Review the objectives and take the readiness test.
127Karnaugh Maps
Switching functions can generally be simplified by using the algebraic techniques
described in Unit 3. However, two problems arise when algebraic procedures areused:
1.The procedures are difficult to apply in a systematic way.
2.It is difficult to tell when you have arrived at a minimum solution.
The Karnaugh map method studied in this unit and the Quine-McCluskey proce-
dure studied in Unit 6 overcome these difficulties by providing systematic methodsfor simplifying switching functions. The Karnaugh map is an especially useful toolfor simplifying and manipulating switching functions of three or four variables, butit can be extended to functions of five or more variables. Generally, you will findthe Karnaugh map method is faster and easier to apply than other simplificationmethods.
5.1 Minimum Forms of Switching Functions
When a function is realized using AND and OR gates, the cost of realizing the func-tion is directly related to the number of gates and gate inputs used. The Karnaughmap techniques developed in this unit lead directly to minimum cost two-levelcircuits composed of AND and OR gates. An expression consisting of a sum ofproduct terms corresponds directly to a two-level circuit composed of a groupof AND gates feeding a single OR gate (see Figure 2-5). Similarly, a product-of-sums expression corresponds to a two-level circuit composed of OR gates feedinga single AND gate (see Figure 2-6). Therefore, to find minimum cost two-levelAND-OR gate circuits, we must find minimum expressions in sum-of-products orproduct-of-sums form.
Aminimum sum-of-products expression for a function is defined as a sum of
product terms which (a) has a minimum number of terms and (b) of all thoseexpressions which have the same minimum number of terms, has a minimum num-ber of literals. The minimum sum of products corresponds directly to a minimumtwo-level gate circuit which has (a) a minimum number of gates and (b) a minimum
128 Unit 5
number of gate inputs. Unlike the minterm expansion for a function, the minimum
sum of products is not necessarily unique; that is, a given function may have two dif-ferent minimum sum-of-products forms, each with the same number of terms andthe same number of literals. Given a minterm expansion, the minimum sum-of-products form can often be obtained by the following procedure:
1.Combine terms by using . Do this repeatedly to eliminate as many
literals as possible. A given term may be used more than once because .
2.Eliminate redundant terms by using the consensus theorem or other theorems.
Unfortunately, the result of this procedure may depend on the order in which terms are
combined or eliminated so that the final expression obtained is not necessarily minimum.
Find a minimum sum-of-products expression for
Example
(5-1)
None of the terms in the above expression can be eliminated by consensus. However,
combining terms in a different way leads directly to a minimum sum of products:
(5-2)
Aminimum product-of-sums expression for a function is defined as a product
of sum terms which (a) has a minimum number of factors, and (b) of all thoseexpressions which have the same number of factors, has a minimum number of lit-erals. Unlike the maxterm expansion, the minimum product-of-sums form of afunction is not necessarily unique. Given a maxterm expansion, the minimum prod-uct of sums can often be obtained by a procedure similar to that used in the mini-mum sum-of-products case, except that the theorem isused to combine terms.
(5-3) /H11005 (A/H11001B/H11032/H11001 D/H11032)(C/H11032/H11001 D)/H11005(A/H11001B/H11032/H11001D/H11032)               ( A/H11001B/H11032/H11001C/H11032)               ( C/H11032/H11001D)/H11005 (A/H11001B/H11032/H11001 D/H11032)  (A/H11001B/H11032/H11001 C/H11032)  (B/H11032/H11001 C/H11032/H11001 D)  (B/H11001C/H11032/H11001 D)(A/H11032/H11001B/H11001C/H11032/H11001D) (A/H11001B/H11032/H11001C/H11001D/H11032)(A/H11001B/H11032/H11001C/H11032/H11001D/H11032)(A/H11001B/H11032/H11001C/H11032/H11001D)(A/H11032/H11001B/H11032/H11001C/H11032/H11001D)(A/H11001B/H11001C/H11032/H11001D) (X/H11001Y )(X/H11001Y/H11032)/H11005X/H11005  a/H11032b/H11032  /H11001 bc/H11032  /H11001 acF/H11005a/H11032b/H11032c/H11032/H11001 a/H11032b/H11032c/H11001a/H11032bc/H11032/H11001 ab/H11032c/H11001abc/H11032/H11001 abc/H11005a/H11032b/H11032/H11001 b/H11032c /H11001 bc/H11032/H11001 abF/H11005a/H11032b/H11032c/H11032/H11001 a/H11032b/H11032c/H11001a/H11032bc/H11032/H11001ab/H11032c/H11001abc/H11032/H11001abcF(a,b,c)/H11005/H9018 m (0, 1, 2, 5, 6, 7) /H11005X X/H11001XXY/H11032/H11001XY /H11005X
¯˚˘˚˙
eliminate by consensus —Example
5.2 Two- and Three-Variable Karnaugh Maps
Just like a truth table, the Karnaugh map of a function specifies the value of the func-
tion for every combination of values of the independent variables. A two-variableKarnaugh map is shown. The values of one variable are listed across the top of themap, and the values of the other variable are listed on the left side. Each square ofthe map corresponds to a pair of values for AandBas indicated.Karnaugh Maps 129
A B F
0 0 1
0 1 11 0 01 1 0
(a)FIGURE 5-1
01
0BA
110
1001
0BA
1A′B′
A′B10
1001
0BA
110
10A′B′ + A′B = A′
F = A′
(d) (c) (b)F = A′B′ + A′B
Figure 5-2 shows a three-variable truth table and the corresponding Karnaugh
map (see Figure 5-27 for an alternative way of labeling maps). The value of onevariable ( A) is listed across the top of the map, and the values of the other two
variables ( B,C) are listed along the side of the map. The rows are labeled in
the sequence 00, 01, 11, 10 so that values in adjacent rows differ in only one vari-able. For each combination of values of the variables, the value of Fis read
from the truth table and plotted in the appropriate map square. For example,for the input combination ABC /H11005001, the value F/H110050 is plotted in the square
for which A/H110050 and BC/H1100501. For the combination ABC /H11005110, F/H110051 is plotted
in the A/H110051,BC/H1100510 square.01
0BA
A = 1, B = 0
1A = 1, B = 1A = 0, B = 0
A = 0, B = 1
Figure 5-1 shows the truth table for a function Fand the corresponding
Karnaugh map. Note that the value of FforA/H11005B/H110050 is plotted in the upper left
square, and the other map entries are plotted in a similar way in Figure 5-1(b).Each 1 on the map corresponds to a minterm of F. We can read the minterms from
the map just like we can read them from the truth table. A 1 in square 00 of Figure5-1(c) indicates that A/H11032B/H11032is a minterm of F. Similarly, a 1 in square 01 indicates
that A/H11032Bis a minterm. Minterms in adjacent squares of the map can be combined
since they differ in only one variable.Thus, A/H11032B/H11032andA/H11032Bcombine to form A/H11032, and
this is indicated by looping the corresponding 1’s on the map in Figure 5-1(d).
130 Unit 5
0 401
1 5
3 7
200bca
01
11
10 6
(b) Decimal notation000 10001
001 101
011 111
01000bca
01
11
10 110
(a) Binar y notation100 is
adjacentto 110FIGURE 5-3
Location of
Minterms on
a Three-Variable
Karnaugh MapFIGURE 5-2
Truth Table and
Karnaugh Map for
Three-Variable
Function0 101
0 0
1 0
100
ABC = 001, F = 0
ABC  = 110, F = 1BCA
01
11
10 1
F
(b)A B C F
0 0 0 0
0 0 1 00 1 0 10 1 1 11 0 0 1
1 0 1 0
1 1 0 11 1 1 0
(a)
Given the minterm expansion of a function, it can be plotted on a map by
placing 1’s in the squares which correspond to minterms of the function and 0’sin the remaining squares (the 0’s may be omitted if desired). Figure 5-4 shows theplot of . If Fis given as a maxterm expansion, the map is
plotted by placing 0’s in the squares which correspond to the maxterms and thenby filling in the remaining squares with 1’s. Thus,gives the same map as Figure 5-4.F(a,b,c)/H11005M
0M2M4M6M7m1/H11001m3/H11001m5 F(a,b,c)/H11005Figure 5-3 shows the location of the minterms on a three-variable map.
Minterms in adjacent squares of the map differ in only one variable and thereforecan be combined using the theorem XY/H11032/H11001XY/H11005X. For example, minterm 011
(a/H11032bc) is adjacent to the three minterms with which it can be combined—001
(a/H11032b/H11032c), 010 ( a/H11032bc/H11032), and 111 ( abc). In addition to squares which are physically
adjacent, the top and bottom rows of the map are defined to be adjacent becausethe corresponding minterms in these rows differ in only one variable. Thus 000and 010 are adjacent, and so are 100 and 110.
Karnaugh Maps 131
101
1 1
1
100bca
01
11
10 11.   The term abc′ is 1 when a = 1 and bc = 10, so
      we place a 1 in the square which corresponds
      to the a = 1 column and the bc = 10 row of the
      map.
2.   The term b′c is 1 when bc = 01, so we place 1's
      in both squares of the bc = 01 row of the map.
3.   The term a′ is 1 when a = 0, so we place 1's in
      all the squares of the a = 0 column of the map.
      (Note: Since there alread y is a 1 in the abc =
      001 square, we do not have to place a second
      1 there because x + x = x.)
abc′Figure 5-5 illustrates how product terms can be plotted on Karnaugh maps. To
plot the term b, 1’s are entered in the four squares of the map where b/H110051. The
term bc/H11032is 1 when b/H110051 and c/H110050, so 1’s are entered in the two squares in the
bc/H1100510 row. The term ac/H11032is 1 when a/H110051 and c/H110050, so 1’s are entered in the a/H11005
1 column in the rows where c/H110050.
01
bb = 1 in
these rowsa = 1 in
this column
c = 0 in
these rows
1 1
100bca
01
1110
101
bc′100bca
01
1110
1101
ac′00bca
01
1110
1FIGURE 5-5
Karnaugh Maps for
Product Terms0
00
401
1
11
5
1
30
7
000bca
01
1110
20
6FIGURE 5-4
Karnaugh Map of 
F(a,b,c)/H11005
/H9018 m(1, 3, 5) /H11005
/H9016M(0, 2, 4, 6, 7) 
If a function is given in algebraic form, it is unnecessary to expand it to minterm
form before plotting it on a map. If the algebraic expression is converted to sum-of-products form, then each product term can be plotted directly as a group of 1’s onthe map. For example, given that
we would plot the map as follows:f (a,b,c)/H11005abc/H11032/H11001 b/H11032c/H11001a/H11032
132 Unit 5
1 101
0 0
0 1
100bca
01
11
10 1T1=b′c′ + bc′=c′T2=abFIGURE 5-7
Complement of
Map in Figure
5.6(a)01
1 1
100bca
01
11
100
F = Σ m(1, 3, 5) F = a′c+b′c
(a) Plot of minterms (b) Simplified form of F1
1 1
100bca
01
11
10T1
=a′b′c + a′bc
=a′cT2
=a′b′c + ab′c
=b′cFIGURE 5-6
Simplification of a
Three-Variable
Function
The map for the complement of F(Figure 5-7) is formed by replacing 0’s with
1’s and 1’s with 0’s on the map of F. To simplify F/H11032, note that the terms in the top
row combine to form b/H11032c/H11032, and the terms in the bottom row combine to form bc/H11032.
Because b/H11032c/H11032and bc/H11032differ in only one variable, the top and bottom rows can then
be combined to form a group of four 1’s, thus eliminating two variables and leav-ingT
1/H11005c/H11032. The remaining 1 combines, as shown, to form T2/H11005ab, so the minimum
sum-of-products form for F/H11032isc/H11032/H11001ab.Figure 5-6 illustrates how a simplified expression for a function can be derived
using a Karnaugh map.The function to be simplified is first plotted on a Karnaughmap in Figure 5-6(a). Terms in adjacent squares on the map differ in only onevariable and can be combined using the theorem . Thus a/H11032b/H11032cand
a/H11032bccombine to form a/H11032c, and a/H11032b/H11032cand ab/H11032ccombine to form b/H11032c, as shown in
Figure 5-6(b). A loop around a group of minterms indicates that these terms havebeen combined. The looped terms can be read directly off the map. Thus, forFigure 5-6(b), term T
lis in the a/H110050(a/H11032)column, and it spans the rows where 
c/H110051, so Tl/H11005a/H11032c. Note that bhas been eliminated because the two minterms in Tl
differ in the variable b. Similarly, the term T2is in the bc/H1100501 row so T2/H11005b/H11032c, and
ahas been eliminated because T2spans the a/H110050 and a/H110051 columns. Thus, the
minimum sum-of-products form for Fisa/H11032c/H11001b/H11032c.XY/H11032/H11001XY /H11005X
5.3 Four-Variable Karnaugh Maps
Figure 5-10 shows the location of minterms on a four-variable map. Each minterm
is located adjacent to the four terms with which it can combine. For example, m5
(0101) could combine with ml(0001), m4(0100), m7(0111), or m13(1101) because it
differs in only one variable from each of the other minterms. The definition of adja-cent squares must be extended so that not only are top and bottom rows adjacentas in the three-variable map, but the first and last columns are also adjacent. Thisrequires numbering the columns in the sequence 00, 01, 11, 10 so that minterms 0and 8, 1 and 9, etc., are in adjacent squares.Karnaugh Maps 133
10
F = a′b′ + bc′ + ac1
1 1
1
100bca
01
1110
110
F = a′c′ + b′c + ab1
1 1
1
100bca
01
1110
1FIGURE 5-9
Function with Two
Minimum FormsIf a function has two or more minimum sum-of-products forms, all of these
forms can be determined from a map. Figure 5-9 shows the two minimum solutionsfor .F/H11005/H9018  m(0, 1, 2, 5, 6, 7)The Karnaugh map can also illustrate the basic theorems of Boolean algebra.
Figure 5-8 illustrates the consensus theorem, . Notethat the consensus term ( YZ) is redundant because its 1’s are covered by the other
two terms.XY/H11001X/H11032Z/H11001YZ/H11005XY/H11001X/H11032Z
01
1
1 100yzx
01
1110
1x′z
xy
xy + x′z + yz = xy + x′zyz (consensus term)01
1
1 100yzx
01
1110
1FIGURE 5-8
Karnaugh Maps
that Illustrate the
Consensus Theorem
134 Unit 5
Next, we will simplify the functions f1and f2given in Figure 5-12. Because the
functions are specified in minterm form, we can determine the locations of the 1’s onthe map by referring to Figure 5-10. After plotting the maps, we can then combineadjacent groups of 1’s. Minterms can be combined in groups of two, four, or eight toeliminate one, two, or three variables, respectively. In Figure 5-12(a), the pair of 1’s intheab/H1100500 column and also in the d/H110051 rows represents a/H11032b/H11032d. The group of four
1’s in the b/H110051 columns and c/H110050 rows represents bc/H11032.1 1 1 100 01 11 10
1
1 1 1
100cdab
01
1110
1 1 1a′b
acdd′FIGURE 5-11
Plot of
acd/H11001a/H11032b/H11001d/H110320 4 12 800 01 11 10
1 5 13 9
3 7 15 11
200CDAB
01
1110
6 14 10FIGURE 5-10
Location
of Minterms on
Four-Variable
Karnaugh Map
We will now plot the following four-variable expression on a Karnaugh map
(Figure 5-11):
The first term is 1 when , so we place 1’s in the two squares which
are in the column and row. The term a/H11032bis 1 when , so we
place four 1’s in the column. Finally, d/H11032is 1 when , so we place
eight 1’s in the two rows for which . (Duplicate 1’s are not plottedbecause .) 1/H110011/H110051d/H110050d/H110050 ab/H1100501ab/H1100501 cd/H1100511 a/H110051a/H11005c/H11005d/H110051f (a,b,c,d )/H11005acd/H11001a/H11032b/H11001d/H11032
Karnaugh Maps 135
The use of Karnaugh maps to find a minimum sum-of-products form for
a function has been illustrated in Figures 5-1, 5-6, and 5-12. A minimum prod-uct of sums can also be obtained from the map. Because the 0’s of fare 1’s of f/H11032,
the minimum sum of products for f/H11032can be determined by looping the 0’s
on a map of f. The complement of the minimum sum of products for f/H11032is thenX00 01 11 10
1 1 X 1
1 100cdab
01
11
10 X
f = Σ m(1, 3, 5, 7, 9) + Σ d(6, 12, 13)
=ad + c d                                   FIGURE 5-13
Simplification of
an Incompletely
Specified Function1 100 01
f1 = Σ m(1, 3, 4, 5, 10, 12, 13)
=bc′ + a′b′d + ab′cd′      f2 = Σ m(0, 2, 3, 5, 6, 7, 8, 10, 11, 14, 15)
=c + b′d′ + a′bd
(a) (b)11 10
1 1 1
1100cdab
01
11
101 100 01 11 10
Four corner terms
combine to give b′d′
1
1 1 1 1
100cdab
01
11
10 1 1 1a′b′d cbc′
ab′cd′a′bdFIGURE 5-12
Simplification of
Four-Variable
Functions
In Figure 5-12(b), note that the four corner 1’s span the b/H110050 columns and d/H110050
rows and, therefore, can be combined to form the term b/H11032d/H11032. The group of eight 1’s
covers both rows where c/H110051 and, therefore, represents the term c. The pair of 1’s
which is looped on the map represents the term a/H11032bdbecause it is in the ab/H1100501
column and spans the d/H110051 rows.
The Karnaugh map method is easily extended to functions with don’t-care
terms. The required minterms are indicated by 1’s on the map, and the don’t-careminterms are indicated by X’s. When choosing terms to form the minimumsum of products, all the 1’s must be covered, but the X’s are only used if they willsimplify the resulting expression. In Figure 5-13, the only don’t-care term used informing the simplified expression is 13.
136 Unit 5
the minimum product of sums for f. The following example illustrates this
procedure for
First, the 1’s of fare plotted in Figure 5-14. Then, from the 0’s,
and the minimum product of sums for fis
f/H11005(y/H11001z/H11032)(w/H11032/H11001x/H11032/H11001 z)(w/H11001x/H11032/H11001y/H11032)f/H11032/H11005 y/H11032z/H11001wxz/H11032/H11001w/H11032xyf/H11005x/H11032z/H11032/H11001wyz /H11001w/H11032y/H11032z/H11032/H11001x/H11032y
1 1 100 01 11 10
1 1
1
100cdab
01
1110
1a′b′c′d′
a′b′cac′
ab′c′
abc′
a′cd′FIGURE 5-155.4 Determination of Minimum Expressions 
Using Essential Prime Implicants
Any single 1 or any group of 1’s which can be combined together on a map of the
function Frepresents a product term which is called an implicant ofF(see Section
6.1 for a formal definition of implicant and prime implicant). Several implicants ofFare indicated in Figure 5-15. A product term implicant is called a prime implicant
if it cannot be combined with another term to eliminate a variable. In Figure 5-15,1 1 0 100 01 11 10
0 0 0 0
1 0 1 1
100yzwx
01
1110
0 0 1FIGURE 5-14
Karnaugh Maps 137
1 100 01 11 10
Minimum solution: F = a′b′d + bc′ + ac
All prime implicants: a′b′d,bc′,ac,a′c′d,ab,b′cd1 1 1
1 1 100cdab
01
1110
1 1a′c′d
b′cdFIGURE 5-16
Determination of
All Prime Implicantsa/H11032b/H11032c, a/H11032cd/H11032, and ac/H11032are prime implicants because they cannot be combined with
other terms to eliminate a variable. On the other hand, a/H11032b/H11032c/H11032d/H11032is not a prime impli-
cant because it can be combined with a /H11032b/H11032cd/H11032orab/H11032c/H11032d/H11032. Neither abc/H11032, nor ab/H11032c/H11032isa
prime implicant because these terms can be combined together to form ac/H11032.
All of the prime implicants of a function can be obtained from a Karnaugh map.
A single 1 on a map represents a prime implicant if it is not adjacent to any other 1’s.Two adjacent 1’s on a map form a prime implicant if they are not contained in a groupof four 1’s; four adjacent 1’s form a prime implicant if they are not contained in agroup of eight 1’s, etc.
The minimum sum-of-products expression for a function consists of some (but not
necessarily all) of the prime implicants of a function. In other words, a sum-of-prod-ucts expression containing a term which is not a prime implicant cannot be minimum.This is true because if a nonprime term were present, the expression could be simpli-fied by combining the nonprime term with additional minterms. In order to find theminimum sum of products from a map, we must find a minimum number of primeimplicants which cover all of the 1’s on the map. The function plotted in Figure 5-16has six prime implicants. Three of these prime implicants cover all of the 1’s on themap, and the minimum solution is the sum of these three prime implicants. The shad-ed loops represent prime implicants which are not part of the minimum solution.
When writing down a list of allof the prime implicants from the map, note that
there are often prime implicants which are not included in the minimum sum ofproducts. Even though all of the 1’s in a term have already been covered by primeimplicants, that term may still be a prime implicant provided that it is not included ina larger group of 1’s. For example, in Figure 5-16, a/H11032c/H11032dis a prime implicant because
it cannot be combined with other 1’s to eliminate another variable. However, abd is
not a prime implicant because it can be combined with two other 1’s to form ab.T h e
term b/H11032cdis also a prime implicant even though both of its 1’s are already covered
by other prime implicants. In the process of finding prime implicants, don’t-cares are
treated just like 1’s. However, a prime implicant composed entirely of don’t-cares can
never be part of the minimum solution.
Because all of the prime implicants of a function are generally not needed in
forming the minimum sum of products, a systematic procedure for selecting prime
Note that some of the minterms on the map of Figure 5-17(a) can be covered
by only a single prime implicant, but other minterms can be covered by two differ-ent prime implicants. For example, m
2is covered only by B/H11032C, but m3is covered by
both B/H11032Cand CD. If a minterm is covered by only one prime implicant, that prime
implicant is said to be essential , and it must be included in the minimum sum of
products. Thus, B/H11032C is an essential prime implicant because m2is not covered by
any other prime implicant. However, CDisnotessential because each of the 1’s in
CD can be covered by another prime implicant. The only prime implicant which
covers m5isBD, so BD is essential. Similarly, ACis essential because no other
prime implicant covers m14. In this example, if we choose all of the essential prime
implicants, all of the 1’s on the map are covered and the nonessential prime impli-cant CDis not needed.
In general, in order to find a minimum sum of products from a map, we should
first loop all of the essential prime implicants. One way of finding essential primeimplicants on a map is simply to look at each 1 on the map that has not alreadybeen covered, and check to see how many prime implicants cover that 1. If there isonly one prime implicant which covers the 1, that prime implicant is essential. Ifthere are two or more prime implicants which cover the 1, we cannot say whetherthese prime implicants are essential or not without checking the other minterms.For simple problems, we can locate the essential prime implicants in this way byinspection of each 1 on the map. For example, in Figure 5-16, m
4is covered only by
the prime implicant bc/H11032, and m10is covered only by the prime implicant ac. All
other 1’s on the map are covered by two prime implicants; therefore, the onlyessential prime implicants are bc/H11032and ac.138 Unit 5
implicants is needed. If prime implicants are selected from the map in the wrong
order, a nonminimum solution may result. For example, in Figure 5-17, if CDis cho-
sen first, then BD, B /H11032C, and ACare needed to cover the remaining 1’s, and the solu-
tion contains four terms. However, if the prime implicants indicated in Figure 5-17(b)are chosen first, all 1’s are covered and CDis not needed.
00 01 11 10
11
1 1 1 1
100CD
m2 m14
f = CD + BD + B′C + AC f = BD + B′C + AC
(a) (b)m5
CDAB
01
11
10 100 01 11 10
1 1
1 1 1 1
100CDAB
01
11
10 1 1 1FIGURE 5-17
Karnaugh Maps 139
0 41 200 01 11 10
Note: 1's shaded in blue are covered
by onl y one prime implicant. All
other 1's are covered b y at least two
prime implicants.8
15 13 9
3 7 15 1100CD
A′C′
ACD
A′B′D′AB
01
11
10
26 1411
1
11
111
10FIGURE 5-18
1This statement is proved in Appendix D.For more complicated maps, and especially for maps with five or more vari-
ables, we need a more systematic approach for finding the essential primeimplicants. When checking a minterm to see if it is covered by only one primeimplicant, we must look at all squares adjacent to that minterm. If the givenminterm and all of the 1’s adjacent to it are covered by a single term, then thatterm is an essential prime implicant.
1If all of the 1’s adjacent to a given minterm
arenotcovered by a single term, then there are two or more prime implicants
which cover that minterm, and we cannot say whether these prime implicantsare essential or not without checking the other minterms. Figure 5-18 illustratesthis principle.
The adjacent 1’s for minterm m
0(l0) are 11,12, and 14. Because no single term
covers these four 1’s, no essential prime implicant is yet apparent. The adjacent 1’sfor 1
1are 10and 15, so the term which covers these three 1’s ( A/H11032C/H11032) is an essential
prime implicant. Because the only 1 adjacent to 12is 10,A/H11032B/H11032D/H11032is also essential.
Because the 1’s adjacent to 17(15and 115) are not covered by a single term, neither
A/H11032BDnorBCD is essential at this point. However, because the only 1 adjacent to
111is 115,ACD is essential.To complete the minimum solution, one of the nonessen-
tial prime implicants is needed. Either A/H11032BD orBCD may be selected. The final
solution is
A/H11032C/H11032/H11001A/H11032B/H11032D/H11032/H11001ACD /H11001/H20902A/H11032BD
or
BCD/H20903
140 Unit 5
If a don’t-care minterm is present on the map, we do not have to check it to see if
it is covered by one or more prime implicants. However, when checking a 1 for adja-cent 1’s, we treat the adjacent don’t-cares as if they were 1’s because don’t-cares maybe combined with 1’s in the process of forming prime implicants. The following proce-dure can then be used to obtain a minimum sum of products from a Karnaugh map:
1.Choose a minterm (a 1) which has not yet been covered.
2.Find all 1’s and X’s adjacent to that minterm. (Check the nadjacent squares on
ann-variable map.)
3.If a single term covers the minterm and all of the adjacent 1’s and X’s, then that
term is an essential prime implicant, so select that term. (Note that don’t-careterms are treated like 1’s in steps 2 and 3 but not in step 1.)Find a minimum set of prime
implicants which cover the
remaining 1's on the map.That term is an essential
prime implicant. Loop it.Find all adjacent
1's and X's.Choose a 1 which has
not been covered.
All
uncovered 1's
checked?
STOPYESAre the chosen
1 and its adjacent 1's
andX's covered b y a
single term?
YESNO
NO
Note: All essential prime
implicants have beendetermined at this point.FIGURE 5-19
Flowchart for
Determining a
Minimum Sum of
Products Using a
Karnaugh Map
Karnaugh Maps 141
4.Repeat steps 1, 2, and 3 until all essential prime implicants have been chosen.
5.Find a minimum set of prime implicants which cover the remaining 1’s on the
map. (If there is more than one such set, choose a set with a minimum numberof literals.)
Figure 5-19 gives a flowchart for this procedure. The following example
(Figure 5-20) illustrates the procedure. Starting with 1
4, we see that the adjacent
1’s and X’s (X0,15, and 16) are notcovered by a single term, so no essential prime
implicant is apparent. However, 16and its adjacent 1’s and X’s (14and X7) are
covered by A/H11032B,soA/H11032Bis an essential prime implicant. Next, looking at 113,w e
see that its adjacent 1’s and X’s (15,19, and X15) are notcovered by a single term,
so no essential prime implicant is apparent. Similarly, an examination of theterms adjacent to 1
8and 19reveals no essential prime implicants. However, 110
has only 18adjacent to it, so AB/H11032D/H11032isan essential prime implicant because it cov-
ers both l10and 18. Having first selected the essential prime implicants, we now
choose AC/H11032Dbecause it covers both of the remaining 1’s on the map.
Judicious selection of the order in which the minterms are selected (step 1)
reduces the amount of work required in applying this procedure. As will be seen inthe next section, this procedure is especially helpful in obtaining minimum solu-tions for five- and six-variable problems.
5.5 Five-Variable Karnaugh Maps
A five-variable map can be constructed in three dimensions by placing one four-vari-able map on top of a second one. Terms in the bottom layer are numbered 0 through15 and corresponding terms in the top layer are numbered 16 through 31, so thatterms in the bottom layer contain A/H11032and those in the top layer contain A. To repre-
sent the map in two dimensions, we will divide each square in a four-variable map bya diagonal line and place terms in the bottom layer below the line and terms in thetop layer above the line (Figure 5-21). Terms in the top or bottom layer combine justlike terms on a four-variable map. In addition, two terms in the same square whichare separated by a diagonal line differ in only one variable and can be combined.X0 14 1800 01 11 10
Shaded 1's are covered b y
onl y one prime implicant.15 113 19
X7 X1500CDAB
01
1110
16 110FIGURE 5-20
142 Unit 5
00 01 11 10
00DEBC
01
11
1011
111
11
0AFIGURE 5-220 4 1200 01 11 10
These eight terms combine to give BD′ (B from
last two columns and D′ from top two rows; A is
eliminated because four terms are in the top la yer
and four in the bottom).8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141 1 1
1 1
11
1111 1
1 1
11
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26These four terms (two from top la yer and two
from bottom) combine to yield CDE  (C from the
middle two columns and DE from the row).
These two terms in the top la yer combine to give AB′DE′.These terms do not combine because the y are
in different la yers and different columns
(the y differ in two variables).FIGURE 5-21
A Five-Variable
Karnaugh Map
However, some terms which appear to be physically adjacent are not. For example,
terms 0 and 20 are not adjacent because they appear in a different column and adifferent layer. Each term can be adjacent to exactly five other terms, four in thesame layer and one in the other layer (Figure 5-22). An alternate representationfor five-variable maps is to draw the two layers side-by-side, as in Figure 5-28, butmost individuals find adjacencies more difficult to see when this form is used.
When checking for adjacencies, each term should be checked against the five
possible adjacent squares. (In general, the number of adjacent squares is equal to thenumber of variables.) Two examples of five-variable minimization using maps follow.Figure 5-23 is a map of
F(A,B,C,D,E)/H11005/H9018  m(0, 1, 4, 5, 13, 15, 20, 21, 22, 23, 24, 26, 28, 30, 31)
Karnaugh Maps 143
P1000 01 11 10
Shaded 1's are used to
select essential prime
implicants.00
1
0DE
ABC
01
11
10111
1
11
11111
11 1
124
P4
P3 P2FIGURE 5-23
     P1 P2 P3 P4Prime implicant P1is chosen first because all of the 1’s adjacent to minterm 0 are
covered by Pl. Prime implicant P2is chosen next because all of the 1’s adjacent to
minterm 24 are covered by P2. All of the remaining 1’s on the map can be cov-
ered by at least two different prime implicants, so we proceed by trial and error.After a few tries, it becomes apparent that the remaining 1’s can be covered bythree prime implicants. If we choose prime implicants P
3and P4next, the remain-
ing two 1’s can be covered by two different groups of four. The resulting mini-mum solution is
F/H11005A/H11032B/H11032D/H11032/H11001ABE /H11032/H11001ACD /H11001A/H11032BCE /H11001/H20902AB/H11032C
or
B/H11032CD/H11032/H20903
     P1  P2   P3   P4   P5Figure 5-24 is a map of
All 1’s adjacent to m16are covered by P1, so choose Plfirst. All 1’s adjacent to m3
are covered by P2, so P2is chosen next. All 1’s adjacent to m8are covered by P3,s o
P3is chosen. Because m14is only adjacent to m15,P4is also essential. There are no
more essential prime implicants, and the remaining 1’s can be covered by two terms,P
5and (1-9-17-25) or (17-19-25-27). The final solution is
F/H11005B/H11032C/H11032D/H11032/H11001B/H11032C/H11032E/H11001A/H11032C/H11032D/H11032/H11001A/H11032BCD /H11001ABDE /H11001/H20902C/H11032D/H11032E
or
AC/H11032E/H20903F(A,B,C,D,E)/H11005/H9018  m(0, 1, 3, 8, 9, 14, 15, 16, 17, 19, 25, 27, 31) 
144 Unit 5
P50 4 1200 01 11 10
8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141
11
11 111
11
11
1
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26P3P1
P2
P4FIGURE 5-24
5.6 Other Uses of Karnaugh Maps
Many operations that can be performed using a truth table or algebraically can be
done using a Karnaugh map.A map conveys the same information as a truth table—it is just arranged in a different format. If we plot an expression for Fon a map, we
can read off the minterm and maxterm expansions for Fand for F/H11032. From the map
of Figure 5-14, the minterm expansion of fis
and because each 0 corresponds to a maxterm, the maxterm expansion of fis
We can prove that two functions are equal by plotting them on maps and show-
ing that they have the same Karnaugh map. We can perform the AND operation(or the OR operation) on two functions by ANDing (or ORing) the 1’s and 0’swhich appear in corresponding positions on their maps. This procedure is validbecause it is equivalent to doing the same operations on the truth tables for thefunctions.
A Karnaugh map can facilitate factoring an expression. Inspection of the map
reveals terms which have one or more variables in common. For the map ofFigure 5-25, the two terms in the first column have A/H11032B/H11032in common; the two terms
in the lower right corner have ACin common.f/H11005/H9016 M(1, 5, 6, 7, 9, 12, 13, 14)f/H11005/H9018 m(0, 2, 3, 4, 8, 10, 11, 15)
Karnaugh Maps 145
100 01 11 10
1
1 100CDAB
F = A′B′(C′ + D) + AC(B + D′)01
1110
1 1FIGURE 5-25
When simplifying a function algebraically, the Karnaugh map can be used as a
guide in determining what steps to take. For example, consider the function
From the map (Figure 5-26), we see that in order to get the minimum solution, we
must add the term ACDE . We can do this using the consensus theorem:
As can be seen from the map, this expression now contains two redundant terms,
ABCD and B/H11032CDE . These can be eliminated using the consensus theorem, which
gives the minimum solution:
F/H11005A/H11032B/H11032/H11001BCE /H11032/H11001ACDEF/H11005ABCD /H11001B/H11032CDE /H11001A/H11032B/H11032/H11001 BCE /H11032/H11001 ACDEF/H11005ABCD /H11001B/H11032CDE /H11001A/H11032B/H11032/H11001BCE /H11032b¬¬¬ ¬¬¬¬¬¬¬¬¬ ¬›¬¬¬ ¬›
0 4 1200 01 11 10
Add this term.
Then these two terms can be eliminated.8
1 5 13 9
3 7 15 1100
1
0DE
ABC
01
11
10
2 6 141
11
1111
11
11
111
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 26FIGURE 5-26
146 Unit 5
5.7 Other Forms of Karnaugh Maps
Instead of labeling the sides of a Karnaugh map with 0’s and 1’s, some people
prefer to use the labeling shown in Figure 5-27. For the half of the map labeled A,
A/H110051; and for the other half, A/H110050. The other variables have a similar interpreta-
tion. A map labeled this way is sometimes referred to as a Veitch diagram. It is par-ticularly useful for plotting functions given in algebraic form rather than inminterm or maxterm form. However, when utilizing Karnaugh maps to solvesequential circuit problems (Units 12 through 16), the use of 0’s and 1’s to label themaps is more convenient.
FIGURE 5-27
Veitch Diagrams
B C
BC DAA
FIGURE 5-28
Other Forms
of Five-Variable
Karnaugh MapsTwo alternative forms for five-variable maps are used. One form simply consists
of two four-variable maps side-by-side as in Figure 5-28(a). A modification of thisuses a mirror image map as in Figure 5-28(b). In this map, first and eighth columns
are “adjacent” as are second and seventh columns, third and sixth columns, andfourth and fifth columns. The same function is plotted on both these maps.
1 1 1 100 01
A = 0
(a) (b)11 10
1 1
100DEBC
01
11
10 11 1 1 100 01
A = 111 10
1 1
1 100DEBC
01
11
101 1 1 1
1 1
1
11 1 1 1
1 1
1 1B
D
C CEA
F/H11005D/H11032E/H11032/H11001B/H11032C/H11032D/H11032/H11001BCE /H11001A/H11032BC/H11032E/H11032/H11001 ACDE
Karnaugh Maps 147
Programmed Exercise 5.1
Cover the answers to this exercise with a sheet of paper and slide it down as you
check your answers.Write your answers in the space provided before looking at thecorrect answer.
Problem: Determine the minimum sum of products and minimum product of
sums for
f/H11005b/H11032c/H11032d/H11032 /H11001 bcd/H11001acd/H11032/H11001a/H11032b/H11032c/H11001a/H11032bc/H11032d
First, plot the map for f.
Answer:
(a) The minterms adjacent to m0on the preceding map are __________ and __________.
(b) Find an essential prime implicant containing m0and loop it.
(c) The minterms adjacent to m3are __________ and __________.
(d) Is there an essential prime implicant which contains m3?
(e) Find the remaining essential prime implicant(s) and loop it (them).1 100 01 11 10
1
1 1 1
100cdab
01
1110
1 100 01 11 10
00
01
1110
148 Unit 5
Answers:
Loop the remaining 1’s using a minimum number of loops.
The two possible minimum sum-of-products forms for fare
f/H11005_____________________________________ and
f/H11005_____________________________________
Answer:
Next, we will find the minimum product of sums for f. Start by plotting the map for f/H11032.
Loop all essential prime implicants of f/H11032and indicate which minterm makes each
one essential.
00 01
f′11 10
00
01
11101 100 01 11 10
1
1 1 1
100cdab
01
1110
1 1f = b′d′ + a′bd + abc +a′cd
or
a′b′c1 100 01 11 10
1
1 1 1
100cdab
01
1110
1 1(a)m2and m8 (b)
(c)m2and m7 (e)
(d) No
Karnaugh Maps 149
Answer:
Loop the remaining 1’s and write the minimum sum of products for f/H11032.
f/H11032/H11005_____________________________________
The minimum product of sums for fis therefore
f/H11005_____________________________________
Final Answer: f/H11032/H11005  b/H11032c/H11032d/H11001a/H11032bd/H11032/H11001ab/H11032d/H11001abc/H11032
f/H11005 (b/H11001c/H11001d/H11032) (a/H11001b/H11032/H11001d)(a/H11032/H11001b/H11001d/H11032)(a/H11032/H11001b/H11032/H11001c)
Programmed Exercise 5.2
Problem: Determine a minimum sum-of-products expression for
f(a, b, c, d, e )/H11005 (a/H11032+c+d) (a/H11032+b+e) (a+c/H11032+e/H11032) (c+d+e/H11032)
(b+c+d/H11032+e) (a/H11032+b/H11032+c+e/H11032)
The first step in the solution is to plot a map for f. Because fis given in product-of-
sums form, it is easier to first plot the map for f/H11032and then complement the map.
Write f/H11032as a sum of products:
f/H11032/H11005_____________________________________
Now plot the map for f/H11032. (Note that there are three terms in the upper layer, one
term in the lower layer, and two terms which span the two layers.)
Next, convert your map for f/H11032to a map for f.1 100 01 11 10
1 1 1
100
Essential because of m1
Essential because of m11
Essential because of m6cdab
f′01
1110
1
150 Unit 5
Answer:
The next step is to determine the essential prime implicants of f.
(a) Why is a/H11032d/H11032e/H11032an essential prime implicant?
(b) Which minterms are adjacent to m3? __________ To m19? __________
(c) Is there an essential prime implicant which covers m3and m19?
(d) Is there an essential prime implicant which covers m21?
(e) Loop the essential prime implicants which you have found.Then, find two more
essential prime implicants and loop them.00 01
f′11 10
00
1
0de
abc
01
11
1011 1
11
1
111 111
11
10 4 1200 01
f11 10
8
1 5 13 9
3 7 15 1100
1
0de
abc
01
11
10
2 6 141
11
111
111111
11
111
1016 20 28 24
17 21 29 25
19 23 31 27
18 22 30 2600 01 11 10
00
1
0de
abc
f′01
11
1000 01 11 10
00
1
0de
abc
f01
11
10
Karnaugh Maps 151
Answers:
(a) It covers m0and both adjacent minterms.
(b)m19and m11;m3and m23
(c) No
(d) Yes(e)
(a) Why is there no essential prime implicant which covers m11?
(b) Why is there no essential prime implicant which covers m28?
Because there are no more essential prime implicants, loop a minimum number of
terms which cover the remaining 1’s.
Answers:
(a) All adjacent 1’s of m11(m3,m10) cannot be covered by one grouping.
(b) All adjacent 1’s of m28(m12,m30,m29) cannot be covered by one grouping.
00 01 11 10
Note: There are five othe r
possible wa ys to loop the
four remaining 1's.00
1
0de
abc
01
11
101
11
111
11111
11
111
100 01 11 10
00
1
0de
abc
01
11
101
11
111
11111
11
111
1
152 Unit 5
Write down two different minimum sum-of-products expressions for f.
f/H11005_____________________________________
f/H11005_____________________________________
Answer:
Problems
5.3 Find the minimum sum of products for each function using a Karnaugh map.
(a)f1(a, b, c )/H11005m0/H11001m2/H11001m5/H11001m6 (b)f2(d, e, f )/H11005/H9018  m(0,1,2,4)
(c)f3(r, s, t)/H11005rt/H11032/H11001r/H11032s/H11032/H11001r/H11032s (d)f4(x, y, z )/H11005M0•M5
5.4 (a) Plot the following function on a Karnaugh map. (Do not expand to minterm
form before plotting.)
F(A,B,C,D)/H11005BD/H11032/H11001B/H11032CD/H11001ABC /H11001ABC /H11032D/H11001B/H11032D/H11032
(b) Find the minimum sum of products.
(c) Find the minimum product of sums.
5.5 A switching circuit has two control inputs ( C1andC2), two data inputs ( X1andX2),
and one output ( Z). The circuit performs one of the logic operations AND, OR,
EQU (equivalence), or XOR (exclusive OR) on the two data inputs. The functionperformed depends on the control inputs:
Function Performed
C1C2 by Circuit
00 O R
0 1 XOR1 0 AND
1 1 EQU
(a) Derive a truth table for Z.
(b) Use a Karnaugh map to find a minimum AND-OR gate circuit to realize Z.
5.6 Find the minimum sum-of-products expression for each function. Underline the essen-
tial prime implicants in your answer and tell which minterm makes each one essential.(a)f(a, b, c, d )/H11005 /H9018 m(0, 1, 3, 5, 6, 7, 11, 12, 14)
(b)f(a, b, c, d )/H11005 /H9016 M(1, 9, 11, 12, 14)
(c)f(a, b, c, d )/H11005 /H9016 M(5, 7, 13, 14, 15) 
•/H9016 D(1, 2, 3, 9)f/H11005a/H11032d/H11032e/H11032/H11001ace/H11001a/H11032ce/H11032/H11001bde/H11032/H11001/H20902abc
or
bce/H11032/H20903/H11001/H20902b/H11032c/H11032de/H11001a/H11032c/H11032de
b/H11032c/H11032de/H11001a/H11032bc/H11032d
ab/H11032de/H11001a/H11032c/H11032de/H20903
Karnaugh Maps 153
5.7 Find the minimum sum-of-products expression for each function.
(a)f(a, b, c, d )/H11005 /H9018 m(0, 2, 3, 4, 7, 8, 14)
(b)f(a, b, c, d )/H11005 /H9018 m(1, 2, 4, 15) /H11001/H9018  d(0, 3, 14)
(c)f(a, b, c, d )/H11005 /H9016 M(1, 2, 3, 4, 9, 15)
(d)f(a, b, c, d )/H11005 /H9016 M(0, 2, 4, 6, 8) •/H9016 D(1, 12, 9, 15)
5.8 Find the minimum sum of products and the minimum product of sums for each
function:(a)f(a, b, c, d )/H11005 /H9016 M(0, 1, 6, 8, 11, 12) 
•/H9016 D(3, 7, 14, 15)
(b)f(a, b, c, d )/H11005 /H9018 m(1, 3, 4, 11) /H11001/H9018  d(2, 7, 8, 12, 14, 15)
5.9 Find the minimum sum of products and the minimum product of sums for each
function:(a)F(A, B, C, D, E )/H11005 /H9018 m(0, 1, 2, 6, 7, 9, 10, 15, 16, 18, 20, 21, 27, 30)
/H11001/H9018  d(3, 4, 11, 12, 19)
(b)F(A, B, C, D, E )/H11005 /H9016 M(0, 3, 6, 9, 11, 19, 20, 24, 25, 26, 27, 28, 29, 30)
•/H9016 D(1, 2, 12, 13)
5.10 F(a, b, c, d, e )/H11005 /H9018 m(0, 3, 4, 5, 6, 7, 8, 12, 13, 14, 16, 21, 23, 24, 29, 31)
(a) Find the essential prime implicants using a Karnaugh map, and indicate why
each one of the chosen prime implicants is essential (there are four essentialprime implicants).
(b) Find all of the prime implicants by using the Karnaugh map. (There are nine in all.)
5.11 Find a minimum product-of-sums solution for f. Underline the essential prime
implicants.
f(a, b, c, d, e )/H11005 /H9018 m(2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 27, 28, 29, 31) /H11001 /H9018 d(1, 30)
5.12 Given F/H11005AB/H11032D/H11032/H11001A/H11032B/H11001A/H11032C/H11001CD.
(a) Use a Karnaugh map to find the maxterm expression for F(express your
answer in both decimal and algebric notation).
(b) Use a Karnaugh map to find the minimum sum-of-products form for F/H11032.
(c) Find the minimum product of sums for F.
5.13 Find the minimum sum of products for the given expression.Then, make minterm
5 a don’t-care term and verify that the minimum sum of products is unchanged.
Now, start again with the original expression and find each minterm whichcould individually be made a don’t-care without changing the minimum sum of
products.
F(A,B,C,D)/H11005A/H11032C/H11032/H11001B/H11032C/H11001ACD /H11032/H11001BC/H11032D
5.14 Find the minimum sum-of-products expressions for each of these functions.
(a)f
1(A, B, C )/H11005m1/H11001m2/H11001m5/H11001m7 (b)f2(d, e, f )/H11005/H9018 m(1, 5, 6, 7)
(c)f3(r, s, t)/H11005rs/H11032/H11001r/H11032s/H11032/H11001st/H11032 (d)f4(a, b, c )/H11005m0/H11001m2/H11001m3/H11001m7
(e)f5(n, p, q )/H11005/H9018 m(1, 3, 4, 5) (f) f6(x, y, z )/H11005M1M7
154 Unit 5
5.15 Find the minimum product-of-sums expression for each of the functions in
Problem 5.14.
5.16 Find the minimum sum of products for each of these functions.
(a)f1(A, B, C )/H11005m1/H11001m3/H11001m4/H11001m6(b)f2(d, e, f )/H11005/H9018  m(1, 4, 5, 7)
(c)f3(r, s, t)/H11005r/H11032t/H11032/H11001rs/H11032/H11001rs (d)f1(a, b, c )/H11005m3/H11001m4/H11001m6/H11001m7
(e)f2(n, p, q )/H11005 /H9018 m(2, 3, 5, 7) (f) f4(x, y, z )/H11005M3M6
5.17 (a) Plot the following function on a Karnaugh map. (Do not expand to minterm
form before plotting.)
F(A,B,C,D )/H11005A/H11032B/H11032/H11001CD/H11032/H11001ABC /H11001A/H11032B/H11032CD/H11032/H11001ABCD /H11032
(b) Find the minimum sum of products.
(c) Find the minimum product of sums.
5.18 Work Problem 5.17 for the following:
f(A,B,C,D )/H11005A/H11032B/H11032/H11001A/H11032B/H11032C/H11032/H11001A/H11032BD/H11032/H11001AC/H11032D/H11001A/H11032BD/H11001AB/H11032CD/H11032
5.19 A switching circuit has two control inputs ( C1andC2), two data inputs ( X1andX2),
and one output ( Z). The circuit performs logic operations on the two data inputs, as
shown in this table:
Function Performed
C1C2 by Circuit
00 X1X2
01 X1⊕X2
10 X /H110321/H11001X2
11 X1/H11013X2
(a) Derive a truth table for Z.
(b) Use a Karnaugh map to find a minimum OR-AND gate circuit to realize Z.
5.20 Use Karnaugh maps to find all possible minimum sum-of-products expressions for
each function.(a)F(a, b, c )/H11005/H9016 M(3, 4)
(b)g(d, e, f )/H11005/H9018 m(1, 4, 6) /H11001/H9018 d(0, 2, 7)
(c)F(p, q, r )/H11005(p/H11001q/H11032/H11001r)(p/H11032/H11001q/H11001r/H11032)
(d)F(s, t, u )/H11005/H9018 m(1, 2, 3) /H11001/H9018 d(0, 5, 7)
(e)f(a, b, c )/H11005/H9016 M(2, 3, 4)
(f)G(D, E, F )/H11005/H9018 m(1, 6) /H11001/H9018 d(0, 3, 5)
Karnaugh Maps 155
5.21 Simplify the following expression first by using a map and then by using Boolean
algebra. Use the map as a guide to determine which theorems to apply to whichterms for the algebraic simplification.
F/H11005a/H11032b/H11032c/H11032/H11001a/H11032c/H11032d/H11001bcd/H11001abc/H11001ab/H11032
5.22 Find all prime implicants and all minimum sum-of-products expressions for each of
the following functions.(a)f(A,B,C,D )/H11005/H9018 m(4, 11, 12, 13, 14) /H11001/H9018 d(5, 6, 7, 8, 9, 10)
(b)f(A,B,C,D )/H11005/H9018 m(3, 11, 12, 13, 14) /H11001/H9018 d(5, 6, 7, 8, 9, 10)
(c)f(A,B,C,D )/H11005/H9018 m(1, 2, 4, 13, 14) /H11001/H9018 d(5, 6, 7, 8, 9, 10)
(d)f(A,B,C,D )/H11005/H9018 m(4, 15) /H11001/H9018 d(5, 6, 7, 8, 9, 10)
(e)f(A,B,C,D )/H11005/H9018 m(3, 4, 11, 15) /H11001/H9018 d(5, 6, 7, 8, 9, 10)
(f)f(A,B,C,D )/H11005/H9018 m(4)/H11001/H9018 d(5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
(g)f(A,B,C,D )/H11005/H9018 m(4, 15) /H11001/H9018 d
(0, 1, 2, 5, 6, 7, 8, 9, 10)
5.23 For each function in Problem 5.22, find all minimum product-of-sums expressions.
5.24 Find the minimum sum-of-products expression for
(a)/H9018 m(0, 2, 3, 5, 6, 7, 11, 12, 13)
(b)/H9018 m(2, 4, 8) /H11001/H9018  d(0, 3, 7)
(c)/H9018 m(1, 5, 6, 7, 13) /H11001/H9018  d(4, 8)
(d)f(w,x,y,z)/H11005/H9018  m(0, 3, 5, 7, 8, 9, 10, 12, 13) /H11001/H9018  d(1, 6, 11, 14)
(e)/H9016 M(0, 1, 2, 5, 7, 9, 11) •/H9016 D(4, 10, 13)
5.25 Work Problem 5.24 for the following:
(a)f(a, b, c, d )/H11005 /H9018 m(1, 3, 4, 5, 7, 9, 13, 15)
(b)f(a, b, c, d )/H11005 /H9016 M(0, 3, 5, 8, 11)
(c)f(a, b, c, d )/H11005 /H9018 m(0, 2, 6, 9, 13, 14) /H11001 /H9018 d(3, 8, 10)
(d)f(a, b, c, d )/H11005 /H9016 M(0, 2, 6, 7, 9, 12, 13) •/H9016 D(1, 3, 5)
5.26 Find the minimum product of sums for the following. Underline the essential prime
implicants in your answer.(a)/H9016 M(0, 2, 4, 5, 6, 9, 14) 
•/H9016 D(10, 11)
(b)/H9018 m(1, 3, 8, 9, 15) /H11001 /H9018 d(6, 7, 12)
5.27 Find a minimum sum-of-products and a minimum product-of-sums expression for
each function:(a)f(A, B, C, D )/H11005/H9016  M(0, 2, 10, 11, 12, 14, 15)
•/H9016 D(5, 7)
(b)f(w,x,y,z)/H11005/H9018  m(0, 3, 5, 7, 8, 9, 10, 12, 13) /H11001 /H9018 d(1, 6, 11, 14)
5.28 A logic circuit realizes the function F(a, b, c, d )/H11005a/H11032b/H11032+a/H11032cd+ac/H11032d+ab/H11032d/H11032.Assuming
that a/H11005cnever occurs when b/H11005d/H110051, find a simplified expression for F.
5.29 Given F/H11005AB/H11032D/H11032/H11001A/H11032B/H11001A/H11032C/H11001CD.
(a) Use a Karnaugh map to find the maxterm expression for F(express your
answer in both decimal and algebric notation).
156 Unit 5
(b) Use a Karnaugh map to find the minimum sum-of-products form for F/H11032.
(c) Find the minimum product of sums for F.
5.30 Assuming that the inputs ABCD /H110050101, ABCD /H110051001, ABCD /H110051011 never
occur, find a simplified expression for
F/H11005A/H11032BC/H11032D/H11001A/H11032B/H11032D/H11001A/H11032CD/H11001ABD /H11001ABC
5.31 Find all of the prime implicants for each of the functions plotted on page 150.
5.32 Find all of the prime implicants for each of the plotted functions:
5.33 Given that f(a, b, c, d, e )/H11005/H9018 m(6, 7, 9, 11, 12, 13, 16, 17, 18, 20, 21, 23, 25, 28), using a
Karnaugh map,(a) Find the essential prime implicants (three).(b) Find the minimum sum of products (7 terms).(c) Find all of the prime implicants (twelve).
5.34 A logic circuit realizing the function fhas four inputs a, b, c, d . The three inputs a,
b, and care the binary representation of the digits 0 through 7 with abeing the
most significant bit. The input dis an odd-parity bit; that is, the value of dis such
that a, b, c , and dalways contains an odd number of 1’s. (For example, the digit 1 is
represented by abc/H11005001 and d/H110050, and the digit 3 is represented by abcd /H11005
0111.) The function fhas value 1 if the input digit is a prime number. (A number is
prime if it is divisible only by itself and 1; 1 is considered to be prime, and 0 is not.)(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f.
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f/H11032
.
(e) Find all minimum product of sums for f.00 01 11 10
00
1
0de
abc
F01
11
1011 1
11
1
111111
11
100 01 11 10
00
1
0de
abc
G01
11
101
11111
111
11 1
Karnaugh Maps 157
5.35 The decimal digits 0 though 9 are represented using five bits A, B, C, D, and E.T h e
bitsA, B, C, and Dare the BCD representation of the decimal digit, and bit Eis a
parity bit that makes the five bits have odd parity. The function F(A, B, C, D, E ) has
value 1 if the decimal digit represented by A, B, C, D, andEis divisible by either 3 or
4. (Zero is divisible by 3 and 4.)(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f. (Prime implicants containing only don’t-cares
need not be included.)
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f/H11032.
(e) Find all minimum product of sums for f.
5.36 Rework Problem 5.35 assuming the decimal digits are represented in excess-3 rather
than BCD.
5.37 The function F(A, B, C, D, E )/H11005/H9018 m(1, 7, 8, 13, 16, 19) /H11001/H9018 d(0, 3, 5, 6, 9, 10, 12, 15,
17, 18, 20, 23, 24, 27, 29, 30).(a) Draw a Karnaugh map for f.
(b) Find all prime implicants of f. (Prime implicants containing only don’t-cares
need not be included.)
(c) Find all minimum sum of products for f.
(d) Find all prime implicants of f/H11032.
(e) Find all minimum product of sums for f.
5.38 F(a,b,c,d,e)/H11005/H9018  m(0, 1, 4, 5, 9, 10, 11, 12, 14, 18, 20, 21, 22, 25, 26, 28)
(a) Find the essential prime implicants using a Karnaugh map, and indicate why
each one of the chosen prime implicants is essential (there are four essentialprime implicants).
(b) Find all of the prime implicants by using the Karnaugh map (there are 13 in all).
5.39 Find the minimum sum-of-products expression for F. Underline the essential prime
implicants in this expression.(a)f(a,b
,c,d,e)/H11005 /H9018 m(0, 1, 3, 4, 6, 7, 8, 10, 11, 15, 16, 18, 19, 24, 25, 28, 29, 31)
/H11001 /H9018 d(5, 9, 30)
(b)f(a,b,c,d,e)/H11005 /H9018 m(1, 3, 5, 8, 9, 15, 16, 20, 21, 23, 27, 28, 31)
5.40 Work Problem 5.39 with
F(A, B, C, D, E )/H11005/H9016  M(2, 3, 4, 8, 9, 10, 14, 15, 16, 18, 19, 20, 23, 24, 30, 31)
5.41 Find the minimum sum-of-products expression for F. Underline the essential prime
implicants in your expression.
F(A,B,C,D,E)/H11005/H9018  m(0, 2, 3, 5, 8, 11, 13, 20, 25, 26, 30) /H11001 /H9018 d(6, 7, 9, 24)
5.42 F(V,W,X,Y,Z)/H11005/H9016  M(0, 3, 5, 6, 7, 8, 11, 13, 14, 15, 18, 20, 22, 24) •/H9016 D(1, 2, 16, 17)
(a) Find a minimum sum-of-products expression for F. Underline the essential
prime implicants.
158 Unit 5
(b) Find a minimum product-of-sums expression for F. Underline the essential
prime implicants.
5.43 Find the minimum product of sums for
(a)F(a, b, c, d, e )/H11005 /H9018 m(1, 2, 3, 4, 5, 6, 25, 26, 27, 28, 29, 30, 31)
(b)F(a, b, c, d, e )/H11005 /H9018 m(1, 5, 12, 13, 14, 16, 17, 21, 23, 24, 30, 31) /H11001 /H9018 d(0, 2, 3, 4)
5.44 Find a minimum product-of-sums expression for each of the following functions:
(a)F(v, w, x, y, z )/H11005 /H9018 m(4, 5, 8, 9, 12, 13, 18, 20, 21, 22, 25, 28, 30, 31)
(b)F(a, b, c, d, e )/H11005 /H9016 M(2, 4, 5, 6, 8, 10, 12, 13, 16, 17, 18, 22, 23, 24) 
•/H9016 D(0, 11, 30, 31)
5.45 Find the minimum sum of products for each function. Then, make the specified
minterm a don’t-care and verify that the minimum sum of products is unchanged.Now, start again with the original expression and find each minterm which couldindividually be made a don’t-care, without changing the minimum sum of products.(a)F(A, B, C, D )/H11005A/H11032C/H11032 /H11001 A/H11032B/H11032/H11001 ACD /H11032/H11001 BC/H11032D,minterm 2
(b)F(A, B, C, D )/H11005A/H11032BD/H11001 AC/H11032D/H11001 AB/H11032 /H11001 BCD /H11001 A/H11032C/H11032D,minterm 7
5.46 F(V , W, X, Y, Z )/H11005/H9016  M(0, 3, 6, 9, 11, 19, 20, 24, 25, 26, 27, 28, 29, 30)
•/H9016 D(1, 2, 12, 13)
(a) Find two minimum sum-of-products expressions for F.
(b) Underline the essential prime implicants in your answer and tell why each one
is essential.
159CHAPTER
00Quine-McCluskey Method
Objectives
1.Find the prime implicants of a function by using the Quine-McCluskey
method. Explain the reasons for the procedures used.
2.Define prime implicant andessential prime implicant .
3.Given the prime implicants, find the essential prime implicants and a min-
imum sum-of-products expression for a function, using a prime implicantchart and using Petrick’s method.
4.Minimize an incompletely specified function, using the Quine-McCluskey
method.
5.Find a minimum sum-of-products expression for a function, using the
method of map-entered variables.
UNIT
6
160 Unit 6
1.Review Section 5.1, Minimum Forms of Switching Functions .
2.Read the introduction to this unit and, then, study Section 6.1. Determination of
Prime Implicants .
(a) Using variables A,B,C,D, and E, give the algebraic equivalent of
(b) Why will the following pairs of terms not combine?
(c) When using the Quine-McCluskey method for finding prime implicants,
why is it necessary to compare terms only from adjacent groups?
(d) How can you determine if two minterms from adjacent groups will com-
bine by looking at their decimal representations?
(e) When combining terms, why is it permissible to use a term which has
already been checked off?
(f) In forming Column II of Table 6-1, note that terms 10 and 14 were com-
bined to form 10, 14 even though both 10 and 14 had already been checkedoff. If this had not been done, which term in Column II could not be elim-inated (checked off)?
(g) In forming Column III of Table 6-1, note that minterms 0, 1, 8, and 9 were
combined in two different ways to form –00–. This is equivalent to loopingthe minterms in two different ways on the Karnaugh map, as shown.10–10 /H11001001–001101 /H110010011110–10 /H1100110–11 /H1100510–1–10110 /H1100110010 /H1100510–10Study Guide
(0, 1) + (8, 9) (0, 8) + (1, 9) (0, 1, 8, 9)==1 100 01 11 10
1 100cdab
01
11101 100 01 11 10
1 100cdab
01
11101 100 01 11 10
1 100cdab
01
1110
Quine-McCluskey Method 161
(h) Using a map, find allof the prime implicants of Equation (6-2) and com-
pare your answer with Equation (6-3).
00 01 11 10
00
01
11
10
(i) The prime implicants of are to
be found using the Quine-McCluskey method. Column III is given; findColumn IV and check off the appropriate terms in Column III.f (a,b,c,d )/H11005/H9018 m(4, 5, 6, 7, 12, 13, 14, 15)
3.(a) List all seven product term implicants of 
Which of these implicants are prime?
Why is a/H11032cnot an implicant?
(b) Define a prime implicant.
(c) Why must every term in a minimum sum-of-products expression be a
prime implicant?F(a,b,c)/H11005/H9018 m(0, 1, 5, 7)00 01 11 10
00
01
11
10Column III Column IV
(4, 5, 6, 7) 01--
(4, 5, 12, 13) –10–
(4, 6, 12, 14) –1–0
(5, 7, 13, 15) –1–1
(6, 7, 14,15) –11–
(12, 13, 14, 15) 11--
Check your answer using a Karnaugh map.
162 Unit 6
abc d 0 4 51 01 11 21 31 5
(0, 4) 0 – 0 0 ××
(4, 5, 12, 13) – 1 0 – ×× × ×
(13, 15) 1 1 – 1 ××
(11, 15) 1 – 1 1 ××
(10, 11) 1 0 1 – ××(d) Given that , which of the follow-
ing terms are notprime implicants and why?
A/H11032B/H11032C/H11032 A/H11032C/H11032 BCD ABC AB /H11032CD/H11032
4.Study Section 6.2, The Prime Implicant Chart .
(a) Define an essential prime implicant.
(b) Find all of the essential prime implicants from the following chart.F(A,B,C,D)/H11005/H9018 m (0, 1, 4, 5, 7, 10, 15)
m4m5m7m13
P1bd ×××
P2bc/H11032 ×× ×
P3a/H11032b ×××
P4c/H11032d ××Check your answer using a Karnaugh map.
(c) Why must all essential prime implicants of a function be included in the
minimum sum of products?
(d) Complete the solution of Table 6-5.
(e) Work Programmed Exercise 6.1.
(f) Work Problems 6.2 and 6.3.
5.Study Section 6.3, Petrick’s Method (optional).
(a) Consider the following reduced prime implicant chart for a function F:
We will find all minimum solutions using Petrick’s method. Let Pi/H110051
mean the prime implicant in row Piis included in the solution.
Which minterm is covered iff ( P1/H11001P3)/H110051?___________
Write a sum term which is 1 iff m4is covered.___________
Quine-McCluskey Method 163
Write a product-of-sum terms which is 1 iff all m4,m5,m7, and m13are all
covered:
P/H11005___________________________________________________________
(b) Reduce Pto a minimum sum of products. (Your answer should have four
terms, each one of the form PiPj.)
P/H11005___________________________________________________________
IfP1P2/H110051, which prime implicants are included in the solution?___________
How many minimum solutions are there?___________Write out each solution in terms of a,b,c, and d.
(1) F/H11005 (2) F/H11005
(3) F/H11005 (4) F/H11005
6.Study Section 6.4, Simplification of Incompletely Specified Function s.
(a) Why are don’t-care terms treated like required minterms when finding the
prime implicants?
(b) Why are the don’t-care terms not listed at the top of the prime implicant
chart when finding the minimum solution?
(c) Work Problem 6.4.
(d) Work Problem 6.5, and check your solution using a Karnaugh map.
7.If you have LogicAid or a similar computer program available, use it to check
your answers to some of the problems in this unit. LogicAid accepts Boolean
functions in the form of equations, minterms or maxterms, and truth tables. Itfinds simplified sum-of-products and product-of-sums expressions for thefunctions using a modified version of the Quine-McCluskey method orEspresso-II. It can also find one or all of the minimum solutions usingPetrick’s method.
8.Study Section 6.5, Simplification Using Map-Entered Variables .
(a) For the following map, find MS
0,MS1, and F. Verify that your solution for
Fis minimum by using a four-variable map.
D 1
1 D
1X01
00BCA
01
11
10
164 Unit 6
The Karnaugh map method described in Unit 5 is an effective way to simplify switch-
ing functions which have a small number of variables. When the number of variablesis large or if several functions must be simplified, the use of a digital computer isdesirable. The Quine-McCluskey method presented in this unit provides a systemat-ic simplification procedure which can be readily programmed for a digital computer.C
C′ 101
0BA
1
(c) Work Problem 6.6.
9.In this unit you have learned a “turn-the-crank” type procedure for finding mini-
mum sum-of-products forms for switching functions. In addition to learning howto “turn the crank” and grind out minimum solutions, you should have learnedseveral very important concepts in this unit. In particular, make sure you know:
(a) What a prime implicant is
(b) What an essential prime implicant is
(c) Why the minimum sum-of-products form is a sum of prime implicants
(d) How don’t-cares are handled when using the Quine-McCluskey method
and the prime implicant chart
10. Reread the objectives of the unit. If you are satisfied that you can meet the
objectives, take the readiness test.(b) Use the method of map-entered variables to find an expression for Ffrom
the following map. Treat CandC/H11032as if they were independent variables. Is
the result a correct representation of F? Is it minimum?
Quine-McCluskey Method
Quine-McCluskey Method 165
The Quine-McCluskey method reduces the minterm expansion (standard sum-
of-products form) of a function to obtain a minimum sum of products. The procedureconsists of two main steps:
1.Eliminate as many literals as possible from each term by systematically
applying the theorem XY/H11001XY/H11032/H11005X. The resulting terms are called prime
implicants.
2.Use a prime implicant chart to select a minimum set of prime implicants which,
when ORed together, are equal to the function being simplified and which con-tain a minimum number of literals.
6.1 Determination of Prime Implicants
In order to apply the Quine-McCluskey method to determine a minimum sum-of-products expression for a function, the function must be given as a sum ofminterms. (If the function is not in minterm form, the minterm expansion can befound by using one of the techniques given in Section 5.3.) In the first part of theQuine-McCluskey method, all of the prime implicants of a function are systematical-ly formed by combining minterms. The minterms are represented in binary notationand combined using
XY/H11001XY/H11032/H11005X (6-1)
where Xrepresents a product of literals and Yis a single variable.Two minterms will
combine if they differ in exactly one variable. The examples given below show boththe binary notation and its algebraic equivalent.
AB/H11032CD/H11032/H11001  AB/H11032CD /H11005AB/H11032C
1010 /H110011011 /H11005101– (the dash indicates a missing variable)
XY XY /H11032 X
A/H11032BC/H11032D/H11001A/H11032BCD /H11032(will not combine)
0101 /H110010110 (will not combine)
In order to find all of the prime implicants, all possible pairs of minterms should
be compared and combined whenever possible. To reduce the required number ofcomparisons, the binary minterms are sorted into groups according to the numberof 1’s in each term. Thus,
(6-2) f (a,b,c,d)/H11005/H9018 m(0, 1, 2, 5, 6, 7, 8, 9, 10, 14)¯˘˙ ¯˘˙ ¯˘˙
166 Unit 6
In this list, the term in group 0 has zero 1’s, the terms in group 1 have one 1, those
in group 2 have two 1’s, and those in group 3 have three 1’s.
Two terms can be combined if they differ in exactly one variable. Comparison of
terms in nonadjacent groups is unnecessary because such terms will always differ inat least two variables and cannot be combined using XY/H11001XY/H11032/H11005X. Similarly, the
comparison of terms within a group is unnecessary because two terms with the samenumber of 1’s must differ in at least two variables. Thus, only terms in adjacentgroups must be compared.
First, we will compare the term in group 0 with all of the terms in group 1. Terms
0000 and 0001 can be combined to eliminate the fourth variable, which yields 000–.Similarly, 0 and 2 combine to form 00–0 ( a/H11032b/H11032d/H11032), and 0 and 8 combine to form –000
(b/H11032c/H11032d/H11032). The resulting terms are listed in Column II of Table 6-1.
Whenever two terms combine, the corresponding decimal numbers differ by a
power of 2 (1, 2, 4, 8, etc.). This is true because when the binary representationsdiffer in exactly one column and if we subtract these binary representations, wegroup 0 0 0000
1 0001
group 1 2 0010
8 1000
5 0101
group 26 0110
9 1001
10 1010
7 0111group 314 1110
¯˚˘˚˙ ¯˘˙ ¯˘˙is represented by the following list of minterms:
Column I Column II Column III
group 0 0 0000 ✓ 0, 1 000– ✓ 0, 1, 8, 9 –00–
1 0001 ✓ 0, 2 00–0 ✓ 0, 2, 8, 10 –0–0
group 1 2 0010 ✓ 0, 8 –000 ✓ 0, 8, 1, 9 –00–
8 1000 ✓ 1, 5 0–01 0, 8, 2,10 –0–0
5 0101 ✓ 1, 9 –001 ✓ 2, 6, 10, 14 --10
6 0110 ✓ 2, 6 0–10 ✓ 2, 10, 6, 14 --10group 2
9 1001 ✓ 2, 10 –010 ✓
10 1010 ✓ 8, 9 100– ✓
7 0111 ✓ 8, 10 10–0 ✓group 3
14 1110 ✓ 5, 7 01–1
6, 7 011–
6, 14 –110 ✓
10, 14 1–10 ✓TABLE 6-1
Determination of
Prime Implicants¯˚˚˘˚˚ ˙ ¯˚˘˚˙ ¯˘˙
Quine-McCluskey Method 167
get a 1 only in the column in which the difference exists. A binary number with a
1 in exactly one column is a power of 2.
Because the comparison of group 0 with groups 2 and 3 is unnecessary, we proceed
to compare terms in groups 1 and 2. Comparing term 1 with all terms in group 2, we findthat it combines with 5 and 9 but not with 6 or 10. Similarly, term 2 combines only with6 and 10, and term 8 only with 9 and 10. The resulting terms are listed in Column II.Each time a term is combined with another term, it is checked off.A term may be usedmore than once because X/H11001X/H11005X. Even though two terms have already been com-
bined with other terms, they still must be compared and combined if possible. This isnecessary because the resultant term may be needed to form the minimum sum solu-tion. At this stage, we may generate redundant terms, but these redundant terms willbe eliminated later. We finish with Column I by comparing terms in groups 2 and 3.New terms are formed by combining terms 5 and 7, 6 and 7, 6 and 14, and 10 and 14.
Note that the terms in Column II have been divided into groups, according to the
number of 1’s in each term.Again, we apply XY/H11001XY/H11032/H11005Xto combine pairs of terms
in Column II. In order to combine two terms, the terms must have the same variables,and the terms must differ in exactly one of these variables.Thus, it is necessary only tocompare terms which have dashes (missing variables) in corresponding places andwhich differ by exactly one in the number of 1’s.
Terms in the first group in Column II need only be compared with terms in the sec-
ond group which have dashes in the same places. Term 000– (0, 1) combines only withterm 100– (8, 9) to yield –00–. This is algebraically equivalent to .The resulting term is listed in Column III along with the designation 0, 1, 8, 9 to indicatethat it was formed by combining minterms 0, 1, 8, and 9. Term (0, 2) combines only with(8, 10), and term (0, 8) combines with both (1, 9) and (2, 10).Again, the terms which havebeen combined are checked off. Comparing terms from the second and third groups inColumn II, we find that (2,6) combines with (10, 14), and (2, 10) combines with (6,14).
Note that there are three pairs of duplicate terms in Column III.These duplicate
terms were formed in each case by combining the same set of four minterms in a dif-ferent order. After deleting the duplicate terms, we compare terms from the twogroups in Column III. Because no further combination is possible, the process ter-minates. In general, we would keep comparing terms and forming new groups ofterms and new columns until no more terms could be combined.
The terms which have not been checked off because they cannot be combined
with other terms are called prime implicants. Because every minterm has beenincluded in at least one of the prime implicants, the function is equal to the sum ofits prime implicants. In this example we have
(6-3)
(1, 5) (5, 7) (6,7) (0, 1, 8, 9) (0, 2, 8, 10) (2, 6, 10, 14)
In this expression, each term has a minimum number of literals, but the number
of terms is not minimum. Using the consensus theorem to eliminate redundant
terms yields
(6-4)
which is the minimum sum-of-products expression for f. Section 6.2 discusses a bet-
ter method of eliminating redundant prime implicants using a prime implicant chart.f/H11005a/H11032bd/H11001b/H11032c/H11032/H11001cd/H11032cd/H11032 b/H11032d/H11032/H11001 b/H11032c/H11032/H11001 f/H11005a/H11032c/H11032d/H11001a/H11032bd/H11001a/H11032bc/H11001a/H11032b/H11032c/H11032/H11001ab/H11032c/H11032/H11005b/H11032c/H11032
168 Unit 6
Next, we will define implicant and prime implicant and relate these terms to the
Quine-McCluskey method.
Definition Given a function Fofnvariables, a product term Pis an implicant ofFiff for every
combination of values of the nvariables for which P/H110051,Fis also equal to 1.
In other words, if for some combination of values of the variables, P/H110051 and F/H110050,
then Pisnotan implicant of F. For example, consider the function
(6-5)
If a/H11032b/H11032c/H11032/H110051, then F/H110051; if ac/H110051, then F/H110051; etc. Hence, the terms a/H11032b/H11032c/H11032,ac, etc., are
implicants of F. In this example, bcisnotan implicant of Fbecause when a/H110050 and 
b/H11005c/H110051,bc/H110051 and F/H110050. In general, if Fis written in sum-of-products form, every
product term is an implicant. Every minterm of Fis also an implicant of F, and so is any
term formed by combining two or more minterms. For example, in Table 6-1, all of theterms listed in any of the columns are implicants of the function given in Equation (6-2).
Definition Aprime implicant of a function Fis a product term implicant which is no longer
an implicant if any literal is deleted from it.
In Equation (6-5), the implicant a/H11032b/H11032c/H11032is not aprime implicant because a/H11032can
be eliminated, and the resulting term ( b/H11032c/H11032) is still an implicant of F. The impli-
cants b/H11032c/H11032and acareprime implicants because ifwe delete a literal from either
term, the term will no longer be an implicant of F. Each prime implicant of a func-
tion has a minimum number of literals in the sense that no more literals can beeliminated from it by combining it with other terms.
The Quine-McCluskey method, as previously illustrated, finds all of the product
term implicants of a function. The implicants which are nonprime are checked off inthe process of combining terms so that the remaining terms are prime implicants.
A minimum sum-of-products expression for a function consists of a sum of some
(but not necessarily all) of the prime implicants of that function. In other words, asum-of-products expression which contains a term which is not a prime implicant can-not be minimum.This is true because the nonprime term does not contain a minimumnumber of literals—it can be combined with additional minterms to form a primeimplicant which has fewer literals than the nonprime term. Any nonprime term in asum-of-products expression can thus be replaced with a prime implicant, whichreduces the number of literals and simplifies the expression.
6.2 The Prime Implicant Chart
The second part of the Quine-McCluskey method employs a prime implicant chartto select a minimum set of prime implicants. The minterms of the function are listedacross the top of the chart, and the prime implicants are listed down the side.A primeF(a,b,c)/H11005a/H11032b/H11032c/H11032/H11001ab/H11032c/H11032/H11001ab/H11032c/H11001abc/H11005b/H11032c/H11032/H11001ac
Quine-McCluskey Method 169
implicant is equal to a sum of minterms, and the prime implicant is said to cover these
minterms. If a prime implicant covers a given minterm, an Xis placed at the inter-
section of the corresponding row and column. Table 6-2 shows the prime implicantchart derived from Table 6-1.All of the prime implicants (terms which have not beenchecked off in Table 6-1) are listed on the left.
In the first row, X’s are placed in columns 0, 1, 8, and 9, because prime implicant
b/H11032c/H11032was formed from the sum of minterms 0, 1, 8, and 9. Similarly, X’s are placed in
columns 0, 2, 8, and 10 opposite the prime implicant b/H11032d/H11032and so forth.
012567891 01 4
(0, 1, 8, 9) b/H11032c/H11032 ×× ××
(0, 2, 8, 10) b/H11032d/H11032 ×× ××
(2, 6, 10, 14) cd/H11032 ×× × ×
(1, 5) a/H11032c/H11032d ××
(5, 7) a/H11032bd ××
(6, 7) a/H11032bc ××TABLE 6-3If a minterm is covered by only one prime implicant, then that prime implicant is
called an essential prime implicant and must be included in the minimum sum of prod-
ucts. Essential prime implicants are easy to find using the prime implicant chart. If agiven column contains only one X, then the corresponding row is an essential prime
implicant. In Table 6-2, columns 9 and 14 each contain one X, so prime implicants b/H11032c/H11032
andcd/H11032are essential.
Each time a prime implicant is selected for inclusion in the minimum sum, the
corresponding row should be crossed out. After doing this, the columns which cor-respond to all minterms covered by that prime implicant should also be crossed out.Table 6-3 shows the resulting chart when the essential prime implicants and the cor-responding rows and columns of Table 6-2 are crossed out. A minimum set of primeimplicants must now be chosen to cover the remaining columns. In this example,a/H11032bdcovers the remaining two columns, so it is chosen. The resulting minimum sum
of products is
which is the same as Equation (6-4). Note that even though the term a/H11032bdis includ-
ed in the minimum sum of products, a/H11032bdisnotanessential prime implicant. It is
the sum of minterms m
5and m7;m5is also covered by a/H11032c/H11032d, and m7is also covered
bya/H11032bc.f/H11005b/H11032c/H11032/H11001cd/H11032/H11001a/H11032bd012567891 0 1 4
(0, 1, 8, 9) b/H11032c/H11032 ×× × ⊗
(0, 2, 8, 10) b/H11032d/H11032 ×× × ×
(2, 6, 10, 14) cd/H11032 ×× × ⊗
(1, 5) a/H11032c/H11032d ××
(5, 7) a/H11032bd ××
(6, 7) a/H11032bc ××TABLE 6-2
Prime Implicant
Chart
170 Unit 6
When the prime implicant chart is constructed, some minterms may be covered
by only a single prime implicant, although other minterms may be covered by two ormore prime implicants.A prime implicant is essential (or necessary) to a function fiff
the prime implicant contains a minterm which is not covered by any other primeimplicant of f. The essential prime implicants are chosen first because all essential
prime implicants must be included in every minimum sum. After the essential primeimplicants have been chosen, the minterms which they cover can be eliminated fromthe prime implicant chart by crossing out the corresponding columns. If the essentialprime implicants do not cover all of the minterms, then additional nonessential primeimplicants are needed. In simple cases, the nonessential prime implicants needed toform the minimum solution may be selected by trial and error. For larger primeimplicant charts, additional procedures for chart reduction can be employed.
1Some
functions have two or more minimum sum-of-products expressions, each having thesame number of terms and literals. The next example shows such a function.
A prime implicant chart which has two or more X’s in every column is called a cyclic
Example prime implicant chart. The following function has such a chart:
F/H11005/H20858 m(0, 1, 2, 5, 6, 7) (6-6)
Derivation of prime implicants:
0 000 ✓ 0, 1 00–
1 001 ✓ 0, 2 0–0
2 010 ✓ 1, 5 –01
5 101 ✓ 2, 6 –10
6 110 ✓ 5, 7 1–1
7 111 ✓ 6, 7 11–
Table 6-4 shows the resulting prime implicant chart. All columns have two X’s, so
we will proceed by trial and error. Both (0, 1) and (0, 2) cover column 0, so we will try
(0, 1). After crossing out row (0, 1) and columns 0 and 1, we examine column 2, whichis covered by (0, 2) and (2, 6). The best choice is (2, 6) because it covers two of theremaining columns while (0, 2) covers only one of the remaining columns.After cross-ing out row (2, 6) and columns 2 and 6, we see that (5, 7) covers the remaining columnsand completes the solution. Therefore, one solution is . F/H11005a/H11032b/H11032/H11001bc/H11032/H11001ac
012567
➀ (0, 1) a/H11032b/H11032××
(0, 2) a/H11032c/H11032 ××
(1, 5) b/H11032c ××
➁ (2, 6) bc/H11032 ××
➂ (5, 7) ac ××
(6, 7) ab ××TABLE 6-4
→
→
→
1For a discussion of such procedures, see E. J. McCluskey, Logic Design Principles. (Prentice-Hall, 1986).
Quine-McCluskey Method 171
However, we are not guaranteed that this solution is minimum.We must go back
and solve the problem over again starting with the other prime implicant that cov-ers column 0. The resulting table (Table 6-5) is
012567
P1 (0, 1) a/H11032b/H11032××
P2 (0, 2) a/H11032c/H11032 ××
P3 (1, 5) b/H11032c ××
P4 (2, 6) bc/H11032 ××
P5 (5, 7) ac ××
P6 (6, 7) ab ××TABLE 6-5
Finish the solution and show that . Because this has the same
number of terms and same number of literals as the expression for Fderived in
Table 6-4, there are two minimum sum-of-products solutions to this problem.Compare these two minimum solutions for Equation (6-6) with the solutionsobtained in Figure 5-9 using Karnaugh maps. Note that each minterm on the mapcan be covered by two different loops. Similarly, each column of the prime implicantchart (Table 6-4) has two X’s, indicating that each minterm can be covered by two
different prime implicants.
6.3 Petrick’s Method
Petrick’s method is a technique for determining all minimum sum-of-products
solutions from a prime implicant chart. The example shown in Tables 6-4 and 6-5has two minimum solutions. As the number of variables increases, the number ofprime implicants and the complexity of the prime implicant chart may increasesignificantly. In such cases, a large amount of trial and error may be required tofind the minimum solution(s). Petrick’s method is a more systematic way of find-ing all minimum solutions from a prime implicant chart than the method usedpreviously. Before applying Petrick’s method, all essential prime implicants andthe minterms they cover should be removed from the chart.
We will illustrate Petrick’s method using Table 6-5. First, we will label the rows of
the table P
1,P2,P3, etc. We will form a logic function, P, which is true when all of the
minterms in the chart have been covered. Let P1be a logic variable which is true
when the prime implicant in row P1is included in the solution, P2be a logic variable
which is true when the prime implicant in row P2is included in the solution, etc.
Because column 0 has X’s in rows P1and P2, we must choose row P1orP2in order
to cover minterm 0. Therefore, the expression ( P1/H11001P2) must be true. In order to
cover minterm 1, we must choose row P1orP3; therefore, ( P1/H11001P3) must be true. InF/H11005a/H11032c/H11032/H11001b/H11032c/H11001ab
172 Unit 6
order to cover minterm 2, ( P2/H11001P4) must be true. Similarly, in order to cover
minterms 5, 6, and 7, the expressions ( P3/H11001P5), (P4/H11001P6) and ( P5/H11001P6) must be true.
Because we must cover all of the minterms, the following function must be true:
The expression for Pin effect means that we must choose row P1orP2,and row P1
orP3,and row P2orP4, etc.
The next step is to reduce Pto a minimum sum of products. This is easy because
there are no complements. First, we multiply out, using and the ordinary distributive law:
Next, we use X/H11001XY/H11005Xto eliminate redundant terms from P, which yields
Because Pmust be true ( P/H110051) in order to cover all of the minterms, we can
translate the equation back into words as follows. In order to cover all of theminterms, we must choose rows P
1and P4and P5, or rows P1and P2and P5and
P6, or . . . or rows P2and P3and P6. Although there are five possible solutions, only
two of these have the minimum number of rows. Thus, the two solutions with theminimum number of prime implicants are obtained by choosing rows P
1,P4, and
P5or rows P2,P3, and P6. The first choice leads to , and the
second choice to , which are the two minimum solutionsderived in Section 6.2.
In summary, Petrick’s method is as follows:
1.Reduce the prime implicant chart by eliminating the essential prime implicant
rows and the corresponding columns.
2.Label the rows of the reduced prime implicant chart P
1,P2,P3, etc.
3.Form a logic function Pwhich is true when all columns are covered. Pconsists
of a product of sum terms, each sum term having the form ( Pi0/H11001Pi1/H11001...) ,
where Pi0,Pi1. . . represent the rows which cover column i.
4.Reduce Pto a minimum sum of products by multiplying out and applying 
X/H11001XY/H11005X.
5.Each term in the result represents a solution, that is, a set of rows which covers all
of the minterms in the table. To determine the minimum solutions (as defined inSection 5.1), find those terms which contain a minimum number of variables. Eachof these terms represents a solution with a minimum number of prime implicants.
6.For each of the terms found in step 5, count the number of literals in each prime
implicant and find the total number of literals. Choose the term or terms whichcorrespond to the minimum total number of literals, and write out the corre-
sponding sums of prime implicants.F/H11005a/H11032c/H11032/H11001b/H11032c/H11001abF/H11005a/H11032b/H11032/H11001bc/H11032/H11001acP/H11005P
1P4P5/H11001P1P2P5P6/H11001P2P3P4P5/H11001P1P3P4P6/H11001P2P3P6/H11001P1P2P3P6/H11001P2P3P4P6/H11001P2P3P6/H11005P1P4P5/H11001P1P2P5P6/H11001P2P3P4P5/H11001P2P3P5P6/H11001P1P3P4P6/H11005 (P1P4/H11001P1P2P6/H11001P2P3P4/H11001P2P3P6) ( P5/H11001P3P6)P/H11005 (P1/H11001P2P3)(P4/H11001P2P6) (P5/H11001P3P6)(X/H11001Y )(X/H11001Z )/H11005X/H11001YZP/H11005(P1/H11001P2)(P1/H11001P3)(P2/H11001P4)(P3/H11001P5)(P4/H11001P6)(P5/H11001P6)/H110051
Quine-McCluskey Method 173
The application of Petrick’s method is very tedious for large charts, but it is easy to
implement on a computer.
6.4 Simplification of Incompletely 
Specified Functions
Given an incompletely specified function, the proper assignment of values to the
don’t-care terms is necessary in order to obtain a minimum form for the function. Inthis section, we will show how to modify the Quine-McCluskey method in order toobtain a minimum solution when don’t-care terms are present. In the process of find-ing the prime implicants, we will treat the don’t-care terms as if they were requiredminterms. In this way, they can be combined with other minterms to eliminate asmany literals as possible. If extra prime implicants are generated because of thedon’t-cares, this is correct because the extra prime implicants will be eliminated inthe next step anyway. When forming the prime implicant chart, the don’t-cares arenotlisted at the top. This way, when the prime implicant chart is solved, all of the
required minterms will be covered by one of the selected prime implicants. However,the don’t-care terms are not included in the final solution unless they have been usedin the process of forming one of the selected prime implicants.The following exampleof simplifying an incompletely specified function should clarify the procedure.
(the terms following dare don’t-care terms)
The don’t-care terms are treated like required minterms when finding the prime
implicants:
1 0001 ✓ (1, 3) 00–1 ✓ (1, 3, 9, 11) –0–1
2 0010 ✓ (1, 9) –001 ✓ (2, 3, 10,11) –01–
3 0011 ✓ (2, 3) 001– ✓ ( 3 ,7 ,1 1 ,1 5 ) --11
9 1001 ✓ (2, 10) –010 ✓ ( 9 ,1 1 ,1 3 ,1 5 ) 1--1
10 1010 ✓ (3, 7) 0–11 ✓
7 0111 ✓ (3, 11) –011 ✓
11 1011 ✓ (9, 11) 10–1 ✓
13 1101 ✓ (9, 13) 1–01 ✓
15 1111 ✓ (10, 11) 101– ✓
(7, 15) –111 ✓
(11, 15) 1–11 ✓
(13, 15) 11–1 ✓F(A,B,C,D)/H11005/H9018  m(2, 3, 7, 9, 11, 13) /H11001/H9018 d(1, 10, 15)
174 Unit 6
The don’t-care columns are omitted when forming the prime implicant chart:
Note that although the original function was incompletely specified, the final
simplified expression for Fis defined for all combinations of values for A,B,C, and
Dand is therefore completely specified. In the process of simplification, we have
automatically assigned values to the don’t-cares in the original truth table for F.I f
we replace each term in the final expression for Fby its corresponding sum of
minterms, the result is
Because m10andm15appear in this expression and mldoes not, this implies that the
don’t-care terms in the original truth table for Fhave been assigned as follows:
forABCD /H110050001, F/H110050; for 1010, F/H110051; for 1111, F/H110051
6.5 Simplification Using Map-Entered Variables
Although the Quine-McCluskey method can be used with functions with a fairly
large number of variables, it is not very efficient for functions that have many vari-ables and relatively few terms. Some of these functions can be simplified by using amodification of the Karnaugh map method. By using map-entered variables,Karnaugh map techniques can be extended to simplify functions with more than fouror five variables. Figure 6-1(a) shows a four-variable map with two additional vari-ables entered in the squares in the map. When Eappears in a square, this means thatF/H11005(m2/H11001m3/H11001m10/H11001m11)/H11001(m3/H11001m7/H11001m11/H11001m15)/H11001(m9/H11001m11/H11001m13/H11001m15)2379 1 1 1 3
(1, 3, 9, 11) ×× ×
*(2, 3, 10, 11) ×× ×F/H11005 B/H11032C/H11001 CD/H11001 AD*(3, 7, 11, 15) ×× ×
*(9, 11, 13, 15) ×× ×
*indicates an essential prime implicant.
100 01 11 10
X E X F
1 E 1 1
100CDAB
G01
11
10 X100 01 11 10
X X
1 1 1
100CDAB
E = F = 0
MS0 = A′B′ + ACD01
11
10 XX00 01 11 10
X 1 X
X 1 X X
X00CDAB
E = 1, F = 0
MS1 = A′D01
11
10 XX00 01 11 10
X X 1
X X X
X00CDAB
E = 0, F = 1
MS2 = AD
(a) (b) (c) (d)01
11
10 XFIGURE 6-1
Use of Map-
Entered
Variables
Quine-McCluskey Method 175
ifE/H110051, the corresponding minterm is present in the function G, and if E/H110050, the
minterm is absent. Thus, the map represents the six-variable function
(/H11001don’t-care terms)
where the minterms are minterms of the variables A,B,C, and D. Note that m9is
present in Gonly when F/H110051.
We will now use a three-variable map to simplify the function:
where the AB/H11032Cis a don’t-care term. Because Dappears in only two terms, we will
choose it as a map-entered variable, which leads to Figure 6-2(a). We will simplify Fby
first considering D/H110050 and then D/H110051. First set D/H110050 on the map, and Freduces to
A/H11032C. Setting D/H110051 leads to the map of Figure 6-2(b). The two 1’s on the original map
have already been covered by the term A/H11032C, so they are changed to X’s because we do
not care whether they are covered again or not. From Figure 6-2(b), when D/H110051.Thus,
the expression
gives the correct value of Fboth when D/H110050 and when D/H110051. This is a minimum
expression for F, as can be verified by plotting the original function on a four-variable
map; see Figure 6-2(c).
Next, we will discuss a general method of simplifying functions using map-entered
variables. In general, if a variable Piis placed in square mjof a map of function F, this
means that F/H110051 when Pi/H110051, and the variables are chosen so that mj/H110051. Given a
map with variables P1,P2, . . . entered into some of the squares, the minimum sum-
of-products form of Fcan be found as follows:
Find a sum-of-products expression for Fof the form
where
MS0is the minimum sum obtained by setting P1/H11005P2/H11005···/H110050.F/H11005MS0/H11001P1MS1/H11001P2MS2/H11001· · ·F/H11005A/H11032C/H11001D(C/H11001A/H11032B)/H11005A/H11032C/H11001CD/H11001A/H11032BDF(A,B,C,D)/H11005A/H11032B/H11032C/H11001A/H11032BC/H11001A/H11032BC/H11032D/H11001ABCD /H11001(AB/H11032C)G(A,B,C,D,E,F)/H11005m0/H11001m2/H11001m3/H11001Em5/H11001Em7/H11001Fm9/H11001m11/H11001m15
(c) (b) (a)00 01 11 10
1XX1
11 100BCDA
01
11
10 101
XX
X1
100BCA
01
11
1001
1X
1 D
D00BCA
01
11
10FIGURE 6-2
Simplification Using
a Map-Entered
Variable
176 Unit 6
2This method is described in R. K. Brayton et al., Logic Minimization Algorithms for VLSI Synthesis
(Kluwer Academic Publishers, 1984).MS1is the minimum sum obtained by setting P1/H110051,Pj/H110050 (j/HS110051), and replacing
all 1’s on the map with don’t-cares.
MS2is the minimum sum obtained by setting P2/H110051,Pj/H110050 (j/HS110052) and replacing
all 1’s on the map with don’t-cares.
(Corresponding minimum sums can be found in a similar way for any remaining
map-entered variables.)
The resulting expression for Fwill always be a correct representation of F. This
expression will be minimum provided that the values of the map-entered variablescan be assigned independently. On the other hand, the expression will not general-ly be minimum if the variables are not independent (for example, if P
1/H11005P/H110322).
For the example of Figure 6-1(a), maps for finding MS0,MS1andMS2are shown
in Figures 6-1(b), (c), and (d), where Ecorresponds to P1and Fcorresponds to P2.
The resulting expression is a minimum sum of products for G:
After some practice, it should be possible to write the minimum expression
directly from the original map without first plotting individual maps for each of theminimum sums.
6.6 Conclusion
We have discussed four methods for reducing a switching expression to a minimumsum-of-products or a minimum product-of-sums form: algebraic simplification,Karnaugh maps, Quine-McCluskey method, and Petrick’s method. Many other meth-ods of simplification are discussed in the literature, but most of these methods are basedon variations or extensions of the Karnaugh map or Quine-McCluskey techniques.Karnaugh maps are most useful for functions with three to five variables. The Quine-McCluskey technique can be used with a high-speed digital computer to simplify func-tions with up to 15 or more variables. Such computer programs are of greatest valuewhen used as part of a computer-aided design (CAD) package that assists with derivingthe equations as well as implementing them. Algebraic simplification is still valuable inmany cases, especially when different forms of the expressions are required. For prob-lems with a large number of variables and a small number of terms, it may be impossi-ble to use the Karnaugh map, and the Quine-McCluskey method may be very cumber-some. In such cases, algebraic simplification may be the easiest method to use. In situa-tions where a minimum solution is not required or where obtaining a minimum solutionrequires too much computation to be practical, heuristic procedures may be used to sim-plify switching functions. One of the more popular heuristic procedures is the Espresso-
II method,
2which can produce near minimum solutions for a large class of problems.
The minimum sum-of-products and minimum product-of-sums expressions we
have derived lead directly to two-level circuits that use a minimum number of ANDG/H11005A/H11032B/H11032/H11001ACD /H11001EA/H11032D/H11001FAD
Quine-McCluskey Method 177
and OR gates and have a minimum number of gate inputs. As discussed in Unit 7,
these circuits are easily transformed into circuits that contain NAND or NOR gates.These minimum expressions may also be useful when designing with some types ofarray logic, as discussed in Unit 9. However, many situations exist where minimumexpressions do not lead to the best design. For practical designs, many other factorsmust be considered, such as the following:
What is the maximum number of inputs a gate can have?What is the maximum number of outputs a gate can drive?Is the speed with which signals propagate through the circuit fast enough?How can the number of interconnections in the circuit be reduced?Does the design lead to a satisfactory circuit layout on a printed circuit board
or on a silicon chip?
Until now, we have considered realizing only one switching function at a time.
Unit 7 describes design techniques and Unit 9 describes components that can beused when several functions must be realized by a single circuit.
Programmed Exercise 6.1
Cover the answers to this exercise with a sheet of paper and slide it down as youcheck your answers.
Find a minimum sum-of-products expression for the following function:
f(A,B,C,D,E)/H11005 /H9018 m(0, 2, 3, 5, 7, 9, 11, 13, 14, 16, 18, 24, 26, 28, 30)
Translate each decimal minterm into binary and sort the binary terms into groups
according to the number of 1’s in each term.
Answer: 0 00000 ✓ 0, 2 000-0
2 00010 ✓
16 10000 
3 00011 5 00101 9 01001 
18 10010 
24 11000 
7 00111 
11 01011 13 01101 14 01110 26 11010 
28 11100 
30 11110 
Compare pairs of terms in adjacent groups and combine terms where possible.
(Check off terms which have been combined.)
178 Unit 6
Answer: 0 00000 ✓ 0, 2 000–0 ✓ 0, 2, 16, 18 –00–0
2 00010 ✓ 0, 16 –0000
16 10000 ✓ 2, 3 0001–
3 00011 ✓ 2, 18 –0010
5 00101 ✓ 16, 18 100–0 ✓
9 01001 ✓ 16, 24 1–000
18 10010 ✓ 3, 7 00–11
24 11000 ✓ 3, 11 0–011
7 00111 ✓ 5, 7 001–1
11 01011 ✓ 5, 13 0–101
13 01101 ✓ 9, 11 010–1
14 01110 ✓ 9, 13 01–01
26 11010 ✓ 18, 26 1–010
28 11100 ✓ 24, 26 110–0
30 11110 ✓ 24, 28 11–00
14, 30 –111026, 30 11–10
28, 30 111–0
Now, compare pairs of terms in adjacent groups in the second column and combine
terms where possible. (Check off terms which have been combined.) Check yourwork by noting that each new term can be formed in two ways. (Cross out duplicateterms.)
Answer: (third column)
0, 2, 16, 18 –00–0 (check off (0, 2), (16, 18), (0, 16), and (2, 18))
16, 18, 24, 26 1–0–0 (check off (16, 18), (24, 26), (16, 24), and (18, 26))
24,26,28,30 11--0 (check off (24, 26), (28, 30), (24, 28), and (26, 30))
Can any pair of terms in the third column be combined? 
Complete the given prime implicant chart.
02
(0, 2, 16, 18)
Quine-McCluskey Method 179
Answer: No pair of terms in the third column combine.
0235791 11 31 41 61 82 42 62 83 0
(0, 2, 16, 18) ×× × ×
(16, 18, 24, 26) ××××
(24, 26, 28, 30) ××× X
(2, 3) ××
(3, 7) ××
(3, 11) ××
(5, 7) ××
(5, 13) ××
(9, 11) ××
(9, 13) ××
(14, 30) ××
Determine the essential prime implicants, and cross out the corresponding rows and
columns.
Answer: 0 2 3 5 7 9 11 13 14 16 18 24 26 28 30
*(0, 2, 16, 18) ×× × ×
(16, 18, 24, 26) ××××
*(24, 26, 28, 30) ××××
(2, 3) ××
(3, 7) ××
(3, 11) ××
(5, 7) ××
(5, 13) ××
(9, 11) ××
(9, 13) ××
*(14, 30) ××
*Indicates an essential prime implicant.
Note that all remaining columns contain two or more X’s. Choose the first column
which has two X’s and then select the prime implicant which covers the first Xin that
column. Then, choose a minimum number of prime implicants which cover theremaining columns in the chart.
180 Unit 6
Answer: 0 2 3 5 7 9 11 13 14 16 18 24 26 28 30
*(0, 2, 16, 18) ×× × ×
(16, 18, 24, 26) ××××
*(24, 26, 28, 30) ××××
(2, 3) ××
(3, 7) ××
(3, 11) ××
(5, 7) ××
(5, 13) ××
(9, 11) ××
(9, 13) ××
*(14, 30) ××
*Indicates an essential prime implicant.
From this chart, write down the chosen prime implicants in 0, 1, and – notation.
Then, write the minimum sum of products in algebraic form.
Answer: –00–0, 11--0, 0–011, 001–1, 01–01, and –1110
The prime implicant chart with the essential prime implicants crossed out is repeated
here.Find a second minimum sum-of-products solution.
0235791 11 31 41 61 82 42 62 83 0
*(0, 2, 16, 18) ×× × ×
(16, 18, 24, 26) ××××
*(24, 26, 28, 30) ××××
(2, 3) ××
(3, 7) ××
(3, 11) ××
(5, 7) ××
(5, 13) ××
(9, 11) ××
(9, 13) ××
*(14, 30) ××
*Indicates an essential prime implicant.
Answer: Start by choosing prime implicant (5, 13).
f/H11005BCDE /H11032/H11001B/H11032C/H11032E/H11032/H11001ABE /H11032/H11001A/H11032B/H11032DE/H11001A/H11032CD/H11032E/H11001A/H11032BC/H11032Ef/H11005B/H11032C/H11032E/H11032/H11001ABE /H11032/H11001A/H11032C/H11032DE/H11001A/H11032B/H11032CE/H11001A/H11032BD/H11032E/H11001BCDE /H11032S
S
S
Quine-McCluskey Method 181
Problems
6.2 For each of the following functions, find all of the prime implicants, using the Quine-
McCluskey method.(a)(b)
6.3 Using a prime implicant chart, find allminimum sum-of-products solutions for each
of the functions given in Problem 6.2.
6.4 For this function, find a minimum sum-of-products solution, using the Quine-
McCluskey method.
6.5 Find all prime implicants of the following function and then find all minimum solu-
tions using Petrick’s method:
6.6 Using the method of map-entered variables, use four-variable maps to find a minimum
sum-of-products expression for(a) where the
m’s represent minterms of the variables A,B,C, and D.
(b)
6.7 For each of the following functions, find all of the prime implicants using the Quine-
McCluskey method.(a)(b)
6.8 Using a prime implicant chart, find allminimum sum-of-products solutions for each
of the functions given in Problem 6.7.
6.9 For each function, find a minimum sum-of-products solution using the Quine-
McCluskey method.(a)(b)(c)
6.10 Work Problem 5.24(a) using the Quine-McCluskey method.
6.11
/H11001/H9018 d(4, 9, 21)F(A,B,C,D,E)/H11005/H9018 m(0, 2, 6, 7, 8, 10, 11, 12, 13, 14, 16, 18, 19, 29, 30)f(a,b,c,d)/H11005/H9018 m(3, 4, 6, 7, 8, 9, 11, 13, 14) /H11001/H9018 d(2, 5, 15)f(a,b,c,d)/H11005/H9018 m(0, 1, 5, 6, 8, 9, 11, 13) /H11001/H9018 d(7, 10, 12)f(a,b,c,d
)/H11005/H9018 m(2, 3, 4, 7, 9, 11, 12, 13, 14) /H11001/H9018 d(1, 10, 15)f(a,b,c,d)/H11005/H9018 m(2, 4, 5, 6, 9, 10, 11, 12, 13, 15)f(a,b,c,d)/H11005/H9018 m(0, 3, 4, 5, 7, 9, 11, 13)/H11001E(m6/H11001m8)/H11001Fm12/H11001Gm5Z(A,B,C,D,E,F,G)/H11005/H9018 m(0, 3, 13, 15) /H11001/H9018 d(1, 2, 7, 9, 14)F(A,B,C,D,E)/H11005/H9018 m(0, 4, 5, 7, 9) /H11001/H9018 d(6, 11) /H11001E(m1/H11001m15),F(A,B,C,D)/H11005/H9018 m(9, 12, 13, 15) /H11001/H9018 d(1, 4, 5, 7, 8, 11,14)f (a,b,c,d )/H11005/H9018 m(1, 3, 4, 5, 6, 7, 10, 12, 13) /H11001/H9018 d(2, 9, 15)f (a,b,c,d )/H11005/H9018  m(0, 1, 3, 5, 6, 7, 8, 10, 14, 15)f (a,b,c,d )/H11005/H9018 m(1, 5, 7, 9, 11, 12, 14, 15)
182 Unit 6
Find the minimum sum-of-products expression for F, using the Quine-McCluskey
method. Underline the essential prime implicants in this expression.
6.12 Using the Quine-McCluskey method, find all minimum sum-of-products expres-
sions for(a)f(A, B, C, D, E )/H11005/H9018 m(0, 1, 2, 3, 4, 8, 9, 10, 11, 19, 21, 22, 23, 27, 28, 29, 30)
(b)f(A, B, C, D, E )/H11005/H9018 m(0, 1, 2, 4, 8, 11, 13, 14, 15, 17, 18, 20, 21, 26, 27, 30, 31)
6.13 Using the Quine-McCluskey method, find all minimum product-of-sums expres-
sions for the functions of Problem 6.12.
6.14 (a) Using the Quine-McCluskey, method find all prime implicants of f(A,B,C,D)/H11005
/H9018m(1, 3, 5, 6, 8, 9, 12, 14, 15) /H11001/H9018 d(4, 10, 13). Identify all essential prime impli-
cants and find all minimum sum-of-products expressions.
(b) Repeat Part (a) for f/H11032.
6.15 (a) Use the Quine-McCluskey method to find all prime implicants of f(a, b, c, d, e )/H11005
/H9018m(1, 2, 4, 5, 6, 7, 9, 12, 13, 15, 17, 20, 22, 25, 28, 30). Find all essential prime impli-
cants, and find all minimum sum-of-products expressions.
(b) Repeat Part (a) for f/H11032.
6.16
(a) Find all minimum sum-of-products expressions for G.
(b) Circle the essential prime implicants in your answer.
(c) If there were no don’t-care terms present in the original function, how would
your answer to part (a) change? (Do this by inspection of the prime implicantchart; do notrework the problem.)
6.17 (a) Use the Quine-McCluskey procedure to find allprime implicants of the
function G(A, B, C, D, E, F )/H11005/H9018 m(1, 7, 11, 12, 15, 33, 35, 43, 47, 59, 60) /H11001
/H9018d(30, 50, 54, 58). Identify all essential prime implicants and find all minimum
sum-of-products expressions.
(b) Repeat Part (a) for G/H11032.
6.18 The following prime implicant table (chart) is for a four-variable function f(A, B, C, D
).
(a) Give the decimal representation for each of the prime implicants.(b) List the maxterms of f.
(c) List the don’t-cares of f, if any.
(d) Give the algebraic expression for each of the essential prime implicants.
23791 11 3
/H110020–1 ×× ×
/H1100201/H11002 ×× ×
--11 ×× ×
1--1 ×× ×/H11001/H9018 d(15, 28, 29, 30)G(A,B,C,D,E,F)/H11005/H9018 m(1, 2, 3, 16, 17, 18, 19, 26, 32, 39, 48, 63)
Quine-McCluskey Method 183
6.19 Packages arrive at the stockroom and are delivered on carts to offices and laboratories
by student employees.The carts and packages are various sizes and shapes.The studentsare paid according to the carts used. There are five carts and the pay for their use isCart C1: $2Cart C2: $1Cart C3: $4Cart C4: $2Cart C5: $2On a particular day, seven packages arrive, and they can be delivered using the fivecarts as follows:C1 can be used for packages P1, P3, and P4.C2 can be used for packages P2, P5, and P6.C3 can be used for packages P1, P2, P5, P6, and P7.C4 can be used for packages P3, P6, and P7.C5 can be used for packages P2 and P4.
The stockroom manager wants the packages delivered at minimum cost. Using
minimization techniques described in this unit, present a systematic procedure forfinding the minimum cost solution.
6.20 Use the Quine-McCluskey procedure to find all prime implicants of the function
h(A,B,C,D,E,F,G) = m(24, 28, 39, 47, 70, 86, 88, 92, 102, 105, 118).
Express the prime implicants algebraically .
6.21 Find all prime implicants of the following function, and then find all minimum solu-
tions using Petrick’s method:
6.22 Using the method of map-entered variables, use four-variable maps to find a mini-
mum sum-of-products expression for(a)(b)
6.23 (a) Rework Problem 6.6(a), using a five-variable map.
(b) Rework Problem 6.6(a), using the Quine-McCluskey method. Note that you must
express Fin terms of minterms of all five variables; the original four-variable
minterms cannot be used.
6.24 Using map-entered variables, find the minimum sum-of-products expressions for
the following function:
G/H11005C/H11032E/H11032F/H11001DEF /H11001AD/H11032E/H11032F/H11032/H11001BDE /H11032F/H11001AD/H11032EF/H11032/H11001E(m
11/H11001m12)/H11001F(m10)/H11001G(m0)Z(A,B,C,D,E,F,G)/H11005/H9018 m(2, 5, 6, 9) /H11001/H9018 d(1, 3, 4, 13, 14)F(A,B,C,D,E)/H11005/H9018 m(0, 4, 6, 13, 14) /H11001/H9018 d(2, 9) /H11001E(m1/H11001m12)F(A,B,C,D)/H11005/H9018 m(7, 12, 14, 15) /H11001/H9018 d(1, 3, 5, 8, 10, 11, 13)/H9018
184184CHAPTER
00Multi-Level Gate Circuits
NAND and NOR Gates
Objectives
1.Design a minimal two-level or multi-level circuit of AND and OR gates to
realize a given function. (Consider both circuits with an OR gate at the
output and circuits with an AND gate at the output.)
2.Design or analyze a two-level gate circuit using any one of the eight basic
forms (AND-OR, NAND-NAND, OR-NAND, NOR-OR, OR-AND, NOR-NOR,AND-NOR, and NAND-AND).
3.Design or analyze a multi-level NAND-gate or NOR-gate circuit.
4.Convert circuits of AND and OR gates to circuits of NAND gates or NOR
gates, and conversely, by adding or deleting inversion bubbles.
5.Design a minimal two-level, multiple-output AND-OR, OR-AND, NAND-
NAND, or NOR-NOR circuit using Karnaugh maps.
UNIT
7
Multi-Level Gate Circuits NAND and NOR Gates 185
1.Study Section 7.1, Multi-Level Gate Circuits .
(a) What are two ways of changing the number of levels in a gate circuit?
(b) By constructing a tree diagram, determine the number of gates, gate
inputs, and levels of gates required to realize Z1and Z2:
Check your answers by drawing the corresponding gate circuits.
(c) In order to find a minimum two-level solution, why is it necessary to consid-
er both a sum-of-products form and a product-of-sums form for the function?
(d) One realization of is Z/H11005ABC (D/H11001E )/H11001FGZ1/H11005[(A/H11001B)C/H11001DE(F/H11001G)]H    Z2/H11005A/H11001B[C/H11001DE(F/H11001G)]Study Guide
A
CB
D
E
F
GZ
Redraw the circuit so that it uses one less gate and so that the output of an
AND gate never goes directly to the input of another AND gate.
(e) Work Problems 7.1 and 7.2. Unless otherwise specified, you may always
assume that both the variables and their complements are available as cir-cuit inputs.
2.Study Section 7.2, NAND and NOR Gates
(a) For each gate, specify the missing inputs:
(b) What is meant by functionally complete set of logic gates?
(c) How can you show that a set of logic gates is functionally complete?
(d) Show that the NOR gate itself is functionally complete.
(e) Using NAND gates, draw a circuit for 
(f) Using NOR gates, draw a circuit for 
3.Study Section 7.3, Design of Two-Level NAND- and NOR-Gate Circuits .
(a) Draw the circuit corresponding to Equation (7-17).
(b) Derive Equation (7-18).
(c) Make sure that you understand the relation between Equations (7-13)
through (7-21) and the diagrams of Figure 7-11.
(d) Why is the NOR-NAND form degenerate?F/H11005((X/H11001Y)/H11032/H11001(X/H11032/H11001Z)/H11032)/H11032F/H11005(A/H11032(BC)/H11032)/H11032.0
01
11 0
01186 Unit 7
Multi-Level Gate Circuits NAND and NOR Gates 187
(e) What assumption is made about the types of inputs available when the
procedures for designing two-level NAND-NAND and NOR-NOR cir-cuits are used?
(f) For these procedures the literal inputs to the output gate are comple-
mented but not the literal inputs to the other gates. Explain why. Use anequation to illustrate.
(g) A general OR-AND circuit follows.Transform this to a NOR-NOR circuit
and prove that your transformation is valid.
/H51291/H51292
...... ...
...x1 P1
P2Fx2
y1y2
(h) Work Problem 7.3.
4.Study Section 7.4, Design of Multi-Level NAND- and NOR-Gate Circuits .
(a) Verify that the NAND circuit of Figure 7-13 is correct by dividing the cor-
responding circuit of AND and OR gates into two-level subcircuits andtransforming each subcircuit.
(b) If you wish to design a two-level circuit using only NOR gates, should you
start with a minimum sum of products or a minimum product of sums?
(c) Note that direct conversion of a circuit of AND and OR gates to a NAND
gate circuit requires starting with an OR gate at the output, but the directconversion to a NOR gate circuit requires starting with an AND gate atthe output. This is easy to remember because a NAND is equivalent to anOR with the inputs inverted:
=a
f f b
ca′
b′
c′
and a NOR is equivalent to an AND with the inputs inverted:
=a
f f b
ca′
b′
c′
188 Unit 7
(d) Convert the circuit of Figure 7-1(b) to all NAND gates.
(e) Work Problems 7.4, 7.5, 7.6, and 7.7.
5.Study Section 7.5, Circuit Conversion Using Alternative Gate Symbols .
(a) Determine the logic function realized by each of the following circuits:
GA
BA
BCFC
F = G =
(b) Convert the circuit of Figure 7-13(a) to NAND gates by adding bubbles and
complementing input variables when necessary. (You should have added 12bubbles. Your result should be similar to Figure 7-13(b), except some of theNAND gates will use the alternative symbol.)
(c) Draw a circuit of AND and OR gates for the following equation:
Then convert to NOR gates by adding bubbles and complementing inputs
when necessary. (You should have added 10 bubbles and complementedsix input variables.)
(d) Work Problem 7.8.
6.Study Section 7.6, Design of Two-Level ,Multiple-Output Circuits .
(a) In which of the following cases would you replace a term xy/H11032with xy/H11032z/H11001xy/H11032z/H11032?
(1) Neither xy/H11032zorxy/H11032z/H11032is used in another function.
(2) Both xy/H11032zand xy/H11032z/H11032are used in other functions.
(3) Term xy/H11032zis used in another function, but xy/H11032z/H11032is not.
(b) In the second example (Figure 7-21), in f
2,ccould have been replaced by
bc/H11001b/H11032cbecause bcand b/H11032cwere available “free” from f1and f3. Why was
this replacement not made?Z/H11005A[BC /H11001D/H11001E(F/H11001GH)]
Multi-Level Gate Circuits NAND and NOR Gates 189
F1 F2 F3100 01 11 10
1
111100cdab
01
1110100 01 11 10
1
11100cdab
01
1110 1100 01 11 10
11
11100cdab
01
1110
(e) Work Problems 7.9, 7.10, and 7.11.
(f) Work Problem 7.12. ( Hint : Work with the 0’s on the maps and first find a
minimum solution for f1/H11032,f2/H11032, and f3/H11032.)
7.Study Section 7.7, Multiple-Output NAND- and NOR-Gate Circuits .
(a) Derive expressions for the F1andF2outputs of the NOR circuits of Figure
7-24(b) by finding the equation for each gate output, and show that theseexpressions reduce to the original expressions for F
1and F2.f1 f211101
00bca
01
11
1011
11101
00bca
01
11
10
(d) Find expressions which correspond to a two-level, minimum multiple-
output, AND-OR realization of F1,F2, and F3. Why should the term cd not
be included in F1?
F1/H11005
F2./H11005
F3/H11005(c) In the following example, compute the cost of realizing f1andf2separately;
then compute the cost using the term a/H11032b/H11032cin common between the two
functions. Use a two-level AND-OR circuit in both cases.
190 Unit 7
(b) Convert Figure 7-24(a) to 7-24(b) by using the bubble method.
(c) Work Problem 7.13.
Multi-Level Gate Circuits 
NAND and NOR Gates
In the first part of this unit, you will learn how to design circuits which have more
than two levels of AND and OR gates. In the second part you will learn techniquesfor designing with NAND and NOR gates. These techniques generally consist offirst designing a circuit of AND and OR gates and then converting it to the desiredtype of gates. These techniques are easy to apply provided that you start with the
proper form of circuit.
7.1 Multi-Level Gate Circuits
The maximum number of gates cascaded in series between a circuit input and theoutput is referred to as the number of levels of gates (not to be confused with volt-
age levels). Thus, a function written in sum-of-products form or in product-of-sumsform corresponds directly to a two-level gate circuit. As is usually the case in digitalcircuits where the gates are driven from flip-flop outputs (as discussed in Unit 11),we will assume that all variables and their complements are available as circuitinputs. For this reason, we will not normally count inverters which are connected
Multi-Level Gate Circuits NAND and NOR Gates 191
directly to input variables when determining the number of levels in a circuit. In this
unit we will use the following terminology:
1.AND-OR circuit means a two-level circuit composed of a level of AND gates
followed by an OR gate at the output.
2.OR-AND circuit means a two-level circuit composed of a level of OR gates fol-
lowed by an AND gate at the output.
3.OR-AND-OR circuit means a three-level circuit composed of a level of OR
gates followed by a level of AND gates followed by an OR gate at the output.
4.Circuit of AND and OR gates implies no particular ordering of the gates; the
output gate may be either AND or OR.
The number of levels in an AND-OR circuit can usually be increased by factoring
the sum-of-products expression from which it was derived. Similarly, the number of lev-els in an OR-AND circuit can usually be increased by multiplying out some of the termsin the product-of-sums expression from which it was derived. Logic designers are con-cerned with the number of levels in a circuit for several reasons. Sometimes factoring(or multiplying out) to increase the number of levels of gates will reduce the requirednumber of gates and gate inputs and, thus, reduce the cost of building the circuit, but inother cases increasing the number of levels will increase the cost. In many applications,the number of gates which can be cascaded is limited by gate delays. When the input ofa gate is switched, there is a finite time before the output changes. When several gatesare cascaded, the time between an input change and the corresponding change in thecircuit output may become excessive and slow down the operation of the digital system.
The number of gates, gate inputs, and levels in a circuit can be determined by
inspection of the corresponding expression. In the example of Figure 7-1(a), the treediagram drawn below the expression for Zindicates that the corresponding circuit
will have four levels, six gates, and 13 gate inputs, as verified in Figure 7-1(b). Each
Level 1Level 2Level 3Level 4A Z = ( AB + C) (D + E + FG) + H B
CD E
H
ZFG
22
3 2
2
2
(a) (b)FIGURE 7-1
Four-Level
Realization of Z
192 Unit 7
FIGURE 7-2
Three-Level
Realization of Z
ZHABDE
CA B FG CFGZ = AB(D + E) + C(D + E) + ABFG + CFG + H
2
3 2
(a) (b)43Level 2Level 3
Level 1 5*
* The same gate can be used for
   both appearances of ( D + E).
FIGURE 7-3
f = a′c′d + bc′d + bcd′ + acd′000000 01 11 10
1110
0000
000cdab
01
11
10 111Example of 
Multi-Level
Design Using 
AND and OR 
Gates
(7-1)node on the tree diagram represents a gate, and the number of gate inputs is writ-
ten beside each node.
We can change the expression for Zto three levels by partially multiplying it out:
As shown in Figure 7-2, the resulting circuit requires three levels, six gates, and 19 gate
inputs.
Problem: Find a circuit of AND and OR gates to realize
Consider solutions with two levels of gates and three levels of gates.Try to minimize
the number of gates and the total number of gate inputs. Assume that all variablesand their complements are available as inputs.
Solution: First, simplify fby using a Karnaugh map (Figure 7-3):f(a,b,c,d)/H11005/H9018  m(1, 5, 6, 10, 13, 14)/H11005AB(D/H11001E )/H11001C(D/H11001E )/H11001ABFG /H11001CFG /H11001HZ/H11005(AB/H11001C )[(D/H11001E )/H11001FG ]/H11001H
Multi-Level Gate Circuits NAND and NOR Gates 193
FIGURE 7-4
Factoring Equation (7-1) yields
(7-2)
which leads to the following three-level OR-AND-OR gate circuit (Figure 7-5):f/H11005c/H11032d(a/H11032/H11001b)/H11001cd/H11032(a/H11001b)a′
c′
d
b
c′
d
bf
c
d′
a
c
d′Two levels
Five gates16 gate inputsThis leads directly to a two-level AND-OR gate circuit (Figure 7-4):
FIGURE 7-5
Three levelsFive gates12 gate Inputsa′
b
ac′
d f
c
d′
b
Both of these solutions have an OR gate at the output.A solution with an AND gate
at the output might have fewer gates or gate inputs. A two-level OR-AND circuitcorresponds to a product-of-sums expression for the function. This can be obtainedfrom the 0’s on the Karnaugh map as follows:
(7-3)
(7-4)
Equation (7-4) leads directly to a two-level OR-AND circuit (Figure 7-6):f/H11005(c/H11001d)(a/H11032/H11001b/H11001c)(c/H11032/H11001d/H11032)(a/H11001b/H11001c/H11032)f/H11032/H11005c/H11032d/H11032/H11001 ab/H11032c/H11032/H11001cd/H11001a/H11032b/H11032c
FIGURE 7-6 c
d
a′
b
c
c′f
d′
a
b
c′Two levels
Five gates14 gate inputs
For this particular example, the best two-level solution had an AND gate at the
output (Figure 7-6), and the best three-level solution had an OR gate at the out-put (Figure 7-5). In general, to be sure of obtaining a minimum solution, onemust find both the circuit with the AND-gate output and the one with the OR-
gate output.
If an expression for f/H11032hasnlevels, the complement of that expression is an
n-level expression for f. Therefore, to realize fas an n-level circuit with an
AND-gate output, one procedure is first to find an n-level expression for f/H11032
with an OR operation at the output level and then complement the expressionforf/H11032. In the preceding example, factoring Equation (7-3) gives a three-level
expression for f/H11032:
(7-7)
Complementing Equation (7-7) gives Equation (7-6), which corresponds to the
three-level AND-OR-AND circuit of Figure 7-7./H11005c/H11032(d/H11032/H11001a)(d/H11032/H11001b/H11032)/H11001c(d/H11001a/H11032)(d/H11001b/H11032)f/H11032/H11005 c/H11032(d/H11032/H11001ab/H11032)/H11001c(d/H11001a/H11032b/H11032)194 Unit 7
FIGURE 7-7To get a three-level circuit with an AND gate output, we partially multiply out
Equation (7-4) using 
(7-5)
Equation (7-5) would require four levels of gates to realize; however, if we mul-
tiply out d/H11032(a/H11001b) and d(a/H11032 /H11001b), we get
(7-6)
which leads directly to a three-level AND-OR-AND circuit (Figure 7-7):f/H11005 (c/H11001a/H11032d/H11001bd )(c/H11032/H11001ad/H11032/H11001bd/H11032)f/H11005[c/H11001d(a/H11032/H11001b)][c/H11032/H11001d/H11032(a/H11001b)](X/H11001Y )(X/H11001Z )/H11005X/H11001YZ:
a
d′
b
d′c′
fThree levels
Seven gates16 gate inputsa′
d
b
dc
Multi-Level Gate Circuits NAND and NOR Gates 195
X1
X2
XnA
B F
C
(a) Three-input NAND gateA
B FF
C
(b) NAND gate equivalent (c) n-input NAND gate...FIGURE 7-8
NAND Gates7.2 NAND and NOR Gates
Until this point we have designed logic circuits using AND gates, OR gates, and
inverters. Exclusive-OR and equivalence gates have also been introduced in Unit 3.In this section we will define NAND and NOR gates. Logic designers frequently useNAND and NOR gates because they are generally faster and use fewer componentsthan AND or OR gates. As will be shown later, any logic function can be imple-mented using only NAND gates or only NOR gates.
Figure 7-8(a) shows a three-input NAND gate. The small circle (or “bubble”)
at the gate output indicates inversion, so the NAND gate is equivalent to anAND gate followed by an inverter, as shown in Figure 7-8(b). A more appropri-ate name would be an AND-NOT gate, but we will follow common usage and callit a NAND gate.The gate output is
The output of the n-input NAND gate in Figure 7-8(c) is
(7-8)
The output of this gate is 1 iff one or more of its inputs are 0.F/H11005(X
1X2. . . Xn)/H11032/H11005X1/H11032/H11001X2/H11032/H11001. . ./H11001Xn/H11032F/H11005(ABC  )/H11032/H11005A/H11032/H11001B/H11032/H11001C/H11032
Figure 7-9(a) shows a three-input NOR gate. The small circle at the gate output
indicates inversion, so the NOR gate is equivalent to an OR gate followed by aninverter. A more appropriate name would be an OR-NOT gate, but we will followcommon usage and call it a NOR gate. The gate output is
F/H11005 (A/H11001B/H11001C)/H11032/H11005A/H11032B/H11032C/H11032
FIGURE 7-9
NOR GatesX1
X2
XnA
B F
C
(a) Three-input NOR gateA
B FF
C
(b) NOR gate equivalent (c) n-input NOR gate...
The output of an n-input NOR gate, shown in Figure 7-9(c), is
(7-9)
A set of logic operations is said to be functionally complete if any Boolean
function can be expressed in terms of this set of operations. The set AND, OR, andNOT is obviously functionally complete because any function can be expressed insum-of-products form, and a sum-of-products expression uses only the AND, OR,and NOT operations. Similarly, a set of logic gates is functionally complete if allswitching functions can be realized using this set of gates. Because the set of oper-ations AND, OR, and NOT is functionally complete, any set of logic gates whichcan realize AND, OR, and NOT is also functionally complete. AND and NOT area functionally complete set of gates because OR can also be realized using ANDand NOT:
If a single gate forms a functionally complete set by itself, then any switching
function can be realized using only gates of that type. The NAND gate is an exam-ple of such a gate. Because the NAND gate performs the AND operation followedby an inversion, NOT, AND, and OR can be realized using only NAND gates, asshown in Figure 7-10. Thus, any switching function can be realized using onlyNAND gates. An easy method for converting an AND-OR circuit to a NAND cir-cuit is discussed in the next section. Similarly, any function can be realized usingonly NOR gates.
X
YX′X′Y′(X′Y′)′ = X + Y
Y′F/H11005(X1/H11001X2/H11001. . ./H11001Xn)/H11032/H11005X1/H11032X2/H11032. . . Xn/H11032196 Unit 7
FIGURE 7-10
NAND Gate
Realization of
NOT, AND, and ORX
A A′
B′ BX′A
B(AB)′
(A′B′)′ = A + BAB
The following procedure can be used to determine if a given set of gates is
functionally complete. First, write out a minimum sum-of-products expression forthe function realized by each gate. If no complement appears in any of theseexpressions, then NOT cannot be realized, and the set is not functionally com-plete. If a complement appears in one of the expressions, then NOT can general-ly be realized by an appropriate choice of inputs to the corresponding gate. (Wewill always assume that 0 and 1 are available as gate inputs). Next, attempt torealize AND or OR, keeping in mind that NOT is now available. Once AND or
OR has been realized, the other one can always be realized using DeMorgan’s
laws if no more direct procedure is apparent. For example, if OR and NOT areavailable, AND can be realized by
7.3 Design of Two-Level NAND-
and NOR-Gate Circuits
A two-level circuit composed of AND and OR gates is easily converted to a circuit
composed of NAND gates or NOR gates. This conversion is carried out by using
and then applying DeMorgan’s laws:
(7-11)
(7-12)
The following example illustrates conversion of a minimum sum-of-products form
to several other two-level forms:
(7-13)
•• (by 7-11) (7-14)
•• (by 7-12) (7-15)
(by 7-12) (7-16)
Equations (7-13), (7-14), (7-15), and (7-16) represent the AND-OR, NAND-NAND,
OR-NAND, and NOR-OR forms, respectively, as shown in Figure 7-11.
Rewriting Equation (7-16) in the form
(7-17)
leads to a three-level NOR-NOR-INVERT circuit. However, if we want a two-level
circuit containing only NOR gates, we should start with the minimum product-of-sums form for Finstead of the minimum sum of products. After obtaining the
minimum product of sums from a Karnaugh map, Fcan be written in the following
two-level forms:
(7-18)
(by 7-12) (7-19)
(by 7-11) (7-20)
•• (by 7-11) (7-21)  (A/H11032CD/H11032)/H11032 (A/H11032BC)/H11032 /H11005(A/H11032B/H11032C/H11032)/H11032/H11005(A/H11032B/H11032C/H11032/H11001A/H11032BC/H11001A/H11032CD/H11032)/H11032/H11005[(A/H11001B/H11001C)/H11032/H11001(A/H11001B/H11032/H11001C/H11032)/H11032/H11001(A/H11001C/H11032/H11001D)/H11032]/H11032/H11005{[(A/H11001B/H11001C)(A/H11001B/H11032/H11001C/H11032)(A/H11001C/H11032/H11001D) ]/H11032}/H11032F/H11005(A/H11001B/H11001C)(A/H11001B/H11032/H11001C/H11032)(A/H11001C/H11032/H11001D)F/H11005{[A/H11001(B/H11032/H11001C)/H11032/H11001(B/H11001C/H11032/H11001D/H11032)/H11032 ]/H11032}/H11032/H11005A/H11001(B/H11032/H11001C )/H11032/H11001(B/H11001C/H11032/H11001D/H11032)/H11032(B/H11001C/H11032/H11001D/H11032)]/H11032 (B/H11032/H11001C ) /H11005[A/H11032(B/H11032CD)/H11032]/H11032 (BC/H11032)/H11032 /H11005[A/H11032F/H11005A/H11001BC/H11032/H11001B/H11032CD/H11005[(A/H11001BC/H11032/H11001B/H11032CD)/H11032]/H11032  (X1X2 . . . Xn)/H11032/H11005 X1/H11032/H11001 X2/H11032/H11001 . . ./H11001Xn/H11032 (X1/H11001X2/H11001. . ./H11001Xn)/H11032/H11005X1/H11032X2/H11032. . . Xn/H11032F/H11005(F/H11032)/H11032XY/H11005(X/H11032/H11001Y/H11032)/H11032Multi-Level Gate Circuits NAND and NOR Gates 197
198 Unit 7
F
A
C′
DA
B′
C′A
B
C
OR-
ANDF = ( A + B + C)(A + B′ + C′)(A + C′ + D) (7-18)
F = ( A′B′C′ + A′BC + A′CD′)′ (7-20)NAND-
ANDNOR-
NOR
AND-
NORB
C′
A FB′
C
D
B′
C
A FB
C′
D′
B′
C
A′ FB
C′
D′AND-
ORF = A + BC′ + B′CD
F = [ A′• (B′ + C)• (B + C′ + D′)]′ (7-15)F = A + ( B′ + C)′ + ( B + C′ + D′)′
(7-16)F = [ A′• (BC′)′• (B'CD)′]′
(7-14)
F = ( A′B′C′)′• (A′BC)′• (A′CD′)′
(7-21)F = [( A + B + C)′ + (A + B′ + C′)′
+ (A + C′ + D)′]′(7-19)NOR-
ORNAND-
NAND
OR-
NAND(7-13)
B
C′
A′ FB′
C
D
F
A
C′
DA
B′
C′A
B
C
F
A′
C
D′A′
B
CA′
B′
C′F
A′
C
D′A′
B
CA′
B′
C′FIGURE 7-11
Eight Basic Forms
for Two-Level
Circuits
Equations (7-18),(7-19),(7-20), and (7-21) represent the OR-AND, NOR-NOR,
AND-NOR, and NAND-AND forms, respectively, as shown in Figure 7-11. Two-level AND-NOR (AND-OR-INVERT) circuits are available in integrated-circuitform. Some types of NAND gates can also realize AND-NOR circuits when the so-called wired OR connection is used.
The other eight possible two-level forms (AND-AND, OR-OR, OR-NOR,AND-
NAND, NAND-NOR, NOR-NAND, etc.) are degenerate in the sense that theycannot realize all switching functions. Consider, for example, the following NAND-NOR circuit:
From this example, it is clear that the NAND-NOR form can realize only a product
of literals and not a sum of products.
Because NAND and NOR gates are readily available in integrated circuit form,
two of the most commonly used circuit forms are the NAND-NAND and the NOR-NOR.Assuming that all variables and their complements are available as inputs, thefollowing method can be used to realize Fwith NAND gates:
Procedure for designing a minimum two-level NAND-NAND circuit:
1.Find a minimum sum-of-products expression for F.
2.Draw the corresponding two-level AND-OR circuit.
3.Replace all gates with NAND gates leaving the gate interconnections unchanged.
If the output gate has any single literals as inputs, complement these literals.
Figure 7-12 illustrates the transformation of step 3. Verification that this transfor-
mation leaves the circuit output unchanged follows. In general, Fis a sum of literals
(/H5129
1,/H51292, . . .) and product terms ( P1,P2,... ) :
F/H11005 /H51291/H11001 /H51292/H11001 ···/H11001 P1/H11001 P2/H11001 ···
After applying DeMorgan’s law,
F/H11005 (/H51291/H11032/H51292/H11032 ···P1/H11032P2/H11032··· )/H11032a
b
c
de F
F = [( ab)′ + (cd)′ + e]′ = abcde′Multi-Level Gate Circuits NAND and NOR Gates 199.........x1
/H51291′′
/H51292′ /H51292/H51291
(a) Before transformationP1
P2Fx2
...y1y2
.........x1
(b) After transformationP1
′P2Fx2
...y1y2FIGURE 7-12
AND-OR to
NAND-NAND
Transformation
So the output OR gate is replaced with a NAND gate with inputs /H5129/H110321,/H5129/H110322,..., P/H110321,P/H110322,...
Because product terms P1,P2,... are each realized with an AND gate, P/H110321,P/H110322,...a r e
each realized with a NAND gate in the transformed circuit.
Assuming that all variables and their complements are available as inputs, the
following method can be used to realize Fwith NOR gates:
Procedure for designing a minimum two-level NOR-NOR circuit:
1.Find a minimum product-of-sums expression for F.
2.Draw the corresponding two-level OR-AND circuit.
3.Replace all gates with NOR gates leaving the gate interconnections unchanged.
If the output gate has any single literals as inputs, complement these literals.
This procedure is similar to that used for designing NAND-NAND circuits. Note,
however, that for the NOR-NOR circuit, the starting point is a minimum product of
sums rather than a sum of products.
7.4 Design of Multi-Level NAND- 
and NOR-Gate Circuits
The following procedure may be used to design multi-level NAND-gate circuits:
1.Simplify the switching function to be realized.
2.Design a multi-level circuit of AND and OR gates.The output gate must be OR.
AND gate outputs cannot be used as AND-gate inputs; OR-gate outputs can-not be used as OR-gate inputs.
3.Number the levels starting with the output gate as level 1. Replace all gates
with NAND gates, leaving all interconnections between gates unchanged.Leave the inputs to levels 2, 4, 6 ,... unchanged. Invert any literals which
appear as inputs to levels 1, 3, 5 ,....
The validity of this procedure is easily proven by dividing the multi-level circuit
into two-level subcircuits and applying the previous results for two-level circuitsto each of the two-level subcircuits. The example of Figure 7-13 illustrates the pro-cedure. Note that if step 2 is performed correctly, each level of the circuit will con-tain only AND gates or only OR gates.
The procedure for the design of multi-level NOR-gate circuits is exactly
the same as for NAND-gate circuits except the output gate of the circuit of
AND and OR gates must be an AND gate, and all gates are replaced withNOR gates.
ExampleFigure 7-13 shows how the AND-OR circuit for F1is converted to the correspon-
ding NAND circuit.F1/H11005a/H11032[b/H11032/H11001c(d/H11001e/H11032)/H11001f/H11032g/H11032]/H11001hi/H11032j/H11001k200 Unit 7
7.5 Circuit Conversion Using Alternative 
Gate Symbols
Logic designers who design complex digital systems often find it convenient to use
more than one representation for a given type of gate. For example, an inverter canbe represented by
In the second case, the inversion “bubble” is at the input instead of the output.
Figure 7-14 shows some alternative representations for AND, OR, NAND, andNOR gates. These equivalent gate symbols are based on DeMorgan’s Laws.A or A′ AA ′Multi-Level Gate Circuits NAND and NOR Gates 201
Level 5 Level 4 Level 3
(a) AND-OR networkLevel 2 Level 1
d
e′c
f′
g′b′a′
hk F1
i′
j
Level 5 Level 4 Level 3
(b) NAND networkLevel 2 Level 1
d′
ec
f′
g′ba′
hk′ F1
i′
jFIGURE 7-13
Multi-Level Circuit
Conversion to
NAND Gates
A
BA
AB = ( A′ + B′)′
(a) ANDA + B = ( A′B′)′
(b) ORBAB A  + B A
BA
(AB)′ = A′ + B′
(c) NAND(A + B)′ = A′B′
(d) NORB(AB)′ (A + B)′ FIGURE 7-14
Alternative Gate
Symbols
These alternative symbols can be used to facilitate the analysis and design of NAND
and NOR gate circuits. Figure 7-15(a) shows a simple NAND-gate circuit. To analyzethe circuit, we will replace the NAND gates at the first and third levels with the alterna-tive NAND gate symbol. This eliminates the inversion bubble at the circuit output.
In the resulting circuit [Figure 7-15(b)], inverted outputs (those with a bubble) are
always connected to inverted inputs, and noninverted outputs are connected to nonin-verted inputs. Because two inversions in a row cancel each other out, we can easily ana-lyze the circuit without algebraically applying DeMorgan’s laws. Note, for example, thatthe output of gate 2 is , but the term appears in the outputfunction.We can also convert the circuit to an AND-OR circuit by simply removing thedouble inversions [see Figure 7-15(c)]. When a single input variable is connected to aninverted input, we must also complement that variable when we remove the inversionfrom the gate input. For example, Ain Figure 7-15(b) becomes A/H11032in Figure 7-15(c).
The circuit of AND and OR gates shown in Figure 7-16(a) can easily be convert-
ed to a NOR-gate circuit because the output gate is an AND gate, and AND and ORgates alternate throughout the circuit.That is,AND gate outputs connect only to ORgate inputs, and OR gate outputs connect only to AND gate inputs. To carry out con-version to NOR gates, we first replace all of the OR and AND gates with NOR gates,as shown in Figure 7-16(b). Because each inverted gate output drives an invertedgate input, the pairs of inversions cancel. However, when an input variable drives aninverted input, we have added a single inversion, so we must complement the vari-able to compensate.Therefore, we have complemented CandG.The resulting NOR-
gate circuit is equivalent to the original AND-OR circuit.
Even if AND and OR gates do not alternate, we can still convert an AND-OR
circuit to a NAND or NOR circuit, but it may be necessary to add extra inverters sothat each added inversion is cancelled by another inversion. The following proce-dure may be used to convert to a NAND (or NOR) circuit:
1.Convert all AND gates to NAND gates by adding an inversion bubble at the out-
put. Convert all OR gates to NAND gates by adding inversion bubbles at the(A/H11032/H11001B)C [(A/H11032/H11001B)C ]/H11032202 Unit 7
A
B′C
DFZ
E12
3
(a) NAND gate network4
A A′ + B[(A′ + B)C]′
(DE)′B′C
DFZ  = ( A′ + B)C + F′ + DE
E2
3
(b) Alternate form for NAND gate network
A′
BC
DF′ Z
E2
3
(c) Equivalent AND-OR network1
1
44FIGURE 7-15
NAND Gate Circuit
Conversion
inputs. (To convert to NOR, add inversion bubbles at all OR gate outputs and all
AND gate inputs.)
2.Whenever an inverted output drives an inverted input, no further action is needed
because the two inversions cancel.
3.Whenever a noninverted gate output drives an inverted gate input or vice versa,
insert an inverter so that the bubbles will cancel. (Choose an inverter with thebubble at the input or output as required.)Multi-Level Gate Circuits NAND and NOR Gates 203
Double inversion cancels
Complemented input
cancels inversionA
B′CD
EG
Z
F
(a) Circuit with OR and AND gates
A
B′C′D
EG′ Z
F
(b) Equivalent circuit with NOR gatesFIGURE 7-16
Conversion to NOR
Gates
A
B′CD′E′FAdded inverter
(c) Completed conversionAdded inverterA
B′CDEFBubbles cancel
(b) First step in NAND conversionA
B′CDEF
(a) AND-OR networkFIGURE 7-17
Conversion of
AND-OR Circuit
to NAND Gates
4.Whenever a variable drives an inverted input, complement the variable (or add
an inverter) so the complementation cancels the inversion at the input.
In other words, if we always add bubbles (or inversions) in pairs, the function
realized by the circuit will be unchanged. To illustrate the procedure we will con-vert Figure 7-17(a) to NANDs. First, we add bubbles to change all gates toNAND gates (Figure 7-17(b)). In four places (highlighted in blue), we haveadded only a single inversion. This is corrected in Figure 7-17(c) by adding twoinverters and complementing two variables.
7.6 Design of Two-Level, Multiple-Output 
Circuits
Solution of digital design problems often requires the realization of several func-
tions of the same variables.Although each function could be realized separately, theuse of some gates in common between two or more functions sometimes leads to amore economical realization. The following example illustrates this:
Design a circuit with four inputs and three outputs which realizes the functions
(7-22)
First, each function will be realized individually. The Karnaugh maps, functions,
and resulting circuit are given in Figures 7-18 and 7-19. The cost of this circuit is 9gates and 21 gate inputs.
An obvious way to simplify this circuit is to use the same gate for ABin both F
l
and F3. This reduces the cost to eight gates and 19 gate inputs. (Another, but less
obvious, way to simplify the circuit is possible.) Observing that the term ACD isF3(A,B,C,D)/H11005/H9018  m(3, 7, 12, 13, 14, 15) F2(A,B,C,D)/H11005/H9018  m(3, 7, 11, 12, 13, 15)F1(A,B,C,D)/H11005/H9018  m(11, 12, 13, 14, 15)204 Unit 7
F1 F2 F3100 01 11 10
1
1100CDAB
01
1110 1100 01 11 10
1
111100CDAB
01
1110100 01 11 10
1
11100CDAB
01
1110 1FIGURE 7-18
Karnaugh
Maps for 
Equations (7-22)
necessary for the realization of Fland A/H11032CDis necessary for F3, if we replace CD
inF2byA/H11032CD/H11001ACD , the realization of CDis unnecessary and one gate is saved.
Figure 7-20 shows the reduced circuit, which requires seven gates and 18 gateinputs. Note that F
2is realized by the expression ABC /H11032/H11001A/H11032CD/H11001ACD which is
not a minimum sum of products, and two of the terms are not prime implicants ofF
2. Thus in realizing multiple-output circuits, the use of a minimum sum of prime
implicants for each function does not necessarily lead to a minimum cost solutionfor the circuit as a whole.Multi-Level Gate Circuits NAND and NOR Gates 205
A
A
BC
D F1 = AB + ACD
A
C
DB
C′ F2 = ABC ′ + CD
A′
A
BC
D F3 = A′CD + ABFIGURE 7-19
Realization of
Equations (7-22)
A
B F1
A
C
D F2
A
B
C′
A′
C
D F3FIGURE 7-20
Multiple-Output
Realization of
Equations (7-22)
When designing multiple-output circuits, you should try to minimize the total
number of gates required. If several solutions require the same number of gates,the one with the minimum number of gate inputs should be chosen. The nextexample further illustrates the use of common terms to save gates. A four-input,three-output circuit is to be designed to realize
(7-23) f
3/H11005/H9018  m(6, 7, 8, 9, 13, 14, 15) f2/H11005/H9018  m(2, 3, 5, 6, 7, 10, 11, 14, 15)f1/H11005/H9018  m(2, 3, 5, 7, 8, 9, 10, 11, 13, 15)
First, we plot maps for fl,f2, and f3(Figure 7-21). If each function is minimized sep-
arately, the result is
(7-23(a))
By inspecting the maps, we can see that terms a/H11032bd(from f2),abd(from f3), and ab/H11032c/H11032
(from f3) can be used in f1. If bdis replaced with a/H11032bd/H11001abd, then the gate needed
to realize bdcan be eliminated. Because m10andmllinf1are already covered by b/H11032c,
ab/H11032c/H11032(from f3) can be used to cover m8and m9, and the gate needed to realize ab’
can be eliminated. The minimal solution is therefore
(7-23(b))
(Terms which are used in common between two functions are underlined.)
When designing multiple-output circuits, it is sometimes best not to combine a 1
with its adjacent 1’s, as illustrated in the example of Figure 7-22.
The solution with the maximum number of common terms is not necessarily
best, as illustrated in the example of Figure 7-23.
Determination of Essential Prime Implicants 
for Multiple-Output Realization
As a first step in determining a minimum two-level, multiple-output realization, it is
often desirable to determine essential prime implicants. However, we must be care-ful because some of the prime implicants essential to an individual function may notbe essential to the multiple-output realization. For example, in Figure 7-21, bdis an f
3/H11005bc/H11001ab/H11032c/H11032/H11001abd                  22 gate inputsf2/H11005c/H11001a/H11032bd        eight gatesf1/H11005a/H11032bd/H11001abd /H11001ab/H11032c/H11032/H11001b/H11032cf3/H11005bc/H11001ab/H11032c/H11032/H11001abd
or
ac/H11032d10 gates,
25 gate inputsf2/H11005c/H11001a/H11032bdf1/H11005bd/H11001b/H11032c/H11001ab/H11032206 Unit 7¯˘˙
¯˘˙abdab′c′
a′bd100 01 11 10
111
1111100cdab
01
1110 100 01 11 10
1
1111100cdab
01
1110 111100 01 11 10
11
1100cdab
01
1110 11FIGURE 7-21
essential prime implicant of f1(only prime implicant which covers m5), but it is not
essential to the multiple-output realization.The reason that bdisnotessential is that
m5also appears on the f2map and, hence, might be covered by a term which is
shared by f1and f2.
We can find prime implicants which are essential to one of the functions and to
the multiple-output realization by a modification of the procedure used for thesingle-output case. In particular, when we check each 1 on the map to see if it is cov-ered by only one prime implicant, we will only check those 1’s which do not appearon the other function maps. Thus, in Figure 7-22 we find that c/H11032d isessential to f
1for
the multiple-output realization (because of m1), but abdis not essential because m15
also appears on the f2map. In Figure 7-23, the only minterms of f1which do not
appear on the f2map are m2and m5. The only prime implicant which covers m2is
a/H11032d/H11032; hence, a/H11032d/H11032isessential to f1in the multiple-output realization. Similarly, the only
prime implicant which covers m5isa/H11032bc/H11032, and a/H11032bc/H11032is essential. On the f2map, bd/H11032is
essential. Why?
Once the essential prime implicants for f1andf2have been looped, selection of the
remaining terms to form the minimum solution is obvious in this example. The tech-niques for finding essential prime implicants outlined above cannot be applied in aproblem such as Figure 7-21 where every minterm of f
1also appears on the f2orf3
map. More sophisticated techniques are available for finding essential multiple-
output terms for such problems, but these techniques are beyond the scope of this text.Multi-Level Gate Circuits NAND and NOR Gates 207
00 01 11 10
1 1 1 1
100cdab
f101
11
101 100 01 11 10
100cdab
f201
11
10 1 100 01 11 10
1 1 1 1
100cdab
f1
(a) Best solution (b) Solution requires an extra gate01
11
101 100 01 11 10
100cdab
f201
11
10 1 1FIGURE 7-22
00 01 11 10
111
11100cdab
f1
(a) Solution with maximum number of
common terms requires 8 gates, 26 inputs01
11
101 1
1100 01 11 10
00cdab
f201
11
10 1 100 01 11 10
111
11100cdab
f1
(b) Best solution requires 7 gates, 18 inputs
and has no common terms01
11
101 100 01 11 10
00cdab
f201
11
10 1 11
1FIGURE 7-23
7.7 Multiple-Output NAND- and NOR-Gate
Circuits
The procedure given in Section 7.4 for design of single-output, multi-level NAND-
and NOR-gate circuits also applies to multiple-output circuits. If all of the outputgates are OR gates, direct conversion to a NAND-gate circuit is possible. If all of theoutput gates are AND, direct conversion to a NOR-gate circuit is possible. Figure 7-24gives an example of converting a 2-output circuit to NOR gates. Note that the inputsto the first and third levels of NOR gates are inverted.
F
1/H11005[(a/H11001b/H11032)c/H11001d ](e/H11032/H11001f )    F2/H11005[(a/H11001b/H11032)c/H11001g/H11032](e/H11032/H11001f )h208 Unit 7
Level 4 Level 3
(a) Network of AND and OR gatesLevel 2 Level 1
a
b′cd
e′
f
g′hF1
F2
(b) NOR networka
b′c′d
e′
f
g′h′F1
F2FIGURE 7-24
Multi-level Circuit
Conversion to NOR
Gates
Problems
7.1 Using AND and OR gates, find a minimum circuit to realize
(a) using two-level logic
(b) using three-level logic (12 gate inputs minimum)f(a,b,c,d)/H11005m4/H11001m6/H11001m7/H11001m8/H11001m9/H11001m10
7.2 Realize the following functions using AND and OR gates. Assume that there are no
restrictions on the number of gates which can be cascaded and minimize the num-ber of gate inputs.(a)(b)
7.3 Find eight different simplified two-level gate circuits to realize
7.4 Find a minimum three-level NAND gate circuit to realize
7.5 Realize using four NOR gates.
7.6 Realize using only two-input NAND gates. Use as few
gates as possible.
7.7 Realize using only two-input NOR gates. Use as few gates
as possible.
7.8 (a) Convert the following circuit to all NAND gates, by adding bubbles and invert-
ers where necessary.
(b) Convert to all NOR gates (an inverter at the output is allowed).Z/H11005AE/H11001BDE /H11001BCEFZ/H11005ABC /H11001AD /H11001C/H11032D/H11032Z/H11005A/H11032D/H11001A/H11032C/H11001AB/H11032C/H11032D/H11032F(A,B,C,D)/H11005/H9018 m(5, 10, 11, 12, 13)    (four gates)F(a,b,c,d)/H11005a/H11032bd/H11001ac/H11032dAE/H11001BDE /H11001BCE /H11001BCFG /H11001BDFG /H11001AFGAC/H11032D/H11001ADE /H11032/H11001BE
/H11032/H11001BC/H11032/H11001A/H11032D/H11032E/H11032Multi-Level Gate Circuits NAND and NOR Gates 209
A′
B
C
D′E
F
G′Z
7.9 Find a two-level, multiple-output AND-OR gate circuit to realize the following
functions. Minimize the required number of gates (six gates minimum).
7.10 Find a minimum two-level, multiple-output AND-OR gate circuit to realize these
functions.
7.11 Find a minimum two-level OR-AND circuit to simultaneously realize
(minimum solution has eight gates)F2(a,b,c,d)/H11005/H9018 m(0, 1, 5, 8, 9, 14, 15)F1(a,b,c,d)/H11005/H9018 m(2, 3, 8, 9, 14, 15)f3(a,b,c,d)/H11005/H9018 m(3, 6, 7, 10, 11)   (11 gates minimum)f2(a,b,c,d)/H11005/H9018 m(2, 4, 8, 10, 11, 12)f1(a,b,c,d)/H11005/H9018 m(3, 4, 6, 9, 11)f1/H11005ac/H11001ad/H11001b/H11032d  and  f2/H11005a/H11032b/H11032/H11001a/H11032d/H11032/H11001cd/H11032
7.12 Find a minimum two-level OR-AND circuit to realize the functions given in
Equations (7-23) on page 205 (nine gates minimum)
7.13 (a) Find a minimum two-level NAND-NAND circuit to realize the functions given
in Equations (7-23) on page 205.
(b) Find a minimum two-level NOR-NOR circuit to realize the functions given in
Equations (7-23).
7.14 Using AND and OR gates, find a minimum circuit to realize
(a) using two-level logic
(b) using three-level logic (12 gate inputs minimum)
7.15 Using AND and OR gates, find a minimum two-level circuit to realize
(a)(b)(c)(d)
7.16 Realize the following functions using AND and OR gates. Assume that there are no
restrictions on the number of gates which can be cascaded and minimize the num-ber of gate inputs.
(a)
(b)
7.17 A combinational switching circuit has four inputs ( A,B,C,D) and one output ( F).
F/H110050 iff three or four of the inputs are 0.
(a) Write the maxterm expansion for F.
(b) Using AND and OR gates, find a minimum three-level circuit to realize F(five
gates, 12 inputs).
7.18 Find eight different simplified two-level gate circuits to realize
(a)(b)
7.19 Implement as a two-level gate circuit, using a minimum
number of gates.(a) Use AND gates and NAND gates.(b) Use NAND gates only.
7.20 Implement f(a,b,c,d)/H11005/H9018 m(3, 4, 5, 6, 7, 11, 15) as a two-level gate circuit, using a
minimum number of gates.(a) Use OR gates and NOR gates.(b) Use NOR gates only.f(x,y,z)/H11005/H9018 m(0, 1, 3, 4, 7)F(a,b,c,d)/H11005/H9018  m(4, 5, 8, 9, 13)F(w,x,y,z)/H11005(x
/H11001y/H11032/H11001z)(x/H11032/H11001y/H11001z)wABCE /H11001ABEF /H11001ACD /H11032/H11001ABEG /H11001ACDEABC /H11032/H11001ACD /H11001A/H11032BC/H11001A/H11032C/H11032DF/H11005a/H11032b/H11001ac/H11001bc/H11001bd/H11032F/H11005a/H11032cd/H11032/H11001a/H11032bc/H11001adF/H11005(b/H11032/H11001c)(a/H11001b/H11032/H11001d)(a/H11001b/H11001c/H11032/H11001d)F/H11005a/H11032c/H11001bc/H11032d/H11001ac/H11032df(a,b,c,d)/H11005M0M1M3M13M14M15210 Unit 7
7.21 Realize each of the following functions as a minimum two-level NAND-gate circuit
and as a minimum two-level NOR-gate circuit.(a)F(A,B,C,D)/H11005BD/H11032/H11001B/H11032CD/H11001A/H11032BC/H11001A/H11032BC/H11032D/H11001B/H11032D/H11032
(b)f(a,b,c,d)/H11005/H9016 M(0, 1, 7, 9, 10, 13) 
•/H9016D(2, 6, 14, 15)
(c)f(a,b,c,d)/H11005/H9018 m(0, 2, 5, 10) /H11001/H9018 d(3, 6, 9, 13, 14, 15)
(d)F(A,B,C,D,E)/H11005/H9018 m(0, 2, 4, 5, 11, 14, 16, 17, 18, 22, 23, 25, 26, 31)
/H11001/H9018d(3, 19, 20, 27, 28)
(e)F(A,B,C,D, E )/H11005/H9016 M(3, 4, 8, 9, 10, 11, 12, 13, 14, 16, 19, 22, 25, 27) 
•/H9016D(16, 18, 28, 29)
(f)f(a,b,c,d)/H11005/H9016 M(1, 3, 10, 11, 13, 14, 15) •/H9016D(4, 6)
(g) f(w,x,y,z)/H11005/H9018 m(1, 2, 4, 6, 8, 9, 11, 12, 13) /H11001/H9018 d(0, 7, 10, 15)
7.22 A combinational switching circuit has four inputs and one output as shown. F/H110050 iff
three or four of the inputs are 1.(a) Write the maxterm expansion for F.
(b) Using AND and OR gates, find a minimum three-level circuit to realize F(5 gates,
12 inputs).
7.23 Implement f(a,b,c,d)/H11005/H9018 m(3, 4, 5, 6, 7, 11, 15) as a two-level gate circuit, using a
minimum number of gates.(a) Use AND gates and NAND gates.(b) Use OR gates and NAND gates.(c) Use NAND gates only.
7.24 (a) Use gate equivalences to convert the circuit into a four-level circuit containing only
NAND gates and a minimum number of inverters. (Assume the inputs are avail-able only in uncomplemented form.)
(b) Derive a minimum SOP expression for f.
(c) By manipulating the expression for f, find a three-level circuit containing only
five NAND gates and inverters.
fA
B
CA
B
C
DFMulti-Level Gate Circuits NAND and NOR Gates 211
7.25 (a) Use gate equivalences to convert the circuit of Problem 7.24 into a five-level cir-
cuit containing only NOR gates and a minimum number of inverters. (Assumethe inputs are available only in uncomplemented form.)
(b) Derive a minimum POS expression forf.
(c) By manipulating the expression for f, find a four-level circuit containing only six
NOR gates and inverters.
7.26 In the circuit, replace each NOR gate by an AND or OR gate so that the resulting
circuit contains the fewest inverters possible. Assume the inputs are available inboth true and complemented form. Do notreplace the exclusive-OR gates.
7.27 (a) Convert the circuit shown into a four-level circuit only containing AND and OR
gates and a minimum number of inverters.
(b) Derive a sum-of-products expression for f.
(c) Find a circuit that realizes f/H11032containing only NOR gates (no internal inverters).
(Hint: Use gate conversions to convert the NAND gates in the given circuit to
NOR gates.)
7.28
(a) Find a minimum two-level NOR-gate circuit to realize f.
(b) Find a minimum three-level NOR-gate circuit to realize f.
7.29 Design a minimum three-level NOR-gate circuit to realize
f/H11005a/H11032b/H11032/H11001abd /H11001acdf (a,b,c,d,e)/H11005/H9018 m(2, 3, 6, 12, 13, 16, 17, 18, 19, 22, 24, 25, 27, 28, 29, 31)C
D
fABB
C′A′
D′
E′
FGJWH
I'212 Unit 7
7.30 Find a minimum four-level NAND- or NOR-gate circuit to realize
(a)(b)
7.31 Implement using four NOR gates.
7.32 Implement using a three-level NAND-gate circuit.
7.33 Design a logic circuit that has a 4-bit binary number as an input and one output.The
output should be 1 iff the input is a prime number (greater than 1) or zero.(a) Use a two-level NAND-gate circuit.(b) Use a two-level NOR-gate circuit.(c) Use only two-input NAND gates.
7.34 Work Problem 7.33 for a circuit that has an output 1 iff the input is evenly divisible
by 3 (0 is divisible by 3).
7.35 Realize the following functions, using only two-input NAND gates. Repeat using
only two-input NOR gates.(a)(b)
7.36 (a) Find a minimum circuit of two-input AND and two-input OR gates to realize
(b) Convert your circuit to two-input NAND gates. Add inverters where necessary.
(c) Repeat (b), except convert to two-input NOR gates.
7.37 Realize using NOR gates.Add inverters if necessary.
7.38 In which of the following two-level circuit forms can an arbitrary switching function
be realized? Verify your answers. (Assume the inputs are available in both comple-mented and uncomplemented form.)(a) NOR-AND(b) NOR-OR(c) NOR-NAND(d) NOR-XOR(e) NAND-AND(f) NAND-OR(g) NAND-NOR(h) NAND-XOR
7.39 Find a minimum two-level, multiple-output AND-OR gate circuit to realize these
functions (eight gates minimum).
f
3 (a,b,c,d)/H11005/H9018 m(4, 11, 13, 14, 15) /H11001/H9018 d(5, 9, 12) f2 (a,b,c,d)/H11005/H9018 m(0, 4, 8, 9) /H11001/H9018 d(1, 10, 12)f1 (a,b,c,d)/H11005/H9018 m(10, 11, 12, 15) /H11001/H9018 d(4, 8, 14)Z/H11005A[BC/H11032/H11001D/H11001E(F/H11032/H11001GH)]F(A,B,C,D)/H11005/H9018 m(0, 1, 2, 3, 4, 5, 7, 9, 11, 13, 14, 15)F/H11005A/H11032CD/H11001AB/H11032C/H11032D/H11001ABD /H11032/H11001BCF/H11005A/H11032BC/H11032/H11001BD/H11001AC/H11001B/H11032CD/H11032x/H11032yz/H11001xvy/H11032w/H11032/H11001xvy/H11032z/H11032abde /H11032/H11001a/H11032b/H11032/H11001cZ/H11005(a/H11032/H11001b/H11001e/H11001f )(c/H11032/H11001a/H11032/H11001b)(d/H11032/H11001a/H11032/H11001b)(g/H11001h)Z/H11005abe/H11032f/H11001c/H11032e/H11032f/H11001d/H11032e/H11032f/H11001ghMulti-Level Gate Circuits NAND and NOR Gates 213
7.40 Repeat 7.39 for the following functions (six gates).
7.41 Repeat 7.39 for the following functions (eight gates).
7.42 (a) Find a minimum two-level, multiple-output OR-AND circuit to realize
.
(b) Realize the same functions with a minimum two-level NAND-NAND circuit.
7.43 Repeat Problem 7.42 for .
7.44 (a) Find a minimum two-level, multiple-output NAND-NAND circuit to realize
.
(b) Repeat for a minimum two-level, NOR-NOR circuit.
7.45 (a) Find a minimum two-level, multiple-output NAND-NAND circuit to realize
.
(b) Repeat for a minimum two-level, multiple-output NOR-NOR circuit.
7.46 Draw a multi-level, multiple-output, circuit equivalent to Figure 7-24(a) using:
(a) NAND and AND gates.(b) NAND gates only (a direct conversion is not possible).f
1/H11005/H9018 m(0, 2, 4, 6, 7, 10, 14) and f2/H11005/H9018 m(0, 1, 4, 5, 7, 10, 14)f1/H11005/H9018 m(3, 6, 7, 11, 13, 14, 15)  and f2/H11005/H9018 m(3, 4, 6, 11, 12, 13, 14)f1/H11005ac/H11032/H11001b/H11032d/H11001c/H11032d  and f2/H11005b/H11032c/H11001a/H11032d/H11001cd/H11032f1/H11005b/H11032d/H11001a/H11032b/H11032/H11001c/H11032d  and f2/H11005a/H11032d/H11032/H11001bc/H11032/H11001bd/H11032f3 (x,y,z)/H11005/H9018 m(1, 2, 4, 5, 6) f2 (x,y,z)/H11005/H9018 m(1, 3, 5, 6)f1 (x,y,z)/H11005/H9018 m(2, 3, 4, 5)f2 (a,b,c,d)/H11005/H9018 m(0, 1, 2, 3, 5, 7, 8, 10) f1 (a,b,c,d)/H11005/H9018  m(2, 3, 5, 6, 7, 8, 10)214 Unit 7
215CHAPTER
00Combinational Circuit Design 
and Simulation Using Gates
Objectives
1.Draw a timing diagram for a combinational circuit with gate delays.
2.Define static 0- and 1-hazards and dynamic hazards. Given a combina-
tional circuit, find all of the static 0- and 1-hazards. For each hazard,specify the order in which the gate outputs must switch in order for thehazard to actually produce a false output.
3.Given a switching function, realize it using a two-level circuit which is free
of static and dynamic hazards (for single input variable changes).
4.Design a multiple-output NAND or NOR circuit using gates with limited
fan-in.
5.Explain the operation of a logic simulator that uses four-valued logic.
6.Test and debug a logic circuit design using a simulator.
UNIT
8
1.Obtain your design problem assignment from your instructor.
2.Study Section 8.1, Review of Combinational Circuit Design.
3.Generally, it is possible to redesign a circuit which has two AND gates cascaded or
two OR gates cascaded so that AND and OR gates alternate. If this is not practi-cal, the conversion to a NAND or NOR circuit by the techniques of Section 7.4 isstill possible by introducing a dummy one-input OR (AND) gate between the twoAND (OR) gates.When the conversion is carried out, the dummy gate becomes aninverter. Try this technique and convert the following circuit to all NAND gates.Alternatively, you may use the procedures given in Section 7.5 to do the conversion.216 Unit 8
Study Guide
4.Study Section 8.2, Design of Circuits with Limited Gate Fan-In .
(a) If a realization of a switching expression requires too many inputs on one
or more gates, what should be done?
(b) Assuming that all variables and their complements are available as inputs
and that both AND and OR gates are available, does realizing the com-plement of an expression take the same number of gates and gate inputsas realizing the original expression?
(c) When designing multiple-output circuits with limited gate fan-in, why is
the procedure of Section 7.6 of little help?
5.(a) Study Section 8.3, Gate Delays and Timing Diagrams . Complete the timing dia-
gram for the given circuit. Assume that the AND gate has a 30-nanosecond(ns) propagation delay and the inverter has a 20-ns delay.
ZB′B
0 20 40 60 80 100 120 t(ns)A
A
BB′Zfa
b′
d′
ec
g′
(b) Work Problem 8.1.
6.Study Section 8.4, Hazards in Combinational Logic .
(a) Even though all of the gates in a circuit are of the same type, each individual
gate may have a different propagation delay. For example, for one type of TTLNAND gate the manufacturer specifies a minimum propagation delay of 5 nsand a maximum delay of 30 ns. Sketch the gate outputs for the following cir-cuit when the xinput changes from 1 to 0, assuming the following gate delays:
(a) gate 1–5 ns (b) gate 2–20 ns (c) gate 3–10 ns.
(b) Define static 0-hazard, static 1-hazard, and dynamic hazard.
(c) Using a Karnaugh map, explain why F/H11005a/H11032b/H11001achas a 1-hazard for the
input change abc/H11005011 to 111, but not for 011 to 010.Then explain it with-
out using the map.
(d) Explain why F/H11005(a/H11032/H11001b/H11032)(b/H11001c) has a 0-hazard for the input change
abc/H11005100 to 110, but not for 100 to 000.
(e) Under what condition does a sum-of-products expression represent a
hazard-free, two-level AND-OR circuit?
(f) Under what condition does a product-of-sums expression represent a
hazard-free, two-level OR-AND circuit?
(g) If a hazard-free circuit of AND and OR gates is transformed to NAND or
NOR gates using the procedure given in Unit 7, why will the results behazard-free?
(h) Work Problems 8.2 and 8.3.Zy2y1y1
y2
50 40 30 20 100 t(ns)x
x 1
0Z13
2Combinational Circuit Design and Simulation Using Gates 217
7.Study Section 8.5, Simulation and Testing of Logic Circuits .
(a) Verify that Table 8-1 is correct. Consider both the case where the unknown
value, X, is 0 and the case where it is 1.
(b) The following circuit was designed to realize the function
F/H11005[A/H11032/H11001B/H11001C/H11032D] [A/H11001B/H11032/H11001(C/H11032/H11001D/H11032)(C/H11001D)]
When a student builds the circuit in lab, he finds that when A/H11005C/H110050 and B/H11005
D/H110051, the output Fhas the wrong value and that the gate outputs are as shown.
Determine some possible causes of the incorrect output if G/H110050 and if G/H110051.
(c) Work Problems 8.4 and 8.5.
8.Study your assigned design problem and prepare a design which meets specifi-
cations. Note that only two-, three-, and four-input NAND gates (or NOR gatesas specified) and inverters are available for this project; therefore, factoringsome of the equations will be necessary. Try to make an economical design byusing common terms; however, do not waste time trying to get an absolute min-imum solution. When counting gates, count both NAND (or NOR) gates andinverters, but do not count the inverters needed for the input variables.
9.Check your design carefully before simulating it. Test it on paper by applying
some input combinations of 0’s and 1’s and tracing the signals through to makesure that the outputs are correct. If you have a CAD program such as LogicAid
available, enter the truth table for your design into the computer, derive theminimum two-level equations, and compare them with your solution.
10. In designing multi-level, multiple-output circuits of the type used in the design
problems in this unit, it is very difficult and time-consuming to find a minimumsolution. You are not expected to find the best possible solution to these prob-lems. All of these solutions involve some “tricks,” and it is unlikely that youcould find them without trying a large number of different ways of factoringyour equations. Therefore, if you already have an acceptable solution, do notwaste time trying to find the minimum solution. Because integrated circuit gatesare quite inexpensive, it is not good engineering practice to spend a largeamount of time finding the absolute minimum solution unless a very large num-ber of units of the same type are to be manufactured.
11. Obtain a Unit 8 supplement from your instructor and follow the instructions
therein regarding simulating and testing your design.C′
D′
CC A′
B
AF
B′D′
G
01 00
1
0
D1357
6
4
2218 Unit 8
219CHAPTER
00Combinational Circuit Design 
and Simulation Using Gates
8.1 Review of Combinational Circuit Design
The first step in the design of a combinational switching circuit is usually to set up a
truth table which specifies the output(s) as a function of the input variables. For ninput
variables this table will have 2nrows. If a given combination of values for the input
variables can never occur at the circuit inputs, the corresponding output values aredon’t-cares. The next step is to derive simplified algebraic expressions for the outputfunctions using Karnaugh maps, the Quine-McCluskey method, or a similar procedure.In some cases, particularly if the number of variables is large and the number of termsis small, it may be desirable to go directly from the problem statement to algebraicequations, without writing down a truth table.The resulting equations can then be sim-plified algebraically.The simplified algebraic expressions are then manipulated into theproper form, depending on the type of gates to be used in realizing the circuit.
The number of levels in a gate circuit is equal to the maximum number of gates
through which a signal must pass when going between the input and output terminals.The minimum sum of products (or product of sums) leads directly to a minimum two-level gate circuit. However, in some applications it is desirable to increase the numberof levels by factoring (or multiplying out) because this may lead to a reduction in thenumber of gates or gate inputs.
When a circuit has two or more outputs, common terms in the output functions can
often be used to reduce the total number of gates or gate inputs. If each function is min-imized separately, this does not always lead to a minimum multiple-output circuit. Fora two-level circuit, Karnaugh maps of the output functions can be used to find the com-mon terms. All of the terms in the minimum multiple-output circuit will not necessari-ly be prime implicants of the individual functions. When designing circuits with threeor more levels, looking for common terms on the Karnaugh maps may be of little value.In this case, the designer will often minimize the functions separately and, then, useingenuity to factor the expressions in such a way to create common terms.
Minimum two-level AND-OR, NAND-NAND, OR-NAND, and NOR-OR cir-
cuits can be realized using the minimum sum of products as a starting point. Minimumtwo-level OR-AND, NOR-NOR, AND-NOR, and NAND-AND circuits can be real-ized using the minimum product of sums as a starting point. Design of multi-level,
multiple-output NAND-gate circuits is most easily accomplished by first designing a
circuit of AND and OR gates. Usually, the best starting point is the minimum sum-of-products expressions for the output functions. These expressions are then factoredin various ways until an economical circuit of the desired form can be found. If thiscircuit has an OR gate at each output and is arranged so that an AND gate (or ORgate) output is never connected to the same type of gate, a direct conversion to aNAND-gate circuit is possible. Conversion is accomplished by replacing all of theAND and OR gates with NAND gates and then inverting any literals which appearas inputs to the first, third, fifth, . . . levels (output gates are the first level).
If the AND-OR circuit has an AND gate (or OR gate) output connected to the
same type of gate, then extra inverters must be added in the conversion process (seeSection 7.5, Circuit Conversion Using Alternative Gate Symbols .)
Similarly, design of multi-level, multiple-output NOR-gate circuits is most easily
accomplished by first designing a circuit of AND and OR gates. In this case the beststarting point is usually the minimum sum-of-products expressions for the comple-
ments of the output functions. After factoring these expressions to the desired form,
they are then complemented to get expressions for the output functions, and thecorresponding circuit of AND and OR gates is drawn. If this circuit has an ANDgate at each output, and an AND gate (or OR gate) output is never connected tothe same type of gate, a direct conversion to a NOR-gate circuit is possible.Otherwise, extra inverters must be added in the conversion process.
8.2 Design of Circuits with Limited Gate Fan-In
In practical logic design problems, the maximum number of inputs on each gate (orthe fan-in) is limited. Depending on the type of gates used, this limit may be two,three, four, eight, or some other number. If a two-level realization of a circuitrequires more gate inputs than allowed, factoring the logic expression to obtain amulti-level realization is necessary.
Realize f(a,b,c,d)/H11005/H9018 m(0, 3, 4, 5, 8, 9, 10, 14, 15) using three-input NOR gates.
Example
map of f:
f′ = a′b′c′d + ab′cd + abc′ + a′bc + a′cd′110100 01 11 10
0101
1010
000cdab
01
11
10 011220 Unit 8
Combinational Circuit Design and Simulation Using Gates 221
a
c
a′b
d′
d′ba′
cb′ fa
c′
c'FIGURE 8-1
FIGURE 8-2
f1 = Σm(0, 2, 3, 4, 5) f2 = Σm(0, 2, 3, 4, 7) f3 = Σm(1, 2, 6, 7)1101
1
1100bca
01
11101101
11
100bca
01
111001
1
1
100bca
01
1110 1As can be seen from the preceding expression, a two-level realization requires two
four-input gates and one five-input gate. The expression for f/H11032is factored to reduce
the maximum number of gate inputs to three and, then, it is complemented:
f/H11032/H11005b/H11032d(a/H11032c/H11032/H11001ac)/H11001a/H11032c(b/H11001d/H11032)/H11001abc/H11032
f/H11005[b/H11001d/H11032/H11001(a/H11001c)(a/H11032/H11001c/H11032)][a/H11001c/H11032/H11001b/H11032d][a/H11032/H11001b/H11032/H11001c]
The resulting NOR-gate circuit is shown in Figure 8-1.
The techniques for designing two-level, multiple-output circuits given in
Section 7.6 are not very effective for designing multiple-output circuits with morethan two levels. Even if the two-level expressions had common terms, most of thesecommon terms would be lost when the expressions were factored. Therefore, whendesigning multiple-output circuits with more than two levels, it is usually best tominimize each function separately. The resulting two-level expressions must thenbe factored to increase the number of levels. This factoring should be done in sucha way as to introduce common terms wherever possible.
Realize the functions given in Figure 8-2, using only two-input NAND gates and 
Exampleinverters. If we minimize each function separately, the result is
f1/H11005b/H11032c/H11032/H11001ab/H11032/H11001a/H11032b
f2/H11005b/H11032c/H11032/H11001bc/H11001a/H11032b
f3/H11005a/H11032b/H11032c/H11001ab/H11001bc/H11032
8.3 Gate Delays and Timing Diagrams
When the input to a logic gate is changed, the output will not change instantaneously.
The transistors or other switching elements within the gate take a finite time to reactto a change in input, so that the change in the gate output is delayed with respect tothe input change. Figure 8-4 shows possible input and output waveforms for an invert-er. If the change in output is delayed by time, /H9280, with respect to the input, we say that
this gate has a propagation delay of /H9280. In practice, the propagation delay for a 0 to 1
output change may be different than the delay for a 1 to 0 change. Propagation delaysfor integrated circuit gates may be as short as a few nanoseconds (1 nanosecond /H11005
10
/H110029second), and in many cases these delays can be neglected. However, in the analy-
sis of some types of sequential circuits, even short delays may be important.
Timing diagrams are frequently used in the analysis of sequential circuits. These
diagrams show various signals in the circuit as a function of time. Several variablesare usually plotted with the same time scale so that the times at which these variableschange with respect to each other can easily be observed.222 Unit 8
a′
c
b
c′
b′b′
a′
a′
bbf1
f2
f3b′c
c
(b)a
c′
b′
c
bb′
a′
a′
bbf1
f2
f3b′c
c′
(a)FIGURE 8-3 Realization of Figure 8-2Each function requires a three-input OR gate, so we will factor to reduce the num-
ber of gate inputs:
The second expression for f2has a term common to fl, so we will choose the second
expression. We can eliminate the remaining three-input gate from f3by noting that
a/H11032b/H11032c/H11005a/H11032(b/H11032c)/H11005a/H11032(b/H11001c/H11032)/H11032
Figure 8-3(a) shows the resulting circuit, using common terms a/H11032band a/H11001c/H11032.
Because each output gate is an OR, the conversion to NAND gates, as shown inFigure 8-3(b), is strainghtforward.f
3/H11005a/H11032b/H11032c/H11001b(a/H11001c/H11032)f2/H11005b(a/H11032/H11001c)/H11001b/H11032c/H11032     or    f2/H11005(b/H11032/H11001c)(b/H11001c/H11032)/H11001a/H11032bf1/H11005b/H11032(a/H11001c/H11032)/H11001a/H11032b
Figure 8-5 shows the timing diagram for a circuit with two gates. We will assume
that each gate has a propagation delay of 20 ns (nanoseconds). This timing diagramindicates what happens when gate inputs BandCare held at constant values 1 and
0, respectively, and input Ais changed to 1 at t/H1100540 ns and then changed back to 0
att/H11005100 ns. The output of gate G
1changes 20 ns after Achanges, and the output
of gate G2changes 20 ns after G1changes.
Figure 8-6 shows a timing diagram for a circuit with an added delay element. The
input Xconsists of two pulses, the first of which is 2 microseconds (2 /H1100310/H110026second)
wide and the second is 3 microseconds wide.The delay element has an output YwhichCombinational Circuit Design and Simulation Using Gates 223
FIGURE 8-4
Propagation Delay
in an Inverter
FIGURE 8-5
Timing Diagram for
AND-NOR CircuitX′X′
/H92801 /H92802TimeX
XTime
0 20 40 60 80 100 120 140 t(ns)G1
G2G2G1A
A
B = 1C = 020 ns
20 ns 20 ns20 ns
is the same as the input except that it is delayed by 1 microsecond. That is, Ychanges
to a 1 value 1 microsecond after the rising edge of the Xpulse and returns to 0 1
microsecond after the falling edge of the Xpulse. The output (Z) of the AND gate
should be 1 during the time interval in which both XandYare 1. If we assume a small
propagation delay in the AND gate ( /H9280), then Zwill be as shown in Figure 8-6.
111
0 1 2 3 4 5 6 7 8 9 10000
ZYX
X
Y Z
Time (microseconds)Rising edge Falling edge
2/H9262s
1/H9262s1  /H9262s3/H9262s
/H92801/H9262s Dela yFIGURE 8-6 Timing Diagram for Circuit with Delay
8.4 Hazards in Combinational Logic
When the input to a combinational circuit changes, unwanted switching transients
may appear in the output. These transients occur when different paths from input tooutput have different propagation delays. If, in response to any single input changeand for some combination of propagation delays, a circuit output may momentarily goto 0 when it should remain a constant 1, we say that the circuit has a static 1-hazard.Similarly, if the output may momentarily go to 1 when it should remain a 0, we say thatthe circuit has a static 0-hazard. If, when the output is supposed to change from 0 to 1(or 1 to 0), the output may change three or more times, we say that the circuit has adynamic hazard. Figure 8-7 shows possible outputs from a circuit with hazards. In eachcase the steady-state output of the circuit is correct, but a switching transient appearsat the circuit output when the input is changed.224 Unit 8
11
011 1
00 0
(a) Static 1-hazard (c) D ynamic hazards001
01
(b) Static 0-hazardFIGURE 8-7 Types of Hazards
Figure 8-8(a) illustrates a circuit with a static 1-hazard. If A/H11005C/H110051, then F/H11005B/H11001B/H11032/H110051,
so the Foutput should remain a constant 1 when Bchanges from 1 to 0. However, as shown
in Figure 8-8(b), if each gate has a propagation delay of 10 ns, Ewill go to 0 before Dgoes
to 1, resulting in a momentary 0 (a glitch caused by the 1-hazard) appearing at the outputF. Note that right after Bchanges to 0, both the inverter input ( B) and output ( B/H11032) are 0
until the propagation delay has elapsed. During this period, both terms in the equation forFare 0, so Fmomentarily goes to 0.
Note that hazards are properties of the circuit and are independent of the delays
existing in the circuit. If the circuit is free of hazards, then for any combination ofdelays that might exist in the circuit and for any single input change, the output willnot contain a transient. On the other hand, if a circuit contains a hazard, then thereis some combination of delays and some input change for which the circuit outputcontains a transient. The combination of delays that produces the transient may ormay not be likely to occur in an implementation of the circuit; in some cases it isvery unlikely that such delays would occur.
Besides depending on the delays existing in a circuit, the occurrence of tran-
sients depends on how gates respond to input changes. In some cases, if multipleinput changes to a gate occur within a short time period, a gate may not respond tothe input changes. For example, in Figure 8-8 assume the inverter has a delay of 2 nsrather than 10 ns. Then the Dand Echanges reaching the output OR gate are 2 ns
apart, in which case the OR gate may not generate the 0 glitch. A gate exhibiting
this behavior is said to have an inertial delay. Quite often the inertial delay value is
assumed to be the same as the propagation delay of the gate; if this is the case, thecircuit of Figure 8-8 will generate the 0 glitch only for inverter delays greater than10 ns. In contrast, if a gate always responds to input changes (with a propagationdelay), no matter how closely spaced the input changes may be, the gate is said tohave an ideal ortransport delay. If the OR gate in Figure 8-8 has an ideal delay, then
the 0 glitch would be generated for any nonzero value of the inverter delay. (Inertialand transport delay models are discussed more in Unit 10.) Unless otherwise noted,the examples and problems in this unit assume that gates have an ideal delay.
Hazards can be detected using a Karnaugh map [Figure 8-8(a)]. As seen on the
map, no loop covers both minterms ABC andAB/H11032C. So if A/H11005C/H110051 and Bchanges,
both terms can momentarily go to 0, resulting in a glitch in F. We can detect hazards
in a two-level AND-OR circuit, using the following procedure:
1.Write down the sum-of-products expression for the circuit.
2.Plot each term on the map and loop it.
3.If any two adjacent 1’s are not covered by the same loop, a 1-hazard exists for
the transition between the two 1’s. For an n-variable map, this transition occurs
when one variable changes and the other n/H110021 variables are held constant.
If we add a loop to the map of Figure 8-8(a) and, then, add the corresponding
gate to the circuit (Figure 8-9), this eliminates the hazard. The term ACremains 1
while Bis changing, so no glitch can appear in the output. Note that Fis no longer
a minimum sum of products.Combinational Circuit Design and Simulation Using Gates 225
0 ns 10 ns 20 ns 30 ns
(b) Timing chart(a) Circuit with a static 1-hazard
40 ns 50 ns1-hazard
60 nsFEDBBAD
EF
C F = AB′ + BC0101
1 0
1
01
000BCA
01
11
10FIGURE 8-8
Detection of a
1-Hazard
Figure 8-10(a) shows a circuit with several 0-hazards. The product-of-sums rep-
resentation for the circuit output is
F/H11005(A/H11001C)(A/H11032/H11001D/H11032)(B/H11032/H11001C/H11032/H11001D)
The Karnaugh map for this function (Figure 8-10(b)) shows four pairs of adja-
cent 0’s that are not covered by a common loop as indicated by the arrows. Eachof these pairs corresponds to a 0-hazard. For example, when A/H110050,B/H110051,D/H11005
0, and Cchanges from 0 to 1, a spike may appear at the Zoutput for some com-
bination of gate delays. The timing diagram of Figure 8-10(c) illustrates this226 Unit 8
C
DAW
YZ
B
Xat 5 ns, 0 →1
at 10 ns, 0 →1
at 8 ns, 1 →0
(a) Circuit with a static 0-hazard (b) Karnaugh map for circuit of (a)at 13 ns, 1 →0at 15 ns, 0 →1
at 18 ns, 1 →0
4
0 5 10
(c) Timing diagram illustrating 0-hazard of (a)15 8 13 18 20ZYXWC0000 01 11 10
0000
0000CDAB
01
1110 001
2
3FIGURE 8-10
Detection of a 
Static 0-HazardFIGURE 8-9
Circuit with Hazard
Removed
BA
AFC
F = AB′ + BC+AC0101
1 0
1
01
000BCA
01
11
10
assuming gate delays of 3 ns for each inverter, and of 5 ns for each AND gate
and each OR gate.
We can eliminate the 0-hazards by looping additional prime implicants that
cover the adjacent 0’s that are not already covered by a common loop. This requiresthree additional loops as shown in Figure 8-11. The resulting equation is
F/H11005(A/H11001C)(A/H11032/H11001D/H11032)(B/H11032/H11001C/H11032/H11001D)(C/H11001D/H11032)(A/H11001B/H11032/H11001D)(A/H11032/H11001B/H11032/H11001C/H11032)
and the resulting circuit requires seven gates in addition to the inverters.Combinational Circuit Design and Simulation Using Gates 227
0000 01 11 10
0000
0000CDAB
01
1110 00FIGURE 8-11
Karnaugh Map
Removing Hazards
of Figure 8-10.
Hazards in circuits with more than two levels can be determined by deriving either
a SOP or POS expression for the circuit that represents a two-level circuit containingthe same hazards as the original circuit. The SOP or POS expression is derived in thenormal manner except that the complementation laws are notused, i.e., xx/H11032/H110050 and x
/H11001x/H11032/H110051 are not used. Consequently, the resulting SOP (POS) expression may contain
products (sums) of the form xx/H11032
/H9251(x/H11001x/H11032/H11001/H9252). (/H9251is a product of literals or it may be
null; /H9252is a sum of literals or it may be empty.) The complementation laws are not used
because we are analyzing the circuit behavior resulting from an input change. As thatinput change propagates through the circuit, at a given point in time a line tendingtoward the value xmay not have the value that is the complement of a line tending
toward the value x/H11032. In the SOP expression, a product of the form xx/H11032
/H9251represents a
pseudo gate that may temporarily have the output value 1 as xchanges and if /H9251/H110051.
Given the SOP expression, the circuit is analyzed for static 1-hazards the same
as for a two-level AND-OR circuit, i.e., the products are mapped on a Karnaughmap and if two 1’s are adjacent on the map and not included in one of the products,they correspond to a static 1-hazard. The circuit can have a static 0-hazard or adynamic hazard only if the SOP expression contains a term of the form xx/H11032
/H9251.A
static 0-hazard exists if there are two adjacent 0’s on the Karnaugh map for which 
/H9251/H110051 and the two input combinations differ just in the value of x.A dynamic hazard
exists if there is a term of the form xx/H11032/H9251and two conditions are satisfied: (1) There
are adjacent input combinations on the Karnaugh map differing in the value of x,
with /H9251/H110051 and with opposite function values, and (2) for these input combinations
the change in xpropagates over at least three paths through the circuit.
As an example consider the circuit of Figure 7-7 (page 194). The expression for
the circuit output is
f/H11005(c/H11032/H11001ad/H11032/H11001bd/H11032)(c/H11001a/H11032d/H11001bd)
/H11005cc/H11032/H11001acd/H11032/H11001bcd/H11032/H11001a/H11032c/H11032d/H11001aa/H11032dd/H11032/H11001a/H11032bdd/H11032/H11001bc/H11032d/H11001abdd /H11032/H11001bdd/H11032
/H11005cc/H11032/H11001acd/H11032/H11001bcd/H11032/H11001a/H11032c/H11032d/H11001aa/H11032dd/H11032/H11001bc/H11032d/H11001bdd/H11032
The Karnaugh map for this function is shown as the circled 1’s in Figure 7-3
(page 192). It is derived in the normal way ignoring the product terms containingboth a variable and its complement. The circuit does not contain any static 1-hazards because each pair of adjacent 1’s are covered by one of the product terms.Potentially, the terms cc/H11032and bdd/H11032may cause either static 0- or dynamic hazards or
both; the first for cchanging and the second for dchanging. (The term aa/H11032dd/H11032can-
not cause either hazard because, for example, if achanges the dd/H11032part of the prod-
uct forces it to 0.) With a/H110050,b
/H110050, and d/H110050 and cchanging, the circuit output is
0 before and after the change, and because the cc/H11032term can cause the output to
temporarily become 1, this transition is a static 0-hazard. Similarly, a change in c, with
a/H110051,b/H110050 and d/H110051, is a static 0-hazard. The cc/H11032term cannot cause a dynamic haz-
ard because there are only two physical paths from input cto the circuit output.
The term bdd/H11032can cause a static 0- or dynamic hazard only if b/H110051. From the
Karnaugh map, it is seen that, with b/H110051 and dchanging, the circuit output changes
for any combination of aand c, so the only possibility is that of a dynamic hazard.
There are four physical paths from dto the circuit output, so a dynamic hazard
exists if a dchange can propagate over at least three of those paths. However, this
cannot happen because, with c/H110050, propagation over the upper two paths is blocked
at the upper OR gate because c/H11032/H110051 forces the OR gate output to be 1, and with 
c/H110051 propagation over the lower two paths is blocked at the lower OR gate.The cir-
cuit does not contain a dynamic hazard.
Another approach to finding the hazards is as follows: If we factor the original
expression for the circuit output (without using the complementation laws), we get
f/H11005(c/H11032/H11001a/H11001b)(c/H11032/H11001d/H11032)(c/H11001a/H11032/H11001b)(c/H11001d)
Plotting the 0’s of ffrom this expression on a Karnaugh map reveals that there
are 0-hazards when a/H11005b/H11005d/H110050 and cchanges, and also when b/H110050,a/H11005d/H110051,
and cchanges. An expression of the form x/H11001x/H11032does not appear in any sum term
off, and this indicates that there are no 1-hazards or dynamic hazards.
To design a circuit which is free of static and dynamic hazards, the following pro-
cedure may be used:
1.Find a sum-of-products expression ( Ft) for the output in which every pair of
adjacent 1’s is covered by a 1-term. (The sum of all prime implicants will alwayssatisfy this condition.) A two-level AND-OR circuit based on this Ftwill be
free of 1-, 0-, and dynamic hazards.
2.If a different form of the circuit is desired, manipulate Ftto the desired form
by simple factoring, DeMorgan’s laws, etc. Treat each xiand xi/H11032as independent
variables to prevent introduction of hazards.228 Unit 8
Combinational Circuit Design and Simulation Using Gates 229
Alternatively, you can start with a product-of-sums expression in which every pair
of adjacent 0’s is covered by a 0-term, and follow the dual procedure to design ahazard-free two-level OR-AND circuit.
It should be emphasized that the discussion of hazards and the possibility of
resulting glitches in this section has assumed that only a single input can change ata time and that no other input will change until the circuit has stabilized. If morethan one input can change at one time, then nearly all circuits will contain hazards,and they cannot be eliminated by modifying the circuit implementation. The circuitcorresponding to the Karnaugh map of Figure 8-11 illustrates this. Consider theinput change ( A, B, C, D )/H11005(0, 1, 0, 1) to (0, 1, 1, 0) with both CandDchanging.The
output is 0 before the change and will be 0 after the circuit has stabilized; however,if the Cchange propagates through the circuit before the Dchange, then the circuit
will output a transient 1. Effectively, the input combination to the circuit can tem-porarily become ( A, B, C, D )/H11005(0, 1, 1, 1), and the circuit output will temporarily
become 1 no matter how it is implemented.
Glitches are of most importance in asynchronous sequential circuits. The
latches and flip-flops discussed in Unit 11 are the most important examples ofasynchronous sequential circuits. Although more than one input can change atthe same time for some of these circuits, restrictions are placed on the changes sothat it is necessary to analyze the circuits for hazards only when a single inputchanges. Consequently, the discussion in this section is relevant to this importantclass of circuits.
8.5 Simulation and Testing of Logic Circuits
An important part of the logic design process is verifying that the final design iscorrect and debugging the design if necessary. Logic circuits may be tested eitherby actually building them or by simulating them on a computer. Simulation is gen-erally easier, faster, and more economical. As logic circuits become more and morecomplex, it is very important to simulate a design before actually building it. Thisis particularly true when the design is built in integrated circuit form, because fab-ricating an integrated circuit may take a long time and correcting errors may bevery expensive. Simulation is done for several reasons, including (1) verificationthat the design is logically correct, (2) verification that the timing of the logic sig-nals is correct, and (3) simulation of faulty components in the circuit as an aid tofinding tests for the circuit.
To use a computer program for simulating logic circuits, you must first speci-
fy the circuit components and connections; then, specify the circuit inputs; and,finally, observe the circuit outputs. The circuit description may be input into asimulator in the form of a list of connections between the gates and other logicelements in the circuit, or the description may be in the form of a logic diagramdrawn on a computer screen. Most modern logic simulators use the latterapproach. A typical simulator which runs on a personal computer uses switches
or input boxes to specify the inputs and probes to read the logic outputs.Alternatively,
the inputs and outputs may be specified as sequences of 0’s and 1’s or in the form oftiming diagrams.
A simple simulator for combinational logic works as follows:
1.The circuit inputs are applied to the first set of gates in the circuit, and the out-
puts of those gates are calculated.
2.The outputs of the gates which changed in the previous step are fed into the next
level of gate inputs. If the input to any gate has changed, then the output of thatgate is calculated.
3.Step 2 is repeated until no more changes in gate inputs occur. The circuit is then
in a steady-state condition, and the outputs may be read.
4.Steps 1 through 3 are repeated every time a circuit input changes.
The two logic values, 0 and 1, are not sufficient for simulating logic circuits. At
times, the value of a gate input or output may be unknown, and we will represent thisunknown value by X.At other times we may have no logic signal at an input, as in the
case of an open circuit when an input is not connected to any output.We use the logicvalue Zto represent an open circuit, or high impedance (hi-Z) connection. The dis-
cussion that follows assumes we are using a four-valued logic simulator with logicvalues 0, 1, X(unknown), and Z(hi-Z).
Figure 8-12(a) shows a typical simulation screen on a personal computer. The
switches are set to 0 or 1 for each input. The probes indicate the value of each gateoutput. In Figure 8-12(b), one gate has no connection to one of its inputs. Becausethat gate has a 1 input and a hi- Zinput, we do not know what the hardware will do,
and the gate output is unknown. This is indicated by an Xin the probe.230 Unit 8
111
00
(a) Simulation screen showing switches0
1
0
11
110
1
0Probe
X11
00
(b) Simulation screen with missing gate input0
1
0
11
ZX0FIGURE 8-12
Table 8-1 shows AND and OR functions for four-valued logic simulation. These
functions are defined in a manner similar to the way real gates work. For an AND gate,if one of the inputs is 0, the output is always 0 regardless of the other input. If one inputis 1 and the other input is X(we do not know what the other input is), then the output
isX(we do not know what the output is). If one input is 1 and the other input is Z(it
has no logic signal), then the output is X(we do not know what the hardware will do).
For an OR gate, if one of the inputs is 1, the output is 1 regardless of the other input.
If one input is 0 and the other input is XorZ, the output is unknown. For gates with
more than two inputs, the operations may be applied several times.
A combinational logic circuit with a small number of inputs may easily be
tested with a simulator or in lab by checking the circuit outputs for all possiblecombinations of the input values. When the number of inputs is large, it is usual-ly possible to find a relatively small set of input test patterns which will test forall possible faulty gates in the circuit.
1
If a circuit output is wrong for some set of input values, this may be due to sev-
eral possible causes:
1.Incorrect design
2.Gates connected wrong
3.Wrong input signals to the circuit
If the circuit is built in lab, other possible causes include
4.Defective gates
5.Defective connecting wires
Fortunately, if the output of a combinational logic circuit is wrong, it is very easy
to locate the problem systematically by starting at the output and working backthrough the circuit until the trouble is located. For example, if the output gate has thewrong output and its inputs are correct, this indicates that the gate is defective. Onthe other hand, if one of the inputs is wrong, then either the gate is connected wrong,the gate driving this input has the wrong output, or the input connection is defective.
The function F/H11005AB(C/H11032D/H11001CD/H11032)/H11001A/H11032B/H11032(C/H11001D) is realized by the circuit of 
ExampleFigure 8-13:Combinational Circuit Design and Simulation Using Gates 231
C′
D
CAF B
A′
B′
DC
D′10
1
11
0
105
623
7
4FIGURE 8-13
Logic Circuit with
Incorrect Output
1Methods for test pattern generation are described in Alexander Miczo, Digital Logic Testing and
Simulation , 2nd ed (John Wiley & Sons, 2003).•01XZ /H11001 01XZ
00 0 0 0 0 0 1 X X
10 1 X X 1 1 1 1 1
X0 X X X X X 1 X X
Z0 X X X Z X 1 X XTABLE 8-1
AND and OR
Functions for
Four-Valued
Simulation
When a student builds the circuit in a lab, he finds that when A/H11005B/H11005C/H11005D/H110051, the
output Fhas the wrong value, and that the gate outputs are as shown in Figure 8-13.
The reason for the incorrect value of Fcan be determined as follows:
1.The output of gate 7 ( F) is wrong, but this wrong output is consistent with the
inputs to gate 7, that is, 1 /H110010/H110051. Therefore, one of the inputs to gate 7 must be
wrong.
2.In order for gate 7 to have the correct output ( F/H110050), both inputs must be 0.
Therefore, the output of gate 5 is wrong. However, the output of gate 5 is con-sistent with its inputs because 1 
/H11080 1/H11080 1/H110051. Therefore, one of the inputs to gate
5 must be wrong.
3.Either the output of gate 3 is wrong, or the AorBinput to gate 5 is wrong.
Because C/H11032D/H11001CD/H11032/H110050, the output of gate 3 is wrong.
4.The output of gate 3 is not consistent with the outputs of gates 1 and 2 because 
0/H110010/H110141. Therefore, either one of the inputs to gate 3 is connected wrong, gate 3
is defective, or one of the input connections to gate 3 is defective.
This example illustrates how to troubleshoot a logic circuit by starting at the output
gate and working back until the wrong connection or defective gate is located.
Problems
8.1 Complete the timing diagram for the given circuit. Assume that both gates have a
propagation delay of 5 ns.
8.2 Consider the following logic function.
F(A,B,C,D)/H11005/H9018 m(0, 4, 5, 10, 11, 13, 14, 15)
(a) Find two different minimum circuits which implement Fusing AND and OR
gates. Identify two hazards in each circuit.
(b) Find an AND-OR circuit for Fwhich has no hazards.
(c) Find an OR-AND circuit for Fwhich has no hazards.ZVYXW
W
X
YV
Z
0 5 10 15 20 25 30 35 40 t(ns)232 Unit 8
8.3 For the following circuit:
(a) Assume that the inverters have a delay of 1 ns and the other gates have a delay
of 2 ns. Initially A/H110050 and B/H11005C/H11005D/H110051, and Cchanges to 0 at time /H110052n s .
Draw a timing diagram and identify the transient that occurs.
(b) Modify the circuit to eliminate the hazard.
8.4 Using four-valued logic, find A,B,C,D,E,F,G, and H.
8.5 The circuit below was designed to implement the logic equation F/H11005AB/H11032D/H11001BC/H11032D/H11032
/H11001BCD , but it is not working properly.The input wires to gates 1, 2, and 3 are so tight-
ly packed, it would take you a while to trace them all back to see whether the inputsare correct. It would be nice to only have to trace whichever one is incorrectly wired.When A/H11005B/H110050 and C/H11005D/H110051, the inputs and outputs of gate 4 are as shown. Is
gate 4 working properly? If so, which of the other gates either is connected incor-rectly or is malfunctioning?
8.6 (a) Assume the inverters have a delay of 1 ns and the other gates have a delay of 
2 ns. Initially A/H11005B/H110050 and C/H11005D/H110051;Cchanges to 0 at time 2 ns. Draw a
timing diagram showing the glitch corresponding to the hazard.
(b) Modify the circuit so that it is hazard free. (Leave the circuit as a two-level,
OR-AND circuit.)1
1
1
0FA
B
C
D12 4
3MESS
OF
WIRES1
(no connection)AC
DE
FG
HBB E
FC
A
DGCombinational Circuit Design and Simulation Using Gates 233
8.7 A two-level, NOR-NOR circuit implements the function 
f(a, b, c, d )/H11005(a/H11001d/H11032)(b/H11032/H11001c/H11001d)(a/H11032/H11001c/H11032/H11001d/H11032)(b/H11032/H11001c/H11032/H11001d).
(a) Find all hazards in the circuit.(b) Redesign the circuit as a two-level, NOR-NOR circuit free of all hazards and
using a minimum number of gates.
8.8 F(A, B, C, D )/H11005/H9018 m(0, 2, 3, 5, 6, 7, 8, 9, 13, 15)
(a) Find three different minimum AND-OR circuits that implement F. Identify two
hazards in each circuit. Then find an AND-OR circuit for Fthat has no hazards.
(b) There are two minimum OR-AND circuits for F; each has one hazard. Identify the
hazard in each circuit, and then find an OR-AND circuit for Fthat has no hazards.
8.9 Consider the following three-level NOR circuit:
(a) Find all hazards in this circuit.(b) Redesign the circuit as a three-level NOR circuit that is free of all hazards.
8.10 Draw the timing diagram for VandZfor the circuit.Assume that the AND gate has
a delay of 10 ns and the OR gate has a delay of 5 ns.
15V
Z
0 5 10 20 25 30 35 40 t (ns)YXW
4550 55W
X
YV
Z10 ns
5 nsA
B
C
DfA
D
C
BE
F
GH234 Unit 8
8.11 Consider the three-level circuit corresponding to the expression f(A, B, C, D) /H11005
(A/H11001B)(B /H11032C/H11032/H11001BD/H11032).
(a) Find all hazards in this circuit.(b) Redesign the circuit as a three-level NOR circuit that is free of all hazards.
8.12 Complete the timing diagram for the given circuit. Assume that both gates have a
propagation delay of 5 ns.
8.13 Implement the logic function from Figure 8.10(b) as a minimum sum of products.
Find the static hazards and tell what minterms they are between. Implement thesame logic function as a sum of products without any hazards.
8.14 Using four-valued logic, find A,B,C,D,E,F,G, and H.
8.15 The following circuit was designed to implement the logic equation F/H11005(A/H11001B/H11032
/H11001C/H11032)(A/H11032/H11001B/H11001C/H11032)(A/H11032/H11001B/H11032/H11001C), but it is not working properly.The input wires to
gates 1, 2, and 3 are so tightly packed, it would take you a while to trace them all backto see whether the inputs are correct. It would be nice to only have to trace whichev-er one is incorrectly wired. When A/H11005B/H11005C/H110051, the inputs and outputs of gate 4
are as shown. Is gate 4 working properly? If so, which of the other gates either is con-nected incorrectly or is malfunctioning?
1
0F
0A
B
C0Mess
of
Wires1
2 4
3(no connection)
(no connection)0AC
D
EF
H
GBZVYXW
W
X
YV
Z
0 5 10 15 20 25 30 35 40 t(ns)Combinational Circuit Design and Simulation Using Gates 235
8.16 Consider the following logic function.
F(A,B,C,D)/H11005/H9018 m(0, 2, 5, 6, 7, 8, 9, 12, 13, 15)
(a) Find two different minimum AND-OR circuits which implement F. Identify two
hazards in each circuit. Then find an AND-OR circuit for Fthat has no hazards.
(b) The minimum OR-AND circuit for Fhas one hazard. Identify it, and then find
an OR-AND circuit for Fthat has no hazards.
Design Problems
Seven-Segment Indicator
Several of the problems involve the design of a circuit to drive a seven-segment indi-
cator (see Figure 8-14). The seven-segment indicator can be used to display any oneof the decimal digits 0 through 9. For example, “1” is displayed by lighting segments2 and 3, “2” by lighting segments 1, 2, 7, 5, and 4, and “8” by lighting all seven seg-ments. A segment is lighted when a logic 1 is applied to the corresponding input onthe display module.236 Unit 8
A
B
C
DCircuit
to Be
Designed1Seven-Segment Indicator
2
3
4
5
6
7X1
X2
X3
X4
X5
X6
X71
2
3
4567 Inputs From
Toggle
SwitchesFIGURE 8-14
Circuit Driving
Seven-Segment
Module
8.A Design an 8-4-2-1 BCD code converter to drive a seven-segment indicator. The four
inputs to the converter circuit ( A,B,C, and Din Figure 8-14) represent an 8-4-2-1
binary-coded-decimal digit. Assume that only input combinations representing thedigits 0 through 9 can occur as inputs, so that the combinations 1010 through 1111are don’t-cares. Design your circuit using only two-, three-, and four-input NANDgates and inverters. Try to minimize the number of gates required. The variables A,
B,C, and Dwill be available from toggle switches.
Use (not ) for 6. Use (not ) for 9.
Any solution that uses 18 or fewer gates and inverters (not counting the four invert-
ers for the inputs) is acceptable.
8.B Design an excess-3 code converter to drive a seven-segment indicator. The four
inputs to the converter circuit ( A,B,C, and Din Figure 8-14) represent an excess-3
coded decimal digit. Assume that only input combinations representing the digits 0
through 9 can occur as inputs, so that the six unused combinations are don’t-cares.Design your circuit using only two-, three-, and four-input NAND gates and invert-ers. Try to minimize the number of gates and inverters required. The variables A,B,
C, and Dwill be available from toggle switches.
Use (not ) for 6. Use (not ) for 9.
Any solution with 16 or fewer gates and inverters (not counting the four inverters
for the inputs) is acceptable.
8.C Design a circuit which will yield the product of two binary numbers, n
2and m2,
where 002/H11349n2/H11349112and 0002/H11349m2/H113491012. For example, if n2/H11005102andm2/H110050012,
then the product is n2/H11003m2/H11005102/H110030012/H1100500102. Let the variables Aand Brepre-
sent the first and second digits of n2, respectively (i.e., in this example A/H110051 and 
B/H110050). Let the variables C,D, and Erepresent the first, second, and third digits of
m2, respectively (in this example C/H110050,D/H110050, and E/H110051). Also let the variables W,
X,Y, and Zrepresent the first, second, third, and fourth digits of the product. (In
this example W/H110050,X/H110050,Y/H110051, and Z/H110050.) Assume that m2/H110221012never occurs
as a circuit input.
Design the circuit using only two-, three-, and four-input NOR gates and inverters.
Try to minimize the total number of gates and inverters required.The variables A,B,
C,D, and Ewill be available from toggle switches.Any solution that uses 15 or fewer
gates and inverters (not counting the five inverters for the inputs) is acceptable.
8.D Work Design Problem 8.C using two-, three-, and four-input NAND gates and
inverters instead of NOR gates and inverters. Any solution that uses 14 gates andinverters or less (not counting the five inverters for the inputs) is acceptable.
8.E Design a circuit which multiplies two 2-bit binary numbers and displays the answer
in decimal on a seven-segment indicator. In Figure 8-14, Aand Bare two bits of a
binary number N
1, and Cand Dare two bits of a binary number N2. The product 
(N1/H11003N2) is to be displayed in decimal by lighting appropriate segments of the
seven-segment indicator. For example, if A/H110051,B/H110050,C/H11005l, and D/H110050, the num-
ber “4” is displayed by lighting segments 2, 3, 6, and 7.
Use (not ) for 6. Use (not ) for 9.CA
BW
X
YZ
D
ECircuit
to be
DesignedProduct o f
n2×m2
m2 Inputn2 InputCombinational Circuit Design and Simulation Using Gates 237
Design your circuit using only two-, three-, and four-input NAND gates and invert-
ers. Try to minimize the number of gates required. The variables A,B,C, and Dwill
be available from toggle switches. Any solution that uses 18 or fewer gates andinverters (not counting the four inverters for the inputs) is acceptable.
8.F Design a Gray code converter to drive a seven-segment indicator. The four inputs
to the converter circuit ( A,B,C, and Din Figure 8-14) represent a decimal digit
coded using the Gray code of Table 1-2. Assume that only input combinations rep-resenting the digits 0 through 9 can occur as inputs, so that the six unused combina-tions are don’t-care terms. Design your circuit using only two-, three-, and four-inputNAND gates and inverters. Try to minimize the numbers of gates and invertersrequired. The variables A,B,C, and Dwill be available from toggle switches.
Use (not ) for 6. Use (not ) for 9.
Any solution with 20 or fewer gates and inverters (not counting the four inverters
for the inputs) is acceptable.
8.G Design a circuit that will add either 1 or 2 to a 4-bit binary number N. Let the inputs
N
3,N2,N1,N0represent N. The input Kis a control signal. The circuit should have
outputs M3,M2,M1,M0, which represent the 4-bit binary number M. When K/H110050,
M/H11005N/H110011. When K/H110051,M/H11005N/H110012. Assume that the inputs for which M/H1102211112
will never occur.
Design the circuit using only two-, three-, and four-input NAND gates and inverters.Try
to minimize the total number of gates and inverters required.The input variables K,N3,
N2,N1, and N0will be available from toggle switches.Any solution that uses 13 or fewer
gates and inverters (not counting the five inverters for the inputs) is acceptable.
8.H Work Problem 8.A, except use 4-2-1-8 code instead of 8-4-2-1 code. For example,
in 4-2-1-8 code, 9 is represented by 0011. Also change the representations of dig-its 6 and 9 to the opposite form given in Problem 8.A. Any solution with 20 orfewer gates and inverters (not counting the four inverters for the inputs) isacceptable.
8.I Work Problem 8.B, except use excess-2 code instead of excess-3 code. (In excess-2
code, 0 is represented by 0010, 1 by 0011, 2 by 0100, etc.).Any solution with 17 or fewergates and inverters (not counting the four inverters for the inputs) is acceptable.
8.J Design a circuit which will multiply a 3-bit binary number CDE by 2, 3, or 5, depend-
ing on the value of a 2-bit code AB(00, 01, or 10), to produce a 4-bit result WXYZ .I f
the result has a value greater than or equal to 15, WXYZ should be 1111 to indicate
an overflow. Assume that the code AB/H1100511 will never occur. Design your circuit
using only two-, three-, and four-input NOR gates and inverters. Try to minimize thenumber of gates required. The inputs A,B,C,D, and Ewill be available from toggle238 Unit 8
switches. Any solution which uses 19 or fewer gates and inverters (not counting the
five inverters for the inputs) is acceptable.
8.K Design a circuit which will divide a 5-bit binary number by 3 to produce a 4-bit bina-
ry quotient. Assume that the input number is in the range 0 through 27 and thatnumbers in the range 28 through 31 will never occur as inputs. Design your circuitusing only two-, three-, and four-input NAND gates and inverters. Try to minimizethe number of gates required. The inputs A,B,C,D, and Ewill be available from
toggle switches. Any solution which uses 22 or fewer gates and inverters (not count-ing the five inverters for the inputs) is acceptable.
8.L Design an excess-3 code converter to drive a seven-segment indicator. The four
inputs ( A,B,C,D) to the converter circuit represent an excess-3 digit. Input com-
binations representing the numbers 0 through 9 should be displayed as decimal dig-its. The input combinations 0000, 0001, and 0010 should be interpreted as an error,and an “E” should be displayed.Assume that the input combinations 1101, 1110, and1111 will never occur. Design your circuit using only two-, three-, and four-inputNOR gates and inverters. Any solution with 18 or fewer gates and inverters (notcounting the four inverters for the inputs) is acceptable.
Use (not ) for 6. Use (not ) for 9.
8.M Design a circuit which displays the letters A through J on a seven-segment indica-
tor. The circuit has four inputs W,X,Y,Zwhich represent the last 4 bits of the
ASCII code for the letter to be displayed. For example, if WXYZ /H110050001, “A” will
be displayed. The letters should be displayed in the following form:
Design your circuit using only two-, three-, and four-input NOR gates and inverters.
Any solution with 22 or fewer gates and inverters (not counting the four invertersfor the inputs) is acceptable.
8.N A simple security system for two doors consists of a card reader and a keypad.
To Door 1
To Door 2
To AlarmLogic
Circuit
Ke ypad
Card Reader
CA
B
D
EX
Y
ZCombinational Circuit Design and Simulation Using Gates 239
A person may open a particular door if he or she has a card containing the corre-
sponding code and enters an authorized keypad code for that card. The outputsfrom the card reader are as follows:
AB
No card inserted 0 0
Valid code for door 1 0 1
Valid code for door 2 1 1
Invalid card code 1 0
To unlock a door, a person must hold down the proper keys on the keypad and,
then, insert the card in the reader. The authorized keypad codes for door 1 are 101and 110, and the authorized keypad codes for door 2 are 101 and 011. If the card hasan invalid code or if the wrong keypad code is entered, the alarm will ring when thecard is inserted. If the correct keypad code is entered, the corresponding door willbe unlocked when the card is inserted.
Design the logic circuit for this simple security system.Your circuit’s inputs will con-
sist of a card code AB, and a keypad code CDE . The circuit will have three outputs
XYZ (ifXorY/H110051, door 1 or 2 will be opened; if Z/H110051, the alarm will sound).
Design your circuit using only two-, three-, and four-input NOR gates and inverters.Any solution with 19 or fewer gates and inverters (not counting the five invertersfor the inputs) is acceptable. Use toggle switches for inputs A,B,C,D, and Ewhen
you test your circuit.
8.O Work Design Problem 8.A using two-, three-, and four-input NOR gates and invert-
ers instead of NAND gates and inverters.Any solution that uses 19 gates and invert-ers or fewer (not counting the four inverters for the inputs) is acceptable.
8.P Work Design Problem 8.F using two-, three-, and four-input NOR gates and inverters
instead of NAND gates and inverters.Any solution that uses 21 gates and inverters orfewer (not counting the four inverters for the inputs) is acceptable.
8.Q Work Design Problem 8.H using two-, three-, and four-input NOR gates and
inverters instead of NAND gates and inverters. Any solution that uses 17 gates andinverters or fewer (not counting the four inverters for the inputs) is acceptable.
8.R Work Design Problem 8.I using two-, three-, and four-input NOR gates and inverters
instead of NAND gates and inverters.Any solution that uses 16 gates and inverters orfewer (not counting the four inverters for the inputs) is acceptable.
8.S Design a “disk spinning” animation circuit for a CD player. The input to the circuit
will be a 3-bit binary number A
1A2A3provided by another circuit. It will count from
0 to 7 in binary, and then it will repeat. (You will learn to design such counters inUnit 12.) The animation will appear on the top four lights of the LED display ofFigure 8-14, i.e., on X
1,X2,X7, and X6, going clockwise.The animation should consist240 Unit 8
of a blank spot on a disk spinning around once, beginning with X1. Then, the entire
disk should blink on and off twice. The pattern is shown.Combinational Circuit Design and Simulation Using Gates 241
Design your circuit using only two-, three-, and four-input NOR gates and inverters.Try to minimize the number of gates required. Any solution which uses 11 or fewergates (not counting the four inverters for the inputs) is acceptable.
242Multiplexers, Decoders, and
Programmable Logic Devices
Objectives
1.Explain the function of a multiplexer. Implement a multiplexer using
gates.
2.Explain the operation of three-state buffers. Determine the resulting out-
put when three-state buffer outputs are connected together. Use three-state buffers to multiplex signals onto a bus.
3.Explain the operation of a decoder and encoder. Use a decoder with
added gates to implement a set of logic functions. Implement a decoderor priority encoder using gates.
4.Explain the operation of a read-only memory (ROM). Use a ROM to imple-
ment a set of logic functions.
5.Explain the operation of a programmable logic array (PLA). Use a PLA to
implement a set of logic functions. Given a PLA table or an internal con-nection diagram for a PLA, determine the logic functions realized.
6.Explain the operation of a programmable array logic device (PAL).
Determine the programming pattern required to realize a set of logicfunctions with a PAL.
7.Explain the operation of a complex programmable logic device (CPLD)
and a field-programmable gate array (FPGA).
8.Use Shannon’s expansion theorem to decompose a switching function.
UNIT
9
Multiplexers, Decoders, and Programmable Logic Devices 243
1.Read Section 9.1, Introduction .
2.Study Section 9.2, Multiplexers .
(a) Draw a logic circuit for a 2-to-1 multiplexer (MUX) using gates.
(b) Write the equation for a 4-to-1 MUX with control inputs Aand C.
Z/H11005___________________________________________
(c) By tracing signals on Figure 9-3, determine what will happen to ZifA/H110051,
B/H110050 and Cchanges from 0 to 1.
(d) Use three 2-to-1 MUXes to make a 4-to-1 MUX with control inputs A
and B. Draw the circuit. ( Hint: One MUX should have I0and I1inputs,
and another should have I2and I3inputs.)
(e) Observe that if A/H110050,A⊕B/H11005B, and that if A/H110051,A⊕B/H11005B/H11032. Using
this observation, construct an exclusive-OR gate using a 2-to-1 multi-plexer and one inverter.
(f) Work Problems 9.1 and 9.2.
(g) This section introduces bus notation. The bus symbol 
represents a group of four wires:
A
3—— —–————
A2—— —–————
A1—— —–————
A0—— —–————A4Study Guide
244 Unit 9
Draw the bus symbol for
B2—— —–————
B1—— —–————
B0—— —–————
(h) Represent the circuit of Figure 4-3 by one 4-bit full adder with two bus
inputs, one bus output, and terminals for carry input C0and output C4.
Note that the carries C3,C2, and C1will not appear on your circuit diagram
because they are signals internal to the 4-bit adder.
3.Study Section 9.3, Three-State Buffers .
(a) Determine the output of each three-state buffer:
1
10
11
00
11
0 Z 1 1
1
1
0
01
1
1
01
0
1
00
1
0
0(b) Determine the inputs for each three-state buffer (use Xif an input is a
don’t-care).
(c) Determine the output for each circuit. Use Xto represent an unknown
output.
(d) The symbol represents 2 three-state buffers with a common C
A B22
control input:
245Using bus notation, draw an equivalent circuit for:C
A1 B1
B0 A0
G
E2F2
F1 E1
F0 E0
4 4
4 4P0101
1100M
I0
ZI1
I2
I3(e) For the following circuit, determine the 4-bit output ( P) if M/H110050.
—— —–———— Repeat for M/H110051.—— —–————
(f) Specify the AND-gate inputs so that the given circuit is equivalent to the
4-to-1 MUX in Figure 9-2. ( Zin the following figure represents an output
terminal, not high impedance.)
(g) Work Problem 9.3.
4.Study Section 9.4, Decoders and Encoders .
(a) The 7442 4-to-10 line decoder (Figure 9-14) can be used as a 3-to-8 line
decoder. To do this, which three lines should be used as inputs?
________________________
The remaining input line should be set equal to ____________ .
(b) Complete the following table for a 4-to-2 priority encoder:
y0y1y2y3 abc
What will a,b, and cbe if y0y1y2y3is 0101?
(c) Work Problems 9.4, 9.5, and 9.6.
5.Study Section 9.5, Read-Only Memories .
(a) The following diagram shows the pattern of 0’s and 1’s stored in a ROM
with eight words and four bits per word. What will be the values of F1,F2,
F3, and F4ifA/H110050 and B/H11005C/H110051?
Give the minterm expansions for F1and F2:246 Unit 9
0
1
0
1
1
1
01
00
0
1DecoderA
B
C 1
01
10
1
0
1
00
0
1
01
0
0
0101
F
1
F2F3
F4
Fl/H11005
F2/H11005
(b) When asked to specify the size of a ROM, give the number of words and
the number of bits per word.What size ROM is required to realize four functions of 5 variables?
What size ROM is required to realize eight functions of 10 variables?
Multiplexers, Decoders, and Programmable Logic Devices 247
(c) When specifying the size of a ROM, assume that you are specifying a stan-
dard size ROM with 2nwords. What size ROM is required to convert 8-4-
2-1 BCD code to 2-out-of-5 code? (See Table 1-2, page 21.)
What size ROM would be required to realize the decoder given in
Figure 9-14?
(d) Draw an internal connection diagram for a ROM which would perform the
same function as the circuit of Figure 7-20. (Indicate the presence of switch-ing elements by dots at the intersection of the word lines and output lines.)
(e) Explain the difference between a mask-programmable ROM and an EEP-
ROM. Which would you use for a new design which had not yet beendebugged?
(f) Work Problem 9.7.
6.Study Section 9.6, Programmable Logic Devices .
(a) When you are asked to specify the size of a PLA, give the number of inputs,
the number of product terms, and the number of outputs.What size PLA would be required to realize Equations (7-22) if nosimplification of the minterm expansions were performed?
(b) If the realization of Equations (7-22) shown in Figure 7-20 were convert-
ed to a PLA realization, what size PLA would be required?
(c) Specify the contents of the PLA of question (b) in tabular form. Your table
should have four rows. (You will only need seven 1’s on the right side of yourtable. If you get eight 1’s, you are probably doing more work than is necessary.)
(d) Draw an internal connection diagram for the PLA of (b). (Use X’s to indi-
cate the presence of switching elements in the AND and OR arrays.)
(e) Given the following PLA table, plot maps for Z1,Z2, and Z3.
ABC Z1Z2Z3
–0 0 110
01– 11 010– 10 0111 01 10–1 10 1
000 00 1
(The Z1map should have six 1’s, Z2should have five, and Z3should have four.)
(f) For a truth table, any combination of input values will select exactly one
row. Is this statement true for a PLA table?
For any combination of input values, the output values from a PLA can be
determined by inspection of the PLA table. Consider Table 9-1, which repre-sents a PLA with three inputs and four outputs. If the inputs are ABC /H11005110,
which three rows in the table are selected?
In a given output column, what is the output if some of the selected rows
are 1’s and some are 0’s? (Remember that the output bits for the selectedrows are ORed together.)
When ABC /H11005110, what are the values of F
0F1F2F3at the PLA output?
When ABC /H11005010, which rows are selected and what are the values of
F0F1F2F3at the PLA output?
(g) Which interconnection points in Figure 9-28(a) must be set in order to
realize the function shown in Figure 9-28(b)?
(h) What size of PAL could be used to realize the 8-to-1 MUX of Figure 9-3?
The quad MUX of Figure 9-5? Give the number of inputs, the number ofOR gates, and the maximum number of inputs to an OR gate.
(i) Work Problems 9.8, 9.9, and 9.10.
7.Study Section 9.7, Complex Programmable Logic Devices .
Work Problem 9.11.
8.Study Section 9.8, Field-Programmable Gate Arrays .
(a) For the CLB of Figure 9-33, write a logic equation for Hin terms of F,G,
and H
1.248 Unit 9
Z1 Z2 Z301
00BCA
01
111001
00
01
11
1001
00
01
11
10
(b) How many 4-variable function generators are required to implement a
four-input OR gate? A 4-variable function with 13 minterms?
(c) Expand the function of Equation 9-7 about the variable cinstead of
a. Expand it algebraically and, then, expand it by using the Karnaugh
map of Figure 9-35. ( Hint: How should you split the map into two
halves?)
(d) Draw a diagram showing how to implement Equation 9-10 using four
function generators and a 4-to-1 MUX.
(e) In the worst case, how many 4-variable function generators are
required to realize a 7-variable function (assume the necessary MUXesare available).
(f) Show how to realize K/H11005abcdefg using only two 4-variable function genera-
tors. ( Hint: Use the output of one function generator as an input to the other.)
(g) Work Problems 9.12 and 9.13.
9.When you are satisfied that you can meet all of the objectives, take the readi-
ness test.Multiplexers, Decoders, and Programmable Logic Devices 249
Multiplexers, Decoders, and 
Programmable Logic Devices
2509.1 Introduction
Until this point we have mainly been concerned with basic principles of logic
design. We have illustrated these principles using gates as our basic buildingblocks. In this unit we introduce the use of more complex integrated circuits(ICs) in logic design. Integrated circuits may be classified as small-scale integra-tion (SSI), medium-scale integration (MSI), large-scale integration (LSI), orvery-large-scale integration (VLSI), depending on the number of gates in eachintegrated circuit package and the type of function performed. SSI functionsinclude NAND, NOR, AND, and OR gates, inverters, and flip-flops. SSI integrat-ed circuit packages typically contain one to four gates, six inverters, or one or twoflip-flops. MSI integrated circuits, such as adders, multiplexers, decoders, regis-ters, and counters, perform more complex functions. Such integrated circuits typ-ically contain the equivalent of 12 to 100 gates in one package. More complexfunctions such as memories and microprocessors are classified as LSI or VLSIintegrated circuits.An LSI integrated circuit generally contains 100 to a few thou-sand gates in a single package, and a VLSI integrated circuit contains severalthousand gates or more.
It is generally uneconomical to design digital systems using only SSI and MSI
integrated circuits. By using LSI and VLSI functions, the required number of inte-grated circuit packages is greatly reduced. The cost of mounting and wiring the inte-grated circuits as well as the cost of designing and maintaining the digital systemmay be significantly lower when LSI and VLSI functions are used.
This unit introduces the use of multiplexers, decoders, encoders, and three-
state buffers in logic design. Then read-only memories (ROMs) are described andused to implement multiple-output combinational logic circuits. Finally, othertypes of programmable logic devices (PLDs), including programmable logicarrays (PLAs), programmable array logic devices (PALs), complex programmablelogic devices (CPLDs), and field-programmable gate arrays (FPGAs) are intro-duced and used in combinational logic design.
Multiplexers, Decoders, and Programmable Logic Devices 251
9.2 Multiplexers
A multiplexer (or data selector, abbreviated as MUX) has a group of data inputs and a
group of control inputs. The control inputs are used to select one of the data inputs andconnect it to the output terminal. Figure 9-1 shows a 2-to-1 multiplexer and its switchanalog. When the control input Ais 0, the switch is in the upper position and the MUX
output is Z/H11005I
0; when Ais 1, the switch is in the lower position and the MUX output is
Z/H11005I1. In other words, a MUX acts like a switch that selects one of the data inputs ( I0
orI1) and transmits it to the output.The logic equation for the 2-to-1 MUX is therefore:
Z/H11005A/H11032I0/H11001AI1
2-to-1
MUXI0
I1
AZI0
I1
AZFIGURE 9-1
2-to-1 Multiplexer
and Switch Analog
4-to-1
MUXData
inputs
Control
inputsI0
I1
I2
I3
A BZ2n-to-1
MUX
ncontrol
inputs2ndata
linesZ
8-to-1
MUXI0
I1
I2
I3
I4
I5
I6
I7
ABCZ
......FIGURE 9-2
MultiplexersFigure 9-2 shows diagrams for a 4-to-1 multiplexer, 8-to-1 multiplexer, and 2n-to-1
multiplexer. The 4-to-1 MUX acts like a four-position switch that transmits one ofthe four inputs to the output. Two control inputs ( AandB) are needed to select one
of the four inputs. If the control inputs are AB/H1100500, the output is I
0; similarly, the
control inputs 01, 10, and 11 give outputs of I1,I2, and I3, respectively.The 4-to-1 mul-
tiplexer is described by the equation
Z/H11005A/H11032B/H11032I0/H11001A/H11032BI1/H11001AB/H11032I2/H11001ABI3 (9-1)
Similarly, the 8-to-1 MUX selects one of eight data inputs using three control inputs.
It is described by the equation
Z/H11005A/H11032B/H11032C/H11032I0/H11001A/H11032B/H11032CI1/H11001A/H11032BC/H11032I2/H11001A/H11032BCI3
/H11001AB/H11032C/H11032I4/H11001AB/H11032CI5/H11001ABC /H11032I6/H11001ABCI7 (9-2)
When the control inputs are ABC /H11005011, the output is I3, and the other outputs are
selected in a similar manner. Figure 9-3 shows an internal logic diagram for the 8-to-1 MUX. In general, a multiplexer with ncontrol inputs can be used to select any
one of 2
ndata inputs. The general equation for the output of a MUX with ncontrol
inputs and 2ndata inputs is
where mkis a minterm of the ncontrol variables and Ikis the corresponding data input.Z/H11005/H208582n/H110021
k/H110050mkIk252 Unit 9
a′b′c′I0a′b′cI1a′bc′I2a′b
ZcI3 ab′c′I4 ab′cI5 abc′I6 abc I7
2-to-1
x0z0
y02-to-1
x1z1
y12-to-1
x2z2
y2A (MUX control)
2-to-1
x3z3
y3FIGURE 9-4
Quad Multiplexer
Used to Select DataFIGURE 9-3
Logic Diagram for
8-to-1 MUX
Multiplexers are frequently used in digital system design to select the data which
is to be processed or stored. Figure 9-4 shows how a quadruple 2-to-1 MUX is usedto select one of two 4-bit data words. If the control is A/H110050, the values of x
0,x1,x2,
and x3will appear at the z0,z1,z2, and z3outputs; if A/H110051, the values of y0,y1,y2, and
y3will appear at the outputs.
Multiplexers, Decoders, and Programmable Logic Devices 253
2-to-14
44
XZ
YAFIGURE 9-5
Quad Multiplexer
with Bus Inputs and
OutputSeveral logic signals that perform a common function may be grouped together
to form a bus. For example, the sum outputs of a 4-bit binary adder can be groupedtogether to form a 4-bit bus. Instead of drawing the individual wires that make up abus, we often represent a bus by a single heavy line. The quad MUX of Figure 9-4is redrawn in Figure 9-5, using bus inputs Xand Y, and bus output Z. The Xbus
represents the four signals x
0,x1,x2, and x3, and similarly for the Yand Zbuses.
When A/H110050, the signals on bus Xappear on bus Z; otherwise, the signals on bus Y
appear.A diagonal slash through a bus with a number beside it specifies the numberof bits in the bus.
The preceding multiplexers do not invert the data inputs as they are routed
to the output. Some multiplexers do invert the inputs, e.g., if the OR gate inFigure 9-3 is replaced by a NOR gate, then the 8-to-1 MUX inverts the selectedinput. To distinguish between these two types of multiplexers, we will say that themultiplexers without the inversion have active high outputs, and the multiplexerswith the inversion have active low outputs.
Another type of multiplexer has an additional input called an enable . The 8-to-1
MUX in Figure 9-3 can be modified to include an enable by changing the ANDgates to five-input gates. The enable signal Eis connected to the fifth input of each
of the AND gates. Then, if E/H110050,Z/H110050 independent of the gate inputs I
iand the
select inputs a,b, and c. However, if E/H110051, then the MUX functions as an ordinary
8-to-1 multiplexer. The terminology used for the MUX output, i.e., active high andactive low, can be used for the enable as well. As described above, the enable isactive high; Emust be 1 for the MUX to function as a multiplexer. If an inverter is
inserted between Eand the AND gates, Emust be 0 for the MUX to function as a
multiplexer; the enable is active low.
Four combinations of multiplexers with an enable are possible. The output can
be active high or active low, whereas the enable can be active high or active low. Ina block diagram for the MUX, an active low line is indicated by inserting a bubbleon the line to indicate the inclusion of an inversion.
9.3 Three-State Buffers
A gate output can only be connected to a limited number of other device inputs with-out degrading the performance of a digital system. A simple buffer may be used toincrease the driving capability of a gate output. Figure 9-6 shows a buffer connected
between a gate output and several gate inputs. Because no bubble is present at the
buffer output, this is a noninverting buffer, and the logic values of the buffer input andoutput are the same, that is, F/H11005C.
Normally, a logic circuit will not operate correctly if the outputs of two or
more gates or other logic devices are directly connected to each other. For exam-ple, if one gate has a 0 output (a low voltage) and another has a 1 output (a highvoltage), when the gate outputs are connected together the resulting output volt-age may be some intermediate value that does not clearly represent either a 0 ora 1. In some cases, damage to the gates may result if the outputs are connectedtogether.
Use of three-state logic permits the outputs of two or more gates or other logic
devices to be connected together. Figure 9-7 shows a three-state buffer and its logi-cal equivalent. When the enable input Bis 1, the output Cequals A; when Bis 0, the
output Cacts like an open circuit. In other words, when Bis 0, the output Cis effec-
tively disconnected from the buffer output so that no current can flow. This is oftenreferred to as a Hi-Z (high-impedance) state of the output because the circuit offersa very high resistance or impedance to the flow of current. Three-state buffers arealso called tri-state buffers.254 Unit 9
...A
BC FFIGURE 9-6
Gate Circuit with
Added Buffer
A CB
A CB FIGURE 9-7
Three-State Buffer
Figure 9-8 shows the truth tables for four types of three-state buffers. In Figures
9-8(a) and (b), the enable input Bis not inverted, so the buffer output is enabled
when B/H110051 and disabled when B/H110050. That is, the buffer operates normally when B
/H110051, and the buffer output is effectively an open circuit when B/H110050.We use the sym-
bolZto represent this high-impedance state. In Figure 9-8(b), the buffer output is
inverted so that C/H11005A/H11032when the buffer is enabled. The buffers in 9-8(c) and (d)
operate the same as in (a) and (b) except that the enable input is inverted, so thebuffer is enabled when B/H110050.
In Figure 9-9, the outputs of two three-state buffers are tied together. When B/H110050,
the top buffer is enabled, so that D/H11005A; when B/H110051, the lower buffer is enabled, so
that D/H11005C. Therefore, D/H11005B/H11032A/H11001BC. This is logically equivalent to using a 2-to-1
multiplexer to select the Ainput when B/H110050 and the Cinput when B/H110051.
When we connect two three-state buffer outputs together, as shown in Figure 9-10,
if one of the buffers is disabled (output /H11005Z), the combined output Fis the same as the
other buffer output. If both buffers are disabled, the output is Z. If both buffers are
enabled, a conflict can occur. If A/H110050 and C/H110051, we do not know what the hardware
will do, so the Foutput is unknown ( X). If one of the buffer inputs is unknown, the
Foutput will also be unknown. The table in Figure 9-10 summarizes the operation of
the circuit. S1 and S2 represent the outputs the two buffers would have if they were notconnected together. When a bus is driven by three-state buffers, we call it a three-statebus. The signals on this bus can have values of 0, 1, Z, and perhaps X.
A multiplexer may be used to select one of several sources to drive a device
input. For example, if an adder input must come from four different sources, a 4-to-1 MUX may be used to select one of the four sources. An alternative is toMultiplexers, Decoders, and Programmable Logic Devices 255
A CB
ACB
ACB
A CB FIGURE 9-8
Four Kinds of
Three-State Buffers
BA C B A C BA C BA C
00 Z 0 0 Z 00 0 00 1
01 Z 0 1 Z 01 1 01 010 0 1 0 1 10 Z 10 Z11 1 1 1 0 11 Z 11 Z
(a) (b) (c) (d)
2-to-1
MUX0
1A
C
BDA
CBDFIGURE 9-9
Data Selection
Using Three-State
Buffers
AB
S1
S2D
CFFIGURE 9-10
Circuit with Two
Three-State BuffersS2
S1 X 0 1 Z
XX X X X
0X 0 X 01X X 1 1ZX 0 1 Z
set up a three-state bus, using three-state buffers to select one of the sources (see
Figure 9-11). In this circuit, each buffer symbol actually represents four three-state buffers that have a common enable signal.
Integrated circuits are often designed using bi-directional pins for input and out-
put. Bi-directional means that the same pin can be used as an input pin and as anoutput pin, but not both at the same time. To accomplish this, the circuit output isconnected to the pin through a three-state buffer, as shown in Figure 9-12.When thebuffer is enabled, the pin is driven with the output signal. When the buffer is dis-abled, an external source can drive the input pin.256 Unit 9
EnA
4
AEnB
4
BEnC
4
CEnD4-bit
adder
4444
DE
Sum
CoutFIGURE 9-11
4-Bit Adder with
Four Sources for
One Operand
Integrated
Logic
CircuitOutputEN
Bi-Directional
Input-Output PinInputFIGURE 9-12
Integrated Circuit
with Bi-Directional
Input-Output Pin
y0 = a′b′c′
y1 = a′b′c
y2 = a′bc′
y3 = a′bc
y4 = ab′c′
y5 = ab′c
y6 = abc′
y7 = abc3-to-8
line
decodera
b
cFIGURE 9-13
A 3-to-8 Line
Decoderabc y0y1y2y3y4y5y6y7
0 0 0 10000000
0 0 1 010000000 1 0 001000000 1 1 000100001 0 0 00001000
1 0 1 00000100
1 1 0 000000101 1 1 000000019.4 Decoders and Encoders
The decoder is another commonly used type of integrated circuit. Figure 9-13 shows
the diagram and truth table for a 3-to-8 line decoder. This decoder generates all ofthe minterms of the three input variables. Exactly one of the output lines will be 1for each combination of the values of the input variables.
Multiplexers, Decoders, and Programmable Logic Devices 257
Figure 9-14 illustrates a 4-to-10 decoder. This decoder has inverted outputs
(indicated by the small circles). For each combination of the values of the inputs,exactly one of the output lines will be 0. When a binary-coded-decimal digit isused as an input to this decoder, one of the output lines will go low to indicatewhich of the 10 decimal digits is present.
FIGURE 9-14
A 4-to-10 Line
Decoder
9 8 7 6 5 4 3 2 1 0D C B A
Outputs
7442
(b) Block diagram(a) Logic diagram
ABCDInputs
m9m8m7m6m5m4m3m2m1m0′′′′′′′′′′BCD Input Decimal Output
ABCD 0123456789
0000 0111111111
0001 10111111110010 1101111111
0011 1110111111
0100 11110111110101 11111011110110 11111101110111 1111111011
1000 1111111101
1001 11111111101010 11111111111011 11111111111100 1111111111
1101 1111111111
1110 1111111111
1111 1111111111
(c) Truth Table
258 Unit 9
In general, an n-to-2nline decoder generates all 2nminterms (or maxterms) of
theninput variables. The outputs are defined by the equations
yi/H11005mi, i/H110050 to 2n/H110021 (noninverted outputs) (9-3)
or
yi/H11005mi/H11032/H11005Mi, i/H110050 to 2n/H110021 (inverted outputs) (9-4)
where miis a minterm of the ninput variables and Miis a maxterm.
Because an n-input decoder generates all of the minterms of nvariables, n-variable
functions can be realized by ORing together selected minterm outputs from a decoder.If the decoder outputs are inverted, then NAND gates can be used to generate thefunctions, as illustrated in the following example. Realize
f
1(a,b,c,d)/H11005m1/H11001m2/H11001m4and f2(a,b,c,d)/H11005m4/H11001m7/H11001m9
using the decoder of Figure 9-14. Rewriting f1and f2, we have
f1/H11005(m1/H11032m2/H11032m4/H11032)/H11032 f2/H11005(m4/H11032m7/H11032m9/H11032)/H11032
Then f1and f2can be generated using NAND gates, as shown in Figure 9-15.
An encoder performs the inverse function of a decoder. Figure 9-16 shows an
8-to-3 priority encoder with inputs y0through y7. If input yiis 1 and the other inputs
are 0, then the abcoutputs represent a binary number equal to i. For example, if y3/H110051,
then abc/H11005011. If more than one input can be 1 at the same time, the output can be
defined using a priority scheme. The truth table in Figure 9-16 uses the following
FIGURE 9-15
Realization of a
Multiple-Output
Circuit Using a
Decoder
4-to-10
Line
Decoder0
1
2
3
4
5
6
7
8
9m1′
′
′
′
′f1
f2m2
m4
m7
m9a
b
c
d
FIGURE 9-16
An 8-to-3 Priority
Encoder
8-to-3
Priorit y
Encodera
b
c
dy0
y1
y2
y3
y4
y5
y6
y7y0y1y2y3y4y5y6y7 abc d
00000000 0 0 0 0
10000000 0 0 0 1
X1000000 0 0 1 1
X X100000 0 1 0 1
X XX10000 0 1 1 1XXXX1 0 0 0 100 1XXXXX1 0 0 101 1XXXXXX10 1 1 0 1XXXXXXX1 1 1 1 1
Multiplexers, Decoders, and Programmable Logic Devices 259
scheme: If more than one input is 1, the highest numbered input determines the out-
put. For example, if inputs y1,y4, and y5are 1, the output is abc/H11005101. The X’s in the
table are don’t-cares; for example, if y5is 1, we do not care what inputs y0through y4
are. Output dis 1 if any input is 1, otherwise, dis 0. This signal is needed to distin-
guish the case of all 0 inputs from the case where only y0is 1.
9.5 Read-Only Memories
A read-only memory (ROM) consists of an array of semiconductor devices that are
interconnected to store an array of binary data. Once binary data is stored in theROM, it can be read out whenever desired, but the data that is stored cannot bechanged under normal operating conditions. Figure 9-17(a) shows a ROM which hasthree input lines and four output lines. Figure 9-17(b) shows a typical truth table whichrelates the ROM inputs and outputs. For each combination of input values on thethree input lines, the corresponding pattern of 0’s and 1’s appears on the ROM out-put lines. For example, if the combination ABC /H11005010 is applied to the input lines, the
pattern F
0F1F2F3/H110050111 appears on the output lines. Each of the output patterns that
is stored in the ROM is called a word . Because the ROM has three input lines, we have
23/H11005eight different combinations of input values. Each input combination serves as
anaddress which can select one of the eight words stored in the memory. Because
there are four output lines, each word is four bits long, and the size of this ROM is8 words /H110034 bits.
A ROM which has ninput lines and moutput lines (Figure 9-18) contains an array
of 2
nwords, and each word is mbits long. The input lines serve as an address to select
one of the 2nwords. When an input combination is applied to the ROM, the pattern
of 0’s and 1’s which is stored in the corresponding word in the memory appears at theoutput lines. For the example in Figure 9-18, if 0 0...1 1  i s  applied to the input (address
lines) of the ROM, the word 110 . . . 010 will be selected and transferred to the output
lines.A 2
n/H11003mROM can realize mfunctions of nvariables because it can store a truth
table with 2nrows and mcolumns. Typical sizes for commercially available ROMs
range from 32 words /H110034 bits to 512K words /H110038 bits, or larger.
FIGURE 9-17
An 8-Word /H110034-Bit
ROMROM
8 Words
× 4 Bits
Four Output LinesThree Input
LinesA
B
C
F0F1F2F3AB C F0F1F2F3
00 0 1 0 1 0
00 1 1 0 1 001 0 0 1 1 1
01 1 0 1 0 1
10 0 1 1 0 010 1 0 0 0 111 0 1 1 1 111 1 0 1 0 1
¯˚˚˚˚˘˚˚˚˚˙Typical DataStored inROM
(2
3words of
4 bits each)
(b) Truth table for ROM(a) Block diagram
260 Unit 9
A ROM basically consists of a decoder and a memory array, as shown in Figure 9-19.
When a pattern of n0’s and 1’s is applied to the decoder inputs, exactly one of the 2n
decoder outputs is 1. This decoder output line selects one of the words in the memory
array, and the bit pattern stored in this word is transferred to the memory output lines.
Figure 9-20 illustrates one possible internal structure of the 8-word /H110034-bit ROM
shown in Figure 9-17.The decoder generates the eight minterms of the three input vari-ables. The memory array forms the four output functions by ORing together selectedminterms.A switching element is placed at the intersection of a word line and an output
lineif the corresponding minterm is to be included in the output function; otherwise,
the switching element is omitted (or not connected). If a switching element connectsan output line to a word line which is 1, the output line will be 1. Otherwise, the pull-down resistors at the top of Figure 9-20 cause the output line to be 0. So the switchingelements which are connected in this way in the memory array effectively form anOR gate for each of the output functions. For example, m
0,ml,m4, and m6are ORed
together to form F0. Figure 9-21 shows the equivalent OR gate.
In general, those minterms which are connected to output line Fby switching
elements are ORed together to form the output Fi. Thus, the ROM in Figure 9-20
generates the following functions:
F0/H11005/H9018 m(0, 1, 4, 6) /H11005A/H11032B/H11032/H11001AC/H11032
F1/H11005/H9018 m(2, 3, 4, 6, 7) /H11005B/H11001AC/H11032
F2/H11005/H9018 m(0, 1, 2, 6) /H11005A/H11032B/H11032/H11001BC/H11032 (9-5)
F3/H11005/H9018 m(2, 3, 5, 6, 7) /H11005AC/H11001BFIGURE 9-18
Read-Only Memory
with nInputs and
mOutputsROM
2n Words
×m Bits
m Output Linesn Input
Lines
......nInput mOutput
Variables Variables
00 · · · 00 100 · · · 110
00 · · · 01 010 · · · 11100 · · · 10 101 · · · 101
00 · · · 11 110 · · · 010
11 · · · 00 001 · · · 011
11 · · · 01 110 · · · 11011 · · · 10 011 · · · 000
11 · · · 11 111 · · · 101
···
···
¯˚˚˚˚˚˘˚˚˚˚˚˙Typical Data
Array Storedin ROM(2
nwords of
mbits each)
Decodern Input
LinesMemor y Arra y
2n Words ×m BitsROM
m Output Lines......
...FIGURE 9-19
Basic ROM
Structure
Multiplexers, Decoders, and Programmable Logic Devices 261
The contents of a ROM are usually specified by a truth table. The truth table of
Figure 9-17(b) specifies the ROM in Figure 9-20. Note that a 1 or 0 in the output partof the truth table corresponds to the presence or absence of a switching element in thememory array of the ROM.
Multiple-output combinational circuits can easily be realized using ROMs.As an
example, we will realize a code converter that converts a 4-bit binary number to ahexadecimal digit and outputs the 7-bit ASCII code. Figure 9-22 shows the truthtable and logic circuit for the converter. Because A
5/H11005A4, and A6/H11005A4/H11032, the ROM
needs only five outputs. Because there are four address lines, the ROM size is 16words by 5 bits. Columns A
4A3A2A1A0of the truth table are stored in the ROM.
Figure 9-23 shows an internal diagram of the ROM. The switching elements at theintersections of the rows and columns of the memory array are indicated using X’s.
AnXindicates that the switching element is present and connected, and no Xindi-
cates that the corresponding element is absent or not connected.
Three common types of ROMs are mask-programmable ROMs, programmable
ROMs (PROMs), and electrically erasable programmable ROMs (EEPROMs). Atthe time of manufacture, the data array is permanently stored in a mask-programma-ble ROM. This is accomplished by selectively including or omitting the switching ele-ments at the row-column intersections of the memory array.This requires preparationFIGURE 9-20
An 8-Word /H110034-Bit
ROM
Word
Lines
F0m7 = ABCm6 = ABC ′m5 = AB′Cm4 = AB′C′m3 = A′BCm2 = A′BC′m1 = A′B′C
F1 F2 F3m0 = A′B′C′
3-to-8
Decoder
Switching
Element
Output
LinesA
B
C
m0m1m4m6F0FIGURE 9-21
Equivalent OR Gate
forF0
262 Unit 9
of a special mask , which is used during fabrication of the integrated circuit.
Preparation of this mask is expensive, so the use of mask-programmable ROMs iseconomically feasible only if a large quantity (typically several thousand or more) isrequired with the same data array. If a small quantity of ROMs is required with agiven data array, EEPROMs may be used.
Modification of the data stored in a ROM is often necessary during the
developmental phases of a digital system, so EEPROMs are used instead ofmask-programmable ROMs. EEPROMs use a special charge-storage mecha-nism to enable or disable the switching elements in the memory array. A PROMprogrammer is used to provide appropriate voltage pulses to store electroniccharges in the memory array locations. Data stored in this manner is generallyROMA6
A5
A4
A3
A2
A1ZYXW
A0Input Hex ASCII Code for Hex Digit
WXYZ Digit A6A5A4A3A2A1A0
0 0 0 0 0 0110000
0 0 0 1 1 01100010 0 1 0 2 0110010
0 0 1 1 3 0110011
0 1 0 0 4 01101000 1 0 1 5 01101010 1 1 0 6 01101100 1 1 1 7 0110111
1 0 0 0 8 0111000
1 0 0 1 9 01110011 0 1 0 A 10000011 0 1 1 B 10000101 1 0 0 C 1000011
1 1 0 1 D 1000100
1 1 1 0 E 10001011 1 1 1 F 1000110FIGURE 9-22
Hexadecimal-to-
ASCII Code
Converter
FIGURE 9-23
ROM Realization of
Code Converter
4-to-16
Decoder
ROM OutputsROM
Inputs
ZYXW
A4m15m14m13m12m11m10m9m8m7m6m5m4m3m2m1m0
A3 A2 A1 A0
Multiplexers, Decoders, and Programmable Logic Devices 263
permanent until erased. After erasure, a new set of data can be stored in the
EEPROM. An EEPROM can be erased and reprogrammed only a limited num-ber of times, typically 100 to 1000 times. Flash memories are similar toEEPROMs, except that they use a different charge-storage mechanism. Theyusually have built-in programming and erase capability so that data can be writ-ten to the flash memory while it is in place in a circuit without the need for aseparate programmer.
9.6 Programmable Logic Devices
A programmable logic device (or PLD) is a general name for a digital integrated cir-cuit capable of being programmed to provide a variety of different logic functions. Inthis section we will discuss several types of combinational PLDs, and later we will dis-cuss sequential PLDs. Simple combinational PLDs are capable of realizing from 2 to10 functions of 4 to 16 variables with a single integrated circuit. More complex PLDsmay contain thousands of gates and flip-flops. Thus, a single PLD can replace a largenumber of integrated circuits, and this leads to lower cost designs.When a digital sys-tem is designed using a PLD, changes in the design can easily be made by changingthe programming of the PLD without having to change the wiring in the system.
Programmable Logic Arrays
A programmable logic array (PLA) performs the same basic function as a ROM. APLA with ninputs and moutputs (Figure 9-24) can realize mfunctions of nvari-
ables. The internal organization of the PLA is different from that of the ROM. Thedecoder is replaced with an AND array which realizes selected product terms of theinput variables. The OR array ORs together the product terms needed to form theoutput functions, so a PLA implements a sum-of-products expression, while a ROMdirectly implements a truth table.
Figure 9-25 shows a PLA which realizes the same functions as the ROM of Figure
9-20. Product terms are formed in the AND array by connecting switching elementsat appropriate points in the array. For example, to form A/H11032B/H11032, switching elements are
used to connect the first word line with the A/H11032and B/H11032lines. Switching elements are
AND
Arra yn Input
Lines
k Word
LinesOR
Arra yPLA
m Output Lines......
...FIGURE 9-24
Programmable
Logic Array
Structure
264 Unit 9
connected in the OR array to select the product terms needed for the output func-
tions. For example, because F0/H11005A/H11032B/H11032/H11001AC/H11032, switching elements are used to con-
nect the A/H11032B/H11032and AC/H11032lines to the F0line. The connections in the AND and OR
arrays of this PLA make it equivalent to the AND-OR array of Figure 9-26.
The contents of a PLA can be specified by a PLA table.Table 9-1 specifies the PLA
in Figure 9-25. The input side of the table specifies the product terms. The symbols 0, l,F3F2 F1
OutputsF0A′B′A′ABC
B′ C′
AC′
B
BC′
AC+VInputs
+V
+V
+V
+VFIGURE 9-25
PLA with Three 
Inputs, Five Product
Terms, and Four
Outputs
A
A′B′B
AC′
B
BC′
AC
F0 F1 F2 F3C
AND Arra yOR Arra yFIGURE 9-26
AND-OR Array
Equivalent to
Figure 9-25
Multiplexers, Decoders, and Programmable Logic Devices 265
and – indicate whether a variable is complemented, not complemented, or not present
in the corresponding product term. The output side of the table specifies which prod-uct terms appear in each output function. A 1 or 0 indicates whether a given productterm is present or not present in the corresponding output function. Thus, the first rowof Table 9-1 indicates that the term A/H11032B/H11032is present in output functions F
0andF2, and
the second row indicates that AC/H11032is present in F0andF1.
Next, we will realize Equations (7-23) using a PLA. Using the minimum multiple-
output solution given in Equations (7-23b), we can construct a PLA table, Figure 9-27(a),with one row for each distinct product term. Figure 9-27(b) shows the correspondingPLA structure, which has four inputs, six product terms, and three outputs. A dot at theintersection of a word line and an input or output line indicates the presence of a switch-ing element in the array.Product Inputs Outputs
Term ABC F0F1F2F3
A/H11032B/H11032 00– 1010 F0/H11005A/H11032B/H11032/H11001AC/H11032
AC/H11032 1– 0 1100 F1/H11005AC/H11032/H11001B
B –1 – 0101 F2/H11005A/H11032B/H11032/H11001BC/H11032
BC/H11032 –1 0 0010 F3/H11005B/H11001AC
AC 1– 1 0001TABLE 9-1
PLA Table for
Figure 9-25
a b c d
F1a′bd
abd
ab′c′
b′c
c
bc
F2F3Inputs
Outputs
(b) PLA structureWord
LinesFIGURE 9-27
PLA Realization of
Equations (7-23b)abcd f1f2f3
01–1 110
11–1 101
100– 101–01– 100––1– 010
–11– 001
(a) PLA table
266 Unit 9
A PLA table is significantly different than a truth table for a ROM. In a truth
table each row represents a minterm; therefore, exactly one row will be selected byeach combination of input values. The 0’s and 1’s of the output portion of theselected row determine the corresponding output values. On the other hand, eachrow in a PLA table represents a general product term. Therefore, zero, one, ormore rows may be selected by each combination of input values. To determine thevalue of f
ifor a given input combination, the values of fiin the selected rows of the
PLA table must be ORed together. The following examples refer to the PLA tableof Figure 9-27(a). If abcd /H110050001, no rows are selected, and all f’s are 0. If abcd /H11005
1001, only the third row is selected, and f
1f2f3/H11005101. If abcd /H110050111, the first, fifth,
and sixth rows are selected. Therefore, fl/H110051/H110010/H110010/H110051,f2/H110051/H110011/H110010/H110051, and
f3/H110050/H110010/H110011/H110051.
Both mask-programmable and field-programmable PLAs are available. The
mask-programmable type is programmed at the time of manufacture in a mannersimilar to mask-programmable ROMs. The field-programmable logic array(FPLA) has programmable interconnection points that use electronic charges tostore a pattern in the AND and OR arrays. An FPLA with 16 inputs, 48 productterms, and eight outputs can be programmed to implement eight functions of 16variables, provided that the total number of product terms does not exceed 48.
When the number of input variables is small, a PROM may be more economi-
cal to use than a PLA. However, when the number of input variables is large, PLAsoften provide a more economical solution than PROMs. For example, to realizeeight functions of 24 variables would require a PROM with over 16 million 8-bitwords. Because PROMs of this size are not readily available, the functions wouldhave to be decomposed so that they could be realized using a number of smallerPROMs. The same eight functions of 24 variables could easily be realized using asingle PLA, provided that the total number of product terms is small. If more termsare required, the outputs of several PLAs can be ORed together.
Programmable Array Logic
The PAL (programmable array logic) is a special case of the programmable logicarray in which the AND array is programmable and the OR array is fixed.The basicstructure of the PAL is the same as the PLA shown in Figure 9-24. Because only theAND array is programmable, the PAL is less expensive than the more general PLA,and the PAL is easier to program. For this reason, logic designers frequently usePALs to replace individual logic gates when several logic functions must be realized.
Figure 9-28(a) represents a segment of an unprogrammed PAL. The symbol
Noninverted Outpu t
Inverted Output
represents an input buffer which is logically equivalent to
Multiplexers, Decoders, and Programmable Logic Devices 267
A buffer is used because each PAL input must drive many AND gate inputs. When
the PAL is programmed, some of the interconnection points are programmed tomake the desired connections to the AND gate inputs. Connections to the ANDgate inputs in a PAL are represented by X’s as shown:
AC
B
CA B C A B CB A
As an example, we will use the PAL segment of Figure 9-28(a) to realize the
function I1I/H110322/H11001I/H110321I2. The X’s in Figure 9-28(b) indicate that I1and I/H110322lines are con-
nected to the first AND gate, and the I/H110321andI2lines are connected to the other gate.
When designing with PALs, we must simplify our logic equations and try to fit
them into one (or more) of the available PALs. Unlike the more general PLA, theAND terms cannot be shared among two or more OR gates; therefore, each func-tion to be realized can be simplified by itself without regard to common terms. Fora given type of PAL, the number of AND terms that feed each output OR gate isfixed and limited. If the number of AND terms in a simplified function is too large,we may be forced to choose a PAL with more gate inputs and fewer outputs.
I1
I2F1
Output
(a) UnprogrammedF4
F5
F8
I1
I1I2 + I1I2′′
I2
(b) ProgrammedFIGURE 9-28
PAL Segment
268 Unit 9
9.7 Complex Programmable Logic Devices
As integrated circuit technology continues to improve, more and more gates can be
placed on a single chip. This has allowed the development of complex programma-ble logic devices (CPLDs). Instead of a single PAL or PLA on a chip, many PALsor PLAs can be placed on a single CPLD chip and interconnected. When storageelements such as flip-flops are also included on the same IC, a small digital systemcan be implemented with a single CPLD.
Figure 9-30 shows the basic architecture of a Xilinx XCR3064XL CPLD. This
CPLD has four function blocks, and each block has 16 associated macrocells (MC1,MC2, . . .). Each function block is a programmable AND-OR array that is configuredas a PLA. Each macrocell contains a flip-flop and multiplexers that route signals fromthe function block to the input-output (I/O) block or to the interconnect array (IA).The IA selects signals from the macrocell outputs or I/O blocks and connects themback to function block inputs. Thus, a signal generated in one function block can beused as an input to any other function block. The I/O blocks provide an interfacebetween the bi-directional I/O pins on the IC and the interior of the CPLD.
Figure 9-31 shows how a signal generated in the PLA is routed to an I/O pin
through a macrocell. Any of the 36 outputs from the IA (or their complements) canX
Cin
Sum
CoutYFIGURE 9-29
Implementation of
a Full Adder Using
a PALAs an example of programming a PAL, we will implement a full adder. The
logic equations for the full adder are
Sum /H11005X/H11032Y/H11032Cin/H11001X/H11032YC/H11032in/H11001XY/H11032C/H11032in/H11001XYCin
Cout/H11005XCin/H11001YCin/H11001XY
Figure 9-29 shows a section of a PAL where each OR gate is driven by four AND
gates. The X’s on the diagram show the connections that are programmed into the
PAL to implement the full adder equations. For example, the first row of X’s
implements the product term X/H11032Y/H11032Cin.
Multiplexers, Decoders, and Programmable Logic Devices 269
be connected to any inputs of the 48 AND gates. Each OR gate can accept up to 48
product term inputs from the AND array.The macrocell logic in this diagram is a sim-plified version of the actual logic. The first MUX (1) can be programmed to select theOR-gate output or its complement. Details of the flip-flop operation will be discussedin Unit 11. The MUX (2) at the output of the macrocell can be programmed to selecteither the combinational output ( G) or the flip-flop output ( Q). This output goes to
the interconnect array and to the output cell. The output cell includes a three-statebuffer (3) to drive the I/O pin. The buffer enable input can be programmed from sev-eral sources. When the I/O pin is used as an input, the buffer must be disabled.
Sophisticated CAD software is available for fitting logic circuits into a PLD and
for programming the interconnections within the PLD. The input to this softwarecan be in several forms such as a logic circuit diagram, a set of logic equations, orcode written in a hardware description language (HDL). Unit 10 discusses the useof an HDL. The CAD software processes the input, determines the logic equationsto be implemented, fits these equations into the PLD, determines the required inter-connections within the PLD, and generates a bit pattern for programming the PLD.16 16
16 16MC1
MC2
MC16FUNCTION
BLOCK
Interconnect
Arra y
(IA)FUNCTION
BLOCKI/OI/O PinsI/O...MC1
MC2
MC16
......
...36 36
16 16
16 16MC1
MC2
MC16FUNCTION
BLOCKFUNCTION
BLOCKI/O I/O...MC1
MC2
MC16
......
...36 36FIGURE 9-30 Architecture of Xilinx XCR3064XL CPLD (Figure based on figures and text owned by Xilinx, Inc.,
Courtesy of Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
One of 16 OR Gates
Part of PLA Simplified Macrocell Output Cell48 AND Gates36 Inputs From IA
...
...
... ...
...123
I/O PinTo IA To IA
D
CE
CKQProgrammable
Select
Flip-FlopProgrammable
EnableGFFIGURE 9-31
CPLD Function
Block and
Macrocell
(A Simplified
Version of
XCR3064XL)
270 Unit 9
9.8 Field-Programmable Gate Arrays
In this section we introduce the use of field-programmable gate arrays (FPGAs) in
combinational logic design. An FPGA is an IC that contains an array of identicallogic cells with programmable interconnections.The user can program the functionsrealized by each logic cell and the connections between the cells. Figure 9-32 showsthe layout of part of a typical FPGA. The interior of the FPGA consists of an arrayof logic cells, also called configurable logic blocks (CLBs). The array of CLBs is sur-rounded by a ring of input-output interface blocks. These I/O blocks connect theCLB signals to IC pins. The space between the CLBs is used to route connectionsbetween the CLB outputs and inputs.
Figure 9-33 shows a simplified version of a CLB. This CLB contains two function
generators, two flip-flops, and various multiplexers for routing signals within the CLB.Each function generator has four inputs and can implement any function of up to fourvariables. The function generators are implemented as lookup tables (LUTs). A four-input LUT is essentially a reprogrammable ROM with 16 1-bit words. This ROMstores the truth table for the function being generated. The Hmultiplexer selects
either ForGdepending on the value of H
1. The CLB has two combinational outputs
Interconnect AreaConfigurable Logic Block I/O BlockFIGURE 9-32
Layout of a Typical
FPGA
Multiplexers, Decoders, and Programmable Logic Devices 271
(XandY) and two flip-flop outputs ( XQandYQ). The XandYoutputs and the flip-
flop inputs are selected by programmable multiplexers. The select inputs to theseMUXes are programmed when the FPGA is configured. For example, the Xoutput
can come from the Ffunction generator, and the Youtput from the Hmultiplexer.
Operation of the CLB flip-flops will be described in Unit 11.
Figure 9-34 shows one way to implement a function generator with inputs a,b,c,d.
The numbers in the squares represent the bits stored in the LUT. These bits enableparticular minterms. Because the function being implemented is stored as a truth table,a function with only one minterm or with as many as 15 minterms requires a singlefunction generator. The functions
F/H11005abc
and
F/H11005a/H11032b/H11032c/H11032d/H11001a/H11032b/H11032cd/H11001a/H11032bc/H11032d/H11001a/H11032bcd/H11032/H11001ab/H11032c/H11032d/H11001ab/H11032cd/H11032/H11001abc/H11032d/H11032/H11001abcd
each require a single function generator.HLUT
GG4 YQ
XQY
XG3
G2DSR
Q
CK
CE
G1
H1
LUT
= Programmable MUXFF4
F3
F2
F1DSR
Q
CK
CEFIGURE 9-33
Simplified
Configurable Logic
Block (CLB)
...
...0
b′a′
c′
d′
1
b′a′
c′
dF
1
ba
c
dabcd F
0000 0
0001 1
1111 1
······FIGURE 9-34
Implementation of
a Lookup Table
(LUT)
Decomposition of Switching Functions
In order to implement a switching function of more than four variables using 4-
variable function generators, the function must be decomposed into subfunctionswhere each subfunction requires only four variables. One method of decomposition
272 Unit 9
is based on Shannon’s expansion theorem. We will first illustrate this theorem by
expanding a function of the variables a,b,c, and dabout the variable a:
f(a,b,c,d)/H11005a/H11032f(0,b,c,d)/H11001a f(1,b,c,d)/H11005a/H11032f0/H11001a f1 (9-6)
The 3-variable function f0/H11005f(0,b,c,d) is formed by replacing awith 0 in f(a,b,c,d),
and f1/H11005f(1,b,c,d) is formed by replacing awith 1 in f(a,b,c,d). To verify that
Equation (9-6) is correct, first set ato 0 on both sides, and then set ato 1 on both sides.
An example of applying Equation (9-6) is as follows:
f(a,b,c,d)/H11005c/H11032d/H11032/H11001a/H11032b/H11032c/H11001bcd/H11001ac/H11032 (9-7)
/H11005a/H11032(c/H11032d/H11032/H11001b/H11032c/H11001bcd)/H11001a(c/H11032d/H11032/H11001bcd/H11001c/H11032)
/H11005a/H11032(c/H11032d/H11032/H11001b/H11032c/H11001cd)/H11001a(c/H11032/H11001bd)/H11005a/H11032f0/H11001a f1
Note that before simplification, the terms c/H11032d/H11032and bcd appear in both f0and f1
because neither term contains a/H11032ora.
Expansion can also be accomplished using a truth table or a Karnaugh map.
Figure 9-35 shows the map for Equation (9-7). The left half of the map where a/H110050 is
in effect a 3-variable map for f0(b,c,d). Looping terms on the left half gives f0/H11005c/H11032d/H11032/H11001
b/H11032c/H11001cd, which is the same as the previous result. Similarly the right half where a/H110051
is a 3-variable map for f1(b,c,d), and looping terms on the right half gives f1/H11005c/H11032/H11001bd.
The expressions for f0and f1obtained from the map are the same as those obtained
algebraically in Equation (9-7).
The general form of Shannon’s expansion theorem for expanding an n-variable
function about the variable xiis
f(x1,x2,..., xi/H110021,xi,xi/H110011,..., xn)
/H11005xi/H11032f(x1,x2,..., xi/H110021,0 ,xi/H110011,..., xn)/H11001xif(x1,x2,..., xi/H110021,1 ,xi/H110011,..., xn)
/H11005xi/H11032f0/H11001xif1 (9-8)
where f0is the ( n/H110021)-variable function obtained by setting xito 0 in the original
function and f1is the ( n/H110021)-variable function obtained by setting xito 1 in the orig-
inal function. The theorem is easily proved for switching algebra by first setting xi
FF0 F1a = 0 a = 1
111100 01 11 10
11
111100cdab
01
1110111100 01 11 10
11
111100cdab
01
1110FIGURE 9-35
Function Expansion
Using a Karnaugh
Map
Multiplexers, Decoders, and Programmable Logic Devices 273
to 0 in Equation (9-8), and, then, setting xito 1. Because both sides of the equation
are equal for xi/H110050 and for xi/H110051, the theorem is true for switching algebra.
Applying the expansion theorem to a 5-variable function gives
f(a,b,c,d,e)/H11005a/H11032f(0,b,c,d,e)/H11001a f(1,b,c,d,e)/H11005a/H11032f0/H11001a f1 (9-9)
This shows that any 5-variable function can be realized using two 4-variable
function generators and a 2-to-1 MUX [Figure 9-36(a)]. This implies that any 5-variable function can be implemented using a CLB of the type shown inFigure 9-33.
To realize a 6-variable function using 4-variable function generators, we apply
the expansion theorem twice:
G(a,b,c,d,e,f)/H11005a/H11032G(0,b,c,d,e,f)/H11001a G(1,b,c,d,e,f)/H11005a/H11032G
0/H11001a G1
G0/H11005b/H11032G(0, 0, c,d,e,f)/H11001b G(0, 1, c,d,e,f)/H11005b/H11032G00/H11001b G01
G1/H11005b/H11032G(1, 0, c,d,e,f)/H11001b G(1, 1, c,d,e,f)/H11005b/H11032G10/H11001bG11
Because G00,G01,G10, and G11are all 4-variable functions, we can realize any 6-variable
function using four 4-variable function generators and three 2-to-1 MUXes, as shownin Figure 9-36(b). Thus, we can realize any 6-variable function using two CLBs of thetype shown in Figure 9-31. Alternatively, we can write
G(a,b,c,d,e,f)/H11005a/H11032b/H11032G
00/H11001a/H11032b G01/H11001ab/H11032G10/H11001ab G11 (9-10)
and realize Gusing four function generators and a 4-to-1 MUX. In general, we can
realize any n-variable function ( n/H110224) using 2n/H1100244-variable function generators
and one 2n/H110024-to-1 MUX. This is a worst-case situation because many functions of
nvariables can be realized with fewer function generators.
b
bc
d G00
G0
G1GG01
G10
G11e
f
c
d
e
f
c
d
e
f
c
d
e
fFG
FG
a ab
c F0
F1Fd
eFG
0
1 b
c
d
eFG
(a) 5-variable function (b) 6-variable functionFG
FGFIGURE 9-36
Realization of 
5- and 6-Variable
Functions with
Function
Generators
274 Unit 9
Problems
9.1 (a) Show how two 2-to-1 multiplexers (with no added gates) could be connected to
form a 3-to-1 MUX. Input selection should be as follows:
IfAB/H1100500, select I0
IfAB/H1100501, select I1
IfAB/H110051–(Bis a don’t-care), select I2
(b) Show how two 4-to-1 and one 2-to-1 multiplexers could be connected to form an
8-to-1 MUX with three control inputs.
(c) Show how four 2-to-1 and one 4-to-1 multiplexers could be connected to form an
8-to-1 MUX with three control inputs.
9.2 Design a circuit which will either subtract Xfrom YorYfrom X, depending on the
value of A. If A/H110051, the output should be X–Y, and if A/H110050, the output should be
Y–X. Use a 4-bit subtracter and two 4-bit 2-to-1 multiplexers (with bus inputs and
outputs as in Figure 9-5).
9.3 Repeat 9.2 using a 4-bit subtracter, four 4-bit three-state buffers (with bus inputs
and outputs), and one inverter.
9.4 Realize a full adder using a 3-to-8 line decoder (as in Figure 9-13) and
(a) two OR gates.(b) two NOR gates.
9.5 Derive the logic equations for a 4-to-2 priority encoder. Refer to your table in the
Study Guide, Part 4(b).
9.6 Design a circuit equivalent to Figure 9-11 using a 4-to-1 MUX (with bus inputs
as in Figure 9-5). Use a 4-to-2 line priority encoder to generate the controlsignals.
9.7 An adder for Gray-coded-decimal digits (see Table 1-2) is to be designed using a
ROM. The adder should add two Gray-coded digits and give the Gray-coded sumand a carry. For example, 1011 /H110011010 /H110050010 with a carry of 1 (7 /H110016/H1100513).
Draw a block diagram showing the required ROM inputs and outputs. What sizeROM is required? Indicate how the truth table for the ROM would be specifiedby giving some typical rows.
9.8 The following PLA will be used to implement the following equations:
X/H11005AB/H11032D/H11001A/H11032C/H11032/H11001BC/H11001C/H11032D/H11032
Y/H11005A/H11032C/H11032/H11001AC/H11001C/H11032D/H11032
Z/H11005CD/H11001A/H11032C/H11032/H11001AB/H11032D
Multiplexers, Decoders, and Programmable Logic Devices 275
(b) Specify the truth table for a ROM which realizes these same equations.
9.9 Show how to implement a full subtracter using a PAL. See Figure 9-29.
9.10 (a) If the ROM in the hexadecimal to ASCII code converter of Figure 9-22 is
replaced with a PAL, give the internal connection diagram.
(b) If the same ROM is replaced with a PLA, give the PLA table.
9.11 (a) Sometimes the programmable MUX (1) in Figure 9-31 helps us to save
AND gates. Consider the case in which F/H11005c/H11032d/H11032/H11001bc/H11032/H11001a/H11032c. If programmable
MUX (1) is not set to invert F(i.e., G/H11005F), how many AND gates are needed?
If the MUX is set to invert F(i.e., G/H11005F/H11032), how many AND gates are needed?
(b) Repeat (a) for F/H11005a/H11032b/H11032/H11001c/H11032d/H11032.
9.12 (a) Implement a 3-variable function generator using a PAL with inputs a,b,c, and 1
(use the input inverter to get 0 also). Give the internal connection diagram.Leave the connections to 0 and 1 disconnected, so that any 3-variable functioncan be implemented by connecting only 0 and 1.
(b) Now connect 0 and 1 so that the function generator implements the sum func-
tion for a full adder. See Figure 9-34.
9.13 Expand the following function about the variable b.
F/H11005ab/H11032cde/H11032/H11001bc/H11032d/H11032e/H11001a/H11032cd/H11032e/H11001ac/H11032de/H11032
9.14 (a) Implement the following function using only 2-to-1 MUXes:
R/H11005ab/H11032h/H11032/H11001bch/H11032/H11001eg/H11032h/H11001fgh
.
(b) Repeat using only tri-state buffers.
9.15 Show how to make a 4-to-1 MUX, using an 8-to-1 MUX.
9.16 Implement a 32-to-1 multiplexer using two 16-to-1 multiplexers and a 2-to-1
multiplexer in two ways: (a) Connect the most significant select line to the 2-to-1multiplexer, and (b) connect the least significant select line to the 2-to-1 multiplexer.A
X Y ZB C D(a) Indicate the connections that will be made to program the PLA to implement
these equations.
276 Unit 9
9.17 2-to-1 multiplexers with an active high output and active high enable are to be used
in the following implementations:(a) Show how to implement a 4-to-1 multiplexer with an active high output and
no enable using two of the 2-to-1 MUXes and a minimum number of addi-tional gates.
(b) Repeat part (a) for a 4-to-1 multiplexer with an active low output.(c) Repeat part (b) assuming the output of the 2-to-1 MUX is 1 (rather than 0)
when the enable is 0.
9.18 Realize a BCD to excess-3 code converter using a 4-to-10 decoder with active low
outputs and a minimum number of gates.
9.19 Use a 4-to-1 multiplexer and a minimum number of external gates to realize the
function F(w, x, y, z )/H11005/H9018 m(3, 4, 5, 7, 10, 14) /H11001/H9018 d(1, 6, 15).
The inputs are only available uncomplemented.
9.20 Realize the function f(a, b, c, d, e )/H11005/H9018 m(6, 7, 9, 11, 12, 13, 16, 17, 18, 20, 21, 23, 25, 28)
using a 16-to-1 MUX with control inputs b, c, d , and e. Each data input should be 0, 1,
a, or a/H11032. Hint: Start with a minterm expansion of Fand combine minterms to elimi-
nate aanda/H11032where possible.
9.21 Implement a full adder
(a) using two 8-to-1 MUXes. Connect X,Y, and C
into the control inputs of the
MUXes and connect 1 or 0 to each data input.
(b) using two 4-to-1 MUXes and one inverter. Connect Xand Yto the control
inputs of the MUXes, and connect 1’s, 0’s, Cin, or Cin/H11032to each data input.
(c) again using two 4-to-1 MUXes, but this time connect Cinand Yto the control
inputs of the MUXes, and connect 1’s, 0’s, X, or X/H11032to each data input. Note
that in this fashion, any N-variable logic function may be implemented using a
2(N/H110021)-to-1 MUX.
9.22 Repeat Problem 9.21 for a full subtracter, except use Bininstead of Cin.
9.23 Make a circuit which gives the absolute value of a 4-bit binary number. Use four
full adders, four multiplexers, and four inverters. Assume negative numbers arerepresented in 2’s complement. Recall that one way to find the 2’s complement ofa binary number is to invert all of the bits and then add 1.
9.24 Show how to make a 4-to-1 MUX using four three-state buffers and a decoder.
9.25 Show how to make an 8-to-1 MUX using two 4-to-1 MUXes, two three-state buffers,
and one inverter.
9.26 Realize a full subtracter using a 3-to-8 line decoder with inverting outputs and
(a) two NAND gates.(b) two AND gates.
Multiplexers, Decoders, and Programmable Logic Devices 277
9.27 Show how to make the 8-to-3 priority encoder of Figure 9-16 using two 4-to-2 pri-
ority encoders and any additional necessary gates.
9.28 Design an adder for excess-3 decimal digits (see Table 1-2) using a ROM. Add two
excess-3 digits and give the excess-3 sum and a carry. For example, 1010 /H110011001 /H11005
0110 with a carry of 1 (7 /H110016/H1100513). Draw a block diagram showing the required ROM
inputs and outputs. What size ROM is required? Indicate how the truth table for theROM would be specified by giving some typical rows.
9.29 A circuit has four inputs RSTU and four outputs VWYZ. RSTU represents a binary-
coded-decimal digit. VW represents the quotient and YZthe remainder when RSTU
is divided by 3 ( VW and YZrepresent 2-bit binary numbers). Assume that invalid
inputs do not occur. Realize the circuit using(a) a ROM.(b) a minimum two-level NAND-gate circuit.(c) a PLA (specify the PLA table).
9.30 Repeat Problem 9.29 if the inputs RSTU represent a decimal digit in Gray code
(see Table 1-2).
9.31 (a) Find a minimum two-level NOR gate circuit to realize F
1and F2. Use as many
common gates as possible.
F1(a,b,c,d)/H11005/H9018 m(1, 2, 4, 5, 6, 8, 10, 12, 14)
F2(a,b,c,d)/H11005/H9018 m(2, 4, 6, 8, 10, 11, 12, 14, 15)
(b) Realize F1andF2using a PLA. Give the PLA table and internal connection dia-
gram for the PLA.
9.32 Braille is a system which allows a blind person to read alphanumerics by feeling a
pattern of raised dots. Design a circuit that converts BCD to Braille.The table showsthe correspondence between BCD and Braille.(a) Use a multiple-output NAND-gate circuit.

(b) Use a PLA. Give the PLA table.
(c) Specify the connection pattern for the PLA.
9.33 (a) Implement your solution to Problem 7.10 using a PLA. Specify the PLA table
and draw the internal connection diagram for the PLA using dots to indicatethe presence of switching elements.
(b) Repeat (a) for Problem 7.41.(c) Repeat (a) for Problem 7.43.
9.34 Show how to make an 8-to-1 MUX using a PAL. Assume that PAL has 14 inputs
and six outputs and assume that each output OR gate may have up to four ANDterms as inputs, as in Figure 9-29. ( Hint : Wire some outputs of the PAL around to
the inputs, external to the PAL. Some PALs allow this inside the PAL to saveinputs.)
9.35 Work Problem 9.34 but make the 8-to-3 priority encoder of Figure 9-16 instead of a
MUX.
9.36 The function F/H11005CD/H11032E/H11001CDE /H11001A/H11032D/H11032E/H11001A/H11032B/H11032DE/H11032/H11001BCD is to be implemented
in an FPGA which uses 3-variable lookup tables.(a) Expand Fabout the variables Aand B
(b) Expand Fabout the variables Band C.
(c) Expand Fabout the variables Aand C.
(d) Any 5-variable function can be implemented using four 3-variable lookup
tables and a 4-to-1 MUX, but this time we are lucky. Use your precedinganswers to implement Fusing only three 3-variable lookup tables and a 4-to-1
MUX. Give the truth tables for the lookup tables.
9.37 Work Problem 9.36 for F/H11005B/H11032D/H11032E/H11032/H11001AB/H11032C/H11001C/H11032DE/H11032/H11001A/H11032BC/H11032D.
9.38 Implement a 4-to-1 MUX using a CLB of the type shown in Figure 9-33. Specify the
function realized by each function generator.
9.39 Realize the function f(A, B, C, D )/H11005A/H11032C
/H11032/H11001A/H11032B/H11032D/H11032/H11001ACD /H11001A/H11032BD.
(a) Use a single 8-to-1 multiplexer with an active low enable and an active high out-
put. Use A, C , and Das the select inputs where Ais the most significant and D
is the least significant.
(b) Repeat Part (a) assuming the multiplexer enable is active high and output is
active low.
(c) Use a single 4-to-1 multiplexer with an active low enable and an active high out-
put and a minimum of additional gates. Show the function expansion both alge-braically and on a Karnaugh map.
9.40 Repeat Problem 9.39 for the function 
f(A, B, C, D, E )/H11005A/H11032C/H11032E/H11032/H11001A/H11032B/H11032D/H11032E/H11032/H11001ACDE /H11032/H11001A/H11032BDE /H11032.278 Unit 9
9.41 F(a, b, c, d )/H11005a/H11032/H11001ac/H11032d/H11032/H11001b/H11032cd/H11032/H11001ad.
(a) Using Shannon’s expansion theorem, expand Fabout the variable d.
(b) Use the expansion in Part (a) to realize the function using two 4-variable LUTs
and a 2-to-1 MUX. Specify the LUT inputs.
(c) Give the truth table for each LUT.
9.42 Repeat 9.41 for F(a, b, c, d )/H11005cd/H11032/H11001ad/H11032/H11001a/H11032b/H11032cd/H11001bc/H11032.
9.43 Repeat 9.41 for F(a, b, c, d )/H11005bd/H11001bc/H11032/H11001ac/H11032d/H11001a/H11032d/H11032.Multiplexers, Decoders, and Programmable Logic Devices 279
280CHAPTER
00
Objectives
1.Represent gates and combinational logic by concurrent VHDL statements.
2.Given a set of concurrent VHDL statements, draw the corresponding
combinational logic circuit.
3.Write a VHDL module for a combinational circuit
(a) by using concurrent VHDL statements to represent logic equations.
(b) by interconnecting VHDL components.
4.Compile and simulate a VHDL module.
5.Use the basic VHDL operators and understand their order of precedence.
6.Use the VHDL types: bit, bit_vector, Boolean, and integer.
Define and use an array-type.
7.Use IEEE Standard Logic. Use std_logic_vectors, together with overloaded
operators, to perform arithmetic operations.
Introduction to VHDLUNIT
10
Study GuideIntroduction to VHDL 281
1.Study Section 10.1, VHDL Description of Combinational Circuits .
(a) Draw a circuit that corresponds to the following VHDL statements:
C/H11021/H11005notA; D /H11021/H11005 Cand B;
(b) If A changes at time 5 ns, at what time do each of the following concurrent
statements execute? At what times are C and D updated?
C/H11021/H11005 A;
D/H11021/H11005 A;
(c) Write a VHDL statement that corresponds to the following circuit.The invert-
er has a delay of 5 ns. Draw the waveform for Massuming that Mis initially 0.
M
1M
0 5 10 15 20 25 t(ns)
(d) Write a VHDL statement to implement A/H11005B⊕Cwithout using the xor
or xnor operator. Do not include gate delays.
(e) Work Problems 10.1 and 10.2.
2.Study Section 10.2, VHDL Models for Multiplexers .
(a) Implement the following VHDL conditional assignment statement, using a
2-to-1 MUX:
F/H11021/H11005 Awhen C/H11005‘1’else B;
(b) Write a VHDL conditional assignment statement that represents the 4-to-1
MUX of Figure 9-2. Assume I0/H110051,I1/H110050, and I2/H11005I3/H11005C.
(c) Write a VHDL selected signal assignment for the same circuit as in (b).
3.Study Section 10.3, VHDL Modules , and Section 10.4, Signals and Constants .
(a) Write an entity for the module MOD1. A,B,C,D, and Eare all of type bit.
A
B
CD
EVHDL
Module
MOD1
282 Unit 10
(b) Write the architecture for MOD1 if D/H11005ABC and E/H11005D/H11032.
(c) What changes must be made in the code of Figure 10-12 to implement a
5-bit adder?
(d) Given the concurrent VHDL statements
R/H11021/H11005 Aafter 5 ns; -- statement 1
S/H11021/H11005 Rafter 10 ns; -- statement 2
If A changes at time 3 ns, at what time will statement 1 be executed?At what time will R be updated?At what time will statement 2 be executed?At what time will S be updated?
Answers: 3 ns, 8 ns, 8 ns, and 18 ns
(e) Write a statement that defines a bit_vector constant C1 equal to 10101011.
(f) The circuit of Figure 8-5 is implemented as a module without gate delays
as follows.(In the figure, Bis set to 1 and Cis set to 0, but here, assume they are inputs.)
entity fig8_5 is
port (A, B, C: in bit ; G2: out bit );
end fig8_5;
architecture circuit offig8_5 is
begin
G2/H11021/H11005not(Cor(Aand B));
end circuit;
Each gate in Figure 8-5 has a delay of 20 ns. Modify the module to include
gate delays. ( Hint :You will need a signal declaration to introduce G1 as an
internal signal.)
(g) Work Problems 10.3 and 10.4.
4.Study Section 10.5, Arrays .
(a) Write VHDL statements that define a ROM that is 16 words of 8 bits each.
Leave the values stored in the ROM unspecified.
(b) Work Problem 10.5.
Introduction to VHDL 283
5.Study Section 10.6, VHDL Operators .
(a) For each of the following statements, eliminate one set of parentheses with-
out changing the order of operation.
(i)not((A & B) xor“10”)
(ii) (not(A & B) xor“10”)
(b) If A(0 to7)/H11005“11011011 ”, what will be the result of executing the follow-
ing concurrent statement?
B/H11021/H11005 A(6to7)&A(0 to5);
What problem will occur when the following concurrent statement isexecuted?
A/H11021/H11005 A(6to7)&A(0 to5);
(Hint : A concurrent statement executes every time the right-hand side
changes.)
(c) Work Problem 10.6(a).
6.Study Section 10.7, Packages and Libraries .
Give the entity and architecture that describes a three-input AND gate with 2-ns
delay. Assume that all signals are of type bit.
7.Study Section 10.8, IEEE Standard Logic .
(a) Suppose A, B, C, D, E, and F are of type std_logic. If the following concur-
rent statements are executed, what are the values of A, B, C, D, E, and F?
A/H11021/H11005 ‘1’; A /H11021/H11005 ’Z’;
B/H11021/H11005 ‘0’; B /H11021/H11005 A;
C/H11021/H11005 ‘0’;
D/H11021/H11005 Awhen C/H11005‘0’else ‘Z’;
D/H11021/H11005 Cwhen C/H11005‘1’else ‘Z’;
E/H11021/H11005 ‘0’when A/H11005‘1’else C;
E/H11021/H11005 Awhen
C/H11005‘0’else ‘1’;
F/H11021/H11005 ‘1’when A/H11005‘1’and C/H11005‘1’else ‘Z’;
F/H11021/H11005 ‘0’when A/H11005‘0’and C/H11005‘0’else ‘Z’;
(b) Given the concurrent statements
F/H11021/H11005 ‘0’;
F/H11021/H11005 ‘1’after 2 ns;
What will happen if F is of type bit? What if F is of type std_logic?
(c) Suppose in Figure 10-19 that A is 1011, B is 0111, and Cin is 1. What is
Addout? Sum? Cout?
(d) If A is a 6-bit std_logic_vector and B is a 4-bit std_logic_vector, write con-
current VHDL statements that will add A and B to result in a 6-bit sumand a carry.
(e) Draw a circuit that implements the following VHDL code:
signal A, B, C, D: std_logic_vector(1 to3);
signal E, F , G: std_logic;
-----------------------------------------------------D/H11021/H11005 Awhen E/H11005‘1’else “ZZZ”;
D/H11021/H11005 Bwhen F/H11005‘1’else “ZZZ”;
D/H11021/H11005 Cwhen G/H11005‘1’else “ZZZ”;
(f) Work Problems 10.6(b), 10.7, and 10.8.
8.Before you take the test on Unit 10, pick up a lab assignment sheet and work
the assigned lab problems. Turn in your VHDL code and simulation results.
Introduction to VHDL
As integrated circuit technology has improved to allow more and more compo-nents on a chip, digital systems have continued to grow in complexity. As digitalsystems have become more complex, detailed design of the systems at the gateand flip-flop level has become very tedious and time consuming. For this reason,
the use of hardware description languages in the digital design process contin-ues to grow in importance. A hardware description language allows a digital
system to be designed and debugged at a higher level before implementation atthe gate and flip-flop level. The use of computer-aided design tools to do thisconversion is becoming more widespread. This is analogous to writing softwareprograms in a high-level language such as C and then using a compiler to con-vert the programs to machine language. The two most popular hardwaredescription languages are VHDL and Verilog.284 Unit 10
VHDL is a hardware description language that is used to describe the behav-
ior and structure of digital systems. The acronym VHDL stands for VHSICHardware Description Language, and VHSIC in turn stands for Very High SpeedIntegrated Circuit. However, VHDL is a general-purpose hardware descriptionlanguage which can be used to describe and simulate the operation of a widevariety of digital systems, ranging in complexity from a few gates to an intercon-nection of many complex integrated circuits. VHDL was originally developed toallow a uniform method for specifying digital systems. The VHDL languagebecame an IEEE standard in 1987, and it is widely used in industry. IEEE pub-lished a revised VHDL standard in 1993, and the examples in this text conformto that standard.
VHDL can describe a digital system at several different levels—behavioral,
data flow, and structural. For example, a binary adder could be described at thebehavioral level in terms of its function of adding two binary numbers, withoutgiving any implementation details. The same adder could be described at the dataflow level by giving the logic equations for the adder. Finally, the adder could bedescribed at the structural level by specifying the interconnections of the gateswhich make up the adder.
VHDL leads naturally to a top-down design methodology in which the system
is first specified at a high level and tested using a simulator. After the systemis debugged at this level, the design can gradually be refined, eventually leadingto a structural description which is closely related to the actual hardwareimplementation. VHDL was designed to be technology independent. If adesign is described in VHDL and implemented in today’s technology, the sameVHDL description could be used as a starting point for a design in some futuretechnology.
In this chapter, we introduce VHDL and illustrate how we can describe sim-
ple combinational circuits using VHDL. We will use VHDL in later units todesign sequential circuits and more complex digital systems. In Unit 17, we intro-duce the use of CAD software tools for automatic synthesis from VHDL descrip-tions. These synthesis tools will derive a hardware implementation from theVHDL code.
10.1 VHDL Description of Combinational 
Circuits
We begin by describing a simple gate circuit using VHDL. A VHDL signal is
used to describe a signal in a physical system. (Section 10.4 contains a summary ofsignals, constants, and types. The VHDL language also includes variables similarto variables in programming languages, but to obtain synthesizable code for hard-ware, signals should be used to represent hardware signals. VHDL variables are not used in this text.) The gate circuit of Figure 10-1 has five signals: A, B, C, DIntroduction to VHDL 285
and E. The symbol “ /H11021/H11005” is the signal assignment operator which indicates that
the value computed on the right-hand side is assigned to the signal on the left side.Abehavioral description of the circuit in Figure 10-1 is
E/H11021/H11005 Dor(Aand B);
Parentheses are used to specify the order of operator execution.
The two assignment statements in Figure 10-1 give a dataflow description of the
circuit where it is assumed that each gate has a 5-ns propagation delay. W hen the
statements in Figure 10-1 are simulated, the first statement will be evaluated any timeA or B changes, and the second statement will be evaluated any time C or D changes.Suppose that initially A /H110051, and B /H11005C/H11005D/H11005E/H110050. If B changes to 1 at time 0, C
will change to 1 at time /H110055 ns. Then, E will change to 1 at time /H1100510 ns.
The circuit of Figure 10-1 can also be described using structural VHDL code.
To do so requires that a two-input AND-gate component and a two-input OR-gate component be declared and defined. Components may be declared anddefined either in a library or within the architecture part of the VHDL code.(VHDL architectures are discussed in Section 10.3, and packages and libraries arediscussed in Section 10.7.) Instantiation statements are used to specify how com-ponents are connected. Each copy of a component requires a separate instantia-tion statement to specify how it is connected to other components and to the portinputs and outputs. An instantiation statement is a concurrent statement that exe-cutes anytime one of the input signals in its port map changes.The circuit of Figure10-1 is described by instantiating the AND gate and the OR gate as follows:
Gate1: AND2 port map (A, B, D);
Gate2: OR2 port map (C, D, E);
The port map for Gate1 connects A and B to the AND-gate inputs, and it connects D
to the AND-gate output. Since an instantiation statement is concurrent, whenever Aor B changes, these changes go to the Gate1 inputs, and then the component computesa new value of D. Similarly, the second statement passes changes in C or D to theGate2 inputs, and then the component computes a new value of E.This is exactly howthe real hardware works. (The order in which the instantiation statements appear isirrelevant.) Instantiating a component is different than calling a function in a com-puter program. A function returns a new value whenever it is called, but an instanti-ated component computes a new output value whenever its input changes.
VHDL signal assignment statements, such as the ones in Figure 10-1, are exam-
ples of concurrent statements. The VHDL simulator monitors the right side of eachconcurrent statement, and any time a signal changes, the expression on the right sideis immediately re-evaluated. The new value is assigned to the signal on the left sideafter an appropriate delay. This is exactly the way the hardware works. Any time aC <= A and B after  5 ns;
E <= C or D after  5 ns;A
BDC
EFIGURE 10-1
Gate Circuit286 Unit 10
gate input changes, the gate output is recomputed by the hardware, and the output
changes after the gate delay.
When we initially describe a circuit, we may not be concerned about propaga-
tion delays. If we write
C/H11021/H11005 Aand B;
E/H11021/H11005 CorD;
this implies that the propagation delays are 0 ns. In this case, the simulator will
assume an infinitesimal delay referred to as /H9004(delta). Assume that initially A /H110051
and B /H11005C/H11005D/H11005E/H110050. If B is changed to 1 at time /H110051 ns, then C will change at
time 1 /H11001/H9004 and E will change at time 1 /H110012/H9004.
Unlike a sequential program, the order of the above concurrent statements is
unimportant. If we write
E/H11021/H11005 CorD;
C/H11021/H11005 Aand B;
the simulation results would be exactly the same as before.
In general, a signal assignment statement has the form
signal _name /H11021/H11005 expression [ after delay];
The expression is evaluated when the statement is executed, and the signal on the
left side is scheduled to change after delay. The square brackets indicate that after
delay is optional; they are not part of the statement. If after delay is omitted, then
the signal is scheduled to be updated after a delta delay. Note that the time atwhich the statement executes and the time at which the signal is updated are notthe same.
Even if a VHDL program has no explicit loops, concurrent statements may exe-
cute repeatedly as if they were in a loop. Figure 10-2 shows an inverter with theoutput connected back to the input. If the output is ‘0’, then this ‘0’ feeds back tothe input and the inverter output changes to ‘1’ after the inverter delay, assumed tobe 10 ns. Then, the ‘1’ feeds back to the input, and the output changes to ‘0’ after theinverter delay.The signal CLK will continue to oscillate between ‘0’ and ‘1’, as shownin the waveform. The corresponding concurrent VHDL statement will produce thesame result. If CLK is initialized to ‘0’, the statement executes and CLK changes to‘1’ after 10 ns. Because CLK has changed, the statement executes again, and CLKwill change back to ‘0’ after another 10 ns. This process will continue indefinitely.Introduction to VHDL 287
CLK
CLK
10 20 30 40 60 50CLK <= not CLK after  10 ns;FIGURE 10-2
Inverter with
Feedback
The statement in Figure 10-2 generates a clock waveform with a half period of
10 ns. On the other hand, the concurrent statement
CLK/H11021/H11005notCLK;
will cause a run-time error during simulation. Because there is 0 delay, the value of
CLK will change at times 0 /H11001/H9004,0/H110012/H9004,0/H110013/H9004, etc. Because /H9004 is an infinitesimal
time, time will never advance to 1 ns.
In general, VHDL is not case sensitive, that is, capital and lower case letters are
treated the same by the compiler and the simulator. Thus, the statements
Clk/H11021/H11005NOT clkAfter 10 NS;
and CLK /H11021/H11005notCLKafter 10 ns;
would be treated exactly the same. Signal names and other VHDL identifiers may
contain letters, numbers, and the underscore character (_).An identifier must startwith a letter, and it cannot end with an underscore. Thus, C123 and ab_23 are legalidentifiers, but 1ABC and ABC_ are not. Every VHDL statement must be termi-nated with a semicolon. Spaces, tabs, and carriage returns are treated in the sameway. This means that a VHDL statement can be continued over several lines, orseveral statements can be placed on one line. In a line of VHDL code, anythingfollowing a double dash (--) is treated as a comment. Words such as and,or, and
after are reserved words (or keywords) which have a special meaning to the
VHDL compiler. In this text, we will put all reserved words in boldface type.
Figure 10-3 shows three gates that have the signal A as a common input and the cor-
responding VHDL code.The three concurrent statements execute simultaneously when-ever A changes, just as the three gates start processing the signal change at the same time.However, if the gates have different delays, the gate outputs can change at differenttimes. If the gates have delays of 2 ns, 1 ns, and 3 ns, respectively, and A changes at time5 ns, then the gate outputs D, E, and F can change at times 7 ns, 6 ns, and 8 ns, respec-tively.The VHDL statements work in the same way. Even though the statements executesimultaneously, the signals D, E, and F are updated at times 7 ns, 6 ns, and 8 ns. However,if no delays were specified, then D, E, and F would all be updated at time 5 /H11001/H9004.
In these examples, every signal is of type bit, which means it can have a value of
‘0’ or ‘1’. (Bit values in VHDL are enclosed in single quotes to distinguish them frominteger values.) In digital design, we often need to perform the same operation on agroup of signals. A one-dimensional array of bit signals is referred to as a bit-vector.If a 4-bit vector named B has an index range 0 through 3, then the four elements ofthe bit-vector are designated B(0), B(1), B(2), and B(3).The statement B/H11021/H11005 “0110”
assigns ‘0’ to B(0), ‘1’ to B(1), ‘1’ to B(2), and ‘0’ to B(3).288 Unit 10
B
CAD
E
F-- when A changes, these concurrent
-- statements all execute at the same time
D <= A and B after  2 ns;
E <= not A after  1 ns;
F <= A or C after  3 ns;FIGURE 10-3
Three Gates with a
Common Input and
Different Delays
Figure 10-4 shows an array of four AND gates. The inputs are represented by
bit-vectors A and B, and the outputs by bit-vector C. Although we can write fourVHDL statements to represent the four gates, it is much more efficient to write asingle VHDL statement that performs the and operation on the bit-vectors A and
B. When applied to bit-vectors, the and operator performs the and operation on
corresponding pairs of elements.
The preceding signal assignment statements containing “ after delay ” create
what is called an inertial delay model. Consider a device with an inertial delay of
D time units. If an input change to the device will cause its output to change, thenthe output changes D time units later. However, this is not what happens if thedevice receives two input changes within a period of D time units and both inputchanges should cause the output to change. In this case the device output does notchange in response to either input change. As an example, consider the signalassignment
C/H11021/H11005 Aand Bafter 10 ns;
Assume A and B are initially 1, and A changes to 0 at 15 ns, to 1 at 30 ns, and to 0 at
35 ns. Then C changes to 1 at 10 ns and to 0 at 25 ns, but C does not change inresponse to the A changes at 30 ns and 35 ns because these two changes occurredless than 10 ns apart. A device with an inertial delay of D time units filters out out-put changes that would occur in less than or equal to D time units.
VHDL can also model devices with an ideal (transport ) delay. Output changes
caused by input changes to a device exhibiting an ideal (transport) delay of D timeunits are delayed by D time units, and the output changes occur even if they occurwithin D time units. The VHDL signal assignment statement that models ideal(transport) delay is
signal _name /H11021/H11005transport expression after delay
As an example, consider the signal assignment
C/H11021/H11005transport Aand Bafter 10 ns;
Assume A and B are initially 1 and A changes to 0 at 15 ns, to 1 at 30 ns, and to 0 at
35 ns. Then C changes to 1 at 10 ns, to 0 at 25 ns, to 1 at 40 ns, and to 0 at 45 ns. Notethat the last two changes are separated by just 5 ns.Introduction to VHDL 289
A(3)
B(3)C(3)
A(2)
B(2)C(2)
A(1)
B(1)C(1)
A(0)
B(0)C(0)-- the hard way
C(3) <= A( 3) and B( 3);
C(2) <= A(2) and B(2);
C(1) <= A(1) and B(1);
C(0) <= A(0) and B(0);
-- the easy way
C <= A and B;FIGURE 10-4
Array of AND
Gates
10.2 VHDL Models for Multiplexers
Figure 10-5 shows a 2-to-1 multiplexer (MUX) with two data inputs and one control
input. The MUX output is F /H11005A/H11032/H11080I0/H11001A/H11080I1. The corresponding VHDL statement is
F/H11021/H11005 (notAand I0)or(Aand I1);
Alternatively, we can represent the MUX by a conditional signal assignment state-
ment, as shown in Figure 10-5. This statement executes whenever A, I0, or I1changes. The MUX output is I0 when A /H11005‘0’, and else it is I1. In the conditional
statement, I0, I1, and F can either be bits or bit-vectors.290 Unit 10
DC
B0
1
EF
A0
1F <= A when  E = '1'
else B when  D = '1'
else C;FIGURE 10-6
Cascaded 2-to-1
MUXesAFI0
I10
1-- conditional signal assignment statement
F <= I0 when  A = '0' else I1;FIGURE 10-5
2-to-1 Multiplexer
The general form of a conditional signal assignment statement is
signal_name /H11021/H11005 expression1 when condition1
else expression2 when condition2
[else expressionN];
This concurrent statement is executed whenever a change occurs in a signal used in
one of the expressions or conditions. If condition1 is true, signal_name is set equalto the value of expression1, or else if condition2 is true, signal_name is set equal tothe value of expression2, etc. The line in square brackets is optional. Figure 10-6shows how two cascaded MUXes can be represented by a conditional signal assign-ment statement. The output MUX selects A when E /H11005‘1’; or else it selects the out-
put of the first MUX, which is B when D /H11005‘1’, or else it is C.
Figure 10-7 shows a 4-to-1 MUX with four data inputs and two control inputs, A
and B. The control inputs select which one of the data inputs is transmitted to theoutput. The logic equation for the 4-to-1 MUX is
F/H11005A’B’I
0/H11001A’BI1/H11001AB’I2/H11001ABI3
Thus, one way to model the MUX is with the VHDL statement
F/H11021/H11005 (notAand not Band I0)or(notAand Band I1)or
(Aand not Band I2)or(Aand Band I3);
Introduction to VHDL 291
ABI0
I1
I2
I3F MUXsel <= A&B;
-- selected signal assignment statementwith sel select
F <= I0 when  "00",
        I1 when  "01",
        I2 when  "10",
        I 3 when  "11";FIGURE 10-7
4-to-1 Multiplexer
Another way to model the 4-to-1 MUX is to use a conditional assignment statement:
F/H11021/H11005 I0when A&B /H11005“00”
else I1when A&B /H11005“01”
else I2when A&B /H11005“10”
else I3;
The expression A&B means A concatenated with B, that is, the two bits A and B
are merged together to form a 2-bit vector. This bit vector is tested, and the appro-priate MUX input is selected. For example, if A /H11005‘1’ and B /H11005‘0’, A&B /H11005“10”
and I2 is selected. Instead of concatenating A and B, we could use a more complexcondition:
F/H11021/H11005 I0when A/H11005‘0’and B/H11005‘0’
else I1when A/H11005‘0’and B/H11005‘1’
else I2when A/H11005‘1’and B/H11005‘0’
else I3;
A third way to model the MUX is to use a selected signal assignment state-
ment, as shown in Figure 10-7. A&B cannot be used in this type of statement, sowe first set Sel equal to A&B. The value of Sel then selects the MUX input that isassigned to F.
The general form of a selected signal assignment statement is
with expression_s select
signal_s /H11021/H11005 expression1 [ after delay-time] when choice1,
expression2 [ after delay-time] when choice2,
...[expression_n [ after delay-time] when others];
This concurrent statement executes whenever a signal changes in any of the
expressions. First, expression_s is evaluated. If it equals choice1, signal_s is setequal to expression1; if it equals choice2, signal_s is set equal to expression2; etc. Ifall possible choices for the value of expression_s are given, the last line should beomitted; otherwise, the last line is required.When it is present, if expression_s is notequal to any of the enumerated choices, signal_s is set equal to expression_n. Thesignal_s is updated after the specified delay-time, or after /H9004if the “ after delay-
time” is omitted.
10.3 VHDL Modules
To write a complete VHDL module, we must declare all of the input and output
signals using an entity declaration, and then specify the internal operation of the
module using an architecture declaration. As an example, consider Figure 10-8. The
entity declaration gives the name “two_gates” to the module. The port declarationspecifies the inputs and outputs to the module. A, B, and D are input signals of typebit, and E is an output signal of type bit. The architecture is named “gates”. Thesignal C is declared within the architecture because it is an internal signal. The twoconcurrent statements that describe the gates are placed between the keywordsbegin and end.292 Unit 10
...Entit y
Architecture
Module 1Entit y
Architecture
Module 2Entit y
Architecture
Entit y
Architecture
Module NFIGURE 10-9
VHDL Program
Structureentity  two_gates is
port (A,B,D: in bit ; E: out bit );
end two_gates;
architecture  gates of two_gates is
signal  C: bit;
begin     C <= A and B; -- concurrent
     E <= C or D; -- statements
end gates;A
B
DC
EFIGURE 10-8
VHDL Module with
Two Gates
When we describe a system in VHDL, we must specify an entity and an
architecture at the top level, and also specify an entity and architecture for each ofthe component modules that are part of the system (see Figure 10-9). Each entitydeclaration includes a list of interface signals that can be used to connect to othermodules or to the outside world. We will use entity declarations of the form:
entity entity-name is
[port(interface-signal-declaration);]
end [entity ] [entity-name];
The items enclosed in square brackets are optional.The interface-signal-declaration
normally has the following form:
list-of-interface-signals: mode type [: /H11005initial-value]
{; list-of-interface-signals: mode type [: /H11005initial-value]};
The curly brackets indicate zero or more repetitions of the enclosed clause. Input
signals are of mode in, output signals are of mode out, and bi-directional signals (see
Figure 9-12) are of mode inout .
So far, we have only used type bit and bit_vector; other types are described in
Section 10.4. The optional initial-value is used to initialize the signals on the associ-ated list; otherwise, the default initial value is used for the specified type. For exam-ple, the port declaration
port(A, B: ininteger : /H110052; C, D: outbit);
indicates that A and B are input signals of type integer that are initially set to 2, and
C and D are output signals of type bit that are initialized by default to ‘0’.
Associated with each entity is one or more architecture declarations of the
form
architecture architecture-name ofentity-name is
[declarations]
begin
architecture body
end [architecture ] [architecture-name];
In the declarations section, we can declare signals and components that are used
within the architecture. The architecture body contains statements that describe theoperation of the module.
Next, we will write the entity and architecture for a full adder module (refer
to Section 4.7 for a description of a full adder). The entity specifies the inputs andoutputs of the adder module, as shown in Figure 10-10. The port declaration spec-ifies that X, Y and Cin are input signals of type bit, and that Cout and Sum areoutput signals of type bit.Introduction to VHDL 293
X
Y
CinCout
SumFull
Adderentity  FullAdder is
port (X,Y,Cin: in bit;  -- Inputs
  Cout, Sum: out bit);  -- Outputs
end FullAdder;FIGURE 10-10
Entity Declaration
for a Full Adder
Module
The operation of the full adder is specified by an architecture declaration:
In this example, the architecture name (Equations) is arbitrary, but the entity name
(FullAdder) must match the name used in the associated entity declaration.architecture Equations ofFullAdder is
begin -- concurrent assignment statements
Sum /H11021/H11005 XxorYxorCinafter 10 ns;
Cout /H11021/H11005 (Xand Y)or(XandCin)or(YandCin)after 10 ns;
end Equations;
The VHDL assignment statements for Sum and Cout represent the logic equations
for the full adder. Several other architectural descriptions such as a truth table or aninterconnection of gates could have been used instead. In the Cout equation, paren-theses are required around (X andY) because VHDL does not specify an order of
precedence for the logic operators.
Four-Bit Full Adder
Next, we will show how to use the FullAdder module defined above as a compo-nent in a system which consists of four full adders connected to form a 4-bit bina-ry adder (see Figure 10-11). We first declare the 4-bit adder as an entity (seeFigure 10-12). Because the inputs and the sum output are four bits wide, wedeclare them as bit_vectors which are dimensioned 3 downto 0. (We could have
used a range 1 to4 instead.)294 Unit 10
Full
AdderCo
A3B3S3
Full
AdderC3
A2B2S2
Full
AdderC2
A1B1S1
Full
AdderC1
A0B0S0
CiFIGURE 10-11
4-Bit Binary Adder
Next, we specify the FullAdder as a component within the architecture of
Adder4 (Figure 10-12). The component specification is very similar to the entitydeclaration for the full adder, and the input and output port signals correspond tothose declared for the full adder. Following the component statement, we declare a3-bit internal carry signal C.
In the body of the architecture, we create several instances of the FullAdder
component. (In CAD jargon, we instantiate four copies of the FullAdder.) Each
copy of FullAdder has a name (such as FA0) and a port map. The signal names fol-lowing the port map correspond one-to-one with the signals in the component port.Thus, A(0), B(0), and Ci correspond to the inputs X, Y, and Cin, respectively. C(1)and S(0) correspond to the Cout and Sum outputs. Note that the order of the sig-nals in the port map must be the same as the order of the signals in the port of thecomponent declaration.
In preparation for simulation, we can place the entity and architecture for the
FullAdder and for Adder4 together in one file and compile. Alternatively, we couldcompile the FullAdder separately and place the resulting code in a library which islinked in when we compile Adder4.
All of the simulation examples in this text use the ModelSim simulator from
Model Tech. Most other VHDL simulators use similar command files and can
Introduction to VHDL 295
entity Adder4 is
port (A, B: inbit_vector(3 downto 0); Ci: inbit; -- Inputs
S:outbit_vector(3 downto 0); Co: outbit); -- Outputs
endAdder4;
architecture Structure ofAdder4 is
component FullAdder
port (X, Y , Cin: inbit; -- Inputs
Cout, Sum: outbit); -- Outputs
end component ;
signal C: bit_vector(3 downto 1);
begin -- instantiate four copies of the FullAdder
FA0: FullAdder port map (A(0), B(0), Ci, C(1), S(0));
FA1: FullAdder port map (A(1), B(1), C(1), C(2), S(1));
FA2: FullAdder port map (A(2), B(2), C(2), C(3), S(2));
FA3: FullAdder port map (A(3), B(3), C(3), Co, S(3));
end Structure;FIGURE 10-12
Structural
Description of
4-Bit Adder
produce output in a similar format. We will use the following simulator com-
mands to test Adder4:
add list A B Co C Ci S -- put these signals on the output list
force A 1111 -- set the A inputs to 1111force B 0001 -- set the B inputs to 0001force Ci 1 -- set Ci to 1run 50 ns -- run the simulation for 50 nsforce Ci 0force A 0101force B 1110run 50 ns
We have chosen to run the simulation for 50 ns because this is more than enough
time for the carry to propagate through all of the full adders. The simulation resultsfor the above command list are:
ns delta a b co c ci s
0 /H110010 0000 0000 0 000 0 0000
0 /H110011 1111 0001 0 000 1 0000
10 /H110010 1111 0001 0 001 1 1111
20 /H110010 1111 0001 0 011 1 1101
30 /H110010 1111 0001 0 111 1 1001
40 /H110010 1111 0001 1 111 1 0001
50 /H110010 0101 1110 1 111 0 0001
60 /H110010 0101 1110 1 110 0 0101
70 /H110010 0101 1110 1 100 0 0111
80 /H110010 0101 1110 1 100 0 0011
296 Unit 10
The listing shows how the carry propagates one position every 10 ns. The full
adder inputs change at time /H11005/H9004:
FA3
100Time = ∆
000
10
FA2
100
FA1
100
FA0
110
The sum and carry are computed by each FA and appear at the FA outputs 10 ns later:
FA3
100Time = 10
001
11
FA2
101
FA1
101
FA0
111
Because the inputs to FA1 have changed, the outputs change 10 ns later:
FA3
100Time = 20
011
11
FA2
101
FA1
100
FA0
111
The final simulation results are:
1111 /H110010001 /H110011/H110050001 with a carry of 1 (at time /H1100540 ns) and
0101 /H110011110 /H110010/H110050011 with a carry of 1 (at time /H1100580 ns).
The simulation stops at 80 ns because no further changes occur after that time. For
more details on how the simulator handles /H9004delays, refer to Section 10.9.
In this section we have shown how to construct a VHDL module using an entity-
architecture pair. The 4-bit adder module demonstrates the use of VHDL componentsto write structural VHDL code. Components used within the architecture are declaredat the beginning of the architecture, using a component declaration of the form
component component-name
port (list-of-interface-signals-and-their-types);
end component ;
The port clause used in the component declaration has the same form as the port
clause used in an entity declaration. The connections to each component used in acircuit are specified by using a component instantiation statement of the form
label: component-name port map (list-of-actual-signals);
The list of actual signals must correspond one-to-one to the list of interface signals
specified in the component declaration.
10.4 Signals and Constants
Input and output signals for a module are declared in a port. Signals internal to amodule are declared at the start of an architecture, before begin , and can be used
only within that architecture. Port signals have an associated mode (usually in orout), but internal signals do not. A signal used within an architecture must bedeclared either in a port or in the declaration section of an architecture, but it can-not be declared in both places. A signal declaration has the form
signal list_of_signal_names: type_name [constraint] [: /H11005initial_value];
The constraint can be an index range like (0 to5) or (4 downto 1), or it can be a
range of values such as range 0 to 7. Examples:
signal A, B, C: bit_vector(3 downto 0):/H11005“1111”;
A, B, and C are 4-bit vectors dimensioned 3 downto 0 and initialized to 1111.
signal E, F: integer range 0to15;
E and F are integers in the range 0 to 15, initialized by default to 0. The compiler or
simulator will flag an error if we attempt to assign a value outside the specified rangeto E or F.
Constants declared at the start of an architecture can be used anywhere within
that architecture. A constant declaration is similar to a signal declaration:
constant constant_name: type_name [constraint] [: /H11005constant_value];
A constant named limit of type integer with a value of 17 can be defined as
constant limit : integer : /H1100517;
A constant named delay1 of type time with the value of 5 ns can be defined as
constant delay1 : time : /H110055 ns;
This constant could then be used in an assignment statement
A/H11021/H11005 Bafter delay1;
Once the value of a constant is defined in a declaration statement, unlike a signal,
the value cannot be changed by using an assignment statement.
Signals and constants can have any one of the predefined VHDL types, or they
can have a user-defined type. Some of the predefined types areIntroduction to VHDL 297
Definition bit ‘0’ or ‘1’
boolean FALSE or TRUEinteger an integer in the range /H11002(2
31/H110021) to /H11001(231/H110021)
(some implementations support a wider range)
positive an integer in the range 1 to 231/H110021 (positive integers)
natural an integer in the range 0 to 231/H110021 (positive integers and zero)
real floating-point number in the range /H110021.0E38 to /H110011.0E38
character any legal VHDL character including upper- and lower case letters,
digits, and special characters; each printable character must beenclosed in single quotes, e.g., ‘d’, ‘7’, ‘ /H11001’
time an integer with units fs, ps, ns, us, ms, sec, min, or hr
Note that the integer range for VHDL is symmetrical even though the range for a
32-bit 2’s complement integer is /H11002231to/H11001(231/H110021).
A common user-defined type is the enumeration type in which all of the values
are enumerated. For example, the declarations
type state_type is(S0, S1, S2, S3, S4, S5);
signal state : state_type : /H11005S1;
define a signal called state which can have any one of the values S0, S1, S2, S3, S4, or
S5 and which is initialized to S1. If no initialization is given, the default initializationis the left most element in the enumeration list, S0 in this example. If we declare thesignal state as shown, the following assignment statement sets state to S3:
state /H11021/H11005 S3;
VHDL is a strongly-typed language so signals of different types generally cannot be
mixed in the same assignment statement, and no automatic type conversion is per-formed. Thus the statement A/H11021/H11005 BorCis only valid if A, B, and C all have the same
type or closely related types.
10.5 Arrays
In order to use an array in VHDL, we must first declare an array type, and thendeclare an array object. For example, the following declaration defines a one-dimen-sional array type named SHORT_WORD:
type SHORT_WORD is array (15downto 0)ofbit;
An array of this type has an integer index with a range from 15 downto 0, and each
element of the array is of type bit.
Next, we will declare array objects of type SHORT_WORD:
signal DATA_WORD: SHORT_WORD;
signal ALT_WORD: SHORT_WORD : /H11005“0101010101010101”;
constant ONE_WORD: SHORT_WORD : /H11005(others /H11005/H11022 ‘1’);298 Unit 10
DATA_WORD is a signal array of 16 bits, indexed 15 downto 0, which is ini-
tialized (by default) to all ‘0’ bits. ALT_WORD is a signal array of 16 bits which isinitialized to alternating 0’s and 1’s. ONE_WORD is a constant array of 16 bits; allbits are set to ‘1’ by ( others /H11005/H11022 ‘1’). Because none of the bits have been set indi-
vidually,
1in this case others applies to all of the bits.
We can reference individual elements of the array by specifying an index value.
For example, ALT_WORD(0) accesses the far right bit of ALT_WORD. We can alsospecify a portion of the array by specifying an index range:ALT_WORD(5 downto 0)
accesses the low order six bits of ALT_WORD, which have an initial value of 010101.
The array type and array object declarations illustrated above have the general
forms:
type array_type_name is array index_range ofelement_type;
signal array_name: array_type_name [ : /H11005initial_values ];
In this declaration, signal may be replaced with constant .
Multidimensional array types may also be defined with two or more dimensions.
The following example defines a two-dimensional array signal which is a matrix ofintegers with four rows and three columns:
type matrix4x3 is array (1to4, 1 to3)ofinteger;
signal matrixA: matrix4x3 : /H11005((1,2,3),(4,5,6),(7,8,9),(10,11,12));
The signal matrixA, will be initialized to
The array element matrixA(3,2) references the element in the third row and second col-
umn, which has a value of 8. The statement B/H11021/H11005 matrixA(2,3) assigns a value of 6 to B.
When an array type is declared, the dimensions of the array may be left unde-
fined. This is referred to as an unconstrained array type. For example,
type intvec is array (natural range /H11021/H11022)ofinteger;
declares intvec as an array type which defines a one-dimensional array of integers with
an unconstrained index range of natural numbers. The default type for array indices isinteger, but another type may be specified. Because the index range is not specified inthe unconstrained array type, the range must be specified when the array object isdeclared. For example,
signal intvec5: intvec(1 to5) :/H11005(3,2,6,8,1);
defines a signal array named intvec5 with an index range of 1 to 5, which is initial-
ized to 3, 2, 6, 8, 1. The following declaration defines matrix as a two-dimensionalarray with unconstrained row and column index ranges:
type matrix is array (natural range /H11021/H11022 , natural range /H11021/H11022)ofinteger;/H209001 2 3
4 5 6
7 8 9
10 11 12/H20901Introduction to VHDL 299
1See Reference [1, p. 86] for information on how to set individual bits.
Predefined unconstrained array types in VHDL include bit_vector and string, which
are defined as follows:
type bit_vector is array (natural range /H11021/H11022)ofbit;
type string is array (positive range /H11021/H11022)ofcharacter;
The characters in a string literal must be enclosed in double quotes. For exam-
ple, “This is a string.” is a string literal. The following example declares a constantstring1 of type string:
constant string1: string(1 to29) :/H11005“This string is 29 characters.”
A bit_vector literal may be written either as a list of bits separated by commas
or as a string. For example, (‘1’,‘0’,‘1’,‘1’,‘0’) and “10110” are equivalent forms. Thefollowing declares a constant A which is a bit_vector with a range 0 to 5.
constant A : bit_vector(0 to5) :/H11005“101011”;
A truth table can be implemented using a ROM (read-only memory) as illustrated
in Figure 9-17. If we represent the ROM outputs by a bit_vector, F(0 to3), we can rep-
resent the truth table that is stored in the ROM by an array of bit_vectors. The VHDLcode for this ROM is given in Figure 10-13. The port declaration (line 4) defines theinputs and outputs for the ROM. The type declaration (line 7) defines an array with 8 rows where each row is 4 bits wide. Line 8 declares ROM1 to be an array of this typewith binary data stored in each row. Line 9 declares an integer called index. This indexwill be used to select one of the 8 rows in the ROM1 array. In line 11, this index isformed by concatenating the three input bits to form a 3-bit vector, and this vector isconverted to an integer.The data is read from the ROM1 array in line 13. For example,if A /H11005‘1’, B /H11005‘0’, and C /H11005‘1’, index /H110055, and “0001” is read from the ROM. Lines 1
and 2 allow us to use the vec2int function, which is defined in a library named BITLIB.300 Unit 10
1 library BITLIB;
2 useBITLIB.bit_pack. all;
3 entity ROM9_17 is
4 port (A, B, C: inbit; F: outbit_vector(0 to3));
5 end entity;
6 architecture ROM ofROM9_17 is
7 type ROM8X4 is array (0to7)ofbit_vector(0 to3);
8 constant ROM1: ROM8X4 : /H11005(“1010”, “1010”, “0111”, “0101”, “1100”, “0001”, “1111”, “0101”);
9 signal index: Integer range 0to7;
10 begin
11 index /H11021/H11005 vec2int(A&B&C); -- A&B&C Is a 3-bit vector
12 -- vec2int is a function that converts this vector to an integer13 F /H11021/H11005 ROM1 (index);
14 -- this statement reads the output from the ROM
15 end ROM;FIGURE 10-13 VHDL Description of a ROM
10.6 VHDL Operators
Predefined VHDL operators can be grouped into seven classes:
1.binary logical operators: and or nand nor xor xnor
2.relational operators: /H11005 //H11005  /H11021/H11021 /H11005/H11022/H11022 /H11005
3.shift operators: sll srl sla sra rol ror
4.adding operators: /H11001/H11002 & (concatenation)
5.unary sign operators: /H11001/H11002
6.multiplying operators: * / mod rem
7.miscellaneous operators: not abs **
When parentheses are not used, operators in class 7 have highest precedence and are
applied first, followed by class 6, then class 5, etc. Class 1 operators have lowest prece-dence and are applied last. Operators in the same class have the same precedence andare applied from left to right in an expression. The precedence order can be changedby using parentheses. In the following expression, A, B, C, and D are bit_vectors:
notAorBand not C & D
In this expression, notis performed first, then &(concatenation), then or, and final-
lyand. The equivalent expression using parentheses is
((notA)orB)and ((notC) &D)
The binary logical operators (class 1) as well as notcan be applied to bits, booleans,
bit_vectors, and boolean_vectors. The class 1 operators require two operands of thesame type and size, and the result is of that type and size.
Relational operators (class 2) are used to compare two expressions and return a
value of FALSE or TRUE.The two expressions must be of the same type and size. Equal(/H11005) and not equal (/ /H11005) apply to any type, but the application of the other relational
operators is more restricted. Note that “ /H11005” is always a relational operator, but “ /H11021/H11005” also
serves as an assignment operator. Example: If A /H110055, B/H110054, and C /H110053 the expression
(A/H11022/H11005 B)and (B/H11021/H11005 C)evaluates to FALSE.
Figure 10-14 shows a comparator for two integers with a restricted range. C must
be of type Boolean since the condition A /H11021/H11005 B evaluates to TRUE or FALSE. If
we implement the comparator in hardware, each integer would be represented by a4-bit signal because the range is restricted to 0 to 15. C, D, and E would each be onebit (0 for FALSE or 1 for TRUE).Introduction to VHDL 301
signal  A,B: integer range  0 to 15;
signal  C, D, E: Boolean;
---------------------------------C <= A <= B;D <= A = B;E <= A > B;A
BC
D
EComparator
>=<=FIGURE 10-14
Comparator for
Integers
The shift operators are used to shift or rotate a bit_vector. In the following
examples, A is an 8- bit vector equal to “10010101”:
Asll2 is “01010100” (shift left logical, filled with ‘0’)
Asrl3 is “00010010” (shift right logical, filled with ‘0’)
Asla3 is “10101111” (shift left arithmetic, filled with rightmost bit)
Asra2 is “11100101” (shift right arithmetic, filled with leftmost bit)
Arol3 is “10101100” (rotate left)
Aror5 is “10101100” (rotate right)
We will not utilize these shift operators because some software used for synthesis
uses different shift operators. Instead, we will do shifting using the concatenationoperator. For example, if A in the above listing is dimensioned 7 downto 0, we canimplement shift right arithmetic two places as follows:
A(7)&A(7)&A(7 downto 2)/H11005‘1’&’1’&“100101” /H11005“11100101”
This makes two copies of the sign bit followed by the left 6 bits of A, which gives the
same result as Asra2.
The /H11001and/H11002operators can be applied to integer or real numeric operands. The
& operator can be used to concatenate two vectors (or an element and a vector, ortwo elements) to form a longer vector. For example, “010” & ‘1’ is “0101” and“ABC” & “DEF” is “ABCDEF.”
The * and / operators perform multiplication and division on integer or float-
ing-point operands. The rem and mod operators calculate the remainder and mod-
ulus for integer operands. (We will not use rem and mod; for further discussion ofthese operators see Reference [1].) The ** operator raises an integer or floating-point number to an integer power, and absfinds the absolute value of a numeric
operand.
10.7 Packages and Libraries
Packages and libraries provide a convenient way of referencing frequently usedfunctions and components. A package consists of a package declaration and anoptional package body. The package declaration contains a set of declarationswhich may be shared by several design units. For example, it may contain type, sig-nal, component, function, and procedure declarations. The package body usuallycontains component descriptions and the function and procedure bodies.The pack-age and its associated compiled VHDL models may be placed in a library, so theycan be accessed as required by different VHDL designs. A package declaration hasthe form:
package package-name is
package declarations
end [package ][package-name];302 Unit 10
A package body has the form
package body package-name is
package body declarations
end [package body ][package name];
We have developed a package called bit_pack which is used in a number of exam-
ples in this book. This package contains commonly used components and functionswhich use signals of type bit and bit_vector. A complete listing of this package andassociated component models is included on the CD-ROM that accompanies thistext. Most of the components in this package have a default delay of 10 ns, but thisdelay can be changed by the use of generics. For an explanation of generics, refer toone of the VHDL references. We have compiled this package and the componentmodels and placed the result in a library called BITLIB.
One of the components in the library is a two-input NOR gate named Nor2,
which has default delay of 10 ns. The package declaration for bit_pack includes thecomponent declaration
component Nor2
port (A1, A2: inbit; Z: outbit);
end component ;
The NOR gate is modeled using a concurrent statement. The entity-architecture
pair for this component is
-- two-input NOR gate
entity Nor2 is
port (A1, A2: inbit; Z: outbit);
end Nor2;
architecture concur ofNor2 is
begin
Z/H11021/H11005not(A1orA2)after 10 ns;
end concur;
To access components and functions within a package requires a library state-
ment and a usestatement. The statement
library BITLIB;
allows your design to access the BITLIB. The statement
useBITLIB.bit_pack. all;
allows your design to use the entire bit_pack package. A statement of the form
useBITLIB.bit_pack.Nor2;
may be used if you want to use a specific component (in this case Nor2) or function
in the package.
When components from a library package are used, component declarations are
not needed. Figure 10-15 shows a NOR-NOR circuit and the corresponding struc-tural VHDL code. This code instantiates three copies of the Nor2 gate componentfrom the package bit_pack and connects the gate inputs and outputs.Introduction to VHDL 303
304 Unit 10
10.8 IEEE Standard Logic
Use of two-valued logic (bits and bit vectors) is generally not adequate for simulation
of digital systems. In addition to ‘0’ and ‘1’, values of ‘Z’ (high-impedance or no con-nection) and ‘X’ (unknown) are frequently used in digital system simulation.The IEEEStandard 1164 defines a std_logic type that actually has nine values (‘U’,‘X’,‘0’,‘1’,‘Z’,‘W’,‘L’,‘H’, and ‘–’).We will only be concerned with the first five values in this text.‘U’stands for uninitialized. When a logic circuit is first turned on and before it is reset, thesignals will be uninitialized. If these signals are represented by std_logic, they will havea value of ‘U’ until they are changed. Just as a group of bits is represented by a bit_vec-tor, a group of std_logic signals is represented by a std_logic_vector.
Figure 10-16 shows how a tri-state buffer can be represented by a concurrent
statement. When the buffer is enabled (B /H11005‘1’), the output is A, or else it is high
impedance (‘Z’). A and C could be std_logic_vectors instead of std_logic bits.library  BITLIB;
use BITLIB. bit_pack. all;
entity  nor_nor is
port (A,B,C,D: in bit; G: out bit);
end nor_nor;
architecture  structural of nor_nor is
signal  E,F,BN,CN: bit;  -- internal signals
begin     BN <= not B;  CN <= not C;
     G1: Nor2 port map  (A, BN, E);
     G2: Nor2 port map  (CN, D, F);
     G 3: Nor2 port map  (E, F, G);
end structural;A
B′
C′E
G
F DG1
G2G3FIGURE 10-15
NOR-NOR Circuit
and Structural
VHDL Code
Using Library
Components
ACB
signal  A,B,C: std_logic;
-------------------------------C <= A when  B = '1' else 'Z';FIGURE 10-16
Tri-State Buffer
FIGURE 10-17
Tri-State Buffers
Driving a Bus AB
signal  A,C,F: std_logic_vector( 3 downto  0);
signal  B,D: std_logic;
--------------------------------------------- concurrent statementsF <= A when  B = '1' else "ZZZZ";
F <= C when  D = '1' else "ZZZZ";1
CD F
2Figure 10-17 shows two tri-state buffers with their outputs connected together
by a tri-state bus. If buffer 1 has an output of ‘1’ and buffer 2 has a hi-Z output, thebus value is ‘1’.When both buffers are enabled, if buffer 1 drives ‘0’ onto the bus andbuffer 2 drives ‘1’ onto the bus, the result is a bus conflict. In this case, the bus valueis unknown, which we represent by an ‘X’.
In the VHDL code,A, C, and F are std_logic_vectors and F represents the tri-state
bus.The signal F is driven from two different sources. If the two concurrent statements
Introduction to VHDL 305
assign different values to F, VHDL automatically calls a resolution function to deter-
mine the resulting value. This is similar to the way the hardware works—if the twobuffers have different output values, the hardware resolves the values and comes upwith an appropriate value on the bus. VHDL uses the table of Figure 10-18 to resolvethe bus value when two different std_logic signals, S1 and S2, drive the bus. (Onlysignal values ‘U’, ‘X’, ‘0’, ‘1’, and ‘Z’ are considered here.) This table is similar toFigure 9-10, which is used for four-valued logic simulation, except for the addition ofa row and a column corresponding to ‘U’. When an uninitialized signal is connectedto any other signal, VHDL considers that the result is uninitialized.
S2
S1 U X 0 1 Z
UU U U U U
XU X X X X0U X 0 X 01U X X 1 1ZU X 0 1 ZFIGURE 10-18
Resolution Function
for Two Signals
If A, B, and F are bits (or bit_vectors) and we write the concurrent statements
F/H11021/H11005 A; F /H11021/H11005notB;
the compiler will flag an error because no resolution function exists for signals of
type bit. If A, B, and F are std_logic bits or vectors, the compiler will generate a callto the resolution function and not report an error. If F is assigned conflicting valuesduring simulation, then F will be set to ‘X’ (unknown).
In order to use signals of type std_logic and std_logic_vector in a VHDL mod-
ule, the following declarations must be placed before the entity declaration:
library ieee;
useieee.std_logic_1164. all;
The IEEE std_logic_1164 package defines std_logic and related types, logic opera-
tions on these types, and functions for working with these types.
The original IEEE standards for VHDL do not define arithmetic operations on
bit_vectors or on std_logic vectors. Based on these standards, we cannot add, sub-tract, multiply, or divide bit_vectors or std_logic_vectors without first convertingthem to other types. For example, if A and B are bit_vectors, the expression A /H11001B
is not allowed. However, VHDL libraries and packages are available that definearithmetic and comparison operations on std_logic_vectors. The operators definedin these packages are referred to as overloaded operators. This means that the com-
piler will automatically use the proper definition of the operator depending onits context. For example, when evaluating the expression A /H11001B, if A and B are inte-
gers, the compiler will use the integer arithmetic routine to do the addition. On theother hand, if A and B are of type std_logic_vector, the compiler will use the addi-tion routine for standard logic vectors. In order to use overloaded operators, theappropriate library and use statements must be included in the VHDL code so thatthe compiler can locate the definitions of these operators.
In this text, we will use the std_logic_unsigned package, originally developed by
Synopsis and now widely available. This package treats std_logic_vectors as
306 Unit 10
unsigned numbers. The std_logic_unsigned package defines arithmetic operators
(/H11001,/H11002, *) and comparison operators ( /H11021,/H11021/H11005,/H11005,//H11005,/H11022,/H11022/H11005) that operate on
std_logic_vectors. For /H11001,/H11002, and comparison operators, if the two operands are of
different length, the shorter operand is filled on the left end with zeros.
These operations can also be applied when the left operand is a std_logic_vec-
tor and the right operand is an integer. The arithmetic operations return astd_logic_vector, and the comparison operations return a Boolean. For example, ifA is “10011”, A /H110017 returns a value of “11010”, and A /H11022/H11005 5 returns TRUE. In these
examples, /H11001and/H11022/H11005 are overloaded operators, and the compiler automatically calls
the appropriate routine to add an integer to a std_logic_vector or to compare aninteger with a std_logic_vector.
If A and B are 4-bit std_logic vectors, A /H11001B gives their sum as a 4-bit vector, and
any carry is lost. If the carry is needed, then A must be extended to five-bits beforeaddition. This is accomplished by concatenating a ‘0’ in front of A. Then ‘0’ &A /H11001B
gives a 5-bit sum that can be split into a carry and a 4-bit sum.
Figure 10-19 shows a binary adder and its VHDL representation using the
std_logic_unsigned package. Addout is a 5-bit sum that is split into Sum and Cout.For example, if A /H11005“1011”, B /H11005“1001”, and Cin /H11005‘1’, Addout evaluates to
“10101”, which is then split into a sum “0101” with a carry out of ‘1’.
Figure 10-20 shows how to implement the bi-directional input-output pin and
tri-state buffer of Figure 9-12 using IEEE std_logic.The I/O pin declared in the port
4-Bit Adder Cout Cin
ABSumlibrary  IEEE;
use IEEE.std_logic_1164. all;
use IEEE.std_logic_unsigned. all;
--------------------------------------------signal  A,B,Sum: std_logic_vector( 3 downto  0);
signal  Addout: std_logic_vector(4 downto  0);
signal  Cin,Cout: std_logic;
------------------------------------Addout <= '0'&A + B + Cin;Sum <= Addout( 3 downto  0);
Cout <= Addout(4);FIGURE 10-19
VHDL Code for
Binary Adder
entity IC_pin is
port(IO_pin: inout std_logic);
end entity ;
architecture bi_dir ofIC_pin is
component IC
port(input: instd_logic; output: outstd_logic);
end component ;
signal input, output, en: std_logic;
begin -- connections to bi-directional I/O pin
IO_pin /H11021/H11005 output when en/H11005‘1’else ‘Z’;
input /H11021/H11005 IO_pin;
IC1: IC port map (input, output);
end bi_dir;FIGURE 10-20
VHDL Code for 
Bi-Directional
I/O Pin
Introduction to VHDL 307
is of mode inout . The concurrent statements in the architecture connect the IC out-
put to the pin via a tri-state buffer and also connect the pin to the IC input.
10.9 Compilation and Simulation of VHDL Code
After describing a digital system in VHDL, simulation of the VHDL code is impor-tant for two reasons. First, we need to verify the VHDL code correctly implementsthe intended design, and second, we need to verify that the design meets its specifi-cations. Before the VHDL model of a digital system can be simulated, the VHDLcode must first be compiled (see Figure 10-21). The VHDL compiler, also called ananalyzer, first checks the VHDL source code to see that it conforms to the syntaxand semantic rules of VHDL. If there is a syntax error such as a missing semicolonor a semantic error such as trying to add two signals of incompatible types, the com-piler will output an error message. The compiler also checks to see that referencesto libraries are correct. If the VHDL code conforms to all of the rules, the compilergenerates intermediate code which can be used by a simulator or by a synthesizer.
In preparation for simulation, the VHDL intermediate code must be converted to
a form which can be used by the simulator. This step is referred to as elaboration .
During elaboration, ports are created for each instance of a component, memory stor-age is allocated for the required signals, the interconnections among the port signalsare specified, and a mechanism is established for executing the VHDL statements inthe proper sequence. The resulting data structure represents the digital system beingsimulated. After an initialization phase, the simulator enters the execution phase. Thesimulator accepts simulation commands which control the simulation of the digitalsystem and specify the desired simulator output.
Understanding the role of the delta ( /H9004) time delays is important when interpreting
output from a VHDL simulator. Although the delta delays do not show up on wave-form outputs from the simulator, they show up on listing outputs. The simulator usesdelta delays to make sure that signals are processed in the proper sequence. Basically,the simulator works as follows: Whenever a component input changes, the output isscheduled to change after the specified delay or after /H9004if no delay is specified.When all
input changes have been processed, the simulated time is advanced to the next time atwhich an output change is specified.When time is advanced by a finite amount (1 ns forexample), the /H9004counter is reset, and simulation resumes. Real time does not advance
again until all /H9004delays associated with the current simulation time have been processed.
Compiler Simulator
Synthesizer Implementer HardwareSimulator
OutputVHDL
CodeVHDL
LibrariesSimulator
Commands
Intermediate
CodeFIGURE 10-21
Compilation,
Simulation, and
Synthesis of VHDL
Code
308 Unit 10
Problems
10.1 Write VHDL statements that represent the following circuit:
(a) Write a statement for each gate.(b) Write one statement for the whole circuit.
A′
B
CF
N
GI
D
E′1     B <= not A;
2     C <= notB;
3     D <= notCafter  5 ns;D C B A FIGURE 10-22
Simulation of
VHDL Codens delta A B C D
0 /H1100100 1 0 1
3 /H1100101 1 0 1
3 /H1100111 0 0 1
3 /H1100121 0 1 1
8 /H1100101 0 1 0The following example illustrates how the simulator works for the circuit of
Figure 10-22. Suppose that A changes at time /H110053 ns. Statement 1 executes, and B is
scheduled to change at time 3 /H11001/H9004. Then time advances to 3 /H11001/H9004, and statement 2 exe-
cutes. C is scheduled to change at time 3 /H110012/H9004.Time advances to 3 /H110012/H9004, and statement
3 executes. D is then scheduled to change at 8 ns. You may think the change shouldoccur at (3 /H110012/H9004/H11001 5) ns. However, when time advances a finite amount (as opposed
to/H9004, which is infinitesimal), the /H9004counter is reset. For this reason, when events are
scheduled a finite time in the future, the /H9004’s are ignored. Because no further changes
are scheduled after 8 ns, the simulator goes into an idle mode and waits for anotherinput change. The table gives the simulator output listing.
After the VHDL code for a digital system has been simulated to verify that it works
correctly, the VHDL code can be synthesized to produce a list of required componentsand their interconnections. The synthesizer output can then be used to implement thedigital system using specific hardware such as a CPLD or FPGA. The CAD softwareused for implementation generates the necessary information to program the CPLDor FPGA hardware. The synthesis and implementation of digital logic from VHDLcode is discussed in more detail in Unit 17.
In this chapter, we have covered the basics of VHDL. We have shown how to
use VHDL to model combinational logic and how to construct a VHDL moduleusing an entity-architecture pair. Because VHDL is a hardware description lan-guage, it differs from an ordinary programming language in several ways. Mostimportantly,VHDL statements execute concurrently because they must model realhardware in which the components are all in operation at the same time.
Introduction to VHDL 309
10.2 Draw the circuit represented by the following VHDL statements:
F/H11021/H11005 Eand I;
I/H11021/H11005 GorH;
G/H11021/H11005 Aand B;
H/H11021/H11005notCand D;
10.3 (a) Implement the following VHDL conditional statement using two 2-to-1 MUXes:
F/H11021/H11005 Awhen D/H11005‘1’else Bwhen E/H11005‘1’else C;
(b) Implement the same statement using gates.
10.4 Write the VHDL code for Figure 9-4 using a conditional signal assignment state-
ment. Use bit_vectors for X, Y, and Z.
10.5 Write a VHDL module that implements a full adder using an array of bit_vectors to
represent the truth table.
10.6 (a) Given that A /H11005“00101101” and B /H11005“10011”, determine the value of F:
F/H11021/H11005notB & “0111” orA & ‘1’ and‘1’& A;
(b) Given A /H11005“11000”, B /H11005“10011”, and C /H11005“0111”, evaluate the following
expression:
notA/H11001C * 2 /H11022B / 4 & “00”
10.7 Write a VHDL module that finds the average value of four 16-bit unsigned numbers
that are represented by std_logic_vectors. Division by four is best accomplished byshifting. Round off your answer to the nearest integer.
10.8 Write VHDL code for the system shown in Figure 9-11. Use four concurrent state-
ments to compute the signal on the tri-state bus.
10.9 (a) Draw the circuit represented by the following VHDL statements:
T1/H11021/H11005notAand not Band I0;
T2/H11021/H11005notAand Band I1;
T3/H11021/H11005
Aand not Band I2;
T4/H11021/H11005 Aand Band I3;
F/H11021/H11005 T1orT2orT3orT4;
(b) Draw a MUX that implements F. Then write a selected signal assignment state-
ment that describes the MUX.
10.10 Assume that the following are concurrent VHDL statements:
(a)L/H11021/H11005 Pnand Qafter 10 ns;
(b) M/H11021/H11005 LnorNafter 5 ns;
(c)R/H11021/H11005notM;
Initially at time t/H110050 ns, P /H110051, Q /H110051, and N /H110050. If Q becomes 0 at time t/H110054 ns,
(1) At what time will statement (a) execute?(2) At what time will L be updated?
310 Unit 10
(3) At what time will statement (c) execute?
(4) At what time will R be updated?
10.11 (a) Write a single concurrent VHDL statement to represent the following circuit.
Do not use parentheses in the statement.
(b) Write individual statements to represent the circuit of part (a). Assume that all
NAND gates have a delay of 10 ns, all NOR gates have a delay of 15 ns, andinverters have a delay of 5 ns.
10.12 Draw a circuit that implements the following VHDL code.
V/H11021/H11005 Tand U;
U/H11021/H11005notRorSand Por not QorS;
T/H11021/H11005notPorQorR;
10.13 Suppose L, M, and N are of type std_logic. If the following are concurrent state-
ments, what are the values of L, M, and N? You can use the resolution function givenin Figure 10-18.
L/H11021/H11005 ‘1’; L /H11021/H11005 ‘0’;
M/H11021/H11005 ‘1’when L/H11005’0’else ‘Z’when L/H11005’1’else ‘0’;
N/H11021/H11005 Mwhen L/H11005’0’else not M;
N/H11021/H11005 ‘Z’;
10.14 (a) Given that D /H11005“011001” and E /H11005“110”, determine the value of F.
F/H11021/H11005notE & “011” or“000100” and not D;
(b) Given A /H11005“101” and B /H11005“011”, evaluate the following expression:
not(A & B) /H11021(notB & A and not A & A)
10.15 Write VHDL code to implement the following logic functions using a 16 words /H110033 bits
ROM.
W/H11005A/H11032B/H11032C/H11001C/H11032D/H11001ACD /H11032
X/H11005A/H11032C/H11032/H11001B/H11032D
Y/H11005BD/H11032/H11001B/H11032C/H11032D
10.16 The diagram shows an 8-bit-wide data bus that transfers data between a micro-
processor and memory. Data on this bus is determined by the control signals mReadand mWrite. When mRead /H11005‘1’, the data on the memory’s internal bus ‘membus’ is
output to the data bus. When mWrite /H11005‘1’, the data on the processor’s internal busA
B
DCG
HE F
Introduction to VHDL 311
‘probus’ is output to the data bus. When both control signals are ‘0’, the data bus
must be in a high-impedance state.
(a) Write VHDL statements to represent the data bus.
(b) Normally mRead /H11005mWrite /H11005‘1’ does not occur. But if it occurs, what value
will the data bus take?
10.17 (a) Write a selected signal assignment statement to represent the 4-to-1 MUX
shown below. Assume that there is an inherent delay in the MUX that causesthe change in output to occur 15 ns after a change in input.
(b) Repeat (a) using a conditional signal assignment statement.
10.18 (a) Write a complete VHDL module for a two-input NAND gate with 4-ns delay.
(b) Write a complete VHDL module for the following circuit that uses the NAND
gate module of Part (a) as a component.
.
10.19 In the following circuit, all gates, including the inverter, have an inertial delay of 10 ns.
(a) Write VHDL code that gives a dataflow description of the circuit. All delays
should be inertial delays.
(b) Using the Direct VHDL simulator simulate the circuit. (Use a View Interval of
100 ns.) Initially set A /H110051, B /H110051 and C /H110051, then run the simulator for 40 ns.
Change B to 0, and run the simulator for 40 ns. Record the waveform.
(c) Change the VHDL code of Part (a) so that the inverter has a delay of 5 ns.(d) Repeat Part (b).(e) Change the VHDL code of Part (c) so that the output OR gate has a transport
delay rather than an inertial delay.
(f) Repeat Part (b)(g) Explain any differences between the waveforms for Parts (b), (d), and (f).A
B
F
C
DI0
I3I2I1A'
B
B'
0
CDFProcessorData Bus
8-BitMemor y
312 Unit 10
10.20 In the following circuit, all gates, including the inverter, have an inertial delay of
10 ns except for gate 3, which has delay 40 ns.(a) Write VHDL code that gives a dataflow description of the circuit. All delays
should be inertial delays.
(b) Using the Direct VHDL simulator simulate the circuit. (Use a View Interval of
150 ns.) Initially set A /H110051, B /H110051, C /H110051 and D /H110050, then run the simulator for
60 ns. Change B to 0, and run the simulator for 60 ns. Record the waveform.
(c) Change the VHDL code of Part (a) so that the inverter has a delay of 5 ns.(d) Repeat Part (b).(e) Change the VHDL code of Part (c) so that gates 4 and 5 have a transport delay
rather than an inertial delay.
(f) Repeat Part (b)(g) Explain any differences between the waveforms for Parts (b), (d), and (f).
10.21 Write VHDL code that gives a behavioral description of a circuit that converts the
representation of decimal digits in BCD to the representation using the 2-4-2-1weighted code, as follows:A
B
C
Df 5
341
2A
B
Cf
Digit 2421 code
0 0000
1 00012 00103 00114 01005 10116 11007 11018 11109 1111
Introduction to VHDL 313
For the six input combinations that do not represent valid BCD digits, the circuit
output should be “XXXX”. Make the inputs and outputs of type std_logic.(a) Write the code using the when else assignment statement.
(b) Use the VHDL simulator to verify the code of Part (a) for the inputs x/H110050100,
0101, 1001, and 1010.
(c) Write the code using the with select when assignment statement.
(d) Use the VHDL simulator to verify the code of Part (c) for the inputs x/H110050100,
0101, 1001, and 1010.
10.22 Write VHDL code that gives a behavioral description of a circuit that converts the
representation of decimal digits in the weighted code with weights 8, 4, /H110022 and /H110021
to the representation using the excess-3 code.(a) Write the code using the when else assignment statement.
(b) Use the VHDL simulator to verify the code of Part (a) for the inputs x/H110050011,
0100, 1001, and 1010.
(c) Write the code using the with select when assignment statement.
(d) Use the VHDL simulator to verify the code of Part (c) for the inputs x/H110050100,
0101, 1001, and 1010.
Design Problems
10.A (a) Design a 4-to-1 MUX using only three 2-to-1 MUXes. Write an entity-architec-
ture pair to implement a 2-to-1 MUX. Then write an entity-architecture pair toimplement a 4-to-1 MUX using three instances of your 2-to-1 MUX.
[Hint : The equation for a 4-to-1 MUX can be rewritten as
F/H11005A/H11032(I
0B/H11032/H11001I1B)/H11001A(I2B/H11032/H11001 I3B)].
Use the following port definitions:For the 2-to-1 MUX:
port (i0, i1: inbit; sel: inbit; z: outbit);
For the 4-to-1 MUX:
port (i0, i1, i2, i3: inbit; a, b: inbit; f: outbit);
(b) Simulate your code and test it using the following inputs:
I0/H11005I2/H110051, I1 /H11005I3/H110050, AB /H1100500, 01, 11, 10
10.B (a) Show how a BCD to Gray code converter can be designed using a 16 words /H11003
4 bits ROM. Then write an entity-architecture pair to implement the converterusing the ROM. For your code to function correctly, you will need to add thefollowing two lines of code to the top of your program.
library BITLIB;
useBITLIB.bit_pack. all;
Use the port definition specified below for the ROM:
port (bcd: inbit_vector (3 downto 0);
gray: outbit_vector (3 downto 0));
314 Unit 10
(b) Simulate your code and test it using the following inputs:
BCD /H110050010, 0101, 1001
10.C (a) A half adder is a circuit that can add two bits at a time to produce a sum and a
carry. Design a half adder using only two gates.Write an entity-architecture pairto implement the half adder. Now write an entity-architecture pair to imple-ment a full adder using two instances of your half adder and an OR gate. Usethe port definitions specified below:
For the half adder: port (a, b: in bit; s, c:out bit );
For the full adder: port (a, b, cin: in bit; sum, cout: out bit );
(b) Simulate your code and test it using the following inputs:
a b cin /H110050 0 1, 0 1 1, 1 1 1, 1 1 0, 1 0 0
10.D (a) Using a 3-to-8 decoder and two four-input OR gates, design a circuit that has
three inputs and a 2-bit output. The output of the circuit represents (in binaryform) the number of 1’s present in the input. For example, when the input isABC /H11005101, the output will be Count /H1100510. Write an entity-architecture pair to
implement a 3-to-8 decoder. Then write an entity-architecture pair for your cir-cuit, using the decoder as a component. Use the port definitions specified below.
For the 3-to-8 decoder:
port (a, b, c: in bit ;
y0, y1, y2, y3, y4, y5, y6, y7: out bit );
For the main circuit: port (a, b, c: in bit ; count: outbit_vector (1 downto 0));
(b) Simulate your code and test it using the following inputs:
a b c /H110050 0 0, 0 1 0, 1 1 0, 1 1 1, 0 1 1
10.E (a) Show how a BCD to seven-segment LED code converter can be designed, using
a 16 words /H110037 bits ROM.Then write an entity-architecture pair to implement the
converter using the ROM. Use the vec2int function in BITLIB for this problem.
Use the port definition specified below for the ROM:
port (bcd: inbit_vector (3 downto 0);
seven: outbit_vector (6 downto 0));
(b) Simulate your code and test it using the following inputs:
BCD /H110050000, 0001, 1000, 1001
10.F (a) Using a 3-to-8 decoder, two three-input OR gates, and one two-input OR gate,
design a circuit that has three inputs and a 1-bit output. The output of the cir-cuit is 1 when the input 3-bit number is less than 3 or is greater than 4. Write anentity-architecture pair to implement a 3-to-8 decoder. Then write an entity-architecture pair for your circuit using the decoder as a component. Use theport definitions specified below.
For the 3-to-8 decoder:
port (a, b, c: in bit ;
y0, y1, y2, y3, y4, y5, y6, y7: out bit );
For the main circuit:
port (a, b, c: in bit ; output : out bit );
(b) Simulate your code and test it using the following inputs:
a b c /H110050 0 0, 1 0 0, 1 0 1, 0 0 1, 0 1 1
10.G (a) Write the VHDL code for a full subtracter, using logic equations. Assume that
the full subtracter has a 5-ns delay.
(b) Write the VHDL code for a 4-bit subtracter using the module defined in (a) as a
component.
(c) Simulate your code and test it using the following inputs:
1100 – 0101, 0110 – 1011
10.H (a) The diagram shows an 8-bit shifter that shifts its input one place to the left.
Write a VHDL module for the shifter.
(b) Write a VHDL module that multiplies an 8-bit input (C) by 1012to give a 11-bit
product (D). This can be accomplished by shifting C two places to the left andadding the result to C. Use two of the modules written in (a) as components andan overloaded operator for addition.
(c) Simulate your code and test it using the following inputs:
10100101 11111111
10.I (a) Design a 4-to-2 priority encoder using gates [see Unit 9, Study Guide, Part 4(b)].
Write a VHDL module for your encoder. Use the port declaration
Port ( y : instd_logic_vector(0 to3);
a1,b1,c1: outstd_logic);
(b) Design an 8-to-3 priority encoder (Figure 9-16), using two instances of the 4-to-2
priority encoder you designed, two 2-to-1 multiplexers, and one OR gate. Write aVHDL module for the 8-to-3 encoder. Use the port declaration
Port ( y : instd_logic_vector(0 to7);
a,b,c,d : outstd_logic);
(Hint : In building the 8-to-3 encoder, use one 4-to-2 encoder for the four most
significant bits, and the other for the four least significant bits. Outputs b and cof the 8-to-3 encoder should come from the multiplexers.)
(c) Simulate your code and test it using the following inputs:
00000000, 10000000, 11000000, ---, 11111111
10.J (a) Write a VHDL module for a 4-bit adder, with a carry-in and carry-out, using an
overloaded addition operator and std_logic_vector inputs and outputs.B (7 down to 0)
A (7 down to 0)Lout RinIntroduction to VHDL 315
(b) Design an 8-bit subtracter with a borrow-out, using two of the 4-bit adders you
designed in (a), along with any necessary gates or inverters. Write a VHDLmodule for the subtracter.
(c) Simulate your code and test it using the following inputs:
11011011 – 01110110, 01110110 – 11011011
10.K (a) Write a VHDL module for a tri-state buffer, with 6-bit data inputs and outputs
and one control input.
(b) Design a 4-to-1 multiplexer with 6-bit data inputs and outputs and two control
inputs. Use four tri-state buffers from part (a) and a 2-to-4 decoder.
(c) Simulate your code and test it for the following data inputs:
000111, 101010, 111000, 010101
10.L (a) Write a VHDL module for a ROM with four inputs and three outputs. The 3-bit
output should be a binary number equal to the number of 1’s in the ROM input.
(b) Write a VHDL module for a circuit that counts the number of 1’s in a 12-bit
number. Use three of the modules from (a) along with overloaded additionoperators.
(c) Simulate your code and test it for the following data inputs:
111111111111, 010110101101, 100001011100
10.M (a) Write a VHDL module for a full subtracter using a ROM to implement the
truth table.
(b) Write a VHDL module for a 3-bit subtracter using the module defined in
part (a). Your module should have a borrow-in and a borrow-out.
(c) Simulate your code and test it for the following data:
110/H11002 010 with a borrow input of 1
011/H11002 101 with a borrow input of 0
10.N (a) Design a 4-to-2 priority encoder with an enable input, using gates. (See Unit 9,
Study Guide Part 4(b)).When enable is 0, all outputs are 0.Write a VHDL mod-ule for the encoder. Use the following port declaration:
Port ( y :instd_logic_vector(0 to3);
enable : instd_logic; a1,b1,c1 : outstd_logic);
(b) Design an 8-to-3 priority encoder (Figure 9-16) with an enable input, using two
of the 4-to-2 priority encoders you designed in (a), three OR gates, an ANDgate, and one inverter. Then write a VHDL module for this encoder. Use theport declaration:
Port ( y :instd_logic_vector(0 to7);
main_enable : instd_logic; a,b,c,d : outstd_logic);
(Hint : In building the 8-to-3 encoder, use one 4-to-2 encoder for the four most
significant bits, and another for the four least significant bits.Also, outputs b andc of the 8-to-3 encoder should come from OR gates. The enable input to theencoder for the least significant bits depends on the main_enable signal and thec1 output from the encoder for the most significant bits.)
(c) Simulate your code and test it using the following inputs:
00000000, 10000000, 11000000, ---, 11111111316 Unit 10
317CHAPTER
00Latches and Flip-Flops
Objectives
In this unit you will study one of the basic building blocks used in sequen-
tial circuits—the flip-flop. Some of the basic analysis techniques used forsequential circuits are introduced here. In particular, you will learn how toconstruct timing diagrams which show how each signal in the circuit variesas a function of time. Specific objectives are:
1.Explain in words the operation of S-R and gated D latches.
2.Explain in words the operation of D, D-CE, S-R, J-K, and T flip-flops.
3.Make a table and derive the characteristic (next-state) equation for such
latches and flip-flops. State any necessary restrictions on the input signals.
4.Draw a timing diagram relating the input and output of such latches and
flip-flops.
5.Show how latches and flip-flops can be constructed using gates. Analyze
the operation of a flip-flop that is constructed of gates and latches.
UNIT
11
318 Unit 11
1.Review Section 8.3, Gate Delays and Timing Diagrams .Then study Section 11.1,
Introduction .
(a) In the circuit shown, suppose that at some instant of time the inputs to
both inverters are 0. Is this a stable condition of the circuit?
Assuming that the output of the left inverter changes before the output of
the right inverter, what stable state will the circuit reach? (Indicate 0’s and1’s on the inverters’ inputs and outputs.)
(b) Work Problem 11.1.
2.Study Section 11.2, Set-Reset Latch .
(a) Build an S-R latch in SimUaid , using NOR gates as in Figure 11-3. Place
switches on the inputs and probes on the outputs. Experiment with it.Describe in words the behavior of your S-R latch.
(b) For Figure 11-4(b), what values would Pand Qassume if S/H11005R/H110051?
(c) What restriction is necessary on SandRso that the two outputs of the S-R
latch are complements?
(d) State in words the meaning of the equation Q
/H11001/H11005S/H11001R/H11032Q.
(e) Starting with Q/H110050 and /H11005/H11005 1 in Figure 11-10(a), change to 0 and
trace signals through the latch until steady-state is reached. Then, change
to 1 and to 0 and trace again.
(f) Work Problems 11.2 and 11.3.
3.Study Section 11.3, Gated D Latch .
(a) Build a gated Dlatch in SimUaid . See Figure 11-11. (Construct the S-R
latch as in Study Guide Section 2(a).) Place switches on the inputs andprobes on the outputs. Experiment with it. Describe in words the behaviorof your gated D latch.
(b) State in words the meaning of the equation Q
/H11001/H11005G/H11032Q/H11001GD.R SS R S0 0Study Guide
Latches and Flip-Flops 319
(c) Given a gated Dlatch with the following inputs, sketch the waveform for Q.
(d) Work Problem 11.4.
4.Study Section 11.4, Edge-Triggered D Flip-Flop .
(a) Experiment with a D flip-flop in SimUaid . Use the D flip-flop on the parts
menu. Place switches on the inputs and probes on the outputs. Describe inwords the behavior of your D flip-flop.
(b) Given a rising-edge-triggered D flip-flop with the following inputs, sketch
the waveform for Q.
(c) Work Programmed Exercise 11.29.
(d) A D flip-flop with a falling-edge trigger is behaving erratically. It has a setup
time of 2 ns and a hold time of 2 ns.The figure shows the inputs to the flip-flopover a typical clock cycle. Why might the flip-flop be behaving erratically?
(e) Suppose that for the circuit of Figure 11-17, new semiconductor technology has
allowed us to improve the delays and setup times.The propagation delay of thenew inverter is 1.5 ns, and the propagation delay and setup times of the newflip-flop are 3.5 ns and 2 ns, respectively. What is the shortest clock period forthe circuit of Figure 11-17(a) which will not violate the timing constraints?
(f) Work Problem 11.5.
5.Study Section 11.5, S-R Flip-Flop .
(a) Describe in words the behavior of an S-R flip-flop.Clock
D
1 nsD
QClockD
G
Q
320 Unit 11
(b) Trace signals through the circuit of Figure 11-19(a) and verify the timing
diagram of Figure 11-19(b).
(c) What is the difference between a master-slave flip-flop and an edge-triggered
flip-flop? Assume that Qchanges on the rising clock edge in both cases.
(d) Work Problem 11.6.
6.Study Section 11.6, J-K Flip-Flop .
(a) Experiment with a J-Kflip-flop in SimUaid. Use the J-Kflip-flop in the
parts menu. Place switches on the inputs and probes on the outputs.Describe in words the behavior of your J-Kflip-flop.
(b) Derive the next-state equation for the J-K flip-flop.
(c) Examine Figures 11-19(a) and 11-21. Construct a J-K flip-flop, using a mas-
ter-slave S-R flip-flop and two AND gates. (Do not draw the interior of theS-R flip-flop. Just use the symbol in Figure 11-18.)
(d) Work Problem 11.7.
7.Study Section 11.7, T Flip-Flop .
(a) Construct a T flip-flop in SimUaid from a D flip-flop as in Figure 11-24(b).
Place switches on the inputs and probes on the outputs. Experiment with it.Describe in words the behavior of the T flip-flop.
(b) Complete the following timing diagram (assume that Q/H110050 initially):
8.Study Section 11.8, Flip-Flops with Additional Inputs .
(a) To set the flip-flop of Figure 11-25 to Q/H110051 without using the clock, the
ClrN input should be set to __________ and the PreN input to __________ .To reset this flip-flop to Q/H110050 without using the clock, the __________ input
should be set to __________ and the __________ input to __________ .Clock
QT
1 2 3 4
Latches and Flip-Flops 321
(b) Complete the following timing diagram for a rising-edge-triggered D flip-
flop with ClrN and PreN inputs. Assume Qbegins at 0.
(c) In Figure 11-27(a), what would happen if En changed from 1 to 0
while CLK /H110051?
What if En changed when CLK /H110050?
In order to have Qchange synchronization with the clock, what restriction
must be placed on the time at which En can change?
Why does this restriction not apply to Figures 11-27(b) and (c)?
(d) Make a table similar to Figure 11-25(b) that describes the operation of a
D flip-flop with a falling-edge clock input, a clock enable input, and anasynchronous active-low clear input (ClrN), but no preset input.
(e) Work Problems 11.8 and 11.9.
9.Study Section 11.9, Summary .
(a) Given one of the flip-flops in this chapter or a similar flip-flop, you
should be able to derive the characteristic equation which gives the nextstate of the flip-flop in terms of the present state and inputs. You shouldunderstand the meaning of each of the characteristic equations given inSection 11.9.
(b) An S-R flip-flop can be converted to a T flip-flop by adding gates at the S
and Rinputs. The Sand Rinputs must be chosen so that the flip-flop will
change state whenever T/H110051 and the clock is pulsed. In order to determine
theSandRinputs, ask yourself the question, “Under what conditions must
the flip-flop be set to 1, and under what conditions must it be reset?” Theflip-flop must be set to 1 if Q/H110050 and T/H110051.
Therefore, S/H11005__________ . In a similar manner, determine the equation
forRand draw the circuit which converts an S-R flip-flop to a T flip-flop.QPreNClrNDClock
322 Unit 11
(c) Work Problem 11.10.
10. When you are satisfied that you can meet the objectives of this unit, take the
readiness test.
11.1 Introduction
Sequential switching circuits have the property that the output depends not only onthe present input but also on the past sequence of inputs. In effect, these circuitsmust be able to “remember” something about the past history of the inputs in orderto produce the present output. Latches and flip-flops are commonly used memorydevices in sequential circuits. Basically, latches and flip-flops are memory deviceswhich can assume one of two stable output states and which have one or moreinputs that can cause the output state to change. Several common types of latchesand flip-flops are described in this unit.
In Units 12 through 16, we will discuss the analysis and design of synchronous digi-
tal systems. In such systems, it is common practice to synchronize the operation of allflip-flops by a common clock or pulse generator. Each of the flip-flops has a clock input,and the flip-flops can only change state in response to a clock pulse. The use of a clockto synchronize the operation of several flip-flops is illustrated in Units 12 and 13. Amemory element that has no clock input is often called a latch, and we will follow thispractice. We will then reserve the term flip-flop to describe a memory device thatchanges output state in response to a clock input and not in response to a data input.
The switching circuits that we have studied so far have not had feedback connec-
tions. By feedback we mean that the output of one of the gates is connected back intothe input of another gate in the circuit so as to form a closed loop. In order to con-struct a switching circuit that has memory, such as a latch or flip-flop, we must intro-
duce feedback into the circuit. For example, in the NOR-gate circuit of Figure 11-3(a),the output of the second NOR gate is fed back into the input of the first NOR gate.
Latches and Flip-Flops
Latches and Flip-Flops 323
In simple cases, we can analyze circuits with feedback by tracing signals through
the circuit. For example, consider the circuit in Figure 11-1(a). If at some instant oftime the inverter input is 0, this 0 will propagate through the inverter and cause theoutput to become 1 after the inverter delay. This 1 is fed back into the input, so afterthe propagation delay, the inverter output will become 0. When this 0 feeds backinto the input, the output will again switch to l, and so forth.The inverter output willcontinue to oscillate back and forth between 0 and 1, as shown in Figure 11-1(b), andit will never reach a stable condition. The rate at which the circuit oscillates is deter-mined by the propagation delay in the inverter.X
X
tFeedback
(a) Inverter with feedback (b) Oscillation at inverter outputFIGURE 11-1
1 00 1
(a)0 11 0
(b)FIGURE 11-2
Next, consider a feedback loop which has two inverters in it, as shown in
Figure 11-2(a). In this case, the circuit has two stable conditions, often referred to asstable states. If the input to the first inverter is 0, its output will be 1. Then, the input tothe second inverter will be 1, and its output will be 0. This 0 will feed back into the firstinverter, but because this input is already 0, no changes will occur.The circuit is then ina stable state. As shown in Figure 11-2(b), a second stable state of the circuit occurswhen the input to the first inverter is 1 and the input to the second inverter is 0.
11.2 Set-Reset Latch
We can construct a simple latch by introducing feedback into a NOR-gate circuit, asseen in Figure 11-3(a). As indicated, if the inputs are S/H11005R/H110050, the circuit can
assume a stable state with Q/H110050 and P/H110051. Note that this is a stable condition of
the circuit because P/H110051 feeds into the second gate forcing the output to be Q/H110050,
and Q/H110050 feeds into the first gate allowing its output to be 1. Now if we change S
to 1, Pwill become 0. This is an unstable condition or state of the circuit because
both the inputs and output of the second gate are 0; therefore Qwill change to 1,
leading to the stable state shown in Figure 11-3(b).
SP
1
(a)Q
00R0SP
0
(b)Q
11R0FIGURE 11-3
324 Unit 11
IfSis changed back to 0, the circuit will not change state because Q/H110051 feeds
back into the first gate, causing Pto remain 0, as shown in Figure 11-4(a). Note that
the inputs are again S/H11005R/H110050, but the outputs are different than those with which
we started. Thus, the circuit has two different stable states for a given set of inputs.If we now change Rto 1, Qwill become 0 and Pwill then change back to 1, as seen
in Figure 11-4(b). If we then change Rback to 0, the circuit remains in this state and
we are back where we started.
This circuit is said to have memory because its output depends not only on the
present inputs, but also on the past sequence of inputs. If we restrict the inputs so thatR/H11005S/H110051 is not allowed, the stable states of the outputs PandQare always comple-
ments, that is, P/H11005Q/H11032. To emphasize the symmetry between the operation of the two
gates, the circuit is often drawn in cross-coupled form [see Figure 11-5(a)]. As shown
in Figures 11-3(b) and 11-4(b), an input S/H110051setsthe output to Q/H110051, and an input
R/H110051resets the output to Q/H110050. When used with the restriction that RandScannot
be 1 simultaneously, the circuit is commonly referred to as a set-reset (S-R) latch and
given the symbol shown in Figure 11-5(b). Note that although Qcomes out of the NOR
gate with the Rinput, the standard S-R latch symbol has Qdirectly above the Sinput.
IfS/H11005R/H110051, the latch will not operate properly, as shown in Figure 11-6. The
notation 1 S0 means that the input is originally 1 and then changes to 0. Note that
when Sand Rare both l, Pand Qare both 0. Therefore, Pis not equal to Q/H11032
, and
this violates a basic rule of latch operation that requires the latch outputs to be com-plements. Furthermore, if Sand Rare simultaneously changed back to 0, Pand Q
may both change to 1. If S/H11005R/H110050 and P/H11005Q/H11005l, then after the 1’s propagateSP
0
(a)Q
10R0SP
1
(b)Q
00R1FIGURE 11-4
Q
RQ′
RQ
S SQ′
L
(a) (b)FIGURE 11-5
S-R Latch
S
RP0→1→0→1
Q0→1→0→11→0
1→0FIGURE 11-6
Improper S-R Latch
Operation
Latches and Flip-Flops 325
through the gates, Pand Qwill become 0 again, and the latch may continue to
oscillate if the gate delays are equal.
Figure 11-7 shows a timing diagram for the S-R latch. Note that when Schanges
to 1 at time tl,Qchanges to 1 a short time ( /H9280) later. ( /H9280represents the response time
or delay time of the latch.) At time t2, when Schanges back to 0, Qdoes not change.
At time t3,Rchanges to 1, and Qchanges back to 0 a short time ( /H9280) later. The dura-
tion of the S(orR) input pulse must normally be at least as great as /H9280in order for a
change in the state of Qto occur. If S/H110051 for a time less than /H9280, the gate output will
not change and the latch will not change state.
When discussing latches and flip-flops, we use the term present state to denote the
state of the Qoutput of the latch or flip-flop at the time any input signal changes, and
the term next state to denote the state of the Qoutput after the latch or flip-flop has
reacted to the input change and stabilized. If we let Q(t) represent the present state
andQ(t/H11001/H9280) represent the next state, an equation for Q(t/H11001/H9280) can be obtained from
the circuit by conceptually breaking the feedback loop at Qand considering Q(t) as
an input and Q(t/H11001/H9280) as the output. Then for the S-R latch of Figure 11-3
Q(t/H11001/H9280)/H11005R(t)/H11032[S(t)/H11001Q(t)]/H11005R(t)/H11032S(t)/H11001R(t)/H11032Q(t) (11-1)
and the equation for output Pis
P(t)/H11005S(t)/H11032Q(t)/H11032 (11-2)
Normally we write the next-state equation without including time explicitly, using Q
to represent the present state of the latch and Q/H11001to represent the next state:
Q/H11001/H11005R/H11032S/H11001R/H11032Q (11-3)
P/H11005S/H11032Q/H11032 (11-4)
These equations are mapped in the next-state and output tables of Table 11-1. The
stable states of the latch are circled. Note that for all stable states, P/H11005Q/H11032except when
S/H11005R/H110051. As discussed previously, this is one of the reasons why S/H11005R/H110051 isRS
Q
t1
t1 + /H9280t2 t3 t4 t
t3 + /H928000 1
/H9280 /H9280FIGURE 11-7
Timing Diagram
for S-R Latch
TABLE 11-1
S-R Latch 
Next State 
and OutputPresent Next State Q/H11001Present Output P
State SR SR SR SR SR SR SR SR
Q 0 00 11 11 00 00 11 11 0
00 0 0 1 1 1 0 0
11 0 0 1 0 0 0 0  
326 Unit 11
disallowed as an input combination to the S-R latch. Making S/H11005R/H110051 a don’t-care
combination allows simplifying the next-state equation, as shown in Figure 11-8(a).After plotting Equation (11-3) on the map and changing two entries to don’t-cares,the next-state equation simplifies to
Q
/H11001/H11005S/H11001R/H11032Q (SR/H110050) (11-5)
In words, this equation tells us that the next state of the latch will be 1 either if it is
set to 1 with an Sinput, or if the present state is 1 and the latch is not reset. The con-
dition SR/H110050 implies that Sand Rcannot both be 1 at the same time. An equation
that expresses the next state of a latch in terms of its present state and inputs will bereferred to as a next-state equation , or characteristic equation .
Another approach for deriving the characteristic equation for an S-R latch is
based on constructing a truth table for the next state of Q. We previously
discussed the latch operation by tracing signals through the gates, and the truth tablein Figure 11-8(b) is based on this discussion. Plotting Q
/H11001on a Karnaugh map gives the
same result as Figure 11-8(a).
The S-R latch is often used as a component in more complex latches and flip-flops
and in asynchronous systems. Another useful application of the S-R latch is fordebouncing switches.When a mechanical switch is opened or closed, the switch contactstend to vibrate or bounce open and closed several times before settling down to theirfinal position. This produces a noisy transition, and this noise can interfere with theproper operation of a logic circuit.The input to the switch in Figure 11-9 is connected toa logic 1 ( /H11001V). The pull-down resistors connected to contacts aandbassure that when
the switch is between aandbthe latch inputs SandRwill always be at a logic 0, and the0101
11
0
XX
000RQ
(a)Q+ mapS
01
1110FIGURE 11-8
Derivation of Q/H11001
for an S-RLatch
S
a+V
1b
RQS
R
Q
Switch
ataSwitch
atbBounce
ataBounce
atbSwitch between
aandbFIGURE 11-9
Switch Debouncing
with an S-R LatchSRQ Q/H11001
000 0001 1010 0011 0100 1
101 1
110 –Inputs not
1 1 1 – allowed
}
(b) Truth table
Latches and Flip-Flops 327
latch output will not change state. The timing diagram shows what happens when the
switch is flipped from atob. As the switch leaves a, bounces occur at the Rinput; when
the switch reaches b, bounces occur at the Sinput. After the switch reaches b, the first
time Sbecomes 1, after a short delay the latch switches to the Q/H110051 state and remains
there. Thus Qis free of all bounces even though the switch contacts bounce. This
debouncing scheme requires a double throw switch that switches between two contacts;
it will not work with a single throw switch that switches between one contact and open.
An alternative form of the S-R latch uses NAND gates, as shown in Figure 11-10.
We will refer to this circuit as an –S-–R latch, and the table describes its operation.
We have labeled the inputs to this latch –Sand–Rbecause–S/H110050 will set Qto 1 and–R/H110050 will reset Qto 0. If –Sand–Rare 0 at the same time, both the Qand Q/H11032out-
puts are forced to 1. Therefore, for the proper operation of this latch, the condition–S/H11005–R/H110050 is not allowed.
S
RQ
Q′S
R
(a) (b)S
L
RQ
Q′FIGURE 11-10
LatchS-RQQ/H11001
110 0
111 1100 0
101 0
010 1011 1000 –Inputs not
0 0 1 – allowedR
S
}
Q
(a) (b)D
GS
L
RQ
Q′DG 01 0FIGURE 11-11
Gated D Latch(c)
11.3 Gated D Latch
A gated D latch (Figure 11-11) has two inputs—a data input ( D) and a gate input ( G).
The D latch can be constructed from an S-R latch and gates (Figure 11-11(a)). WhenG/H110050,S/H11005R/H110050, so Qdoes not change. When G/H110051 and D/H110051,S/H110051 and R/H110050, so
Qis set to 1.When G/H110051 and D/H110050,S/H110050 and R/H110051, so Qis reset to 0. In other words,
when G/H110051, the Qoutput follows the Dinput, and when G/H110050, the Qoutput holds
the last value of D(no state change). This type of latch is also referred to as a trans-
parent latch because when G/H110051, the Qoutput is the same as the Dinput. From the
truth table (Figure 11-12), the characteristic equation for the latch is Q
/H11001/H11005G/H11032Q/H11001GD.
328 Unit 11
11.4 Edge-Triggered D Flip-Flop
A D flip-flop (Figure 11-13) has two inputs, D(data) and Ck (clock). The small
arrowhead on the flip-flop symbol identifies the clock input. Unlike the Dlatch, the
flip-flop output changes only in response to the clock, not to a change in D. If the out-
put can change in response to a 0 to 1 transition on the clock input, we say that theflip-flop is triggered on the rising edge (or positive edge) of the clock. If the output
can change in response to a 1 to 0 transition on the clock input, we say that the flip-flop is triggered on the falling edge (or negative edge) of the clock.An inversion bub-
ble on the clock input indicates a falling-edge trigger (Figure 11-13(b)), and no bub-
ble indicates a rising-edge trigger [Figure 11-13(a)]. The term active edge refers to the
clock edge (rising or falling) that triggers the flip-flop state change.
Q′ Q
CkDFF
(a) Rising-edge triggerQ′ Q
DFF
(b) Falling-edge trigge rCkDQ Q/H11001
00 0
01 0
10 111 1FIGURE 11-13
D Flip-Flops
(c) Truth tableQ+/H11005D
QCk
1010110
11 0 0DFIGURE 11-14
Timing for
D Flip-Flop
(Falling-Edge
Trigger)The state of a D flip-flop after the active clock edge ( Q/H11001) is equal to the input
(D) before the active edge. For example, if D/H110051 before the clock pulse, Q/H110051 after
the active edge, regardless of the previous value of Q. Therefore, the characteristic
equation is Q/H11001/H11005D.I fDchanges at most once following each clock pulse, the out-
put of the flip-flop is the same as the Dinput, except that the output changes are
delayed until after the active edge of the clock pulse, as illustrated in Figure 11-14.D
L
GQ
Q′
Q+ = G′Q + GD001000 01 11 10
11100QGD
1GDQ Q/H11001
000 0
001 1010 0011 1100 0
101 0
110 1111 1FIGURE 11-12
Symbol and Truth
Table for Gated
Latch
Latches and Flip-Flops 329
A rising-edge-triggered Dflip-flop can be constructed from two gated Dlatches
and an inverter, as shown in Figure 11-15(a). The timing diagram is shown in Figure11-15(b). When CLK /H110050,G
1/H110051, and the first latch is transparent so that the Pout-
put follows the Dinput. Because G2/H110050, the second latch holds the current value of
Q. When CLK changes to 1, G1changes to 0, and the current value of Dis stored in
the first latch. Because G2/H110051, the value of Pflows through the second latch to the
Qoutput.When CLK changes back to 0, the second latch takes on the value of Pand
holds it and, then, the first latch starts following the Dinput again. If the first latch
starts following the Dinput before the second latch takes on the value of P, the flip-
flop will not function properly. Therefore, the circuit designers must pay carefulattention to timing issues when designing edge-triggered flip-flops. With this circuit,output state changes occur only following the rising edge of the clock. The value ofDat the time of the rising edge of the clock determines the value of Q, and any extra
changes in Dthat occur between rising clock edges have no effect on Q.
Because a flip-flop changes state only on the active edge of the clock, the propaga-
tion delay of a flip-flop is the time between the active edge of the clock and the result-ing change in the output. However, there are also timing issues associated with the D
input. To function properly, the Dinput to an edge-triggered flip-flop must be held at a
constant value for a period of time before and after the active edge of the clock. If D
changes at the same time as the active edge, the behavior is unpredictable. The amountof time that Dmust be stable before the active edge is called the setup time ( t
su), and
the amount of time that Dmust hold the same value after the active edge is the hold
time ( th). The times at which Dis allowed to change during the clock cycle are shaded
in the timing diagram of Figure 11-16.The propagation delay ( tp) from the time the clock
changes until the Qoutput changes is also indicated. For Figure 11-15(a), the setup time
allows a change in Dto propagate through the first latch before the rising edge of Clock.
The hold time is required so that Dgets stored in the first latch before Dchanges.
Using these timing parameters, we can determine the minimum clock period for
a circuit which will not violate the timing constraints. Consider the circuit ofDPQ D1
L
(a) Construction from two gated D latchesG1Q1D2
L
G2Q2
CLK
(b) Timing anal ysisQPDG1CLK = G2FIGURE 11-15
D Flip-Flop
(Rising-Edge
Trigger)
330 Unit 11
Figure 11-17(a). Suppose the inverter has a propagation delay of 2 ns, and suppose
the flip-flop has a propagation delay of 5 ns and a setup time of 3 ns. (The hold timedoes not affect this calculation.) Suppose, as in Figure 11-17(b), that the clock periodis 9 ns, i.e., 9 ns is the time between successive active edges (rising edges for this fig-ure).Then, 5 ns after a clock edge, the flip-flop output will change, and 2 ns after that,the output of the inverter will change.Therefore, the input to the flip-flop will change7 ns after the rising edge, which is 2 ns before the next rising edge. But the setup timeof the flip-flop requires that the input be stable 3 ns before the rising edge; therefore,the flip-flop may not take on the correct value.
Suppose instead that the clock period were 15 ns, as in Figure 11-17(c). Again,
the input to the flip-flop will change 7 ns after the rising edge. However, because theclock is slower, this is 8 ns before the next rising edge. Therefore, the flip-flop willwork properly. Note in Figure 11-17(c) that there is 5 ns of extra time between thetime the Dinput is correct and the time when it must be correct for the setup time
to be satisfied. Therefore, we can use a shorter clock period, and have less extratime, or no extra time. Figure 11-17(d) shows that 10 ns is the minimum clock peri-od which will work for this circuit.
DQCLK
D Q
CLK
(a) Simple flip-flop circuit (b) Setup time not satisfied
(c) Setup time satisfied (d) Minimum clock periodSetup
time 3 ns
Flip-flop
dela y 5 ns
Inverter
dela y 2 ns
DQCLKSetup
time 3 ns
Extra time
5 ns Flip-flop
dela y 5 ns
Inverter
dela y 2 ns DQCLKSetup
time 3 ns
Flip-flop
dela y 5 ns
Inverter
dela y 2 nsFIGURE 11-17
Determination of
Minimum Clock
PeriodQD
CLKtsu th
tp tpFIGURE 11-16
Setup and Hold
Times for an
Edge-Triggered
D Flip-Flop
Latches and Flip-Flops 331
11.5 S-R Flip-Flop
An S-R flip-flop (Figure 11-18) is similar to an S-R latch in that S/H110051 sets the Qout-
put to 1, and R/H110051 resets the Qoutput to 0. The essential difference is that the flip-
flop has a clock input, and the Qoutput can change only after an active clock edge.
The truth table and characteristic equation for the flip-flop are the same as for thelatch, but the interpretation of Q
/H11001is different. For the latch, Q/H11001is the value of Q
after the propagation delay through the latch, while for the flip-flop, Q/H11001is the value
that Qassumes after the active clock edge.
Figure 11-19(a) shows an S-R flip-flop constructed from two S-R latches and
gates. This flip-flop changes state after the rising edge of the clock. The circuit isoften referred to as a master-slave flip-flop. When CLK /H110050, the Sand Rinputs set
the outputs of the master latch to the appropriate value while the slave latch holdsthe previous value of Q. When the clock changes from 0 to 1, the value of Pis held
in the master latch and this value is transferred to the slave latch. The master latchholds the value of Pwhile CLK /H110051, and, hence, Qdoes not change. When the clock
changes from 1 to 0, the Qvalue is latched in the slave, and the master can process
new inputs. Figure 11-19(b) shows the timing diagram. Initially, S/H110051 and Qchanges
to 1 at t
1. Then R/H110051 and Qchanges to 0 at t3.
S Q
RQ ′CkFIGURE 11-18
S-R Flip-FlopOperation summary:
S/H11005R/H110050 No state change
S/H110051,R/H110050 Set Qto 1 (after active Ck edge)
S/H110050,R/H110051 Reset Qto 0 (after active Ck edge)
S/H11005R/H110051 Not allowed
(a) Implementation with two latches
(b) Timing anal ysisS
RS1
Master
R1P
P′S2
Slave
R2Q
Q′Q
CLK
Q′
Q
t1 t2 t3 t4 t5PRSCLK ′CLKFIGURE 11-19
S-R Flip-Flop
Implementation
and Timing
332 Unit 11
At first glance, this flip-flop appears to operate just like an edge-triggered
flip-flop, but there is a subtle difference. For a rising-edge-triggered flip-flop thevalue of the inputs is sensed at the rising edge of the clock, and the inputs canchange while the clock is low. For the master-slave flip-flop, if the inputs changewhile the clock is low, the flip-flop output may be incorrect. For example, inFigure 11-19(b) at t
4,S/H110051 and R/H110050, so Pchanges to 1. Then Schanges to 0 at
t5, but Pdoes not change, so at t5,Qchanges to 1 after the rising edge of CLK.
However, at t5,S/H11005R/H110050, so the state of Qshould not change. We can solve this
problem if we only allow the Sand Rinputs to change while the clock is high.
11.6 J-K Flip-Flop
The J-K flip-flop (Figure 11-20) is an extended version of the S-R flip-flop. The J-K
flip-flop has three inputs— J,K, and the clock (CK). The Jinput corresponds to S, and
Kcorresponds to R.That is, if J/H110051 and K/H110050, the flip-flop output is set to Q/H110051 after
the active clock edge; and if K/H110051 and J/H110050, the flip-flop output is reset to Q/H110050
after the active edge. Unlike the S-R flip-flop, a 1 input may be applied simultaneous-ly to JandK, in which case the flip-flop changes state after the active clock edge.When
J/H11005K/H110051, the active edge will cause Qto change from 0 to 1, or from 1 to 0. The next-
state table and characteristic equation for the J-K flip-flop are given in Figure 11-20(b).
Figure 11-20(c) shows the timing for a J-K flip-flop. This flip-flop changes state a
short time ( t
p) after the rising edge of the clock pulse, provided that Jand Khave
Q′ Q
J KFF
CK
(a) J-K flip-flop
(c) J-K flip-flop timingQKJClock
t1tp tp tp
t2 t3FIGURE 11-20
J-K Flip-Flop
(QChanges on the
Rising Edge)
(b) Truth table and characteristic equationJKQ Q/H11001
00 0 000 1 101 0 001 1 010 0 1
10 1 1
11 0 111 1 0
Q+/H11005JQ/H11032/H11001K/H11032Q
Latches and Flip-Flops 333
11.7 T Flip-Flop
The T flip-flop, also called the toggle flip-flop, is frequently used in building counters.
Most CPLDs and FPGAs can be programmed to implement T flip-flops.The T flip-flopin Figure 11-22(a) has a Tinput and a clock input. When T/H110051 the flip-flop changes
state after the active edge of the clock. When T/H110050, no state change occurs. The next-
state table and characteristic equation for the T flip-flop are given in Figure 11-22(b).The characteristic equation states that the next state of the flip-flop ( Q
/H11001) will be 1 iff the
present state ( Q) is 1 and T/H110050 or the present state is 0 and T/H110051.
Figure 11-23 shows a timing diagram for the T flip-flop. At times t2and t4theT
input is 1 and the flip-flop state ( Q) changes a short time ( tp) after the falling edge
of the clock pulse. At times tland t3theTinput is 0, and the clock edge does not
cause a change of state.J
KS1
Master
R1P
P′S2
Slave
R2Q
Q′Q
CLK
Q′FIGURE 11-21
Master-Slave
J-K Flip-Flop
(QChanges on
Rising Edge)
Q' Q
CkTFF
(a)TQ Q/H11001
00 0
01 110 1
11 0Q+/H11005T/H11032Q/H11001TQ/H11032/H11005T⊕ Q
(b)FIGURE 11-22
T Flip-Flopappropriate values. If J/H110051 and K/H110050 when Clock /H110050,Qwill be set to 1 following
the rising edge. If K/H110051 and J/H110050 when Clock /H110050,Qwill be set to 0 after the rising
edge. Similarly, if J/H11005K/H110051,Qwill change state after the rising edge. Referring to
Figure 11-20(c), because Q/H110050,J/H11005l, and K/H110050 before the first rising clock edge, Q
changes to 1 at t1. Because Q/H110051,J/H110050, and K/H110051 before the second rising clock
edge, Qchanges to 0 at t2. Because Q/H110050,J/H110051, and K/H110051 before the third rising
clock edge, Qchanges to 1 at t3.
One way to realize the J-K flip-flop is with two S-R latches connected in a
master-slave arrangement, as shown in Figure 11-21. This is the same circuit as forthe S-R master-slave flip-flop, except SandRhave been replaced with JandK, and
theQand Q/H11032outputs are feeding back into the input gates. Because S/H11005J
/H11080Q/H11032/H11080Clk/H11032
and R/H11005K/H11080Q/H11080Clk/H11032, only one of Sand Rinputs to the first latch can be 1 at any
given time. If Q/H110050 and J/H110051, then S/H110051 and R/H110050, regardless of the value of K.
IfQ/H110051 and K/H110051, then S/H110050 and R/H110051, regardless of the value of J.
334 Unit 11
Q′
TQ
Ck
ClockJ
(a) Conversion of J-K to TKQ′
ClockQ
D
T
(b) Conversion of D to TCkFIGURE 11-24
Implementation
of T Flip-Flops
Q′ Q
CkClrN PreN
D
(a)FIGURE 11-25
D Flip-Flop with
Clear and PresetCk DPreN ClrN Q/H11001
x x 0 0 (not allowed)
xx 01 1xx 10 0
c 01 1 0
c 11 1 1
0,1,Tx1 1 Q(no change)
(b)Q
t2 t1 t3 t4T
tp tpCkFIGURE 11-23
Timing Diagram
for T Flip-Flop
(Falling-Edge
Trigger)
One way to implement a T flip-flop is to connect the JandKinputs of a J-K flip-
flop together, as shown in Figure 11-24(a). Substituting TforJand Kin the J-K
characteristic equation gives
Q/H11001/H11005JQ/H11032/H11001K/H11032Q/H11005TQ/H11032/H11001T/H11032Q
which is the characteristic equation for the T flip-flop. Another way to realize a T
flip-flop is with a D flip-flop and an exclusive-OR gate [Figure 11-24(b)]. The D
input is Q⊕T, so Q/H11001/H11005Q⊕T/H11005TQ/H11032/H11001T/H11032Q, which is the characteristic equation
for the T flip-flop.
11.8 Flip-Flops with Additional Inputs
Flip-flops often have additional inputs which can be used to set the flip-flops to aninitial state independent of the clock. Figure 11-25 shows a D flip-flop with clear andpreset inputs. The small circles (inversion symbols) on these inputs indicate that alogic 0 (rather than a 1) is required to clear or set the flip-flop. This type of input isoften referred to as active-low because a low voltage or logic 0 will activate the clear
Latches and Flip-Flops 335
or preset function.We will use the notation ClrN or PreN to indicate active-low clear
and preset inputs. Thus, a logic 0 applied to ClrN will reset the flip-flop to Q/H110050, and
a 0 applied to PreN will set the flip-flop to Q/H110051.These inputs override the clock and
Dinputs. That is, a 0 applied to the ClrN will reset the flip-flop regardless of the val-
ues of Dand the clock. Under normal operating conditions, a 0 should not be applied
simultaneously to ClrN and PreN. When ClrN and PreN are both held at logic 1, theDand clock inputs operate in the normal manner. ClrN and PreN are often referred
to as asynchronous clear and preset inputs because their operation does not dependon the clock. The table in Figure 11-25(b) summarizes the flip-flop operation. In thetable, cindicates a rising clock edge, and Xis a don’t-care. The last row of the table
indicates that if Ck is held at 0, held at 1, or has a falling edge, Qdoes not change.
Figure 11-26 illustrates the operation of the clear and preset inputs. At t
1, ClrN /H110050
holds the Qoutput at 0, so the rising edge of the clock is ignored. At t2andt3, normal
state changes occur because ClrN and PreN are both 1. Then, Qis set to 1 by PreN /H110050,
butQis cleared at t4by the rising edge of the clock because D/H110050 at that time.
In synchronous digital systems, the flip-flops are usually driven by a common
clock so that all state changes occur at the same time in response to the same clockedge. When designing such systems, we frequently encounter situations where wewant some flip-flops to hold existing data even though the data input to the flip-flopsmay be changing. One way to do this is to gate the clock, as shown in Figure 11-27(a).When En /H110050, the clock input to the flip-flop is 0, and Qdoes not change. This
method has two potential problems. First, gate delays may cause the clock to arriveat some flip-flops at different times than at other flip-flops, resulting in a loss of syn-chronization. Second, if En changes at the wrong time, the flip-flop may trigger dueto the change in En instead of due to the change in the clock, again resulting in lossof synchronization. Rather than gating the clock, a better way is to use a flip-flop witha clock enable (CE). Such flip-flops are commonly used in CPLDs and FPGAs.
Figure 11-27(b) shows a D flip-flop with a clock enable, which we will call a D-CE
flip-flop. When CE /H110050, the clock is disabled and no state change occurs, so Q
/H11001/H11005Q.
When CE /H110051, the flip-flop acts like a normal D flip-flop, so Q/H11001/H11005D. Therefore, the
characteristic equation is Q/H11001/H11005Q•CE/H11032/H11001D•CE. The D-CE flip-flop is easily imple-
mented using a D flip-flop and a multiplexer (Figure 11-27(c)). For this circuit, theMUX output is
Q
/H11001/H11005D/H11005Q/H11080CE/H11032/H11001Din/H11080CE
Because there is no gate in the clock line, this cannot cause a synchronization problem.
Q
t1 t2 t3 t4PreNClrNDCLKFIGURE 11-26
Timing Diagram
for D Flip-Flop
with Asynchronous
Clear and Preset
336 Unit 11
11.9 Summary
In this unit, we have studied several types of latches and flip-flops. Flip-flops have a
clock input, and the output changes only in response to a rising or falling edge of theclock. All of these devices have two output states: Q/H110050 and Q/H110051. For the S-R
latch, S/H110051 sets Qto 1, and R/H110051 resets Qto 0. S/H11005R/H110051 is not allowed. The S-R
flip-flop is similar except that Qonly changes after the active edge of the clock. The
gated D latch transmits Dto the Qoutput when G/H110051. When Gis 0, the current
value of Dis stored in the latch and Qdoes not change. For the D flip-flop, Qis
set equal to Dafter the active clock edge. The D-CE flip-flop works the same
way, except the clock is only enabled when CE /H110051.The J-K flip-flop is similar to the
S-R flip-flop in that when J/H110051 the active clock edge sets Qto 1, and when K/H110051,
the active edge resets Qto 0. When J/H11005K/H110051, the active clock edge causes Qto
change state. The T flip-flop changes state on the active clock edge when T/H110051; oth-
erwise, Qdoes not change. Flip-flops can have asynchronous clear and preset inputs
that cause Qto be cleared to 0 or preset to 1 independently of the clock.
Flip-flops can be constructed using gate circuits with feedback. Analysis of such
circuits can be accomplished by tracing signal changes through the gates.Analysis canalso be done using flow tables and asynchronous sequential circuit theory, but that isbeyond the scope of this text. Timing diagrams are helpful in understanding the timerelationships between the input and output signals for a latch or flip-flops. In general,the inputs must be applied a specified time before the active clock edge (the setuptime), and they must be held constant a specified time after the active edge (the holdtime). The time after the active clock edge before Qchanges is the propagation delay.
The characteristic (next-state) equation for a flip-flop can be derived as follows:
First, make a truth table that gives the next state ( Q
/H11001) as a function of the present state
(Q) and the inputs. Any illegal input combinations should be treated as don’t-cares.
Then, plot a map for Q/H11001and read the characteristic equation from the map.
The characteristic equations for the latches and flip-flops discussed in this chap-
ter are:
Q/H11001/H11005S/H11001R/H11032Q(SR/H110050) (S-R latch or flip-flop) (11-6)
Q/H11001/H11005GD /H11001G/H11032Q (gated D latch) (11-7)
Q/H11001/H11005D (D flip-flop) (11-8)D Q
Q′ CkCLK
(a) Gating the clock (b) D-CE s ymbol (c) ImplementationEnD Q
Q′CEDDinQ
Q′ Ck Ck CLKCE0
1FIGURE 11-27
D Flip-Flop with
Clock Enable
Latches and Flip-Flops 337
Q/H11001/H11005D/H11080CE/H11001Q/H11080CE/H11032 (D-CE flip-flop) (11-9)
Q/H11001/H11005JQ/H11032/H11001K/H11032Q (J-K flip-flop) (11-10)
Q/H11001/H11005T⊕Q/H11005TQ/H11032/H11001T/H11032Q (T flip-flop) (11-11)
In each case, Qrepresents an initial or present state of the flip-flop, and Q/H11001repre-
sents the final or next state.These equations are valid only when the appropriate restric-tions on the flip-flop inputs are observed. For the S-R flip-flop, S/H11005R/H110051 is forbidden.
For the master-slave S-R flip-flop, SandRshould not change during the half of the clock
cycle preceding the active edge. Setup and hold time restrictions must also be satisfied.
The characteristic equations given above apply to both latches and flip-flops, but
their interpretation is different for the two cases. For example, for the gated D latch,Q
/H11001represents the state of the flip-flop a short time after one of the inputs changes.
However, for the D flip-flop, Q/H11001represents the state of the flip-flop a short time
after the active clock edge.
Conversion of one type of flip-flop to another is usually possible by adding exter-
nal gates. Figure 11-24 shows how a J-K flip-flop and a D flip-flop can be convertedto a T flip-flop.
Problems
11.1 Assume that the inverter in the given circuit has a propagation delay of 5 ns and the
AND gate has a propagation delay of 10 ns. Draw a timing diagram for the circuitshowing X,Y, and Z. Assume that Xis initially 0, Yis initially 1, after 10 ns X
becomes 1 for 80 ns, and then Xis 0 again.
11.2 A latch can be constructed from an OR gate, an AND gate, and an inverter con-
nected as follows:
(a) What restriction must be placed on Rand Hso that Pwill always equal Q/H11032
(under steady-state conditions)?
(b) Construct a next-state table and derive the characteristic (next-state) equation for
the latch.R
HQ
PY
XZ
338 Unit 11
(c) Complete the following timing diagram for the latch.
11.3 This problem illustrates the improper operation that can occur if both inputs to an
S-R latch are 1 and are then changed back to 0. For Figure 11-6, complete the fol-lowing timing chart, assuming that each gate has a propagation delay of exactly 10ns. Assume that initially P/H110051 and Q/H110050. Note that when t/H11005100 ns, Sand Rare
both changed to 0. Then, 10 ns later, both Pand Qwill change to 1. Because these
1’s are fed back to the gate inputs, what will happen after another 10 ns?
11.4 Design a gated D latch using only NAND gates and one inverter.
11.5 What change must be made to Figure 11-15(a) to implement a falling-edge-triggered
D flip-flop? Complete the following timing diagram for the modified flip-flop.
11.6 A reset-dominant flip-flop behaves like an S-R flip-flop, except that the input
S/H11005R/H110051 is allowed, and the flip-flop is reset when S/H11005R/H110051.
(a) Derive the characteristic equation for a reset-dominant flip-flop.QPG2DClock = G10QPRS
50 100
140150 200 t(ns)PQHR
Latches and Flip-Flops 339
(b) Show how a reset-dominant flip-flop can be constructed by adding gate(s) to an
S-R flip-flop.
11.7 Complete the following timing diagram for the flip-flop of Figure 11-20(a).
11.8 Complete the following diagrams for the falling-edge-triggered D-CE flip-flop of
Figure 11-27(c). Assume Qbegins at 1.
(a) First draw Qbased on your understanding of the behavior of a D flip-flop with
clock enable.
(b) Now draw in the internal signal Dfrom Figure 11-27(c), and confirm that this
gives the same Qas in (a).
11.9 (a) Complete the following timing diagram for a J-K flip-flop with a falling-edge
trigger and asynchronous ClrN and PreN inputs.
QClockKJPreNClrNDQCEDinClockQKJClock
340 Unit 11
(b) Complete the timing diagram for the following circuit. Note that the Ck inputs
on the two flip-flops are different.
11.10 Convert by adding external gates:
(a) a D flip-flop to a J-K flip-flop.(b) a T flip-flop to a D flip-flop.(c) a T flip-flop to a D flip-flop with clock enable.
11.11 Complete the following timing diagram for an S-R latch. Assume Qbegins at 1.
11.12 Using a truth table similar to Figure 11-8(b), confirm that each of these circuits is an
S-R latch. What happens when S/H11005R/H110051 for each circuit?
11.13 AnAB latch operates as follows: If A/H110050 and B/H110050, the latch state is Q/H110050; if
either A/H110051 or B/H110051 (but not both), the latch output does not change; and when
both A/H110051 and B/H110051, the latch state is Q/H110051.
(a) Construct the state table and derive the characteristic equation for this ABlatch.
(b) Derive a circuit for the ABlatch that has four two-input NAND gates and two
inverters.
(c) In your circuit of Part (b), are there any transitions between input combinations
that might cause unreliable operation? Verify your answer.S
RQ
Q′
SRQ
Q′
(a) (b)00
01100
1
11QRSQ′1 Q1
CkCLRClrN
ClockD1Q′2 Q2
CkCLR
D2
Q2Q1ClockClrN
11.15 The following circuit is intended to be a gated latch circuit where the signal Gis
the gate.(a) Derive the next-state equation for this circuit using Qas the state variable and
Pas an output.
(b) Construct the state table and output table for the circuit. Circle the stable states
of the circuit.
(c) Are there any restrictions on the allowable input combinations on Mand N?
Explain your answer.
(d) Is the output Pusable as the complement of Q? Verify your answer.
(e) Assume that Gate 1 has a propagation delay of 30 ns and Gates 2, 3, and 4 have
propagation delays of 10 ns. Construct a timing diagram for the circuit for thefollowing input change: M/H11005N/H11005Q/H110050 with Gchanging from 1 to 0.Latches and Flip-Flops 341
(d) In your circuit of Part (b), is there a gate output that provides the signal Q/H11032?
Verify your answer.
(e) Derive a circuit for the AB latch using four two-input NOR gates and two
inverters.
(f) Answer Parts (c) and (d) for your circuit of Part (e).
11.14 (a) Construct a state table for this circuit and identify the stable states of the circuit.
(b) Derive a Boolean algebra equation for the next value of the output Qin terms
ofQ,Aand B.
(c) Analyze the behavior of the circuit. Is it a useful circuit? If not, explain why not;
if yes, explain what it does.
2-to-1
MUXYI1
I0
S
2-to-1
MUXYI1
I0
SQ0
A
1
B
M
N
GPQ1
23
4
342 Unit 11
11.16 Analyze the latch circuit shown.
(a) Derive the next-state equation for this circuit using Qas the state variable and
Pas an output.
(b) Construct the state table and output table for the circuit. Circle the stable states
of the circuit.
(c) Are there any restrictions on the allowable input combinations on Aand B?
Explain your answer.
(d) Is the output Pusable as the complement of Q? Verify your answer.
A
B Q
P
11.17 Derive the characteristic equations for the following latches and flip-flops in product-
of-sums form.(a) S-R latch or flip-flop(b) Gated D latch(c) D flip-flop(d) D-CE flip-flop(e) J-K flip-flop(f) T flip-flop
11.18 Complete the following timing diagrams for a gated D latch. Assume Qbegins at 0.
(a) First draw Qbased on your understanding of the behavior of a gated D latch.
(b) Now draw in the internal signals Sand Rfrom Figure 11-11, and confirm that
Sand Rgive the same value for Qas in (a).
RSQGD
Latches and Flip-Flops 343
11.19 Complete the following diagrams for the rising-edge-triggered D flip-flop of Figure
11-15. Assume Qbegins at 1.
(a) First draw Qbased on your understanding of the behavior of a D flip-flop.
(b) Now draw in the internal signal Pfrom Figure 11-15, and confirm that Pgives
the same Qas in (a).
11.20 A set-dominant flip-flop is similar to the reset-dominant flip-flop of Problem 11.6
except that the input combination S/H11005R/H110051 sets the flip-flop. Repeat Problem 11.6
for a set-dominant flip-flop.
11.21 Fill in the timing diagram for a falling-edge-triggered S-R flip-flop. Assume Q
begins at 0.
11.22 Fill in the timing diagram for a falling-edge-triggered J-K flip-flop.
(a) Assume Qbegins at 0.
(b) Assume Qbegins at 1, but Clock, J, and Kare the same.QKJClockQRSClockPQDClock
344 Unit 11
11.23 (a) Find the input for a rising-edge-triggered D flip-flop that would produce the
output Qas shown. Fill in the timing diagram.
(b) Repeat for a rising-edge-triggered T flip-flop.
11.24 Here is the diagram of a 3-bit ripple counter.Assume Q0/H11005Q1/H11005Q2/H110050 at t/H110050, and
assume each flip-flop has a delay of 1 ns from the clock input to the Qoutput. Fill in
Q0,Q1, and Q2of the timing diagram. Flip-flop Q1, will be triggered when Q0changes
from 0 to 1.
11.25 Fill in the following timing diagram for a rising-edge-triggered T flip-flop with an
asychronous active-low PreN input. Assume Qbegins at 1.
11.26 The ClrN and PreN inputs introduced in Section 11.8 are called asynchronous
because they operate independently of the clock (i.e., they are not synchronizedwith the clock). We can also make flip-flops with synchronous clears or presetQTPreNClockQ2Q1Q0Clock
5111
10 15 20 25 30 35 40 45 50Q0
T
ClockQ1
TQ2
TTDQClock
Latches and Flip-Flops 345
inputs. A D-flip-flop with an active-low synchronous ClrN input may be construct-
ed from a regular D flip-flop as follows.
Fill in the timing diagram. For Q1, assume a synchronous ClrN as above, and for Q2,
assume an asynchronous ClrN as in Section 11.8.Assume Q1/H11005Q2/H110050 at the beginning.
11.27 (a) Construct a D flip-flop using an inverter and an S-R flip-flop.
(b) If the propagation delay and setup time of the S-R flip-flop in (a) are 2.5 ns and
1.5 ns, respectively, and if the inverter has a propagation delay of 1 ns, what arethe propagation delay and setup time of the D flip-flop of Part (a)?
11.28 Redesign the debouncing circuit of Figure 11-9 using the –S-–R latch of Figure 11-10.
Programmed Exercise 11.29
Cover the bottom part of each page with a sheet of paper and slide it down as you
check your answers.
The internal logic diagram of a falling-edge-triggered D flip-flop follows. This
flip-flop consists of two basic S-R latches with added gates. When the clock input(CK) is 1, the value of Dis stored in the first S-R latch ( P).When the clock changes
from 1 to 0, the value of Pis transferred to the output latch ( Q). Thus, the opera-
tion is similar to that of the master-slave S-R flip-flop shown in Figure 11-19, exceptfor the edges at which the data is stored.Q2Q1DClrNClockDD
ClrNQ
Clk
Q
Q′DPR
SCK
346 Unit 11
In this exercise you will be asked to analyze the operation of the D flip-flop
shown above by filling in a table showing the values of CK, D,P,S,R, and Qafter
each change of input. It will be helpful if you mark the changes in these values on thecircuit diagram as you trace the signals. Initially, assume the following signal values:
CK DPSRQ
0 0 0 0 1 0 (stable)
Verify by tracing signals through the circuit that this is a stable condition of the circuit;
that is, no change will occur in P,S,R, or Q. Now assume that CK is changed to 1:
CK DPSRQ
1. 0 0 0 0 1 0 (stable)
2 . 1 0 0010?3.
Trace the change in CK through the circuit to see if a change in P,S, or Rwill occur. If
a change does occur, mark row 2 of the preceding table “unstable” and enter the newvalues in row 3.
Answer: 2. 1 0 0 0 1 0 (unstable)3. 1 0 0 0 0 0 (stable)4. 1 1 0 0 0 0 (unstable)
5. 1 1 ?
Verify that row 3 is stable; that is, by tracing signals show that no further change in
P,S,R, or Qwill occur. Next Dis changed to 1 as shown in row 4. Verify that row 4
is unstable, fill in the new values in row 5, and indicate if row 5 is stable or unstable.
Answer: CK DPSRQ
5. 1 1 1 0 0 0 (stable)
6 . 0 1 1000?7. 0 1 ?
8. 0 1
Then CK is changed to 0 (row 6). If row 6 is unstable, indicate the new value of Sin
row 7. If row 7 is unstable, indicate the new value of Qin row 8. Then determine
whether row 8 is stable or not.
Answer: CK DPSRQ
7. 0 1 1 1 0 0 (unstable)
8. 0 1 1 1 0 1 (stable)9. 0 0 (stable)
10. 1 0
11. 1 0
Next, Dis changed back to 0 (row 9). Fill in the values in row 9 and verify that it is
stable. CK is changed to 1 in row 10. If row 10 is unstable, fill in row 11 and indicatewhether it is stable or not.
Answer: 9. 0 0 1 1 0 1 (stable)
10. 1 0 1 1 0 1 (unstable)11. 1 0 0 0 0 1 (stable)12. 0 013. 0 0
14. 0 0
CK is changed back to 0 in row 12. Complete the rest of the table.
Answer: 12. 0 0 0 0 0 1 (unstable)
13. 0 0 0 0 1 1 (unstable)
14. 0 0 0 0 1 0 (stable)
Using the previous results, plot PandQon the following timing diagram.Verify that
your answer is consistent with the description of the flip-flop operation given in thefirst paragraph of this exercise.
Answer:
QPDCK2468 1 0 1 2 RowQPDCK2468 1 0 1 2 RowLatches and Flip-Flops 347
348CHAPTER
00Registers and Counters
Objectives
1.Explain the operation of registers. Show how to transfer data between
registers using a tri-state bus.
2.Explain the operation of shift registers, show how to build them using
flip-flops, and analyze their operation. Construct a timing diagram for ashift register.
3.Explain the operation of binary counters, show how to build them using
flip-flops and gates, and analyze their operation.
4.Given the present state and desired next state of a flip-flop, determine
the required flip-flop inputs.
5.Given the desired counting sequence for a counter, derive the flip-flop
input equations.
6.Explain the procedures used for deriving flip-flop input equations.
7.Construct a timing diagram for a counter by tracing signals through the
circuit.
UNIT
12
Registers and Counters 349
1.Study Section 12.1, Registers and Register Transfers .
(a) For the diagram of Figure 12-4, suppose registers A,B,C, and Dhold the
8-bit binary numbers representing 91, 70, 249, and 118, respectively.Suppose Gand Hare both initially 0. What are the contents of Gand H
(decimal equivalent) after the rising edge of the clock:
(1) if EF/H1100510,LdG /H110050, and LdH /H110051 at the rising edge?
(2) if EF/H1100501,LdG /H110050, and LdH /H110051 at the next rising edge?
(3) if EF/H1100511,LdG /H110051, and LdH /H110051 at the next rising edge?
(4) if EF/H1100500,LdG /H110051, and LdH /H110050 at the next rising edge?
(5) if EF/H1100510,LdG /H110050, and LdH /H110050 at the next rising edge?
(b) Work Problem 12.1.
2.Study Section 12.2, Shift Registers .
(a) Compare the block diagrams for the shift registers of Figures 12-7 and
12-10. Which one changes state on the rising edge of the clock pulse? Thefalling edge?
(b) Complete the following table and timing diagram (see next page) for the
shift register of Figure 12-8.
Clock State of Shift Register
Cycle When Clock /H110051
Number Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0
10 0 0 0 0 0 0 0
2345
6
789
10
11121314
15
16Study Guide
(c) Explain in words the function of the MUX on the Dinput of flip-flop
Q3in Figure 12-10(b). Explain in words the meaning of the first of
Equations (12-1).
(d) Verify that Equations (12-1) are consistent with Table 12-1.
(e) Work Problem 12.2.
3.Study Section 12.3, Design of Binary Counters , and Section 12.4, Counters for
Other Sequences .
(a) For Figure 12-13, if CBA /H11005101, which of the Tinputs is 1?
(b) Complete the following timing diagram for the binary counter of Figure
12-13. The initial value of Clock is 1; this does not count as a rising edge.
(c) Using the results of (b), draw a state graph for this binary counter
(similar to Figure 12-21).TATBTCABCClock
00 00
01 01
10 01350 Unit 12
SOSIClock23456789 1 0 1 1 1 2 1 3 1 4 1 5 1 61
Registers and Counters 351
(d) Complete the following timing diagram for the binary counter of Figure 12-15.
(e) Use Table 12-4 to verify that the values of TC,TB, and TAin Table 12-2 are
correct.
(f) What happens if the circuit of Figure 12-23 is started in one of the don’t-care
states and, then, a clock pulse occurs? In particular, augment the state graphof Figure 12-25 to indicate the result for starting in states 101 and 110.
(g) What happens if the circuit of Figure 12-26 is started in one of the don’t-care
states and then a clock pulse occurs? In particular, augment the state graphof Figure 12-21 to indicate the result for starting in states 001, 101, and 110.
(h) Work Problems 12.3, 12.4, 12.5, 12.6, and 12.7.
4.Study Section 12.5, Counter Design Using S-R and J-K Flip-Flops .
(a) Referring to Table 12-5(c):
IfQ/H11005Q
/H11001/H110050, explain in words why Ris a don’t-care.
IfQ/H11005Q/H11001/H110051, explain in words why Sis a don’t-care.
IfQ/H110050 and Q/H11001/H110051, what value should Shave and why?
IfQ/H110051 and Q/H11001/H110050, what value should Rhave and why?DADBDCABCClock
0000
0011
0101
(b) For Figure 12-27, verify that the RBandSBmaps are consistent with the B/H11001
map, and verify that the Rcand Scmaps are consistent with the C/H11001map.
(c) In Figure 12-27, where do the gate inputs ( C,B,A, etc.) come from?
(d) For Figure 12-27(c), which flip-flop inputs will be 1 if CBA /H11005100? What
will be the state after the rising clock edge?
(e) Complete the following state graph by tracing signals in Figure 12-27(c).
Compare your answer with Figure 12-21. What will happen if the counteris in state 110 and a clock pulse occurs?
(f) Referring to Table 12-7(c).
IfQ/H11005Q
/H11001/H110050, explain in words why Kis a don’t-care.
IfQ/H11005Q/H11001/H110051, explain in words why Jis a don’t-care.
IfQ/H110050 and Q/H11001/H110051, explain why both JK/H1100510 and JK/H1100511 will produce
the required state change.
IfQ/H110051 and Q/H11001/H110050, give two sets of values for Jand Kwhich will pro-
duce the required state change, and explain why your answer is valid.
(g) Verify that the maps of Figure 12-28(b) can be derived from the maps of
Figure 12-28(a).
(h) Compare the number of logic gates in Figures 12-27 and 12-28. The J-K
realization requires fewer gates than the S-R realization because the J-Kmaps have more don’t-cares than the S-R maps.
(i) Draw in the implied feedback connections on the circuit of Figure 12-28(c).
(j) By tracing signals through the circuit, verify that the state sequence for
Figure 12-28(c) is correct.000
100352 Unit 12
Registers and Counters 353
(k) Find a minimum expression for F1and for F2.(Hint: No variables are required.)
(l) Work Problems 12.8 and 12.9.
5.Study Section 12.6, Derivation of Flip-Flop Input Equations—Summary .
(a) Make sure that you know how to derive input equations for the different
types of flip-flops. It is important that you understand the procedures forderiving the equations; merely memorizing the rules is not sufficient.
(b) Table 12-9 is provided mainly for reference. It is not intended that you memo-
rize this table; instead you should understand the reasons for the entries in thetable. If you understand the reasons why a given map entry is 0, 1, or X, you
should be able to derive the flip-flop input maps without reference to a table.
6.Work the part of Problem 12.10 that you have been assigned. Bring your solu-
tion to this problem with you when you come to take the readiness test.F1 F201
00BCA
01
11
10XX
1 X
X 1
XX01
00BCA
01
11
10XX
0 X
XX
XX
A register consists of a group of flip-flops with a common clock input. Registers are
commonly used to store and shift binary data. Counters are another simple type ofsequential circuits.A counter is usually constructed from two or more flip-flops which
Registers and Counters
change states in a prescribed sequence when input pulses are received. In this unit,
you will learn procedures for deriving flip-flop input equations for counters. Theseprocedures will be applied to more general types of sequential circuits in later units.
12.1 Registers and Register Transfers
Several D flip-flops may be grouped together with a common clock to form a register[Figure 12-1(a)]. Because each flip-flop can store one bit of information, this register canstore four bits of information.This register has a load signal that is ANDed with the clock.354 Unit 12
Q3
D3Clr
(a) Using gated clockData inData out
0→1
1ClrN
Load
Clk
101Q2
D2Clr0→1
Q1
D1Clr0→0
Q0
D0Clr0→1
Q3
D3Clr
(b) With clock enable
(c) S ymbolData inData out
0→1
1Load
ClrN
Clk
101Q2
D2Clr0→1
Q1
D1Clr0→0
Q0
D0 CE CE CE CEClr
Q
D CE
Load Clk44
Clr ClrN0→1FIGURE 12-1
4-Bit D Flip-Flop
Registers with
Data, Load,
Clear, and 
Clock Inputs
Registers and Counters 355
When Load /H110050, the register is not clocked, and it holds its present value.When it is time
to load data into the register, Load is set to 1 for one clock period. When Load /H110051, the
clock signal (Clk) is transmitted to the flip-flop clock inputs and the data applied to theDinputs will be loaded into the flip-flops on the falling edge of the clock. For example, if
theQoutputs are 0000 ( Q
3/H11005Q2/H11005Q1/H11005Q0/H110050) and the data inputs are 1101 ( D3/H110051,
D2/H110051,D1/H110050 and D0/H110051), after the falling edge Qwill change from 0000 to 1101 as
indicated. (The notation 0 S 1 at the flip-flop outputs indicates a change from 0 to 1.)
The flip-flops in the register have asynchronous clear inputs that are connected
to a common clear signal, ClrN. The bubble at the clear inputs indicates that a logic0 is required to clear the flip-flops. ClrN is normally 1, and if it is changed momen-tarily to 0, the Qoutputs of all four flip-flops will become 0.
As discussed in Section 11.8, gating the clock with another signal can cause timing
problems. If flip-flops with clock enable are available, the register can be designedas shown in Figure 12-1(b). The load signal is connected to all four CE inputs. WhenLoad /H110050, the clock is disabled and the register holds its data. When Load is 1, the
clock is enabled, and the data applied to the Dinputs will be loaded into the flip-flops,
following the falling edge of the clock. Figure 12-1(c) shows a symbol for the 4-bit reg-ister using bus notation for the Dinputs and Qoutputs.A group of wires that perform
a common function is often referred to as a bus. A heavy line is used to represent abus, and a slash with a number beside it indicates the number of bits in the bus.
Transferring data between registers is a common operation in digital systems.
Figure 12-2 shows how data can be transferred from the output of one of two regis-ters into a third register using tri-state buffers. If En /H110051 and Load /H110051, the output of
register Ais enabled onto the tri-state bus and the data in register Awill be stored in
Qafter the rising edge of the clock. If En /H110050 and Load /H110051, the output of register B
will be enabled onto the tri-state bus and stored in Qafter the rising edge of the clock.
A1
FF
D1
CEFF
D2Q1
Q2
CE
ClkEn
LoadFFA2
FF
B1
FF
B2
FFRegister
A Register A =
   Flip-flops A1 and A2
Register B =
   Flip-flops B1 and B2
Register Q =
   Flip-flops Q1 and Q2Register
BRegiste r
QTri-State Bus FIGURE 12-2
Data Transfer
Between
Registers
Figure 12-3(a) shows an integrated circuit register that contains eight D flip-
flops with tri-state buffers at the flip-flop outputs. These buffers are enabled whenEn/H110050. A symbol for this 8-bit register is shown in Figure 12-3(b).
Figure 12-4 shows how data can be transferred from one of four 8-bit registers into
one of two other registers. Registers A,B,C, and Dare of the type shown in Figure 12-3.
The outputs from these registers are all connected in parallel to a common tri-state bus.
Registers GandHare similar to the register of Figure 12-1 except that they have eight
flip-flops instead of four. The flip-flop inputs of registers GandHare also connected to
the bus. When EnA /H110050, the tri-state outputs of register Aare enabled onto the bus. If
LdG /H110051, these signals on the bus are loaded into register Gafter the rising clock edge
(or into register HifLdH /H110051). Similarly, the data in register B,C, or Dis transferred 
toG(orH) when EnB ,EnC , or EnD is 0, respectively and LdG /H110051 (or LdH /H110051). If
LdG /H11005LdH /H110051, both GandHwill be loaded from the bus.The four enable signals may
be generated by a decoder. The operation can be summarized as follows:
IfEF/H1100500,Ais stored in G(orH).
IfEF/H1100501,Bis stored in G(orH).
IfEF/H1100510,Cis stored in G(orH).
IfEF/H1100511,Dis stored in G(orH).
Note that 8 bits of data are transferred in parallel from register A,B,C, or Dto reg-
ister GorH. As an alternative to using a bus with tri-state logic, eight 4-to-1 multi-
plexers could be used, but this would lead to a more complex circuit.
Parallel Adder with Accumulator
In computer circuits, it is frequently desirable to store one number in a register offlip-flops (called an accumulator) and add a second number to it, leaving the resultstored in the accumulator. One way to build a parallel adder with an accumulatoris to add a register to the adder of Figure 4-2, resulting in the circuit of Figure 12-5.Suppose that the number X/H11005x
n...x2x1is stored in the accumulator. Then, the356 Unit 12
FIGURE 12-3
Logic Diagram for
8-Bit Register with
Tri-State Output Q1 Q2 Q7 Q8
D1 D2 D7 D8Q...En
ClockEn
CK8
8
(a)(b)
EnABus8
8 8Clock LdGRegister
G
Register
AEnB
E
F8
Register
BEnC8
Register
C
DecoderEnD8
Register
DCE
8Clock LdHRegister
HCEFIGURE 12-4
Data Transfer Using
a Tri-State Bus
Registers and Counters 357
number Y/H11005yn...y2y1is applied to the full adder inputs, and after the carry has prop-
agated through the adders, the sum of XandYappears at the adder outputs. An add
signal ( Ad) is used to load the adder outputs into the accumulator flip-flops on the
rising clock edge. If si/H110051, the next state of flip-flop xiwill be 1. If si/H110050, the next state
of flip-flop xiwill be 0. Thus, xi/H11001/H11005si, and if Ad/H110051, the number Xin the accumulator
is replaced with the sum of XandY, following the rising edge of the clock.
Observe that the adder with accumulator is an iterative structure that consists of
a number of identical cells. Each cell contains a full adder and an associated accu-mulator flip-flop. Cell i, which has inputs c
iandyiand outputs ci/H110011andxi, is referred
to as a typical cell.
Before addition can take place, the accumulator must be loaded with X. This can
be accomplished in several ways. The easiest way is to first clear the accumulator usingthe asynchronous clear inputs on the flip-flops, and then put the Xdata on the Yinputs
to the adder and add to the accumulator in the normal way.Alternatively, we could addmultiplexers at the accumulator inputs so that we could select either the Yinput data
or the adder output to load into the accumulator. This would eliminate the extra stepof clearing the accumulator but would add to the hardware complexity. Figure 12-6Q Q′
D CE
Full
AdderQ Q′
D CE
Full
AdderQ Q′
D CE
Full
AdderQ Q′
D CEAccumulator
Register
Full
Adder ...... ...
...xn xi x2 x1
sn si s2 s1xn xi x2 x1Ad
CLK
ClrN
yn yi y2 y1cn ci ci + 1 cn + 1c2 c3 c1 = 0FIGURE 12-5 n-Bit Parallel Adder with Accumulator
Q
D CECK
FAxi
ci
yisi
ci + 1Ad
Ld
10FIGURE 12-6
Adder Cell with
Multiplexer
shows a typical cell of the adder where the accumulator flip-flop can either be loaded
directly from yior from the sum output ( si).When Ld/H110051 the multiplexer selects yi, and
yiis loaded into the accumulator flip-flop ( xi) on the rising clock edge. When Ad/H110051
and Ld/H110050, the adder output ( si) is loaded into xi. The Adand Ldsignals are ORed
together to enable the clock when either addition or loading occurs.When Ad/H11005Ld/H110050,
the clock is disabled and the accumulator outputs do not change.
12.2 Shift Registers
A shift register is a register in which binary data can be stored, and this data can beshifted to the left or right when a shift signal is applied. Bits shifted out one end of theregister may be lost, or if the shift register is of cyclic type, bits shifted out one end areshifted back in the other end. Figure 12-7(a) illustrates a 4-bit right-shift register withserial input and output constructed from D flip-flops. When Shift /H110051, the clock is
enabled and shifting occurs on the rising clock edge. When Shift /H110050, no shifting
occurs and the data in the register is unchanged. The serial input (SI) is loaded intothe first flip-flop ( Q
3) by the rising edge of the clock. At the same time, the output of358 Unit 12
(a) Flip-flop connections
(b) Timin g diagramD3Q3
CED2Q2
CED1Q1
CED0Q0
CESerial in
(SI)
Shift
ClockSerial ou t
(SO)
Q0Q1Q2Q3SIClockFIGURE 12-7
Right-Shift
Register
Registers and Counters 359
the first flip-flop is loaded into the second flip-flop, the output of the second flip-flop
is loaded into the third flip-flop, and the output of the third flip-flop is loaded into thelast flip-flop. Because of the propagation delay of the flip-flops, the output valueloaded into each flip-flop is the value before the rising clock edge. Figure 12-7(b) illus-trates the timing when the shift register initially contains 0101 and the serial inputsequence is 1, 1, 0, 1.The sequence of shift register states is 0101, 1010, 1101, 0110, 1011.
If we connect the serial output to the serial input, as shown by the dashed line, the
resulting cyclic shift register performs an end-around shift. If the initial contents of theregister is 0111, after one clock cycle the contents is 1011.After a second pulse, the stateis 1101, then 1110, and the fourth pulse returns the register to the initial 0111 state.
Shift registers with 4, 8, or more flip-flops are available in integrated circuit
form. Figure 12-8 illustrates an 8-bit serial-in, serial-out shift register. Serial in means
that data is shifted into the first flip-flop one bit at a time, and the flip-flops cannotbe loaded in parallel. Serial out means that data can only be read out of the last flip-
flop and the outputs from the other flip-flops are not connected to terminals of theintegrated circuit. The inputs to the first flip-flop are S/H11005SI and R/H11005SI/H11032. Thus, if 
SI/H110051, a 1 is shifted into the register when it is clocked, and if SI /H110050, a 0 is shifted
in. Figure 12-9 shows a typical timing diagram.
Figure 12-10(a) shows a 4-bit parallel-in, parallel-out shift register. Parallel-
in implies that all four bits can be loaded at the same time, and parallel-out
8-Bit Serial-In, Serial-Out
Shift Register
Clock
SI
(Serial in)SO
(Serial out)SO(Serial out)SI
(Serial in)
CLK(a) Block diagram
(b) Logic diagramS QQ7 Q0
RQ ′S Q
RQ ′S Q
RQ ′S Q
RQ ′S Q
RQ ′S Q
RQ ′S Q
RQ ′S Q
RQ ′FIGURE 12-8 8-Bit Serial-in, Serial-out Shift Register
Clock
SOSI23456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 71
7 Clock Periods7 Clock PeriodsFIGURE 12-9
Typical Timing
Diagram for
Shift Register of
Figure 12-8
implies that all bits can be read out at the same time. The shift register has two
control inputs, shift enable ( Sh) and load enable ( L). If Sh/H110051 (and L/H110051 or 
L/H110050), clocking the register causes the serial input (SI) to be shifted into the first
flip-flop, while the data in flip-flops Q3,Q2, and Q1are shifted right. If Sh/H110050 and
L/H110051, clocking the shift register will cause the four data inputs ( D3,D2,D1,D0)
to be loaded in parallel into the flip-flops. If Sh/H11005L/H110050, clocking the register
causes no change of state. Table 12-1 summarizes the operation of this shift reg-ister. All state changes occur immediately following the falling edge of the clock.
The shift register can be implemented using MUXes and D flip-flops, as shown
in Figure 12-10(b). For the first flip-flop, when Sh/H11005L/H110050, the flip-flop Q
3output is
selected by the MUX, so Q3/H11001/H11005Q3and no state change occurs. When Sh/H110050 and 
L/H110051, the data input D3is selected and loaded into the flip-flop. When Sh/H110051 and360 Unit 12
4-bit Parallel-In,
Parallel-Out
Shift RegisterParallel Output
Parallel Input
(a) Block diagram
(b) Implementation usin g flip-flops and MUXesSI(Serial In)SO(Serial Out)
Sh(Shift Enable)
L(Load Enable)
Clock
D3D2D1D0Q3Q2Q1Q0
00
01
10
11D
D3SI
Sh
L
CLKQ3
D2 D1 D0QQ2 Q1 Q0
00
01
10
11DQ00
01
10
11DQ00
01
10
11DQFIGURE 12-10
Parallel-in,
Parallel-Out
Right Shift 
Register
Inputs Next State
Sh(Shift) L(Load) Q3/H11001Q2/H11001Q1/H11001Q0/H11001Action
00 Q3Q2Q1 Q0 No change
01 D3D2 D1 D0 Load
1X S I Q3Q2 Q1 Right shiftTABLE 12-1
Shift Register
Operation
Registers and Counters 361
L/H110050 or 1, SI is selected and loaded into the flip-flop. The second MUX selects Q2,
D2, or Q3, etc. The next-state equations for the flip-flops are
Q3/H11001/H11005Sh/H11032/H11080L/H11032/H11080Q3/H11001Sh/H11032/H11080L/H11080D3/H11001Sh/H11080SI (12-1)
Q2/H11001/H11005Sh/H11032/H11080L/H11032/H11080Q2/H11001Sh/H11032/H11080L/H11080D2/H11001Sh/H11080Q3
Q1/H11001/H11005Sh/H11032/H11080L/H11032/H11080Q1/H11001Sh/H11032/H11080L/H11080D1/H11001Sh/H11080Q2
Q0/H11001/H11005Sh/H11032/H11080L/H11032/H11080Q0/H11001Sh/H11032/H11080L/H11080D0/H11001Sh/H11080Q1
A typical application of this register is the conversion of parallel data to serial
data. The output from the last flip-flop ( Q0) serves as a serial output as well as one
of the parallel outputs. Figure 12-11 shows a typical timing diagram. The first clockpulse loads data into the shift register in parallel. During the next four clock pulses,this data is available at the serial output. Assuming that the register is initially clear(Q
3Q2Q1Q0/H110050000), that the serial input is SI /H110050 throughout, and that the data
inputs D3D2D1D0are 1011 during the load time ( t0), the resulting waveforms are as
shown. Shifting occurs at the end of t1,t2, and t3, and the serial output can be read dur-
ing these clock times. During t4,Sh/H11005L/H110050, so no state change occurs.
Figure 12-12(a) shows a 3-bit shift register with the Q1/H11032output from the last flip-
flop fed back into the Dinput of the first flip-flop. If the initial state of the register
is 000, the initial value of D3is 1, so after the first clock pulse, the register state is
100. Successive states are shown on the state graph of Figure 12-12(b). When the
Q0
t0 t1 t2 t3 t4 t5Q1Q2Q3D3,D1,D0Sh(Shift)L(Load)Clock
1000
010010101 (0) 1 0 1 (1)FIGURE 12-11
Timing Diagram for
Shift Register
000
111011001
110100
101010
D3Q3
Q′3D2Q2
Q′2D1Q1
Q′1
CLK
(a) Flip-flop connections (b) State graphFIGURE 12-12
Shift Register
with Inverted
Feedback
register is in state 001, D3is 0, and the next register state is 000. Then, successive
clock pulses take the register around the loop again. Note that states 010 and 101are not in the main loop. If the register is in state 010, then a shift pulse takes it to101 and vice versa; therefore, we have a secondary loop on the state graph. A circuitthat cycles through a fixed sequence of states is called a counter , and a shift register
with inverted feed back is often called a Johnson counter .
12.3 Design of Binary Counters
The counters discussed in this chapter are all synchronous counters. This means the
operation of the flip-flops is synchronized by a common clock pulse so that whenseveral flip-flops must change state, the state changes occur simultaneously. Ripplecounters, in which the state change of one flip-flop triggers the next flip-flop in line,are not discussed in this text.
We will first construct a binary counter using three T flip-flops to count clock pulses
(Figure 12-13).We will assume that all the flip-flops change state a short time followingthe rising edge of the input pulse. The state of the counter is determined by the statesof the individual flip-flops; for example, if flip-flop Cis in state 0, Bin state 1, and Ain
state 1, the state of the counter is 011. Initially, assume that all flip-flops are set to the 0state. When a clock pulse is received, the counter will change to state 001; when a sec-ond pulse is received, the state will change to 010, etc. The sequence of flip-flop statesisCBA /H11005000, 001, 010, 011, 100, 101, 110, 111, 000, . . . Note that when the counter
reaches state 111, the next pulse resets it to the 000 state, and then the sequence repeats.
First, we will design the counter by inspection of the counting sequence; then, we will
use a systematic procedure which can be generalized to other types of counters. Theproblem is to determine the flip-flop inputs— T
C,TB, and TA. From the preceding count-
ing sequence, observe that Achanges state every time a clock pulse is received. Because
Achanges state on every rising clock edge, TAmust equal 1. Next, observe that B
changes state only if A/H110051. Therefore, Ais connected to TBas shown, so that if A/H110051,
Bwill change state when a rising clock edge occurs. Similarly, Cchanges state when a
rising clock edge occurs only if BandAare both 1.Therefore, an AND gate is connected
toTCso that Cwill change state if B/H110051 and A/H110051 when a rising clock edge occurs.362 Unit 12
C C′
TCB B′
TBA A′
TA
1
Cloc kFIGURE 12-13
Synchronous
Binary Counter
Registers and Counters 363
Now, we will verify that the circuit of Figure 12-13 counts properly by tracing sig-
nals through the circuit. Initially, CBA /H11005000, so only TAis 1 and the state will change
to 001 when the first active clock edge arrives. Then, TB/H11005TA/H110051, and the state will
change to 010 when the second active clock arrives.This process continues until final-ly when state 111 is reached, T
C/H11005TB/H11005TA/H110051, and all flip-flops return to the 0 state.
Next, we will redesign the binary counter by using a state table (Table 12-2). This
table shows the present state of flip-flops C,B, and A(before a clock pulse is
received) and the corresponding next state (after the clock pulse is received). Forexample, if the flip-flops are in state CBA /H11005011 and a clock pulse is received, the next
state will be C
/H11001B/H11001A/H11001/H11005100.Although the clock is not explicit in the table, it is under-
stood to be the input that causes the counter to go to the next state in sequence. Athird column in the table is used to derive the inputs for T
C,TB, and TA.Whenever the
entries in the AandA/H11001columns differ, flip-flop Amust change state and TAmust be
1. Similarly, if Band B/H11001differ, Bmust change state so TBmust be 1. For example, if
CBA /H11005011, C/H11001B/H11001A/H11001/H11005100, all three flip-flops must change state, so TCTBTA/H11005111.
TC,TB, and TAare now derived from the table as functions of C,B, and A.B y
inspection, TA/H110051. Figure 12-14 shows the Karnaugh maps for TCand TB, from
which TC/H11005BAand TB/H11005A. These equations yield the same circuit derived previ-
ously for Figure 12-13.
Next, we will redesign the binary counter to use D flip-flops instead of T flip-
flops. The easiest way to do this is to convert each D flip-flop to a T flip-flop byadding an XOR (exclusive-OR) gate, as shown in Figure 11-24(b). Figure 12-15Present State Next State Flip-Flop Inputs
CBA C/H11001B/H11001A/H11001TCTBTA
000 0 0 1 0 0 1
001 0 1 0 0 1 1010 0 1 1 0 0 1
011 1 0 0 1 1 1100 1 0 1 0 0 1
101 1 1 0 0 1 1110 1 1 1 0 0 1
111 0 0 0 1 1 1TABLE 12-2
State Table 
for Binary 
Counter
TC TB01
00BAC
01
11
1000
00
11
0001
00BAC
01
11
1000
11
11
00FIGURE 12-14
Karnaugh Maps
for Binary Counter
shows the resulting counter circuit. The rightmost XOR gate can be replaced with
an inverter because A⊕1/H11005A/H11032.
We can also derive the D flip-flop inputs for the binary counter starting with
its state table (Table 12-2). For a D flip-flop, Q/H11001/H11005D. By inspection of the table,
QA/H11001/H11005A/H11032, so DA/H11005A/H11032.The maps for QB/H11001andQC/H11001are plotted in Figure 12-16.The
Dinput equations derived from the maps are
DA/H11005A/H11001/H11005A/H11032
DB/H11005B/H11001/H11005BA/H11032/H11001B/H11032A/H11005B⊕A (12-2)
DC/H11005C/H11001/H11005C/H11032BA/H11001CB/H11032/H11001CA/H11032/H11005C/H11032BA/H11001C(BA)/H11032/H11005C⊕BA
which give the same logic circuit as was obtained by inspection.
Next, we will analyze an up-down binary counter. The state graph and table
for an up-down counter are shown in Figure 12-17. When U/H110051, the counter
counts up in the sequence 000, 001, 010, 011, 100, 101, 110, 111, 000 . . . When D/H110051, the counter counts down in the sequence 000, 111, 110, 101, 100, 011, 010,
001, 000 . . . When U/H11005D/H110050, the counter state does not change, and U/H11005D/H110051
is not allowed.364 Unit 12
C C′
D
Cloc k1B B′
DA A′
DFIGURE 12-15
Binary Counter
with D Flip-Flops
DC DA DB01
00BAC
01
11
1001
01
10
0101
00BAC
01
11
1000
11
00
1101
00BAC
01
11
1011
00
00
11FIGURE 12-16
Karnaugh Maps
for D Flip-Flops
Registers and Counters 365
The up-down counter can be implemented using D flip-flops and gates, as shown in
Figure 12-18. The corresponding logic equations are
DA/H11005A/H11001/H11005A⊕(U/H11001D)
DB/H11005B/H11001/H11005B⊕(UA/H11001DA/H11032)
DC/H11005C/H11001/H11005C⊕(UBA /H11001DB/H11032A/H11032)
When U/H110051 and D/H110050, these equations reduce to equations for a binary up count-
er (Equations (12-2)).
When U/H110050 and D/H110051, these equations reduce to
DA/H11005A/H11001/H11005A⊕1/H11005A/H11032 (Achanges state every clock cycle)
DB/H11005B/H11001/H11005B⊕A/H11032 (Bchanges state when A/H110050)
DC/H11005C/H11001/H11005C⊕B/H11032A/H11032 (Cchanges state when B/H11005A/H110050)000
111
110
101
100011010001U
D
DD
DD
D DDU
UU
UU
U UC/H11001B/H11001A/H11001
CBA U D
000 001 111
001 010 000010 011 001011 100 010
100 101 011
101 110 100110 111 101111 000 110FIGURE 12-17
State Graph
and Table for
Up-Down
Counter
C C′
Clock Clock Clock
DU
D DU UDB B′
DA A′
DFIGURE 12-18
Binary Up-Down
Counter
By inspection of the table in Figure 12-17, we can verify that these are the correct
equations for a down counter. For every row of the table, A/H11001/H11005A/H11032, so Achanges
state every clock cycle. For those rows where A/H110050,B/H11001/H11005B/H11032. For those rows where
B/H110050 and A/H110050,C/H11001/H11005C/H11032.
Next, we will design a loadable counter [Figure 12-19(a)]. This counter has two
control signals Ld(load) and Ct(count). When Ld/H110051 binary data is loaded into
the counter on the rising clock edge, and when Ct/H110051, the counter is incremented
on the rising clock edge. When Ld/H11005Ct/H110050, the counter holds its present state.
When Ld/H11005Ct/H110051, load overrides count, and data is loaded into the counter. The
counter also has an asynchronous clear input that clears the counter when ClrN is0. Figure 12-19(b) summarizes the counter operation. All state changes occur on therising edge of the clock (except for the asynchronous clear).
Figure 12-20 shows how the loadable counter can be implemented using flip-
flops, MUXes, and gates. When Ld/H110051, each MUX selects a D
iinput, and because
the output of each AND gate is 0, the output of each XOR gate is Di, which gets
stored in a flip-flop.When Ld/H110050 and Ct/H110051, each MUX selects one of the flip-flop
outputs ( C,B, or A). The circuit then becomes equivalent to Figure 12-15, and the
counter is incremented on the rising clock edge.
The next-state equations for the counter of Figure 12-20 are
A/H11001/H11005DA/H11005(Ld/H11032/H11080A/H11001Ld/H11080DAin)⊕Ld/H11032/H11080Ct
B/H11001/H11005DB/H11005(Ld/H11032/H11080B/H11001Ld/H11080DBin)⊕Ld/H11032/H11080Ct/H11080A
C/H11001/H11005DC/H11005(Ld/H11032/H11080C/H11001Ld/H11080DCin)⊕Ld/H11032/H11080Ct/H11080B/H11080A366 Unit 12
(a)Q
D
Clk33
ClrNCt
LdClrN Ld Ct C/H11001B/H11001A/H11001
0X X 0 0 0
11 X DCDBDA (load)
10 0 CBA (no change)
1 0 1 Present state /H110011
(b)FIGURE 12-19
Loadable Counter
with Count Enable
C C′
Clk
Ld
Ld
CtDC
DCinClrNB B′
Clk
LdDB
DBinClrNA A′
Clk
LdDA
DAinClrNFIGURE 12-20
Circuit for 
Figure 12-19
Registers and Counters 367
When Ld/H110050 and Ct/H110051, these equations reduce to A/H11001/H11005A/H11032,B/H11001/H11005B⊕A, and
C/H11001/H11005C⊕BA, which are the equations previously derived for a 3-bit counter.
12.4 Counters for Other Sequences
In some applications, the sequence of states of a counter is not in straight binary order.
Figure 12-21 shows the state graph for such a counter. The arrows indicate the statesequence. If this counter is started in state 000, the first clock pulse will take it to state100, the next pulse to 111, etc.The clock pulse is implicitly understood to be the input tothe circuit and not shown on the graph. The corresponding state table for the counter isTable 12-3. Note that the next state is unspecified for the present states 001, 101, and 110.
We will design the counter specified by Table 12-3 using T flip-flops. We could
derive T
C,TB, and TAdirectly from this table, as in the preceding example. However,
it is often more convenient to plot next-state maps showing C/H11001,B/H11001, and A/H11001as func-
tions of C,B, and A, and then derive TC,TB, and TAfrom these maps. The next-state
maps in Figure 12-22(a) are easily plotted from inspection of Table 12-3. From thefirst row of the table, the CBA /H11005000 squares on the C
/H11001,B/H11001, and A/H11001maps are filled
in with 1, 0, and 0, respectively. From the second row, the CBA /H11005001 squares on all
three maps are filled in with don’t-cares. From the third row, the CBA /H11005010 squares
on the C/H11001,B/H11001, and A/H11001maps are filled in with 0, 1, and 1, respectively. The next-state
maps can be quickly completed by continuing in this manner.
Next, we will derive the maps for the Tinputs from the next-state maps. In the fol-
lowing discussion, the general symbol Qrepresents the present state of the flip-flop
(C,B, or A) under consideration, and Q/H11001represents the next state ( C/H11001,B/H11001, or A/H11001) of
the same flip-flop. Given the present state of a T flip-flop ( Q) and the desired next
000
011
010 111100FIGURE 12-21
State Graph for
Counter
CBA C/H11001B/H11001A/H11001
000 1 0 0
001 – – –
010 0 1 1011 0 0 0100 1 1 1
101 – – –
110 – – –111 0 1 0TABLE 12-3
State Table for
Figure 12.21
state ( Q/H11001), the Tinput must be 1 whenever a change of state is required. Thus, T/H110051
whenever Q/H11001/H11014Q, as shown in Table 12-4.
In general, the next-state map for flip-flop Qgives Q/H11001as a function of Qand
several other variables. The value written in each square of the map gives the valueofQ
/H11001, while the value of Qis determined from the row or column headings. Given
the map for Q/H11001, we can then form the map for TQby simply putting a 1 in each
square of the TQmap for which Q/H11001is different from Q. Thus, to form the TCmap in
Figure 12-22(b) from the C/H11001map in Figure 12-22(a), we place a 1 in the CBA /H11005000
square of TCbecause C/H110050 and C/H11001/H110051 for this square. We also place a 1 in the 111
square of TCbecause C/H110051 and C/H11001/H110050 for this square.
If we don’t care what the next state of a flip-flop is for some combination of vari-
ables, we don’t care what the flip-flop input is for that combination of variables.Therefore, if the Q
/H11001map has a don’t-care in some square, the TQmap will have a
don’t-care in the corresponding square. Thus, the TCmap has don’t-cares for CBA
/H11005001, 101, and 110 because C/H11001has don’t-cares in the corresponding squares.368 Unit 12
1 101
XX
0 0
000BACC = 0 half C = 1 half
(a) Next-state maps for Table 12-3B = 0 half
B = 1 half
C+01
11
10 X0 101
XX
0 1
100BAC
B+01
11
10 XA = 1 halfA = 0 hal f 0 101
XX
0 0
100BAC
A+01
11
10 X
1 001
XX
0 1
000BACC = 0 half C = 1 half
(b) Derivation of T inputsTC = C′B′ + CB TB = C′A + CB′ TA = C + BB = 0 half
B = 1 half
TC01
11
10 X0 101
XX
1 0
000BAC
TB01
11
10 XA = 1 halfA = 0 hal f 0 101
XX
1 1
100BAC
TA01
11
10 XFIGURE 12-22
QQ/H11001T
00 0
01 1 T/H11005Q/H11001⊕Q
10 111 0TABLE 12-4
Input for 
T Flip-Flop
Registers and Counters 369
Instead of transforming the Q/H11001map into the TQmap one square at a time, we can
divide the Q/H11001map into two halves corresponding to Q/H110050 and Q/H110051, and transform
each half of the map. From Table 12-4, whenever Q/H110050,T/H11005Q/H11001, and whenever Q/H110051,
T/H11005(Q/H11001)/H11032.Therefore, to transform the Q/H11001map into a Tmap, we copy the half for which
Q/H110050 and complement the half for which Q/H110051, leaving the don’t-cares unchanged.
We will apply this method to transform the C/H11001,B/H11001, and A/H11001maps for our counter
shown in Figure 12-22(a) into Tmaps. For the first map, Ccorresponds to Q(and C/H11001
toQ/H11001), so to get the TCmap from the C/H11001map, we complement the second column
(where C/H110051) and leave the rest of the map unchanged. Similarly, to get TBfrom B/H11001,
we complement the bottom half of the Bmap, and to get TAfrom A/H11001, we complement
the middle two rows. This yields the maps and equations of Figure 12-22(b) and thecircuit shown in Figure 12-23. The clock input is connected to the clock (CK) inputof each flip-flop so that the flip-flops can change state only in response to a clockpulse. The gate inputs connect directly to the corresponding flip-flop outputs as indi-cated by the dashed lines. To facilitate reading similar circuit diagrams, such con-necting wires will be omitted in the remainder of the book.
The timing diagram of Figure 12-24, derived by tracing signals through the circuit,
verifies that the counter functions according to the state diagram of Figure 12-21; forexample, starting with CBA /H11005000, T
C/H110051 and TB/H11005TA/H110050. Therefore, when the
clock pulse comes along, only flip-flop Cchanges state, and the new state is 100.Then,
TC/H110050 and TB/H11005TA/H110051, so flip-flops BandAchange state when the next clock pulse
occurs, etc. Note that the flip-flops change state following the falling clock edge.
Although the original state table for the counter (Table 12-3) is not completely
specified, the next states of states 001, 101, and 110 have been specified in the processof completing the circuit design. For example, if the flip-flops are initially set to C/H110050,
B/H110050, and A/H110051, tracing signals through the circuit shows that T
C/H11005TB/H110051 and 
TA/H110050, so that the state will change to 111 when a clock pulse is applied.This behav-
ior is indicated by the dashed line in Figure 12-25. Once state 111 is reached,
successive clock pulses will cause the counter to continue in the original countingsequence as indicated on the state graph. When the power in a circuit is first turned
C C′
TCCKB B′
TBCKA A′
TACKFF FF FF
Clock
C′B′CB
CB CB ′C′AFIGURE 12-23
Counter Using
T Flip-Flops
on, the initial states of the flip-flops may be unpredictable. For this reason, all of the
don’t-care states in a counter should be checked to make sure that they eventually
lead into the main counting sequence unless a power-up reset is provided.
In summary, the following procedure can be used to design a counter using T
flip-flops:
1.Form a state table which gives the next flip-flop states for each combination of
present flip-flop states.
2.Plot the next-state maps from the table.
3.Plot a Tinput map for each flip-flop.When filling in the TQmap, TQmust be 1 when-
ever Q/H11001/H11014Q. This means that the TQmap can be formed from the Q/H11001map by 
complementing the Q/H110051 half of the map and leaving the Q/H110050 half unchanged.
4.Find the Tinput equations from the maps and realize the circuit.
Counter Design Using D Flip-Flops
For a D flip-flop, Q/H11001/H11005D, so the Dinput map is identical with the next-state map.
Therefore, the equation for Dcan be read directly from the Q/H11001map. For the counter
of Figure 12-21, the following equations can be read from the next-state maps shownin Figure 12-22(a):
D
C/H11005C/H11001/H11005B/H11032 DB/H11005B/H11001/H11005C/H11001BA/H11032
DA/H11005A/H11001/H11005CA/H11032/H11001BA/H11032/H11005A/H11032(C/H11001B)
This leads to the circuit shown in Figure 12-26 using D flip-flops. Note that the
connecting wires between the flip-flop outputs and the gate inputs have been omit-ted to facilitate reading the diagram.370 Unit 12
TATBTCABCClock
0110 0 0
0011 1 0
0010 1 0FIGURE 12-24
Timing Diagram
for Figure 12-23
000
011
010 111 001100FIGURE 12-25
State Graph for
Counter
Registers and Counters 371
12.5 Counter Design Using S-R and J-K Flip-Flops
The procedures used to design a counter with S-R flip-flops are similar to the pro-
cedures discussed in Sections 12.3 and 12.4. However, instead of deriving an inputequation for each D or T flip-flop, the SandRinput equations must be derived. We
will now develop methods for deriving these Sand Rflip-flop input equations.
Table 12-5(a) describes the behavior of the S-R flip-flop. Given S,R, and Q, we can
determine Q
/H11001from this table. However, the problem we must solve is to determine S
andRgiven the present state Qand the desired next state Q/H11001. If the present state of
the flip-flop is Q/H110050 and the desired next state is Q/H11001/H110051, a 1 must be applied to the
Sinput to set the flip-flop to l. If the present state is 1, and the desired next state is 0,
a 1 must be applied to the Rinput to reset the flip-flop to 0. Restrictions on the flip-
flop inputs require that S/H110050 if R/H110051, and R/H110050 if S/H110051. Thus, when forming Table
12-5(b), the rows corresponding to QQ/H11001/H1100501 and 10 are filled in with SR/H1100510 and
01, respectively. If the present state and next state are both 0, Smust be 0 to prevent
setting the flip-flop to 1. However, Rmay be either 0 or 1 because when Q/H110050,R/H110051
has no effect on the flip-flop state. Similarly, if the present state and next state are 
both 1, Rmust be 0 to prevent resetting the flip-flop, but Smay be either 0 or 1. The
required SandRinputs are summarized in Table 12-5(b). Table 12-5(c) is the same as
12-5(b), except the alternative choices for RandShave been indicated by don’t-cares.C C′
DCCKFF
BA ′B′B
CB′
DBCKFF
CBA
A′A′
DACKFF
ClockFIGURE 12-26
Counter of 
Figure 12-21
Using D Flip-Flops
(a)
SRQ Q/H11001
000 0
001 1010 0011 0
100 1
101 11 1 0 – inputs not1 1 1 – allowedTABLE 12-5
S-R Flip-Flop 
Inputs(c)
QQ/H11001SR
00 0 X
01 1 0
10 0 1
11 X 0(b)
QQ/H11001SR
0000
01
01 1 0
10 0 1
1100
10
¸˝˛
¸˝˛ ¸˝˛
Next, we will redesign the counter of Figure 12-21 using S-R flip-flops. Table 12-3
is repeated in Table 12-6 with columns added for the Sand Rflip-flop inputs. These
columns can be filled in using Table 12-5(c). For CBA /H11005000, C/H110050 and C/H11001/H110051, so 
SC/H110051,RC/H110050. For CBA /H11005010 and 011, C/H110050 and C/H11001/H110050, so SC/H110050 and RC/H11005X.
For CBA /H11005100, C/H110051 and C/H11001/H110051, so SC/H11005Xand RC/H110050. For row 111, C/H110051 and 
C/H11001/H110050, so SC/H110050 and RC/H11005l. For CBA /H11005001, 101, and 110, C/H11001/H11005X, so SC/H11005RC/H11005X.
Similarly, the values of SBandRBare derived from the values of BandB/H11001, and SAand
RAare derived from Aand A/H11001. The resulting flip-flop input functions are mapped in
Figure 12-27(b).
It is generally faster and easier to derive the S-R flip-flop input maps directly
from the next-state maps than to derive them from the state table as was done inTable 12-6. For each flip-flop, we will derive the Sand Rinput maps from the next-
state ( Q
/H11001) map using Table 12-5(c) to determine the values for Sand R. Just as we
did for the T flip-flop, we will use the next-state maps for C/H11001,B/H11001, and A/H11001in Figure
12-22(a) as a starting point for deriving the S-R flip-flop input equations. For con-venience, these maps are repeated in Figure 12-27(a). We will consider one-half ofeach next-state map at a time when deriving the input maps. We will start with flip-flop C(Q/H11005CandQ
/H11001/H11005C/H11001) and consider the C/H110050 column of the map. From Table
12-5(c), if C/H110050 and C/H11001/H110051, then S/H110051 and R/H110050.Therefore, for every square in the
C/H110050 column where C/H11001/H110051, we plot SC/H110051 and RC/H110050 (or blank) in the corre-
sponding squares of the input maps. Similarly, for every square in the C/H110050 column
where C/H11001/H110050, we plot SC/H110050 and RC/H11005Xon the input maps. For the C/H110051 column,
ifC/H11001/H110050, we plot SC/H110050 and RC/H110051; if C/H11001/H110051, we plot SC/H11005Xand RC/H110050. Don’t-
cares on the C/H11001map remain don’t-cares on the SCandRCmaps, because if we do not
care what the next state is, we do not care what the input is. In a similar manner, wecan derive the S
BandRBmaps from the B/H11001map by working with the B/H110050 (top) half
of the map and the B/H110051 (bottom) half of the map. As before, 1’s are placed on the
SorRmap when the flip-flop must be set or reset. Sis a don’t-care if Q/H110051 and no
state change is required, and R/H11005XifQ/H110050 and no state change is required. Finally,
SAandRAare derived from the A/H11001map. Figure 12-27(c) shows the resulting circuit.
The procedure used to design a counter with J-K flip-flops is very similar to that
used for S-R flip-flops. The J-K flip-flop is similar to the S-R flip-flop except that J
andKcan be 1 simultaneously, in which case the flip-flop changes state.Table 12-7(a)
gives the next state ( Q/H11001) as a function of J,K, and Q. Using this table, we can derive
the required input conditions for JandKwhen QandQ/H11001are given.Thus if a change
from Q/H110050 to Q/H11001/H110051 is required, either the flip-flop can be set to 1 by using J/H110051372 Unit 12
CBA C/H11001B/H11001A/H11001SCRCSBRBSARA
000 1 0 0 1 0 0 X 0 X
001 – – – X X X X X X
010 0 1 1 0 X X 0 1 0
011 0 0 0 0 X 0 1 0 1100 1 1 1 X 0 1 0 1 0101 – – – X X X X X X
110 – – – X X X X X X
111 0 1 0 0 1 X 0 0 1TABLE 12-6
Registers and Counters 373
(and K/H110050) or the state can be changed by using J/H11005K/H110051. In other words, Jmust
be l, but Kis a don’t-care. Similarly, a state change from 1 to 0 can be accomplished
by resetting the flip-flop with K/H110051 (and J/H110050) or by changing the flip-flop state
with J/H11005K/H110051. When no state change is required, the inputs are the same as the
corresponding inputs for the S-R flip-flops. The J-K flip-flop input requirements aresummarized in Tables 12-7(b) and 12-7(c).
We will now redesign the counter of Figure 12-21 using J-K flip-flops. Table 12-3
is repeated in Table 12-8 with columns added for the Jand Kflip-flop inputs. We
will fill in these columns using Table 12-7(c). For CBA /H11005000, C/H110050 and C
/H11001/H110051,1 101
XX
0 0
000BAC
(a) Next-state mapsB = 0 half
B = 1 half
C+01
11
10 X
01
XX
X 1
X00BAC
(b) S-R flip-flop equations
(c) Logic circuitRC01
11
10 X1X
XX
SC
RC = ASC = B′X01
XX
X
100BAC
RB01
11
10 X1
XX
X
SB
RB = C′ASB = CX X01
XX
X
1 100BAC
RA01
11
10 X1
X
1X
SA
RA = ASA = CA′ + BA′
    = A′(C + B)X0 101
XX
0 1
100BAC
B+01
11
10 XA = 1 halfA = 0 half 0 101
XX
0 0
100BAC
A+01
11
10 X
Q Q′C C′
B′ A
CLKS RQ Q′B B′
AC ′CS RQ Q′A A′
AS R
A′
BCFIGURE 12-27
Counter of 
Figure 12-21 Using
S-R Flip-Flops
374 Unit 12
(a)
JK Q Q/H11001
000 0
001 1010 0
011 0
100 1101 1110 1
111 0TABLE 12-7
J-K Flip-Flop 
Inputs(c)
QQ/H11001JK
00 0 X
01 1 X10 X 111 X 0(b)
QQ/H11001JK
0000
01
0110
11
1001
11
1100
10¸˝˛ ¸˝˛ ¸˝˛ ¸˝˛
CBA C/H11001B/H11001A/H11001JCKCJBKBJAKA
000 1 0 0 1 X 0 X 0 X
001 – – – X X X X X X
010 0 1 1 0 X X 0 1 X
011 0 0 0 0 X X 1 X 1100 1 1 1 X 0 1 X 1 X101 – – – X X X X X X110 – – – X X X X X X
111 0 1 0 X 1 X 0 X 1TABLE 12-8
soJC/H110051 and KC/H11005X. For CBA /H11005010 and 011, C/H110050 and C/H11001/H110050, so JC/H110050 and
KC/H11005X. The remaining table entries are filled in similarly. The resulting J-K 
flip-flop input functions are plotted in Figure 12-28(b) on the next page. Afterderiving the flip-flop input equations from the J-K maps, we can draw the logic cir-cuit of Figure 12-28(c).
12.6 Derivation of Flip-Flop Input 
Equations—Summary
The input equation for the flip-flops in a sequential circuit may be derived from the
next-state equations by using truth tables or by using Karnaugh maps. For circuitswith three to five variables, it is convenient to first plot maps for the next-stateequations, and then transform these maps into maps for the flip-flop inputs.
Given the present state of a flip-flop ( Q) and the desired next state ( Q
/H11001),
Table 12-9 gives the required inputs for various types of flip-flops. For the D flip-flop, the input is the same as the next state. For the T flip-flop, the input is 1 when-ever a state change is required. For the S-R flip-flop, Sis 1 whenever the flip-flop
must be set to 1 and Ris 1 when it must be reset to 0. We do not care what Sis if
the flip-flop state is 1 and must remain 1; we do not care what Ris if the flip-flop
state is 0 and must remain 0. For a J-K flip-flop, the Jand Kinputs are the same
Registers and Counters 375
asSandR, respectively, except that when one input is 1 the other input is X. This dif-
ference arises because S/H11005R/H110051 is not allowed, but J/H11005K/H110051 causes a change of state.
Table 12-9 summarizes the rules for transforming next-state maps into flip-flop
input maps. Before applying these rules, we must copy any don’t-cares from the next-state maps onto the input maps.Then, we must work with the Q/H110050 and Q/H110051 halves
of each next-state map separately. The rules given in Table 12-9 are easily derived bycomparing the values of Q
/H11001with the corresponding input values. For example, in the
Q/H110050 column of the table, we see that Jis the same as Q/H11001, so the Q/H110050 half of the J
map is the same as the Q/H11001map. In the Q/H110051 column, J/H11005X(independent of Q/H11001), so
we fill in the Q/H110051 half of the Jmap with X’s.(c) Logic circuit (omitting the feedback lines)C C′
B′ A
ClockJC KCB B′
C′ACJB KBA A′
1JA KA
CBCK CK CKFF FF FF1 101
XX
0 0
000BAC
(a) Next-state mapsB = 0 half
B = 1 half
C+01
11
10 X
01
XX
X1X 00BAC
(b) J-K flip-flop input equationsJC01
11
10 XX
X
X
XX
1
KC
JC = B'KC = AX01 01 01 01
XX
XX
XX1 00BAC
JB01
11
10X
X
1XX
KB
JB = C KB = C'AX01
XX1
X
1X00BAC
JA01
11
10 XXX
XX
1
X1
X
KA
JA = C + B KA = 10 101
XX
0 1
100BAC
B+01
11
10 XA = 1 halfA = 0 half 0 101
XX
0 0
100BAC
A+01
11
10 XFIGURE 12-28
Counter of 
Figure 12-21 Using
J-K Flip-Flops
376 Unit 12
Rules for Forming Input Map 
Q=0 Q= 1 From Next-State Map*
Type of Q/H110050 Half of Q/H110051 Half of 
Flip-Flop Input Q/H11001/H110050Q/H11001/H110051Q/H11001/H110050Q/H11001/H110051 Map Map
Delay D 0 1 0 1 no change no change
Toggle T 0 1 1 0 no change complement
Set-Reset S 0 1 0 X no change replace 1’s 
with X’s**
R X 0 1 0 replace 0’s complement
with X’s**
J-K J 0 1 X X no change fill in with X’s
K X X 1 0 fill in with X’s complement
Q/H11001means the next state of Q
X is a don’t-care
*Always copy X’s from the next-state map onto the input maps first.
**Fill in the remaining squares with 0’s.TABLE 12-9
Determination of
Flip-Flop Input
Equations from
Next-State
Equations
Using Karnaugh
Maps
0 101
1 0
0 0
100ABQ
Q+
Next-state map01
11
10 X
0X01
1 0
0 0
100ABQ
S = AB′ + Q ′A′B01
11
10 XX 001
0 1
X 1
000ABQ
R = Q B
S-R input maps01
11
10 X0X01
1X
0X
100ABQ
J = A′B + AB′01
11
10 XX 001
X 1
X 1
X00ABQ
K = B
J-K input maps01
11
10 X0 101
1 0
0 0
100ABQ
D = Q ′A′B + Q B′ + AB′
D input map01
11
10 X0 001
1 1
0 1
100ABQ
T = A′B + AB′ + Q B
T input map01
11
10 XExample
(illustrating
the use of 
Table 12-9 )
For the S-R flip-flop, note that when Q/H110050,R/H11005XifQ/H11001/H110050; and when Q/H110051,
R/H110051 if Q/H11001/H110050. Therefore, to form the Rmap from the Q/H11001map, replace 0’s with X’s
on the Q/H110050 half of the map and replace 0’s with 1’s on the Q/H110051 half (and fill in
0’s for the remaining entries). Similarly, to form the Smap from the Q/H11001map, copy
the 1’s on the Q/H110050 half of the map, and replace the 1’s with X’s on the Q/H110051 half.
Registers and Counters 377
Examples of deriving 4-variable input maps are given in Figure 12-29. In each case,
Qirepresents the flip-flop for which input equations are being derived A,B, and C
represent other variables on which the next state depends.As shown in Figure 12-29(a),a 1 is placed on the T
1map whenever Q1must change state. In Figure 12-29(b), 1’s are
placed on the Q2/H110050 half of the S2map whenever Q2must be set to 1, and 1’s are
placed on the Q2/H110051 half of the R2map whenever Q2must be reset. Figure 12-29(c)
illustrates derivation of J3andK3by using separate JandKmaps. As will be seen in
Unit 14, the methods used to derive flip-flop input equations for counters are easilyextended to general sequential circuits.
The procedures for deriving flip-flop input equations discussed in this unit can
be extended to other types of flip-flops. If we want to derive input equations for adifferent type of flip-flop, the first step is to construct a table which gives the next0 1 0 100 01 11 10
X 1 1 0
1XX 1
000BCQ1A
01
11
10 0 0X0 1 1 000 01 11 10
X 1 0 1
1XX 0
000BCQ1A
T1 Q1 = 0
half
Q2 = 0
half01
11
10 0 1X
1X 1 000 01 11 10
0 0X 1
1 0X 1
X00CQ2AB
01
11
10 0 0 10X 0X00 01 11 10
1 1X 0
0 1X 0
X00CQ2AB
R201
11
10 XX 01X 1 000 01 11 10
0 0XX
X 0XX
X00CQ2AB
S201
11
10 0 0 1Q1 = 1
half
Q1+
Q2+
Q3+(a)
(b)
0 0 1X00 01 11 10
0 1X 1
XX 0 0
100Q3CAB
01
11
10 1 1 00 0 1X00 01 11 10
0 1X 1
XXXX
X00Q3CAB
J3 = A + BC01
11
10 XXXXXXX00 01 11 10
XXXX
XX 1 1
000Q3CAB
K3 = C + AB′01
11
10 0 0 1
(c)Q2 = 1 half
Q3 = 0 half
Q3 = 1 halfFIGURE 12-29
Derivation of
Flip-Flop Input
Equations Using
4-Variable Maps
state ( Q/H11001) as a function of the present state ( Q) and the flip-flop inputs. From this
table, we can construct another table which gives the required flip-flop input com-binations for each of the four possible pairs of values of Qand Q
/H11001. Then, using this
table, we can plot a Karnaugh map for each input function and derive minimumexpressions from the maps.
Problems
12.1 Consider a 6-bit adder with an accumulator, as in Figure 12-5. Suppose the Xregis-
ter contains a number from a previous calculation. We do not want this number.Instead, we want Xto equal 3 /H11003Y.(X/H11005x
5x4x3x2x1x0and Y/H11005y5y4y3y2y1y0.) On the
timing diagram, give values for Ad and ClrN so that we will have X/H110053/H11003Yheld in
the accumulator.
12.2 The shift register of Figure 12-10 can be made to shift to the left by adding external
connections between the Qoutputs and Dinputs. Draw a block diagram like the one
in Figure 12-10(a) and indicate the appropriate connections. Which input line wouldserve as a serial input in this case? With the connections you have made, what shouldShandLdbe for a left shift? For a right shift?
12.3 Show how to modify the internal circuitry of the shift register of Figure 12-10 so that
it will also shift to the left without external connections as in Problem 12.2. ReplaceShandLwith AandBand let the register operate according to the following table:ClrNAdClock378 Unit 12
Inputs Next State
AB Q3/H11001Q2/H11001Q1/H11001Q0/H11001Action
00 Q3Q2Q1Q0 no change
01 S I Q3Q2Q1 right shift
10 Q2Q1Q0SI left shift
11 D3D2D1D0 load
12.4 (a) Design a 4-bit synchronous binary counter using T flip-flops.
(Hint : Add one flip-flop, with necessary gates, to the left side of Figure 12-13.
Verify that the gates for the other three flip-flops do not change.)
(b) Repeat (a) using D flip-flops. See Figure 12-15.
Registers and Counters 379
12.5 Repeat Problem 12.4(a) using D flip-flops, but implement each Dinput as a sum of
products, without using XOR gates. ( Hint : Use Equations (12-2). As in Problem
12.4, you will need one more equation.)
12.6 Design a circuit using D flip-flops that will generate the sequence 0, 0, 1, 0, 1, 1 and
repeat. Do this by designing a counter for any sequence of states such that the firstflip-flop takes on this sequence. There are many correct answers, but do not dupli-cate states, because each state can have only one next state.
12.7 Design a 3-bit counter which counts in the sequence:
001, 011, 010, 110, 111, 101, 100, (repeat) 001, . . .(a) Use D flip-flops(b) Use T flip-flopsIn each case, what will happen if the counter is started in state 000?
12.8 Design a 3-bit counter which counts in the sequence:
001, 011, 010, 110, 111, 101, 100, (repeat) 001 ,...
(a) Use J-K flip-flops(b) Use S-R flip-flops
In each case, what will happen if the counter is started in state 000?
12.9 An M-N flip-flop works as follows:
IfMN /H1100500, the next state of the flip-flop is 0.
IfMN /H1100501, the next state of the flip-flop is the same as the present state.
IfMN /H1100510, the next state of the flip-flop is the complement of the present state.
IfMN /H1100511, the next state of the flip-flop is 1.
(a) Complete the following table (use don’t-cares when possible):
(b) Using this table and Karnaugh maps, derive and minimize the input equations for a
counter composed of three M-N flip-flops which counts in the following sequence:
CBA /H11005000, 001, 011, 111, 101, 100, (repeat) 000, . . .
12.10 Design a counter which counts in the sequence that has been assigned to you. Use
D flip-flops and NAND gates. Simulate your design using SimUaid .
(a) 000, 001, 011, 101, 111, 010, (repeat) 000 ,...
(b) 000, 011, 101, 111, 010, 110, (repeat) 000 ,...
(c) 000, 110, 111, 100, 101, 001, (repeat) 000 ,...
(d) 000, 100, 001, 110, 101, 111, (repeat) 000 ,...
(e) 000, 010, 111, 101, 011, 110, (repeat) 000 ,...
(f) 000, 100, 001, 111, 110, 101, (repeat) 000 ,...Present State Next State
QQ/H11001MN
00
011011
(g) 000, 010, 111, 101, 001, 110, (repeat) 000 ,...
(h) 000, 101, 010, 011, 001, 110, (repeat) 000 ,...
(i) 000, 100, 010, 001, 110, 111, (repeat) 000 ,...
(j) 000, 001, 111, 010, 110, 011, (repeat) 000 ,...
(k) 000, 100, 010, 001, 101, 111, (repeat) 000 ,...
(l) 000, 011, 111, 110, 001, 100, (repeat) 000 ,...
(m) 000, 100, 111, 110, 010, 011, (repeat) 000 ,...
(n) 000, 011, 111, 110, 010, 100, (repeat) 000 ,...
12.11 Redesign the right-shift register circuit of Figure 12-10 using four D flip-flops with
clock enable, four 2-to-1 MUXes, and a single OR gate.
12.12 Design a left-shift register similar to that of Figure 12-10. Your register should shift
left if Sh/H110051, load if Sh/H110050 and Ld/H110051, and hold its state if Sh/H11005Ld/H110050.
(a) Draw the circuit using four D flip-flops and four 4-to-1 MUXes.(b) Give the next-state equations for the flip-flops.
12.13 A 74178 shift register is described by the given table. All state changes occur on the
1-0 transition of the clock.The shift register is connected as shown. Complete the tim-ing diagram.
12.14 Design a 5-bit synchronous binary counter. ( Hint : See Problem 12.4.)
(a) Use T flip-flops.(b) Use D flip-flops.QDSI = QCQBQALdShClockQD QAQBQC
DD DADBDC74178
Cloc k
0101SI
Sh
Ld380 Unit 12
Sh Ld QA/H11001QB/H11001QC/H11001QD/H11001
00 QA QBQCQD
01 DA DBDCDD
1X S I QAQBQC
Registers and Counters 381
12.15 Construct a 4-bit Johnson counter using J-K flip-flops. (See Figure 12-12 for a
Johnson counter.) What sequence of states does the counter go through if it is start-ed in state 0000? State 0110?
12.16 Design a 3-bit binary up-down counter which functions the same as the up-down
counter of Figures 12-17 and 12-18. Use a 3-bit register of D flip-flops, a 3-bit adder,and one OR gate. (If you are clever enough, you can do it without the OR gate.)(Hint : To subtract one, add 111.)
12.17 Design a decade counter which counts in the sequence:
0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 0000 ,...
(a) Use D flip-flops.(b) Use J-K flip-flops.(c) Use S-R flip-flops.(d) Use T flip-flops.(e) Draw a complete state diagram for the counter of (b) showing what happens
when the counter is started in each of the unused states.
12.18 Repeat Problem 12.17 for the downward decade sequence:
0000, 1001, 1000, 0111, 0110, 0101, 0100, 0011, 0010, 0001, 0000, . . .
12.19 Design a 3-bit counter which counts in the sequence:
001, 100, 101, 111, 110, 010, 011, 001, . . .(a) Use D flip-flops.(b) Use J-K flip-flops.(c) Use T flip-flops.(d) Use S-R flip-flops.(e) What will happen if the counter of (a) is started in state 000?
12.20 Design a decade counter using the following 2-4-2-1 weighted code for decimal
digits. Use NAND gates and the indicated flip-flop types.(a) Use D flip-flops.(b) Use J-K flip-flops.(c) Use T flip-flops.(d) Use S-R flip-flops.
Digit ABCD
0 0000
1 00012 00103 00114 0100
5 1011
6 11007 11018 11109 1111
12.21 Repeat Problem 12.20 using NOR gates instead of NAND gates.
12.22 Design a decade counter using the excess-3 code for decimal digits. Use NAND
gates and the indicated flip-flop types.(a) Use D flip-flops.(b) Use J-K flip-flops.(c) Use T flip-flops.(d) Use S-R flip-flops.
12.23 Repeat Problem 12.22 using NOR gates instead of NAND gates.
12.24 The following binary counter increments on each rising clock edge unless the exter-
nal clear (ClrN) control input is low.(a) Implement a modulo 12 counter using this binary counter assuming the Clr con-
trol input is a synchronous control input.
(b) Repeat Part (a) assuming Clr is an asynchronous control input.
12.25 The following binary counter operates according to the function table given. Using this
binary counter, implement a decimal counter that uses the 2-4-2-1 weighted code forrepresenting decimal digits. Minimize the gate logic required by using the parallel load
inputs only to change the counting sequence from straight binary to 2-4-2-1 code.
ClkClr4-Bit CounterLdP3 P2 P1P0
Q3 Q2 Q1Q0ClrNClkClr 4-Bit Counter
Q3 Q2 Q1Q0ClrN382 Unit 12
ClN Ld Function
0 — Clear
1 1 Parallel Load1 0 Increment
12.26 The general form of a shift register counter is shown. The inputs to the logic are the
shift register outputs, and the output from the logic is the serial input to the shiftregister. If the gate logic contains only exclusive-OR gates, then this is a linear shiftregister counter. For each value of N, there exists an exclusive-OR circuit so that the
counter cycles through 2
N/H110021 counts.
(a) For N/H110053, construct the state diagram for the counter if Sin/H11005Q2/H17053Q1.( T h e
shift register stages are numbered Q0,Q1,Q2from left to right.)
(b) For N/H110054, find an exclusive-OR circuit so that the counter cycles through 15 counts.
Registers and Counters 383
(c) Make a simple modification the logic of Part (b) so that the counter cycles
through 16 counts. (The counter is no longer linear.)
12.27 Binary up counters can be designed using J-K flip-flops by noting that the least signif-
icant stage, Q0, always toggles and stage Qialways toggles when stages 0, ...(i/H110021) are
1. This approach can be modified to design counters with a shorter cycle and obtainingnearly minimum equations. Note that an optimum solution may not have the sameequations for JandK.
(a) Modify the binary up counter design to obtain a BCD decade up counter using
J-K flip-flops.
(b) Modify the binary up counter design to obtain an excess-3 decade up counter
using J-K flip-flops.
(c) Modify the design for Part (b) so that the counters can be cascaded to obtain
excess-3 counters that can count to 99, 999, etc.
12.28 A three-stage binary up-down counter has control input U; when U/H110050, the counter
counts down and when U/H110051, the counter counts up. Design this counter with a
minimum number of NAND gates, using(a) reset-dominant S-R flip-flops.(b) D-CE flip-flops.
12.29 A two-stage counter has two input control lines, Mand N. The count sequences are
as follows:
MN Sequence
0 0 0 ,  1 ,  2 ,  3 ,  0 ,   ....
0 1 0 ,  1 ,  0 ,  1 ,  0 ,  1 ,...
1 0 2 ,  0 ,  2 ,  0 ,  2 ,  0 ,...
1 1 1 ,  2 ,  1 ,  2 ,  1 ,  2 ,...
(a) Design the counter assuming the outputs come directly from J-K flip-flops.
(b) Design the counter assuming a two-stage binary counter is used with the J-K
flip-flop outputs decoded.
12.30 A pulse-generating circuit generates eight repetitive pulses as shown in the figure.
Implement the pulse-generating circuit using the counter circuits listed and a mini-mum of gate logic. Use J-K flip-flops for the counters that trigger on the falling edgeof a clock that has a frequency eight times the frequency of one of the pulses. Thepulses must be free of glitches; explain any restrictions on the propagation delays ofgates and flip-flops so that the pulses will be glitch free.(a) Ring counter (A ring counter is a shift register with end-to-end feedback.)Clk
Gate LogicN-Bit Shift Register Sin
N
(b) Johnson counter
(c) Binary counter
12.31 A U-V flip-flop behaves as follows:
IfUV/H1100500, the flip-flop does not change state.
IfUV/H1100510, the flip-flop is set to Q/H110050.
IfUV/H1100511, the flip-flop changes state.
The input combination UV/H1100501 is not allowed.
(a) Give the characteristic (next-state) equation for this flip-flop.(b) Complete the following table, using don’t-cares where possible.
QQ/H11001UV
00
01
10
11
(c) Realize the following next-state equation for Qusing a U-V flip-flop:
Q/H11001/H11005A/H11001BQ. Find equations for Uand V.
12.32 A M-F flip-flop behaves as follows:
IfMF/H1100501, the flip-flop changes state.
IfMF/H1100511, the flip-flop is set to Q/H110050.
IfMF/H1100500, the flip-flop is set to Q/H110051.
The input combination MF/H1100510 is not allowed.
(a) Give the characteristic (next-state) equation for this flip-flop.(b) Complete the table, using don’t-cares where possible.
QQ/H11001MF
00
01
10
11T0
T1
T2
T3
T4
T5
T6
T7384 Unit 12
(c) Realize the following next-state equation for Qusing a MF flip-flop:
Q/H11001/H11005CQ/H11001DQ/H11032. Find equations for MandF.
12.33 An L-M flip-flop works as follows:
IfLM /H1100500, the next state of the flip-flop is 1.
IfLM /H1100501, the next state of the flip-flop is the same as the present state.
IfLM /H1100510, the next state of the flip-flop is the complement of the present state.
IfLM /H1100511, the next state of the flip-flop is 0.
(a) Complete the following table (use don’t-cares when possible):
(b) Using this table and Karnaugh maps, derive and minimize the input equations for
a counter composed of three L-M flip-flops which counts in the following sequence:
ABC /H11005000, 100, 101, 111, 011, 001, 000, . . .
12.34 A sequential circuit contains a register of four flip-flops. Initially a binary number
N(0000 /H11349N/H113491100) is stored in the flip-flops. After a single clock pulse is
applied to the circuit, the register should contain N/H110010011. In other words, the
function of the sequential circuit is to add 3 to the contents of a 4-bit register.Design the circuit using J-K flip-flops.
12.35 When an adder is part of a larger digital system, an arrangement like the given fig-
ure often works well. For the control signals and the input data in the followingtable, give the value of the addend, the accumulator, and the bus at the end of eachclock cycle (i.e., immediately before the active clock edge). Express the register andbus values in decimal.
Accumulator
Register8-Bit
Adder
CE LdAc Addend
RegisterCE LdAd88
888 88
EnAd
88
EnIn
Input
DataBusRegisters and Counters 385
Present State Next State
QQ/H11001LM
00
011011
12.36 A digital system can perform any 4-variable bitwise logic function, but it may take
several clock cycles. (A bitwise logic function performs the same logic function oneach bit.) Recall that the NAND operation is functionally complete, i.e., we can doany logic function by a series of NAND operations. On the following 8-bit registers,En is a tri-state buffer enable as in Figure 12-3, and CE is a clock enable as inFigure 12-1.
(a) Show how to connect a 2-to-4 decoder (with inverting outputs) so that the next
rising edge of the clock will load the result into register A,B,C, or Dfor con-
trol inputs G
0G1/H1100500, 01, 10, or 11, respectively.
(b) Show how to connect three control signals, E0,E1, and E2, to the registers so that
E0/H110050 places the Aregister contents on the Xbus,E0/H110051 places Bonto the Xbus,
E1E2/H1100500 places Conto the Ybus,E1E2/H1100501 places Donto the Ybus,E1E2/H1100510
places 00000000 on the Ybus, and E1E2/H1100511 places 11111111 on the Ybus. You
may use a few additional gates. ( Hint : Connect E2to all 8 data inputs on the tri-
state buffer on the right side of the circuit.)
(c) Show how to make the bits in the Cregister be the OR of the corresponding bits in
theAregister and in the Dregister, in four clock cycles.Tell what G0,G1,E0,E1, and
E2should be for each cycle. [ Hint: Use DeMorgan’s law and X/H11032/H11005(XNAND 1).]
12.37 Show how to make the shift register of Figure 12-10 reverse the order of its bits,
i.e.,Q3/H11001/H11005Q0,Q2/H11001/H11005Q1,Q1/H11001/H11005Q2, and Q0/H11001/H11005Q3.
(a) Use external connections between the Qoutputs and the Dinputs.What should
the values of Shand Lbe for a reversal?CE
En A
CK8 8
8 8
88 8
CE
En B
CKCE8 NAND Gates
EnRX Y
C
CKCE
En D
CK88386 Unit 12
Clock Input Accumulator Addend
Cycle Data EnIn EnAd LdAc LdAd Register Register Bus
01 8 1 0 1 0 0 0 1 8
11 3 1 0 0 1
21 5 0 1 1 039 3 1 0 0 144 7 0 1 1 052 2 1 0 0 1
60 0100
(b) Change the internal circuitry to allow bit reversal, so that the Dinputs may be
used for other purposes. Replace Shand Lwith Aand B, and let the register
operate according to the following table:Registers and Counters 387
Inputs Next State
AB Q3/H11001Q2/H11001Q1/H11001Q0/H11001Action
00 Q3Q2Q1Q0 No change
01 S I Q3Q2Q1 Right shift
10 D3D2D1D0 Load
11 Q0Q1Q2Q3 Reverse bits
388CHAPTER
00Analysis of Clocked 
Sequential Circuits
Objectives
1.Analyze a sequential circuit by signal tracing.
2.Given a sequential circuit, write the next-state equations for the flip-flops
and derive the state graph or state table. Using the state graph, deter-mine the state sequence and output sequence for a given input sequence.
3.Explain the difference between a Mealy machine and a Moore machine.
4.Given a state table, construct the corresponding state graph, and
conversely.
5.Given a sequential circuit or a state table and an input sequence, draw a
timing chart for the circuit. Determine the output sequence from the
timing chart, neglecting any false outputs.
6.Draw a general model for a clocked Mealy or Moore sequential circuit.
Explain the operation of the circuit in terms of these models. Explain whya clock is needed to ensure proper operation of the circuit.
UNIT
13
Analysis of Clocked Sequential Circuits 389
1.Study Section 13.1, A Sequential Parity Checker .
(a) Explain how parity can be used for error detection.
(b) Verify that the parity checker (Figure 13-4) will produce the output wave-
form given in Figure 13-2 when the input waveform is as shown.
2.Study Section 13.2, Analysis by Signal Tracing and Timing Charts .
(a) What is the difference between a Mealy machine and a Moore machine?
(b) For normal operation of clocked sequential circuits of the types discussed
in this section, when should the inputs be changed?
When do the flip-flops change state?At what times can the output change for a Moore circuit?At what times can the output change for a Mealy circuit?
(c) At what time (with respect to the clock) should the output of a Mealy cir-
cuit be read?
(d) Why can false outputs appear in a Mealy circuit and not in a Moore circuit?
What can be done to eliminate the false outputs?
If the output of a Mealy circuit is used as an input to another Mealy circuit syn-
chronized by the same clock, will false outputs cause any problem? Explain.
(e) Examine the timing diagram of Figure 13-8.The value of Zwill always be cor-
rect just before the falling (active) clock edge that causes the state change.Note there are two types of false outputs. A false 0 output occurs if Zis 1 just
before two successive falling clock edges, and Zgoes to 0 between the clock
edges. A false 1 output occurs if Zis 0 just before two successive falling clock
edges and Zgoes to 1 between the edges. When the output is 0 (or 1) just
before an active clock edge and 1 (or 0) just before the next, the output mayStudy Guide
390 Unit 13
be temporarily incorrect after the state changes following the first active edge
but before the input has changed to its next value. In this case, we will not saythat a false output has occurred because the sequence of outputs is still correct.
3.Study Section 13.3, State Tables and Graph s.
(a) In Equations (13-1) through (13-5), at what time (with respect to the
clock) is the right-hand side evaluated?
What does Q
/H11001mean?
(b) Derive the timing chart of Figure 13-6 using Table 13-2(a).
(c) What is the difference between the state graphs for Mealy and Moore
machines?
(d) For a state table,Table 13-3(b) for example, what do the terms “ present state,”
“next state,” and “ present output” mean with respect to the active clock edge?
(e) Why does a Moore state table have only one output column?
(f) For ease in making state tables from Karnaugh maps and vice versa, state
transition tables with three or four states are often written with states in theorder 00, 01, 11, 10. However, this is not necessary. (In fact, for sequential cir-cuits with five or more states, it is impossible.) For example, the following tableis equivalent to Table 13-2, because it represents the circuit of Figure 13-5.
A/H11001B/H11001
AB X /H110050X/H110051 Z
00 10 01 0
01 00 11 110 11 01 111 01 11 0
4.The following timing chart was derived from the circuit of Figure 13-7.
Clock
X
A
B
Z
Zd
Analysis of Clocked Sequential Circuits 391
(a) Noting that extra input changes which occur between clock pulses cannot
affect the state of the circuit, what is the effective input sequence seen bythe flip-flops in the circuit?
(b) Using Table 13-3, verify the waveforms given for A,B, and Z.
(c) Indicate any false outputs. What is the correct output sequence from the
circuit?
(d) Using the effective input sequence from (a), determine the output sequence
from the state graph (Figure 13-11). This output sequence should be thesame as your answer to (c).
(e) The output Zis fed into a clocked D flip-flop, using the same clock (CK)
as the circuit. Sketch the waveform for Z
d. Does Zdhave any false outputs?
(f) Starting with Figure 13-11, construct the corresponding state table. Verify
that your answer is the same as Table 13-3(b). Note that the output labelon a given arrow of the graph is associated with the state from which thearrow originates.
(g) Assume that the flip-flops in Figure 13-7 are changed to flip-flops which trig-
ger on the rising edge of the clock; that is, the inversion circles are removedfrom the clock inputs.Also, the clock waveform in Figure 13-8 is replaced with
The input waveform is left unchanged. What changes, if any, would occur
in the remainder of the timing diagram? Explain.
5.Consider the following state tables:ClockD
Clock CK Q′Q Zd Z
Mealy
N.S. Z
P.S. X/H1100501 X/H1100501
S0 S1S0 00
S1 S0S2 10
S2 S0S0 10Moore
N.S.
P.S. X/H1100501 Z
S0 S1S0 0
S1 S3S2 0
S2 S3S0 0
S3 S3S0 1
(a) Draw the corresponding state graphs.
(b) Show that the same output sequence is obtained from both state graphs when
the input sequence is 010 (ignore the initial output for the Moore circuit).
(c) Using the state tables, complete the following timing diagrams for the two
circuits. Note that the Mealy circuit has a false output, but the Moore doesnot. Also note that the output from the Moore circuit is delayed withrespect to the Mealy.
(d) Work Programmed Exercise 13.1.
(e) Work Problems 13.2 and 13.3.
6.Study Section 13.4, General Models for Sequential Circuits .
(a) A Mealy sequential circuit has the form shown. The combinational circuit
realizes the following equations:
Q
1/H11001/H11005X1/H11032Q1/H11001X1Q1/H11032Q2/H11032 Z1/H11005X1Q1
Q2/H11001/H11005X1Q2/H11032/H11001X2/H11032Q1 Z2/H11005X1/H11032Q1/H11001X2Q2/H11032
D
ClockCombinational
CircuitD
Q2Q1Z1
Z2X1
X2
Q1+
Q2+ClockMeal y
010
01StateX
S0 S1 S2S0
ZMoore
010X
S0
Z392 Unit 13
Analysis of Clocked Sequential Circuits 393
Initially, X1/H11005X2/H110051 and Q1/H11005Q2/H110050 as shown.
(1) Before the falling clock edge, show the values of the four combinational
circuit outputs on the preceding diagram and on the following timingchart.
(2) Show the signal values on the circuit and timing chart immediately after the
falling edge.
(3) Show any further changes in signal values which will occur after the new
values of Q
1and Q2have propagated through the circuit.
(4) Next change X1to 0 and repeat steps (1), (2), and (3). Show the values for
each step on the circuit and on the timing chart.
(5) Next change the inputs to X1/H110051 and X2/H110050 and repeat steps (1), (2),
and (3).
(6) Change X2to 1 and repeat.
(b) Draw a block diagram for a general model of a Mealy circuit, using
J-K flip-flops as memory elements. If the circuit has noutput variables and
kflip-flops, how many outputs will the combinational subcircuit have?
(c) If the circuit of Figure 13-5 were not synchronized using a clock, but
instead, the flip-flops were updated continuously, and if the XOR gate hada longer delay than the OR gate, what problem could appear?
(d) The minimum clock period for a Moore circuit is determined the same
way as for a Mealy circuit. Should t
cbe determined by the combinational
subcircuit for the flip-flop inputs or for the outputs? (See Figure 13-19.)
(e) We can think of the binary counter of Figure 12-15 as a Moore circuit if we
say the outputs Z1,Z2, and Z3areZ1/H11005A,Z2/H11005B, and Z3/H11005C. (The combi-
national subcircuit for outputs has no gates, but that is okay.) If the XORgates have a propagation delay of 4 ns and the AND gate has a propagationClock
X1
X2
Q1
Q2
Z1
Z2
delay of 2 ns, what is the longest total propagation delay through the combi-
national subcircuit for flip-flops (i.e., the XOR gates and the AND gate) totheDinputs of the flip-flops? If the flip-flops have t
su/H110053 ns and tp/H110053n s ,
what is the minimum clock period for the binary counter?
(f) In Equations (13-6) and (13-7), what do the symbols /H9254and /H9261mean?
Equation (13-7) is for a Mealy circuit. What is the corresponding equation
for a Moore circuit?
(g) For Table 13-5,
/H9254(S3,1 )/H11005____________ /H9261(S3,1 )/H11005____________
/H9254(S1,2 )/H11005____________ /H9261(S1,2 )/H11005____________
7.Work Problems 13.4 through 13.6.
8.When you are satisfied that you can meet the objectives, take the readiness test.394 Unit 13
The sequential circuits which we discussed in Chapter 12 perform simple functions
such as shifting or counting. The counters we designed go through a fixed sequenceof states and have no inputs other than a clock pulse that causes the state to change.We will now consider sequential circuits that have additional inputs. In general, the
sequence of outputs and the sequence of flip-flop states for such circuits will
depend on the input sequence which is ap plied to the circuit. Given a sequential cir-
cuit and an input sequence, we can anal yze the circuit to determine the flip-flop state
sequence and the output sequence by tracing the 0 and 1 signals through the circuit.
Although signal tracing may be adequate for small circuits, for larger circuits it is
Analysis of Clocked 
Sequential Circuits
Analysis of Clocked Sequential Circuits 395
better to construct a state graph or state table which represents the behavior of the
circuit. Then, we can determine the output and state sequences from the graph ortable. Such graphs and tables are also useful for the design of sequential circuits.
In this chapter we will also study the timing relationships between the inputs, the
clock, and the outputs for sequential circuits by constructing timing diagrams. Thesetiming relationships are very important when a sequential circuit is used as part ofa larger digital system. After analyzing several specific sequential circuits, we willdiscuss a general model for a sequential circuit which consists of a combinationalcircuit together with flip-flops that serve as memory.
13.1 A Sequential Parity Checker
When binary data is transmitted or stored, an extra bit (called a parity bit) is frequentlyadded for purposes of error detection. For example, if data is being transmitted ingroups of 7 bits, an eighth bit can be added to each group of 7 bits to make the totalnumber of 1’s in each block of 8 bits an odd number.When the total number of 1 bits inthe block (including the parity bit) is odd, we say that the parity is odd. Alternately, theparity bit could be chosen such that the total number of 1’s in the block is even, in whichcase we would have even parity. Some examples of 8-bit words with odd parity are
If any single bit in the 8-bit word is changed from 0 to 1 or from 1 to 0, the parity is
no longer odd.Thus, if any single bit error occurs in transmission of a word with oddparity, the presence of this error can be detected because the number of 1 bits in theword has been changed from odd to even.
As a simple example of a sequential circuit which has one input in addition to
the clock, we will design a parity checker for serial data. (Serial implies that the dataenters the circuit sequentially, one bit at a time.) This circuit has the form shown inFigure 13-1. When a sequence of 0’s and 1’s is applied to the Xinput, the output of00000001
00000010
01101101
1010101101110000
8-Bit Word7 Data Bits Parit y Bits
Parit y
CheckerZ
ClockX
(Data Input)FIGURE 13-1
Block Diagram
for Parity Checker
the circuit should be Z/H110051 if the total number of 1 inputs received is odd; that is,
the output should be 1 if the input parity is odd. Thus, if data which originally hadodd parity is transmitted to the circuit, a final output of Z/H110050 indicates that an error
in transmission has occurred.
The value of Xis read at the time of the active clock edge. The Xinput must be
synchronized with the clock so that it assumes its next value before the next active clockedge. The clock input is necessary in order to distinguish consecutive 0’s or consecutive1’s on the Xinput. Typical input and output waveforms are shown in Figure 13-2.
We will start the design by constructing a state graph (Figure 13-3). The sequen-
tial circuit must “remember” whether the total number of 1 inputs received is evenor odd; therefore, only two states are required. We will designate these states as S
0
and S1, corresponding respectively to an even number of 1’s received and an odd
number of 1’s received. We will start the circuit in state S0because initially zero 1’s
have been received, and zero is an even number. As indicated in Figure 13-3, if thecircuit is in state S
0(even number of 1’s received) and X/H110050 is received, the circuit
must stay in S0because the number of 1’s received is still even. However, if X/H110051 is
received, the circuit goes to state S1because the number of 1’s received is then odd.
Similarly, if the circuit is in state S1(odd number of 1’s received) a 0 input causes no
state change, but a 1 causes a change to S0because the number of 1’s received is then
even. The output Zshould be 1 whenever the circuit is in state S1(odd number of
1’s received). The output is listed below the state on the state graph.
Table 13-1(a) gives the same information as the state graph in tabular form. For
example, the table shows that if the present state is S0, the output is Z/H110050, and if the
input is X/H110051, the next state will be S1.
Because only two states are required, a single flip-flop ( Q) will suffice. We will
letQ/H110050 correspond to state S0and Q/H110051 correspond to S1. We can then set up a
table which shows the next state of flip-flop Qas a function of the present state and
X. If we use a T flip-flop, Tmust be 1 whenever QandQ/H11001differ. From Table 13-1(b),
theTinput must be 1 whenever X/H110051. Figure 13-4 shows the resulting circuit.
Figure 13-2 shows the output waveform for the circuit. When X/H110051, the flip-flop
changes state after the falling edge of the clock. Note that the final value of Zis 0
because an even number of 1’s was received. If the number of 1’s received had been odd,396 Unit 13
Clock11 1 1 00 0 0X
Z = QFIGURE 13-2
Waveforms for
Parity Checker
S0
Z = 0X = 1
X = 1S1
Z = 1X = 0 X = 0FIGURE 13-3
State Graph for
Parity Checker
Analysis of Clocked Sequential Circuits 397
ClockCKQ′ Q
TZ
XFIGURE 13-4
Parity Checker(a)
Present Next State Present
State X/H110050X/H110051 Output
S0 S0 S1 0
S1 S1 S0 1(b)
Q+T
QX /H110050X/H110051 X/H110050X/H110051 Z
00 1 0 1 0
11 0 0 1 1TABLE 13-1
State Table for
Parity Checker
the final value of Zwould be l. In this case, it would be necessary to reset the flip-flop
to the proper initial state ( Q/H110050) before checking the parity of another input sequence.
13.2 Analysis by Signal Tracing
and Timing Charts
In this section we will analyze clocked sequential circuits to find the output
sequence resulting from a given input sequence by tracing 0 and 1 signals throughthe circuit. The basic procedure is as follows:
1.Assume an initial state of the flip-flops (all flip-flops reset to 0 unless otherwise
specified).
2.For the first input in the given sequence, determine the circuit output(s) and
flip-flop inputs.
3.Determine the new set of flip-flop states after the next active clock edge.
4.Determine the output(s) that corresponds to the new states.
5.Repeat 2, 3, and 4 for each input in the given sequence.
As we carry out the analysis, we will construct a timing chart which shows the
relationship between the input signal, the clock, the flip-flop states, and the circuitoutput. We have already seen how to construct timing charts for flip-flops (Unit 11)and counters (Unit 12).
In this unit we will use edge-triggered flip-flops that change state shortly after
the active edge (rising or falling edge) of the clock. We will assume that the flip-flopinputs are stable a sufficient time before and after the active clock edge so thatsetup and hold time requirements are met. When the state of the sequential circuitchanges, the change will always occur in response to the active clock edge. The cir-cuit output may change at the time the flip-flops change state or at the time theinput changes depending on the type of circuit.
Two types of clocked sequential circuits will be considered—those in which the out-
put depends only on the present state of the flip-flops and those in which the outputdepends on both the present state of the flip-flops and on the value of the circuit inputs.If the output of a sequential circuit is a function of the present state only (as in Figures13-4 and 13-5), the circuit is often referred to as a Moore machine . The state graph for
a Moore machine has the output associated with the state (as in Figures 13-3 and 13-9).If the output is a function of both the present state and the input (as in Figure 13-7),the circuit is referred to as a Mealy machine . The state graph for a Mealy machine has
the output associated with the arrow going between states (as in Figure 13-11).
As an example of a Moore circuit, we will analyze Figure 13-5 using an input
sequence X/H1100501101. In this circuit, the initial state is A/H11005B/H110050, and all state changes
occur after the rising edge of the clock, as shown in Figure 13-6.The Xinput is synchro-
nized with the clock so that it assumes its next value after each rising edge. Because Z
is a function only of the present state (in this case, Z/H11005A⊕B) the output will only
change when the state changes. Initially, X/H110050, so D
A/H110051 and DB/H110050, and the state will
change to A/H110051 and B/H110050 after the first rising clock edge. Then Xis changed to 1, so
DA/H110050,DB/H110051 and the state changes to AB/H1100501 after the second rising clock edge.
After the state change, Xremains 1, so DA/H11005DB/H110051, and the next rising edge causes
the state to change to 11. When Xchanges to 0, DA/H110050 and DB/H110051, and the state
changes to AB/H1100501 on the fourth rising edge. Then, with X/H110051,DA/H11005DB/H110051, so the398 Unit 13
ClockA′ A
DAZ
XX A B′ClockB′ B
DBFIGURE 13-5
Moore Sequential
Circuit to be
Analyzed
(0) 1 1 0 1 0ClockX
A
B
ZFIGURE 13-6
Timing Chart for
Figure 13-5
Analysis of Clocked Sequential Circuits 399
fifth rising clock edge causes the state to change to AB/H1100511. The input, state, and out-
put sequences are plotted on the timing chart of Figure 13-6 and are also listed below.
X/H11005 01 1 0 1
A/H11005 01 0 1 0 1
B/H11005 00 1 1 1 1
Z/H11005(0) 1 1 0 1 0
When the circuit is reset to its initial state ( A/H11005B/H110050), the initial output is Z/H110050.
Because this initial 0 is not in response to any Xinput, it should be ignored. The
resulting output sequence is Z/H1100511010. Note that for the Moore circuit, the output
which results from application of a given input does not appear until after the activeclock edge; therefore, the output sequence is displaced in time with respect to theinput sequence.
As an example of a Mealy circuit, we will analyze Figure 13-7 and construct a
timing chart using the input sequence X/H1100510101.The input is synchronized with the
clock so that input changes occur after the falling edge, as shown in Figure 13-8. Inthis example, the output depends on both the input ( X) and the flip-flop states ( A
and B), so Zmay change either when the input changes or when the flip-flops
change state. Initially, assume that the flip-flop states are A/H110050,B/H110050. If X/H110051, the
output is Z/H110051 and J
B/H11005KA/H110051. After the falling edge of the first clock pulse, B
changes to 1 so Zchanges to 0. If the input is changed to X/H110050,Zwill change back
to 1. All flip-flop inputs are then 0, so no state change occurs with the second fallingedge. When Xis changed to 1, Zbecomes 0 and J
A/H11005KA/H11005JB/H110051.Achanges to 1
on the third falling clock edge, at which time Zchanges to 1. Next, Xis changed to
0 so Zbecomes 0, and no state change occurs with the fourth clock pulse. Then, Xis
changed to 1, and Zbecomes 1. Because JA/H11005KA/H11005JB/H11005KB/H110051, the fifth clock
pulse returns the circuit to the initial state. The input, state, and output sequencesare plotted on the timing chart of Figure 13-8 and are also listed below
X/H1100510 1 01
A/H1100500 0 11 0
B/H1100501 1 11 0
Z/H110051(0) 1 0(1) 0 1 (False outputs are indicated in parentheses.)
ClockA′ A
JA KA
Z
X
X BCK
ClockB′ B
JB KB
XX
B′
X
A
X′
A′
B
X ACKFIGURE 13-7
Mealy Sequential
Circuit to be
Analyzed
A careful interpretation of the output waveform ( Z) of the Mealy circuit is
necessary. After the circuit has changed state and before the input is changed, theoutput may temporarily assume an incorrect value, which we call a false output.
As indicated on the timing chart, this false value arises when the circuit hasassumed a new state but the old input associated with the previous state is stillpresent.
For a clocked sequential circuit, the value of the input immediately preced-
ing the active clock edge determines the next state of the flip-flops. Extra inputchanges which might occur between active clock edges do not affect the stateof the flip-flops. In a similar manner, the output from a Mealy circuit is only ofinterest immediately preceding the active clock edge, and extra output changes(false outputs) which might occur between active clock edges should beignored.
Two types of false outputs can occur, as indicated in Figure 13-8. In one case
the output Zmomentarily goes to 0 and returns to 1 before the active clock
edge. In the other case the output Zmomentarily goes to 1 and returns to 0
before the active edge. These false outputs are often referred to as glitches and
spikes . In both cases, two changes of output occur when no change is expected.
Ignoring the false outputs by reading the output just before the falling clockedge, the output sequence for the circuit is Z/H1100511001. If circuit delays are neg-
ligible, the false outputs could be eliminated if the input Xwas allowed to
change only at the same time as the falling edge of the clock. If the output ofthe circuit is fed into a second sequential circuit which uses the same clock, thefalse outputs will not cause any problem because the inputs to the second cir-cuit can cause a change of state only when a falling clock edge occurs. Becausethe output of a Moore circuit can change state only when the flip-flops changestate and not when the input changes, no false outputs can appear in a Moorecircuit.
For the Mealy circuit, the output which corresponds to a given input appears
shortly after the application of that input. Because the correct output appears
before the active clock edge, the output sequence is notdisplaced in time with
respect to the input sequence as was the case for the Moore circuit.400 Unit 13
11
"False" 1 output "False" 0 output10 001 11 0
ClockX
A
B
ZFIGURE 13-8
Timing Chart
for Circuit of
Figure 13-7
Analysis of Clocked Sequential Circuits 401
13.3 State Tables and Graphs
In the previous section we analyzed clocked sequential circuits by signal tracing and
the construction of timing charts. Although this is satisfactory for small circuits andshort input sequences, the construction of state tables and graphs provides a moresystematic approach which is useful for the analysis of larger circuits and whichleads to a general synthesis procedure for sequential circuits.
The state table specifies the next state and output of a sequential circuit in terms of
its present state and input.The following method can be used to construct the state table:
1.Determine the flip-flop input equations and the output equations from the circuit.
2.Derive the next-state equation for each flip-flop from its input equations, using
one of the following relations:
D flip-flop Q
/H11001/H11005D (13-1)
D-CE flip-flop Q/H11001/H11005D/H11080CE/H11001Q/H11080CE/H11032 (13-2)
T flip-flop Q/H11001/H11005T⊕Q (13-3)
S-R flip-flop Q/H11001/H11005S/H11001R/H11032Q (13-4)
J-K flip-flop Q/H11001/H11005JQ/H11032/H11001K/H11032Q (13-5)
3.Plot a next-state map for each flip-flop.
4.Combine these maps to form the state table. Such a state table, which gives the
next state of the flip-flops as a function of their present state and the circuitinputs, is frequently referred to as a transition table.
As an example of this procedure, we will derive the state table for the circuit of
Figure 13-5:
1.The flip-flop input equations and output equation are
D
A/H11005X⊕B/H11032DB/H11005X/H11001AZ /H11005A⊕B
2.The next-state equations for the flip-flops are
A/H11001/H11005X⊕B/H11032B/H11001/H11005X/H11001A
3.The corresponding maps are
1001
01
01100AB
A+X
01
1110 00101
01
11100AB
B
+X
01
1110 1
4.Combining these maps yields the transition table in Table 13-2(a), which gives the
next state of both flip-flops ( A/H11001B/H11001) as a function of the present state and input.
The output function Zis then added to the table. In this example, the output
depends only on the present state of the flip-flops and not on the input, so only asingle output column is required.
Using Table 13-2(a), we can construct the timing chart of Figure 13-6 or any
other timing chart for some given input sequence and specified initial state.Initially AB/H1100500 and X/H110050, so Z/H110050 and A
/H11001B/H11001/H1100510. This means that after the
rising clock edge, the flip-flop state will be AB/H1100510.Then, with AB/H1100510, the out-
put is Z/H110051. The next input is X/H110051, so A/H11001B/H11001/H1100501 and the state will change
after the next rising clock edge. Continuing in this manner, we can complete thetiming chart.
If we are not interested in the individual flip-flop states, we can replace each
combination of flip-flop states with a single symbol which represents the state of thecircuit. Replacing 00 with S
0, 01 with S1, 11 with S2, and 10 with S3in Table 13-2(a)
yields Table 13-2(b). The Zcolumn is labeled Present Output because it is the out-
put associated with the Present State. The state graph of Figure 13-9 representsTable 13-2(b). Each node of the graph represents a state of the circuit, and the cor-responding output is placed in the circle below the state symbol.The arc joining twonodes is labeled with the value of Xwhich will cause a state change between these
nodes. Thus, if the circuit is in state S
0andX/H110051, a clock edge will cause a transition
to state S1.402 Unit 13
11
0 00
0
1
1S0
0
S1
1
S2
0S3
1FIGURE 13-9
Moore State
Graph for 
Figure 13-5(a)
A/H11001B/H11001
AB X /H110050X/H110051 Z
00 10 01 0
01 00 11 111 01 11 0
10 11 01 1TABLE 13-2
Moore State
Tables for 
Figure 13-5(b)
Present Next State Present
State X/H110050X/H110051 Output ( Z)
S0 S3 S1 0
S1 S0 S2 1
S2 S1 S2 0
S3 S2 S1 1
Analysis of Clocked Sequential Circuits 403
0001
01
10100AB
A+X
01
1110 00101
11
10000AB
B
+X
01
1110 10101
10
01000AB
ZX
01
1110 1FIGURE 13-10Next, we will construct the state table and graph for the Mealy machine of Figure
13-7. The next-state and output equations are
A/H11001/H11005JAA/H11032/H11001K/H11032AA/H11005XBA /H11032/H11001X/H11032A
B/H11001/H11005JBB/H11032/H11001K/H11032BB/H11005XB/H11032/H11001(AX)/H11032B/H11005XB/H11032/H11001X/H11032B/H11001A/H11032B
Z/H11005X/H11032A/H11032B/H11001XB/H11032/H11001XA
The next-state and output maps (Figure 13-10) combine to form the transition table
in Table 13-3(a). Given values for A,B, and X, the current value of the output is
determined from the Zcolumn of this table, and the states of the flip-flops after the
active clock edge are determined from the A/H11001B/H11001columns.
We can construct the timing chart of Figure 13-8 using Table 13-3(a). Initially
with A/H11005B/H110050 and X/H110051, the table shows that Z/H110051 and A/H11001B/H11001/H1100501. Therefore,
after the falling clock edge, the state of flip-flop Bwill change to 1, as indicated in
Figure 13-8. Now, from the 01 row of the table, if Xis still 1, the output will be 0 until
the input is changed to X/H110050. Then, the output is Z/H110051, and the next falling clock
edge produces no state change. Finish stepping through the state table in this man-ner and verify that A,B, and Zare as given in Figure 13-8.
If we let AB/H1100500 correspond to circuit state S
0, 01 to S1, 11 to S2, and 10 to S3,w e
can construct the state table in Table 13-3(b) and the state graph of Figure 13-11. InTable 13-3(b), the Present Output column gives the output associated with the pres-ent state and present input. Thus, if the present state is S
0and the input changes
from 0 to 1, the output will immediately change from 0 to 1. However, the state willnot change to the next state ( S
1) until after the clock pulse. For Figure 13-11, the
(a)
A/H11001B/H11001Z
AB X /H1100501 X/H1100501
00 00 01 0 1
01 01 11 1 011 11 00 0 1
10 10 01 0 1(b)
Present
Present Next State Output
State X/H1100501 X/H1100501
S0 S0S1 01
S1 S1S2 10
S2 S2S0 01
S3 S3S1 01TABLE 13-3
Mealy State
Tables for 
Figure 13-7
labels on the arrows between states are of the form X/Z, where the symbol before
the slash is the input and the symbol after the slash is the corresponding output.Thus, in state S
0an input of 0 gives an output of 0, and an input of 1 gives an output
of 1. For any given input sequence, we can easily trace out the state and outputsequences on the state graph. For the input sequence X/H1100510101, verify that the cor-
responding output sequence is 11001. This agrees with Figure 13-8 if the false out-puts are ignored. Note that the false outputs do not show on the state graph becausethe inputs are read at the active clock edge, and no provision is made for extra inputchanges between active edges.
Next, we will analyze the operation of a serial adder [Figure 13-12(a)] that
adds two n-bit binary numbers X/H11005x
n/H110021...x1x0and Y/H11005yn/H110021...y1y0. The oper-
ation of the serial adder is similar to the parallel adder of Figure 4-2 except thatthe binary numbers are fed in serially, one pair of bits at a time, and the sum isread out serially, one bit at a time. First, x
0and y0are fed in; a sum digit s0is gen-
erated, and the carry c1is stored. At the next clock time, x1and y1are fed in and
added to c1to give the next sum digit s1and the new carry c2, which is stored.
This process continues until all bits have been added. A full adder is used to addthex
i,yi, and cibits to form ci/H110011and si. A D flip-flop is used to store the carry
(ci/H110011) on the rising edge of the clock. The xiand yiinputs must be synchronized
with the clock.
Figure 13-13 shows a timing diagram for the serial adder. In this example we add
10011 /H1100100110 to give a sum of 11001 and a final carry of 0. Initially the carry flip-flop
must be cleared so that c0/H110050.We start by adding the least-significant (rightmost) bits
in each word. Adding 1 /H110010/H110010 gives s0/H110051 and c1/H110050, which is stored in the flip-flop404 Unit 13
Cloc k CK Q′Q Dxi
yi
cisi
ci + 1
(a) With D flip-flopFull
AdderFIGURE 13-12
Serial Adderxiyici ci/H11001 1si
000 0 0
001 0 1
010 0 1011 1 0100 0 1101 1 0
110 1 0
111 1 1
(b) Truth tableS0
S3 S1 S2
0
01
01
11
10
0
1
1 0
0
0
1FIGURE 13-11
Mealy State
Graph for 
Figure 13-7
Analysis of Clocked Sequential Circuits 405
11 1 00Clock
xi
yi
ci
ci + 1
siFIGURE 13-13
Timing Diagram
for Serial Adder
xiyisi00
001
110
111
0
00
1,, 01
010
011
1,,
S0 S1FIGURE 13-14
State Graph for
Serial Adder
Present Next State Present Output ( Z1Z2)
State X1X2/H1100500 01 10 11 X1X2/H1100500 01 10 11
S0 S3S2S1S0 00 10 11 01
S1 S0S1S2S3 10 10 11 11
S2 S3S0S1S1 00 10 11 01
S3 S2S2S1S0 00 00 01 01TABLE 13-4
A State Table with
Multiple Inputs
and Outputsat the rising clock edge. Because y1is 1, adding 1 /H110011/H110010 gives s1/H110050 and c2/H110051, which
is stored in the flip-flop on the rising clock edge.This process continues until the addi-tion is completed. Reading the sum output just before the rising edge of the clockgives the correct result.
The truth table for the full adder (Table 4-4) is repeated in Figure 13-12(b) in
modified form. Using this table, we can construct a state graph (Figure 13-14) for theserial adder. The serial adder is a Mealy machine with inputs x
iandyiand output si.
The two states represent a carry ( ci) of 0 and 1, respectively. From the table, ciis the
present state of the sequential circuit, and ci/H110011is the next state. If we start in S0(no
carry), and xiyi/H1100511, the output is si/H110050 and the next state is S1. This is indicated by
the arrow going from state S0toS1.
Table 13-4 shows a state table for a Mealy sequential circuit with two inputs
and two outputs. Figure 13-15 shows the corresponding state graph. The notation00, 01/00 on the arc from S
3toS2means if X1/H11005X2/H110050 or X1/H110050 and X2/H110051, then
Z1/H110050 and Z2/H110050.
Construction and Interpretation of Timing Charts
Several important points concerning the construction and interpretation of timing
charts are summarized as follows:
1.When constructing timing charts, note that a state change can only occur after
the rising (or falling) edge of the clock, depending on the type of flip-flopused.
2.The input will normally be stable immediately before and after the active
clock edge.
3.For a Moore circuit, the output can change only when the state changes, but for
a Mealy circuit, the output can change when the input changes as well as whenthe state changes. A false output may occur between the time the state changesand the time the input is changed to its new value. (In other words, if the statehas changed to its next value, but the old input is still present, the output maybe temporarily incorrect.)
4.False outputs are difficult to determine from the state graph, so use either sig-
nal tracing through the circuit or use the state table when constructing timingcharts for Mealy circuits.
5.When using a Mealy state table for constructing timing charts, the procedure is
as follows:(a) For the first input, read the present output and plot it.(b) Read the next state and plot it (following the active edge of the clock pulse).406 Unit 13
00
1010
1101
10
01
1011
1111
0111
01
00
00
10
01
00
0001
10 10
11
10
1111
0100, 01
00,S0
S1
S2S3FIGURE 13-15
State Graph for
Table 13-4
Analysis of Clocked Sequential Circuits 407
S1 S0
Clock
State, Q
X
Z
AS0 S1 S1ZXAA
B B F FA
EDD
E
B CD
Read X and Z in shaded area
(before rising edge of clock).Inital values
are shown.
E F0
10
0Q
DCK
Q′ 110/1
1/1
0/0 0 1QX  = 0 1 1 0
00 S0 S1 S1
1 S1 S0 S1, 1/0FIGURE 13-16(c) Go to the row in the table which corresponds to the next state and read
the output under the old input column and plot it. (This may be a falseoutput.)
(d) Change to the next input and repeat steps (a), (b), and (c).
(Note: If you are just trying to read the correct output sequence from thetable, step (c) is naturally omitted.)
6.For Mealy circuits, the best time to read the output is just before the active edge
of the clock, because the output should always be correct at that time.
The example in Figure 13-16 shows a state graph, a state table, a circuit that
implements the table, and a timing chart. When the state is S
0and the input is 
X/H110050, the output from the state graph, state table, circuit, and timing chart is 
Z/H110051 (labeled Aon the figure). Note that this output occurs before the rising
edge of the clock. In a Mealy circuit, the output is a function of the present stateand input; therefore, the output should be read just before the clock edge thatcauses the state to change.
As you continue to study this example, each time the input Xchanges, trace the
changes on the state graph, the state table, the circuit, and the timing chart. Becausethe input Xwas 0 before the first rising edge of the clock, the state changes to S
1
after the first rising edge of the clock. Because of the state change, the output also
changes (B on the timing chart), but because the input has not yet changed to itsnew value, the output value may not be correct. We refer to this as a false output or
glitch . If the input changes several times before it assumes its correct value, the out-
put may also change several times (C). The input must assume its correct valuebefore the rising edge of the clock, and the output should be read at this time (D).After the rising clock edge, the state stays the same and the output stays the samefor this particular example. In general, the state may change after a rising edge ofthe clock, and the state change may result in an output change. Again, the outputvalue may be wrong because the input still has the old value (E). When the input ischanged to its new value, the output changes to its new value (F), and this valueshould be read before the next rising clock edge.
If we look at the input and output just before each rising edge of the clock, we
find the following sequences:
X/H11005010
Z/H11005110
You should be able to verify the sequence for Zusing the state graph, using the state
table, and using the circuit diagram.
The synthesis procedure for sequential circuits, discussed in detail in Units 14
through 16, is just the opposite of the procedure used for analysis. Starting with thespecifications for the sequential circuit to be synthesized, a state graph is construct-ed. This graph is then translated to a state table, and the flip-flop output values areassigned for each state. The flip-flop input equations are then derived, and finally,the logic diagram for the circuit is drawn. For example, to synthesize the circuit inFigure 13-7, we would start with the state graph of Figure 13-11. Then, we wouldderive Table 13-3(b), Table 13-3(a), the next-state and output equations, and, final-ly, the circuit of Figure 13-7.
13.4 General Models for Sequential Circuits
A sequential circuit can be divided conveniently into two parts—the flip-flopswhich serve as memory for the circuit and the combinational logic which realizesthe input functions for the flip-flops and the output functions. The combinationallogic may be implemented with gates, with a ROM, or with a PLA. Figure 13-17illustrates the general model for a clocked Mealy sequential circuit with minputs,
noutputs, and kclocked D flip-flops used as memory. Drawing the model in this
form emphasizes the presence of feedback in the sequential circuit because the flip-flop outputs are fed back as inputs to the combinational subcircuit.408 Unit 13
Analysis of Clocked Sequential Circuits 409
DkQk
CK
ClockCombinational
Subcircuit
Q2Q1D1
D2Z1
Z2X1
X2
QkZn Xm
Qk+CKQ2
Q2+CKQ1
Q1+......
...
............FIGURE 13-17
General Model
for Mealy Circuit
Using Clocked
D Flip-Flops
The combinational subcircuit realizes the noutput functions and the knext-state
functions, which serve as inputs to the D flip-flops:
Z1/H11005f1(X1,X2,..., Xm,Q1,Q2,..., Qk)
Z2/H11005f2(X1,X2,..., Xm,Q1,Q2,..., Qk)
Zn/H11005fn(X1,X2,..., Xm,Q1,Q2,..., Qk)
Q1/H11001/H11005D1/H11005g1(X1,X2,..., Xm,Q1,Q2,..., Qk)
Q2/H11001/H11005D2/H11005g2(X1,X2,..., Xm,Q1,Q2,..., Qk)
Qk/H11001/H11005Dk/H11005gk(X1,X2,..., Xm,Q1,Q2,..., Qk)
When a set of inputs is applied to the circuit, the combinational subcircuit gener-
ates the outputs ( Z1,Z2,..., Zn) and the flip-flop inputs ( D1,D2,..., Dk).Then, a clock
pulse is applied and the flip-flops change to the proper next state. This process isrepeated for each set of inputs. Note that at a given point in time, the outputs of theflip-flops represent the present state of the circuit (Q
1,Q2,..., Qk). These Qi’s feed
back into the combinational circuit, which generates the flip-flop inputs using the Qi’s
and the Xinputs. When D flip-flops are used, Di/H11005Qi/H11001; therefore, the combinational
circuit outputs are labeled Q1/H11001,Q2/H11001, etc. Although the model in Figure 13-17 uses D
flip-flops, a similar model may be used for other types of clocked flip-flops, in whichcase the combinational circuit must generate the appropriate flip-flop inputs insteadof the next-state functions.
... ...
¯˚˘˚˙
¯˚˘˚˙noutput functions
knext-state
functions
410 Unit 13
The clock synchronizes the operation of the flip-flops and prevents timing prob-
lems. The gates (or other logic) in the combinational subcircuit have finite propaga-tion delays, so when the inputs to the circuit are changed, a finite time is requiredbefore the flip-flop inputs reach their final values. Because the gate delays are not allthe same, the flip-flop input signals may contain transients, and they may change atdifferent times. If the next active clock edge does not occur until all flip-flop inputsignals have reached their final steady-state values, the unequal gate delays will notcause any timing problems. All flip-flops which must change state do so at the sametime in response to the active edge of the clock. When the flip-flops change state, thenew flip-flop outputs are fed back into the combinational subcircuit. However, nofurther change in the flip-flop states can occur until the next clock pulse.
We can determine the fastest clock speed (the minimum clock period) from the
general model of the Mealy circuit in Figure 13-17. The computation of the minimumclock period is similar to that of Figure 11-17, except that we must also consider theeffect of the Xinputs. Figure 13-18 shows the sequence of events during one clock
period. Following the active edge of the clock the flip-flops change state, and the flip-flop output is stable after the propagation delay ( t
p). The new values of Qthen
propagate through the combinational circuit so that the Dvalues are stable after the
combinational circuit delay ( tc). Then, the flip-flop setup time ( tsu) must elapse before
the next active clock edge.Thus, the propagation delay in the flip-flops, the propagationdelay in the combinational subcircuit, and the setup time for the flip-flops determinehow fast the sequential circuit can operate, and the minimum clock period is
t
clk(min)/H11005tp/H11001tc/H11001tsu
The preceding discussion assumes that the Xinputs are stable no later than tc/H11001tsu
before the next active clock edge. If this is not the case, then we must calculate the
minimum clock period by
tclk(min)/H11005tx/H11001tc/H11001tsu
where txis the time after the active clock edge at which the Xinputs are stable.
The general model for the clocked Moore circuit (Figure 13-19) is similar to
the clocked Mealy circuit.The output subcircuit is drawn separately for the Moorecircuit because the output is only a function of the present state of the flip-flopsand not a function of the circuit inputs. Operation of the Moore circuit is similarto that of the Mealy except when a set of inputs is applied to the Moore circuit,the resulting outputs do not appear until after the clock causes the flip-flops tochange state.
Minimum Clock Period ( tclk)
Flip-Flop
Propagation
Dela y
(tp)Combinational
Circuit Dela y
(tc)Setup Time
(tsu)
Active edge
of ClockQ
Outputs
StableD
Inputs
StableNext active
Edge of Cloc kFIGURE 13-18
Minimum Clock
Period for a
Sequential Circuit
Analysis of Clocked Sequential Circuits 411
To facilitate the study of sequential circuits with multiple inputs and outputs, the
assignment of symbols to represent each combination of input values and each combi-nation of output values is convenient. For example, we can replace Table 13-4 withTable 13-5 if we let X/H110050 represent the input combination X
1X2/H1100500,X/H110051 represent
X1X2/H1100501, etc., and similarly let Z/H110050 represent the output combination Z1Z2/H1100500,
Z/H110051 represent Z1Z2/H1100501, etc. In this way we can specify the behavior of any sequen-
tial circuit in terms of a single input variable Xand a single output variable Z.
Table 13-5 specifies two functions, the next-state function and the output function.
The next-state function, designated /H9254, gives the next state of the circuit (i.e., the state
after the clock pulse) in terms of the present state ( S) and the present input ( X):
S/H11001/H11005/H9254(S,X) (13-6)
The output function, designated /H9261, gives the output of the circuit ( Z) in terms of the
present state ( S) and input ( X):
Z/H11005/H9261 (S,X) (13-7)
Values of S/H11001andZcan be determined from the state table. From Table 13-5, we have
/H9254(S0,1 )/H11005S2 /H9254(S2,3 )/H11005S1
/H9261(S0,1 )/H110052 /H9261(S2,3 )/H110051
We will use the /H9261and /H9254notation when we discuss equivalent sequential circuits in
Unit 15.DkQk
CK
ClockCombinational
Subcircuit
(for Flip-Flop
Inputs)Combinational
Subcircuit
(for Outputs)Q2Q1D1
D2Z1
Z2X1
X2
QkZn Xm
Qk+CKQ2
Q2+CKQ1
Q1+
......
...
...
.........
..................FIGURE 13-19
General Model
for Moore Circuit
Using Clocked
D Flip-Flops
Present Next State Present Output ( Z)
State X/H1100501 23 X/H110050123
S0 S3S2S1S0 0231
S1 S0S1S2S3 2233
S2 S3S0S1S1 0231
S3 S2S2S1S0 0011TABLE 13-5
State Table with
Multiple Inputs
and Outputs
412 Unit 13
Programmed Exercise 13.1
Cover the bottom of each page with a sheet of paper and slide it down as you check
your answers.
13.1(a) In this exercise you will analyze the following sequential circuit using a state table
and a timing chart.Derive the next-state and output equations.
A
/H11001/H11005 ________________________________________________
B/H11001/H11005 ________________________________________________
Z/H11005 ________________________________________________
Answer Z/H11005XA/H11001X/H11032B,B/H11001/H11005(A/H11032⊕X)B/H11032/H11001XB/H11005A/H11032B/H11032X/H11032/H11001AB/H11032X/H11001XB
A/H11001/H11005B(A/H11001X)
13.1(b) Plot these equations on maps and complete the transition table.
01
00AB
A+X
01
111001
00AB
B+X
01
111001
00AB
ZX
01
1110A′ A
ADAZ
BCK
ClockB′ B
JB KB
X′X′
X XB
X
A
A′CK
A/H11001B/H11001Z
AB X /H1100501 0 1
00
01
11
10
Analysis of Clocked Sequential Circuits 413
Answer to 13.1(b)
13.1(c) Convert your transition table to a state table using the given state numbering.
Answer to 13.1(c)
13.1(d) Complete the corresponding state graph.
S0
S1
S2S30
01
0A/H11001B/H11001Z
AB X /H1100501 0 1
S0 00 01 00 0 0
S1 01 00 11 1 0
S2 11 10 11 1 1
S3 10 00 01 0 1
Next State Output
X/H1100501 01
S0
S1
S2
S3
X/H1100501 0 1
S0 S1S0 00
S1 S0S2 10
S2 S3S2 11
S3 S0S1 01
414 Unit 13
Answer to 13.1(d)
13.1(e) Using this graph, determine the state sequence and output sequence if the initial
state is S0and the input sequence is X/H110050, 1, 0, 1.
(1) The initial output with X/H110050 in state S0isZ/H11005____________ and the next state is
____________ .
(2) The output in this state when the next input ( X/H110051) is applied is Z/H11005____________
and the next state is____________ .
(3) When the third input ( X/H110050) is applied, the output is Z/H11005____________ and
the next state is ____________ .
(4) When the last input is applied, Z /H11005____________ and the final state is
____________.
In summary, the state sequence is S0,____________, ____________, ____________,
____________ . The output sequence is Z/H11005____________ .
Answer to 13.1(e) S0,S1,S2,S3,S1 Z/H110050011
13.1(f) This sequence for Zis the correct output sequence. Next, we will determine the tim-
ing chart including any false outputs for Z. Assuming that Xchanges midway
between falling and rising clock edges, draw the waveform for X(X/H110050, 1, 0, 1).
Clock
XS0
S1
S2S3
1
0
1
11
10
10
01
0
0
0
0
1
Analysis of Clocked Sequential Circuits 415
Answer
13.1(g) Referring to the transition table, sketch the waveforms for Aand Bassuming that
initially A/H11005B/H110050. The state sequence is
AB/H1100500, ____________, ____________, ____________, ____________ .
Answer (Note that Aand Bchange immediately after the falling clock edge.)
13.1(h) Using the output table, sketch the waveform for Z. At time t1,X/H11005A/H11005B/H110050,
soZ/H11005____________. At time t2,X/H11005____________ and AB/H11005____________, so
Z/H11005____________. At time t3,X/H11005____________ and AB/H11005____________,
soZ/H11005____________. Complete the waveform for Z, showing the output at t4,t5, etc.
Answer (Note that Zcan change immediately following the change in Xor immediately
following the falling clock edge.)
Clock
X
Z
t7 t6 t5 t4 t3 t2 t1Clock
X
A
B
Z
t7 t6 t5 t4 t3 t2 t1Clock
X
A
BA/H11001B/H11001
AB X /H1100501
00 01 00
01 00 1111 10 1110 00 01
Z
AB X /H1100501
00 0 0
01 1 0
11 1 1
10 0 1
Check your state sequence
against the answer to 13.1(e),noting that S
0/H1100500, S1/H1100501,
S2/H1100511 and S3/H1100510.
416 Unit 13
13.1(i) (1) Because this is a Mealy circuit, the correct times to read the output are during
intervals t1, ____________, ____________, and ____________ .
(2) The correct output sequence is therefore Z/H11005____________ .
(3) False outputs may occur during intervals ____________, ____________, and
____________ .
(4) In two of these intervals, false outputs actually occur. These intervals are
____________ and ____________.
Answer (1)t1,t3,t5, and t7
(2) Check your Zsequence against the answer to 13.1(e).
(3)t2,t4,and t6.
(4)t2and t6(output during t4is not false because it is the same as t5).
13.1(j) Finally, we will verify part of the timing chart by signal tracing on the original circuit
(see 13.1(a)).
(1) Initially, A/H11005B/H110050 and X/H110050, so DA/H11005____________, JB/H11005____________,
KB/H11005____________, and Z/H11005____________ .
(2) After the clock pulse A/H11005_______________, B/H11005_______________, and
Z/H11005____________ .
(3) After Xis changed to 1, DA/H11005____________, JB/H11005____________,
KB/H11005____________, and Z/H11005____________ .
(4) After the clock pulse, A/H11005_______________, B/H11005_______________, and
Z/H11005____________ .
Check your answers against the timing chart. Answer to (1) corresponds to t1, (2) to
t2, (3) to t3, and (4) to t4.
Problems
13.2 Construct a state graph for the shift register shown. ( Xis the input, and Zis the output.)
Is this a Mealy or Moore machine?
13.3 (a) For the following sequential circuit, find the next-state equation or map for each
flip-flop. (Is this a Mealy or Moore machine?) Using these next-state equationsor maps, construct a state table and graph for the circuit.
(b) What is the output sequence when the input sequence is X/H1100501100?S
R
ClockCKX Z S
RCK
Q2Q2 Q3 S
RCK
Q3 ′ Q1Q1
′′
Analysis of Clocked Sequential Circuits 417
(c) Draw a timing diagram for the input sequence in (b). Show the clock, X,A,B,
and Z. Assume that the input changes between falling and rising clock edges.
13.4 A sequential circuit has the form shown in Figure 13-17, with
D1/H11005Q2Q3/H11032 D3/H11005Q2/H11032/H11001X
D2/H11005Q3 Z/H11005XQ2/H11032/H11001X/H11032Q2
(a) Construct a state table and state graph for the circuit. (Is this a Mealy or Moore
machine?)
(b) Draw a timing diagram for the circuit showing the clock, X,Q1,Q2,Q3, and Z.
Use the input sequence X/H1100501011. Change Xbetween clock edges so that we
can see false outputs, and indicate any false outputs on the diagram.
(c) Compare the output sequence obtained from the timing diagram with that from
the state graph.
(d) At what time with respect to the clock should the input be changed in order to
eliminate the false output(s)?
13.5 Below is a state transition table with the outputs missing. The output should be 
Z/H11005X/H11032B/H11032/H11001XB.
(a) Is this a Mealy machine or Moore machine?(b) Fill in the outputs on the state transition table.(c) Give the state graph.(d) For an input sequence of X/H1100510101, give a timing diagram for the clock, X,A,
B,C, and Z. State changes occur on the rising clock edge. What is the correct
output sequence for Z? Change Xbetween rising and falling clock edges so
that we can see false outputs, and indicate any false outputs on the diagram.ClockA′ A
JA KA
X′
X′Z
A′
B′B
XCK
ClockB′ B
JB KBCK
A/H11001B/H11001C/H11001
ABC X /H110050X/H110051
000 011 010
001 000 100010 100 100011 010 000100 100 001
418 Unit 13
13.6 A sequential circuit of the form shown in Figure 13-17 is constructed using a ROM
and two rising-edge-triggered D flip-flops.The contents of the ROM are given in thetable. Assume the propagation delay of the ROM is 8 ns, the setup time for the flip-flops is 2 ns, and the propagation delay of the flip-flops is 4 ns.
(a) What is the minimum clock period for this circuit?
(b) Draw a timing diagram for this circuit, using the given delays and the
minimum clock period of Part (a). Give the clock, X,D
1,D2,Q1,Q2, and Z.
Assume Q1Q2/H1100500 to start with and assume Xtakes on its new value 4 ns
after each rising edge. Use the input sequence X/H110050, 1, 1, 0. Specify the cor-
rect output sequence for Z.
(c) Construct a state table and a state graph for the circuit.
13.7 (a) Construct a state table and graph for the circuit shown.
(b) Construct a timing chart for the circuit for an input sequence X/H1100510111.
(Assume that initially Q1/H11005Q2/H110050 and that Xchanges midway between the
rising and falling clock edges.)
(c) List the output values produced by the input sequence.
X
ZClk Ck FFQ1
Q1′J1
K1
Ck FFQ2
Q2′J2
K2Q1Q2XD1D2Z
00 0 10 0
00 1 10 001 0 00 001 1 11 010 0 11 0
10 1 01 1
11 0 01 111 1 11 1
Analysis of Clocked Sequential Circuits 419
13.8 (a) Construct a state table and graph for the circuit shown.
(b) Construct a timing chart for the input sequence X/H1100510101. (Assume that ini-
tially Q1/H11005Q2/H110050 and that Xchanges midway between the rising and falling
clock edges.) Indicate the times Zhas the correct value.
(c) List the output values produced by the input sequence.
13.9 (a) Construct a state table and graph for the circuit shown.
(b) Construct a timing chart for the input sequence X1X2/H1100511, 11, 01, 10, 10, 00.
(Assume that initially Q1/H11005Q2/H110050  and that X1andX2change midway between
the rising and falling clock edges.)
(c) List the output values produced by the input sequence.
ClockX2′
Z
CkD2 Q2
Q2′CkD1 Q1
Q1′X1′
Q1
Q1
Q2
X1′
Q2
X1′X1
X2′X2
Q2Q1′X
ZClk Ck FFQ1
Q1′J1
K1
Ck FFQ2
Q2′J2
K2
13.10 (a) Construct a state table and graph for the circuit shown.
(b) Construct a timing chart for the input sequence X1X2/H1100501, 10, 01, 11, 11, 01.
(Assume that initially Q1/H11005Q2/H110050 and that X1andX2change midway between
the rising and falling clock edges.)
(c) List the output values produced by the input sequence.
13.11 (a) Construct a state table and graph for the given circuit.
(b) Construct a timing chart for the circuit for an input sequence X/H1100510011.
Indicate at what times Zhas the correct value and specify the correct output
sequence. (Assume that Xchanges midway between falling and rising clock
edges.) Initially, Q1/H11005Q2/H110050.
ClockQ1 Q1 Q2 Q2
J1 K1 J2 K2
XXX
XZX
Q2 Q1′Clock′′ClockX2
Z
CkD2 Q2
Q2′CkD1 Q1
Q1′
Q1′
Q2X1
Q1
Q1
Q2
X2
Q2
X1′X1
X2′X2
Q2
Q1′420 Unit 13
Analysis of Clocked Sequential Circuits 421
13.12 Repeat Problem 13.11 for the circuit below and X1X2/H1100510, 01, 10, 11, 11, 10.
13.13 A sequential circuit has one input X, one output Z, and three flip-flops Q1,Q2, and
Q3. The transition and output tables for the circuit follow:X2ClockQ1 Q1 Q2 Q2
D1 D2Z
Q1 Q1Clock
Q2 X1 X1X2
X1X2 X1Q2 Q2 Q1 ′
′′′′
Present Next State Output ( Z)
State X/H110050X/H110051 X/H110050X/H110051
000 100 101 1 0
001 100 101 0 1010 000 000 1 0
011 000 000 0 1
100 111 110 1 0101 110 110 0 1110 011 010 1 0111 011 011 0 1
(a) Construct a timing chart for the input sequence X/H110050101 and initial state Q1Q2Q3=
000. Identify any false outputs. (Assume that the flip-flops are rising-edge trig-gered and that the input changes midway between the rising and falling edgesof the clock.)
(b) List the output values produced by the input sequence.
13.14 Repeat Problem 13.13 for the input sequence X/H110051001 and initial state Q
1Q2Q3/H11005000.
13.15 A sequential circuit has the form shown in Figure 13-17 with
D1/H11005Q2Q3/H11032/H11001XQ1/H11032 D3/H11005Q2/H11032/H11001X
D2/H11005Q3/H11001X/H11032Q2 Z/H11005XQ2/H11032/H11001X/H11032Q2
(a) Construct a state table and state graph for the circuit.
(b) Draw a timing diagram for the circuit showing the clock, X,Q1,Q2,Q3, and Z.
Use the input sequence X/H1100501011 and assume that Xchanges midway between
falling and rising clock edges. Indicate any false outputs on the diagram.
(c) Compare the output sequence obtained from the timing diagram with that from
the state graph.
(d) At what time with respect to the clock should the input be changed in order to
eliminate the false output(s)?
13.16 Repeat Problem 13.15 for the given equations and the input sequence X/H1100501100.
D1/H11005Q3/H11032X/H11032 D3/H11005Q2/H11032X/H11001Q1Q2
D2/H11005Q3/H11032Q1/H11001XQ2/H11032 Z/H11005XQ3/H11001X/H11032Q3/H11032
13.17 Consider the circuit shown.
(a) Construct a state table and graph for the following circuit. Is the circuit a Mealy or
Moore circuit? Does the circuit have any unused states? Assume 00 is the initial state.
(b) Draw a timing diagram for the input sequence X/H1100501100.
(c) What is the output sequence for the input sequence?
13.18 A Mealy sequential circuit has one input, one output, and two flip-flops. A tim-
ing diagram for the circuit follows. Construct a state table and state graph for thecircuit.
Clock
X
Q1
Q2
ZX
ZClk Ck FFQ1
Q1′J1
K1
Ck FFQ2
Q2′J2
K2Q2′
Q2
Q1422 Unit 13
Analysis of Clocked Sequential Circuits 423
13.19 Repeat Problem 13.18 for the following timing diagram.
13.20 Given the following timing chart for a sequential circuit, construct as much of the
state table as possible. Is this a Mealy or Moore circuit?
13.21 Given the following timing chart for a sequential circuit, construct as much of the
state table as possible.
X1
X2
Clock
Q1
Q2
Z1
Z2Clock
Q1
Q2X1
X2
Z1
Z2Clock
X
Q1
Q2
Z
13.22 For the following sequential circuit, the table gives the contents of the PLA. (All
PLA outputs are 0 for input combinations not listed in the table.)(a) Draw a state graph.(b) Draw a timing diagram showing the clock, X,Q
1,Q2, and Zfor the input
sequence X/H1100510011. Assume that initially Q1/H11005Q2/H110050.
(c) Identify any false outputs in the timing diagram. What is the correct output
sequence for Z?
13.23 A sequential circuit of the form shown in Figure 13-17 is constructed using a ROM
and two D flip-flops. The contents of the ROM are given in the table.(a) Draw a timing diagram for the circuit for the input sequence X
1X2/H1100510, 01, 11,
10. Assume that input changes occur midway between rising and falling clockedges. Indicate any false outputs on the diagram, and specify the correct out-put sequence for Z
1and Z2.
(b) Construct a state table and state graph for the circuit.CkD2
ClockQ2+
+Q1PLAQ2X Z
CkD1Q1424 Unit 13
Q1Q2X1X2 D1D2Z1Z2
0 000 0010
0 001 00100 010 0110
0 011 0110
0 100 11000 101 11100 110 10010 111 1011
1 000 1100
1 001 00001 010 11011 011 0001
1 100 1000
1 101 01001 110 10001 111 0100XQ1Q2 D1D2Z
01 – 10 0
10 1 10 00– 1 01 1
10 0 01 1
11 0 00 1
Analysis of Clocked Sequential Circuits 425
13.24 For the following state graph, give the state table. Then, give the timing diagram for
the input sequence X/H11005101001.Assume Xchanges midway between the falling and
rising edges of the clock, and that the flip-flops are falling-edge triggered. What isthe correct output sequence?
13.25 For the circuit of Problem 13.3, assume the delays of the NAND gates and NOR
gates are 3 ns, and assume the delay of the inverter is 2 ns. Assume the propagationdelays and setup times for the J-K flip-flops are 4 ns and 2 ns, respectively.(a) Fill in the given timing diagram. The clock period is 15 ns, and 1-ns increments
are marked on the clock signal. Does the circuit operate properly with thesetiming parameters?
(b) What is the minimum clock period for this circuit, if Xis changed early enough?
How late may Xchange with this clock period without causing improper oper-
ation of the circuit?
Clock
X
A
B
JA
KA
JB = KB
Z5 ns 10 ns 15 ns 20 ns 25 ns 30 ns 35 ns1
01
01
00
00
0
1
11
10
0
0
00
0S0
S3 S4S1 S2
13.26 Draw a timing diagram for the following circuit starting with an initial state ABC /H11005000
and using an input sequence X/H1100501010. Assume that the input changes occur
midway between the falling and rising clock edges. Give the output sequence, and indi-cate false outputs, if any. Verify that your answer is correct by making a state table forthe circuit.
13.27 (a) For the following sequential circuit, write the next-state equations for flip-
flops Aand B.
(b) Using these equations, find the state table and draw the state graph.
A′ A
S R
X2 X2′
X2′
X2′X1Z1
Z2′X1′
X1′
X1′BB ′B
BA
AB′
B′A′
A′ClkB′ B
T
ClkClockA′ A
J K
X′CXC′CkC′ C
J KCkB′ B
D
XC′ X′ CA′ X0 X
ACk
XZ
B X′ AB′ X′C′X AB′426 Unit 13
427CHAPTER
00Derivation of State Graphs 
and Tables
Objectives
1.Given a problem statement for the design of a Mealy or Moore sequen-
tial circuit, find the corresponding state graph and table.
2.Explain the significance of each state in your graph or table in terms of
the input sequences required to reach that state.
3.Check your state graph using appropriate input sequences.
UNIT
14
428 Unit 14
1.Study Section 14.1, Design of a Sequence Detector .
(a) Verify that the state graph in Figure 14-4 will produce the correct output
sequence for Zwhen the input sequence for Xis as given in Equation (14-1).
(b) Using the equations from the Karnaugh maps on p. 396, construct the
next-state table for the circuit and verify that it is the same as given inTable 14-2, except that the new table will have four states because thedon’t-cares were assigned in the process of designing the circuit.
(c) Complete the design of the Moore sequential circuit whose transition
table is given by Table 14-4. Use clocked J-K flip-flops for Aand B.
(d) Verify that the state graph of Figure 14-6 gives the correct output sequence
when the input sequence (14-1) is applied. (Ignore the initial output forthe Moore graph.)
2.Study Section 14.2, More Complex Design Problems .
3.Study Section 14.3, Guidelines for Construction of State Graphs . Study the
examples carefully and observe how some of the guidelines were applied.
4.Work through Programmed Exercises 14.1, 14.2, and 14.3.
5.A very important part of deriving state tables or state graphs is knowing how to
tell when your answer is right (or wrong!). One way to do this is to make up asuitable list of test sequences, apply them to the state graph, and check theresulting output sequences.
6.To gain proficiency in construction of state tables or graphs requires a fair
amount of practice. Work Problems 14.4, 14.5, 14.6, 14.7, and 14.8. The problemson the readiness tests will be about the same order of difficulty as these prob-lems, so make sure that you can work them in a reasonable time.
Note : Do not look at the answers to these problems in the back of the
book until you have tried the problems and checked your answers usingthe following test sequences:
14.4 X/H11005 01110101
Z/H11005( 0 ) 00001111
(Your solution should have five self-loops. A self-loop is anarrow which starts at one state and goes back to the same state.)
14.5 X/H1100510101001000100
Z
1/H1100500010100000000
Z2/H1100500000010010001
(Your solution should have four self-loops.)
14.6 X1/H11005 1001011000
X2/H11005 1000010010
Z/H11005( 0 )0111000110
(Your solution should have at least four self-loops.)Study Guide
Derivation of State Graphs and Tables 429
14.7 (a) X/H1100500110101011
Z/H1100511000110001
(Your solution should have three self-loops.)(b) X/H110051110010101
Z/H110050000100001
14.8 (a) X
1/H1100500111100100
X2/H1100501011010011
Z1/H1100501110000100
Z2/H1100500000111010
(b) You should get the same sequences as in (a) after an initial
output of Z1Z2/H1100500.
7.If you have the LogicAid program available, use it to check your state tables. This
has several advantages over looking at the answers in the back of the book. First,LogicAid will determine whether or not your solution is correct even if your states
are numbered differently from those in the solution, or even if the number of statesis different. Second, if your solution is wrong, LogicAid will find a short input
sequence for which your state table fails, and you can use this sequence to helplocate the error in your solution. If you are having trouble learning to derive stategraphs, LogicAid has a state graph tutor mode which can be used to check partial
state graphs. By using the partial graph checker, you can check your graph afteradding each state, and then correct any errors before proceeding to the next state.
8.Read Section 14.4, Serial Data Code Conversion .
(a) Complete the following timing diagram, showing waveforms for the NRZ,
NRZI, RZ, and Manchester coding schemes:
(b) The timing chart of Figure 14-20(b) shows several glitches. By referring to
the state table, explain why the second glitch is present.
(c) Consider Figure 14-20. If an error in data transmission occurs, the input
sequence X/H1100501 or 10 could occur. Add an Error state to the state dia-
gram. The circuit should go to this error state if such an error occurs.
(d) Work Problem 14.9.Bit sequence 01 00 11 10
NRZ
NRZI
RZ
Manchester
Clock
430 Unit 14
9.Read Section 14.5, Alphanumeric State Graph Notation .
(a) Sometimes all outputs are 0 for a given state or arc.We denote this by plac-
ing a 0 in the place of the output. For example, a Moore state with all out-puts being 0 might be labeled S
3/0, and a Mealy arc with all outputs being
0 might be labeled X/H11032Y/0.
(b) Try to write the row of a Mealy state table that describes state S3in the fol-
lowing partial state graph. You cannot, because there are two contradicto-ry directions when S/H11005N/H110051. Also, the row is not completely specified.
Redraw state S
3so that Stakes priority over N, and so that the circuit stays
in state S3with no output if no directions are specified by the partial state
graph.Then, give the state table row. Show that it has no contradictions andthat it is completely specified.
(c) Work Problems 14.10 and 14.11.
10. When you are satisfied that you can meet all of the objectives, take the readiness test.S1
S5S3N
Z
S
0
In Unit 13 we analyzed sequential circuits using timing charts and state graphs. Now,
we will consider the design of sequential circuits starting from a problem statementwhich specifies the desired relationship between the input and output sequences. Thefirst step in the design is to construct a state table or graph which specifies the desiredbehavior of the circuit. Flip-flop input equations and output equations can then bederived from this table. Construction of the state table or graph, one of the most impor-tant and challenging parts of sequential circuit design, is discussed in detail in this unit.
Derivation of State Tables
14.1 Design of a Sequence Detector
To illustrate the design of a clocked Mealy sequential circuit, we will design a
sequence detector. The circuit has the form shown in Figure 14-1.Derivation of State Graphs and Tables 431
FIGURE 14-2FIGURE 14-1
Sequence Detector
to be DesignedZ X
Clock
1
00
0
S0
S1The circuit will examine a string of 0’s and 1’s applied to the Xinput and generate an
output Z/H110051 only when a prescribed input sequence occurs. It will be assumed that the
input Xcan only change between clock pulses. Specifically, we will design the circuit
so that any input sequence ending in 101 will produce an output Z/H110051 coincident with
the last 1. The circuit does not reset when a 1 output occurs. A typical input sequenceand the corresponding output sequence are
X/H110050011011001 010100
Z/H11005 0000010000 010100 (14-1)
(time: 01234567891 01 11 21 31 41 5 )
Initially, we do not know how many flip-flops will be required, so we will designate the
circuit states as S
0,S1, etc., and later assign flip-flop states to correspond to the circuit
states.We will construct a state graph to show the sequence of states and outputs whichoccur in response to different inputs. Initially, we will start the circuit in a reset state des-ignated S
0. If a 0 input is received, the circuit can stay in S0because the input sequence
we are looking for does not start with 0. However, if a 1 is received, the circuit must goto a new state ( S
1) to “remember” that the first input in the desired sequence has been
received (Figure 14-2). The labels on the graph are of the form X/Z, where the symbol
before the slash is the input and the symbol after the slash is the corresponding output.
When in state S1, if we receive a 0, the circuit must change to a new state ( S2) to
remember that the first two inputs of the desired sequence (10) have been received.If a 1 is received in state S
2, the desired input sequence (101) is complete and the out-
put should be l. The question arises whether the circuit should then go to a new stateor back to S
0orS1. Because the circuit is not supposed to reset when an output
occurs, we cannot go back to S0. However, because the last 1 in a sequence can also
be the first 1 in a new sequence, we can return to S1, as indicated in Figure 14-3.
432 Unit 14
FIGURE 14-3 1
0
1
1
0
00
0S0
S1
S2
1
0
1
01
1
0
00
0
0
0S0
S1
S2FIGURE 14-4
Mealy State Graph
for Sequence
Detector
Present
Present Next State Output
State X/H110050X/H110051 X/H110050X/H110051
S0 S0 S1 00
S1 S2 S1 00
S2 S0 S1 01TABLE 14-1The graph of Figure 14-3 is still incomplete. If a 1 input occurs when in state S1,w e
can stay in S1because the sequence is simply restarted. If a 0 input occurs in state S2,w e
have received two 0’s in a row and must reset the circuit to state S0because 00 is not
part of the desired input sequence, and going to one of the other states could lead to anincorrect output.The final state graph is given in Figure 14-4. Note that for a single input
variable each state must have two exit lines (one for each value of the input variable)
but may have any number of entry lines, depending on the circuit specifications.
State S
0is the starting state, state S1indicates that a sequence ending in 1 has
been received, and state S2indicates that a sequence ending in 10 has been
received. An alternative way to start the solution would be to first define statesin this manner and then construct the state graph. Converting the state graph toa state table yields Table 14-1. For example, the arc from S
2toS1is labeled 1/1.
This means that when the present state is S2and X/H110051, the present output is 1.
This 1 output is present as soon as Xbecomes 1, that is, before the state change
occurs. Therefore, the 1 is placed in the S2row of the table.
At this point, we are ready to design a circuit which has the behavior described by
the state table. Because one flip-flop can have only two states, two flip-flops are neededto represent the three states. Designate the two flip-flops as AandB. Let flip-flop states
A/H110050 and B/H110050 correspond to circuit state S
0;A/H110050 and B/H110051 correspond to S1; and
A/H110051 and B/H110050 correspond to circuit state S2. Each circuit state is then represented by
a unique combination of flip-flop states. Substituting the flip-flop states for S0,S1andS2
in the state table yields the transition table (Table 14-2).
From this table, we can plot the next-state maps for the flip-flops and the map for
the output function Z:Derivation of State Graphs and Tables 433
0001
10
XX
000AB
A+ = X ′BX
01
1110 00101
01
XX
000AB
B+ = XX
01
1110 10001
00
XX
000AB
Z = X AX
01
1110 1
The flip-flop inputs are then derived from the next-state maps using the
same method that was used for counters (Section 12.4). If D flip-flops are used,D
A/H11005A/H11001/H11005X/H11032BandDB/H11005B/H11001/H11005X, which leads to the circuit shown in Figure 14-5.
Initially, we will reset both flip-flops to the 0 state. By tracing signals through thecircuit, you can verify that an output Z/H110051 will occur when an input sequence
ending in 101 occurs. To avoid reading false outputs, always read the value ofZafter the input has changed and before the active clock edge.
ClockCkA′ A
DCkB′ B
D
Z
XFIGURE 14-5A+B+Z
AB X /H110050X/H110051 X/H110050X/H110051
00 00 01 0 0
01 10 01 0 0
10 00 01 0 1TABLE 14-2
The procedure for finding the state graph for a Moore machine is similar to that
used for a Mealy machine, except that the output is written with the state instead ofwith the transition between states. We will rework the previous example as a Mooremachine to illustrate this procedure. The circuit should produce an output of 1 onlyif an input sequence ending in 101 has occurred. The design is similar to that for the
434 Unit 14
1
00S0
0S1
0
S2
0Mealy machine up until the input sequence 10 has occurred, except that 0 output is
associated with states S0,S1, and S2:
11
110
0
00S0
0S1
0
S2
0S3
1FIGURE 14-6
Moore State Graph
for Sequence
Detector
Present Next State Present
State X/H110050X/H110051 Output (Z)
S0 S0 S1 0
S1 S2 S1 0
S2 S0 S3 0
S3 S2 S1 1TABLE 14-3Now, when a 1 input occurs to complete the 101 sequence, the output must become 1;
therefore, we cannot go back to state S1and must create a new state S3with a 1 output:
We now complete the graph, as shown in Figure 14-6. Note the sequence 100 resets
the circuit to S0. A sequence 1010 takes the circuit back to S2because another 1
input should cause Zto become 1 again.
The state table corresponding to the circuit is given by Table 14-3. Note that there
is a single column for the output because the output is determined by the present stateand does not depend on X. Note that in this example the Moore machine requires one
more state than the Mealy machine which detects the same input sequence.1
100S0
0S1
0
S2
0S3
1
Because there are four states, two flip-flops are required to realize the circuit. Using
the state assignment AB/H1100500 for S0,AB/H1100501 for S1,AB/H1100511 for S2, and AB/H1100510 for
S3, the following transition table for the flip-flops results (Table 14-4):Derivation of State Graphs and Tables 435
A+B+
AB X /H110050X/H110051 Z
00 00 01 0
01 11 01 011 00 10 010 11 01 1TABLE 14-4
The output function is Z/H11005AB/H11032. Note that Zdepends only on the flip-flop states
and is independent of X, while for the corresponding Mealy machine, Zwas a func-
tion of X. The derivation of the flip-flop input equations is straightforward and will
not be given here.
14.2 More Complex Design Problems
In this section we will derive a state graph for a sequential circuit of somewhat greatercomplexity than the previous examples. The circuit to be designed again has the formshown in Figure 14-1. The output Zshould be 1 if the input sequence ends in either
010 or 1001, and Zshould be 0 otherwise. Before attempting to draw the state graph,
we will work out some typical input-output sequences to make sure that we have aclear understanding of the problem statement. We will determine the desired outputsequence for the following input sequence:
X/H1100500101001000100110
↑↑↑ ↑ ↑↑abc d ef
Z/H1100500010101100010100
At point a, the input sequence ends in 010, one of the sequences for which we are look-
ing, so the output is Z/H110051. At point b, the input again ends in 010, so Z/H110051. Note that
overlapping sequences are allowed because the problem statement does not say any-thing about resetting the circuit when a 1 output occurs. At point c, the input sequence
ends in 1001, so Zis again 1. Why do we have a 1 output at points d,e, and f? This is
just one of many input sequences.A state machine that gives the correct output for thissequence will not necessarily give the correct output for all other sequences.
We will start construction of the state graph by working with the two sequences
which lead to a 1 output.Then, we will later add arrows and states as required to makesure that the output is correct for other cases. We start off with a reset state S
0which
corresponds to having received no inputs. Whenever an input is received that corre-sponds to part of one of the sequences for which we are looking, the circuit should goto a new state to “remember” having received this input. Figure 14-7 shows a partialstate graph which gives a 1 output for the sequence 010. In this graph S
1corresponds
436 Unit 14
0
0
0
1
1
0a1
0
S3 S2S0
S1State Sequence Received
S0 Reset
S1 0
S2 01
S3 010FIGURE 14-7
to having received a sequence ending in 0, S2to a sequence ending in 01, and S3to a
sequence ending in 010. Now, if a 1 input is received in state S3, we again have a
sequence ending in 01, which is part of the input sequence for which we are looking.Therefore, we can go back to state S
2(arrow a) because S2corresponds to having
received a sequence ending in 01.Then, if we get another 0 in state S2, we go to S3with
a 1 output. This is correct because the sequence again ends in 010.
Next, we will construct the part of the graph corresponding to the sequence
1001. Again, we start in the reset state S0, and when we receive a 1 input, we go to S4
(Figure 14-8, arrow b) to remember that we have received the first 1 in the sequence 1001.
The next input in the sequence is 0, and when this 0 is received, we should ask the ques-tion: Should we create a new state to correspond to a sequence ending in 10, or can we goto one of the previous states on the state graph? Because S
3corresponds to a sequence
ending in 10, we can go to S3(arrow c). The fact that we did not have an initial 0 this time
does not matter because 10 starts off the sequence for which we are looking. If we get a 0input when in S
3, the input sequence received will end in 100 regardless of the path we
took to get to S3. Because there is so far no state corresponding to the sequence 100, we
create a new state S5to indicate having received a sequence ending in 100.
If we get a 1 input when in state S5, this completes the sequence 1001 and gives
a 1 output as indicated by arrow e. Again, we ask the question: Can we go back to
one of the previous states or do we have to create a new state? Because the end ofthe sequence 1001 is 01, and S
2corresponds to a sequence ending in 01, we can go
back to S2(Figure 14-9). If we get another 001, we have again completed the
sequence 1001 and get another 1 output.
0
0
0
0
0
00
1
1
?11
0
eb
c
d1
01
0
S3 S2S0
S5S1 S4FIGURE 14-8 State Sequence Ends in
S0 Reset
S1 0 (but not 10)
S2 01
S3 10
S4 1 (but not 01)
S5 100
Derivation of State Graphs and Tables 437
FIGURE 14-9
0
00
00
00
0
0
00
1
1
11
0i
eh
cgf
1
01
01
0 1
0
S3 S2S0
S5S1 S4State Sequence Ends in
S0 Reset
S1 0 (but not 10)
S2 01
S3 10
S4 1 (but not 01)
S5 100
We have now taken care of putting out a 1 when either the sequence 010 or 1001 is
completed. Next, we will go back and complete the state graph to take care of the otherinput sequences, for which we have not already accounted. In state S
1, we have account-
ed for a 1 input but not a 0 input. If we are in S1and get a 0 input, to which state should
we go? If a 0 input occurs in S1, we have a sequence ending in 00. Because 00 is not part
of either of the input sequences for which we are looking, we can ignore the extra 0 andstay in S
1(arrow f). No matter how many extra 0’s occur, we still have a sequence end-
ing in 0, and we stay in S1until a 1 input occurs. In S2, we have taken care of the 0 input
case but not the 1 input case. If a 1 is received, the input sequence ends in 11. Because11 is not part of either the sequence 010 or 1001, we do not need a state which corre-sponds to a sequence ending in 11. We cannot stay in S
2because S2corresponds to a
sequence ending in 01. Therefore, we go to S4,which corresponds to having received a
sequence ending in 1 (arrow g).S3already has arrows corresponding to 0 and 1 inputs,
so we examine S4next. If a 1 is received in S4, the input sequence ends in 11. We can
stay in S4and ignore the extra 1 (arrow h) because 11 is not part of either sequence for
which we are looking. In S5, if we get a 0 input, the sequence ends in 000. Because 000
is not contained in either 010 or 1001, we can go back to S1, because S1corresponds to
having received a sequence ending in one (or more) 0’s.This completes the state graphbecause every state has arrows leaving it which correspond to both 0 and 1 inputs. Weshould now go back and check the state graph against the original input sequences tomake sure that a 1 output is always obtained for a sequence ending in 010 or 1001 andthat a 1 output does not occur for any other sequence.
Next, we will derive the state graph for a Moore sequential circuit with one input X
and one output Z. The output Zis to be 1 if the total number of 1’s received is odd and
at least two consecutive 0’s have been received. A typical input and output sequence is
X/H1100510110011
↑↑ ↑ ↑ ↑ab c d e
Z/H11005( 0 ) 00000101
We have shifted the Zsequence to the right to emphasize that for a Moore circuit an
input change does not affect Zimmediately, but Zcan change only after the next
active clock edge. The initial 0 in parentheses is the output associated with the reset
438 Unit 14
state. At points aand bin the preceding sequence, an odd number of 1’s has been
received, but two consecutive 0’s have not been received, so the output remains 0.Atpoints cande, an odd number of 1’s and two consecutive 0’s have been received, so
Z/H110051. At point d,Z/H110050 because the number of 1’s is even.
We start construction of the Moore state graph (Figure 14-10) with the reset state
S
0, and we associate a 0 output with this state. First, we will consider keeping track of
whether the number of 1’s is even or odd. If we get a 1 input in S0, we will go to state
S1to indicate an odd number of 1’s received. The output for S1is 0 because two con-
secutive 0’s have not been received. When a second 1 is received, should we go to anew state or go back to S
0? For this problem, it is unnecessary to distinguish between
an even number of 1’s and no 1’s received, so we can go back to S0. A third 1 then
takes us to S1(odd number of 1’s), a fourth 1 to S0(even 1’s), and so forth.
0
0
a1
1S0
0S1
0
S2
0
11 S4
1S3
0FIGURE 14-11 State Sequence Received
S0 Reset or even 1’s
S1 Odd 1’s
S2 Even 1’s and ends in 0
S3 Even 1’s and 00 has occurred
S4 00 has occurred and odd 1’sReset or
even 1’sOdd 1’s1
1S0
0S1
0FIGURE 14-10
If a 0 is received in S0, this starts a sequence of two consecutive 0’s, so we go to S2
(0 output) in Figure 14-11. Another 0 then takes us to S3to indicate two consecutive
0’s received. The output is still 0 in S3because the number of 1’s received is even.
Now if we get a 1 input, we have received an odd number of 1’s and go to S4.( W h y
can we not go to S1?) In S4we have received two consecutive 0’s and an odd number
of 1’s, so the output is 1.
If we receive a 1 in S4, we have an even number of 1’s and two consecutive 0’s,
so we can return to S3(arrow a). The output in S3is 0, and when we get another 1
input, the number of 1’s is odd, so we again go to S4with a 1 output. Now, suppose
that we are in S1(odd number of 1’s received), and we get a 0. We cannot go to S2
(Why?), so we go to a new state S5(Figure 14-12, arrow b) which corresponds to an
odd number of 1’s followed by a 0. Another 0 results in two consecutive 0’s, and wecan go to S
4(arrow c) which gives us a 1 output.
Now, we must go back and complete the state graph by making sure that there are
two arrows leaving each state. In S2, a 1 input means that we have received an odd
number of 1’s. Because we have not received two consecutive 0’s, we must return to S1
(arrow d) and start counting 0’s over again. Similarly, if we receive a 1 in S5, we return
toS0(Why?). Now, what should happen if we receive a 0 in S3? Referring to the original
problem statement, we see that once two consecutive 0’s have been received, additional
Derivation of State Graphs and Tables 439
0’s can be ignored.Therefore, we can stay in S3(arrow f). Similarly, extra 0 inputs can be
ignored in S4(arrow g).This completes the Moore state diagram, and we should go back
and verify that the correct output sequence is obtained for various input sequences.
14.3 Guidelines for Construction of State Graphs
Although there is no one specific procedure which can be used to derive stategraphs or tables for every problem, the following guidelines should prove helpful:
1.First, construct some sample input and output sequences to make sure that you
understand the problem statement.
2.Determine under what conditions, if any, the circuit should reset to its initial state.
3.If only one or two sequences lead to a nonzero output, a good way to start is to
construct a partial state graph for those sequences.
4.Another way to get started is to determine what sequences or groups of
sequences must be remembered by the circuit and set up states accordingly.
5.Each time you add an arrow to the state graph, determine whether it can go to
one of the previously defined states or whether a new state must be added.
6.Check your graph to make sure there is one and only one path leaving each
state for each combination of values of the input variables.
7.When your graph is complete, test it by applying the input sequences formulated
in part 1 and making sure the output sequences are correct.
Several examples of deriving state graphs or tables follow.
A sequential circuit has one input ( X) and one output ( Z). The circuit examines groupsFIGURE 14-12 State Input Sequences
S0 Reset or even 1’s
S1 Odd 1’s
S2 Even 1’s and ends in 0
S3 Even 1’s and 00 has occurred
S4 Odd 1’s and 00 has occurred
S5 Odd 1’s and ends in 000
0
000e d
b
g c f1
1
1
1S0
0S1
0
S2
0
1
Even 1’s Odd 1’s1S4
1S5
0
S3
0
of four consecutive inputs and produces an output Z/H110051 if the input sequence 0101 or
1001 occurs. The circuit resets after every four inputs. Find the Mealy state graph.
Solution A typical sequence of inputs and outputs is
X/H110050101 0010 1001 0100
Z/H110050001|0000|0001|0000Example 1
440 Unit 14
1
10
0
0
0
0
01
01
0
S3
S4S0
S1 S2
1
10
0
0
0
0
00
0
1
00
00
0
0
01
01
01
0
1
01
0
S3
S4S0
S1 S2
S5
S6FIGURE 14-13
Partial State
Graph for
Example 1
FIGURE 14-14
Complete State
Graph for
Example 1State Sequence Received
S0 Reset
S1 0
S2 1
S3 01 or 10
S4 010 or 100
State Sequence Received
S0 Reset
S1 0
S2 1
S3 01 or 10
S4 010 or 100
S5 Two inputs received, no 1 
output is possible
S6 Three inputs received, no 1
output is possibleThe vertical bars indicate the points at which the circuit resets to the initial state.
Note that an input sequence of either 01 or 10 followed by 01 will produce an output ofZ/H110051. Therefore, the circuit can go to the same state if either 01 or 10 is received. The
partial state graph for the two sequences leading to a 1 output is shown in Figure 14-13.
Note that the circuit resets to S
0when the fourth input is received. Next, we add
arrows and labels to the graph to take care of sequences which do not give a 1output, as shown in Figure 14-14.
The addition of states S
5andS6was necessary so that the circuit would not reset
toS0before four inputs were received. Note that once a 00 or 11 input sequence has
been received (state S5), no output of 1 is possible until the circuit is reset.
A sequential circuit has one input ( X) and two outputs ( Z1and Z2). An output
Z1/H110051 occurs every time the input sequence 100 is completed, provided that the
sequence 010 has never occurred. An output Z2/H110051 occurs every time the input
sequence 010 is completed. Note that once a Z2/H110051 output has occurred, Z1/H110051
can never occur but not vice versa. Find a Mealy state graph and table.Example 2
Solution A typical sequence of inputs and outputs is:
X/H11005100110010|
|1010010110100
Z1/H11005001000100|
|0000000000000
Z2/H11005000000001|
|0101001000010
Note that the sequence 100 occurs twice before 010 occurs, and Z1/H110051 each time.
However, once 010 occurs and Z2/H110051,Z1/H110050 even when 100 occurs again. Z2/H110051 all
five times that 010 occurs. Because we were not told to reset the circuit, 01010 meansthat 010 occurred twice.
We can begin to solve this problem by constructing the part of the state graph
which will give the correct outputs for the sequences 100 and 010. Figure 14-15(a)shows this portion of the state graph.Derivation of State Graphs and Tables 441
FIGURE 14-15
Partial Graphs for
Example 21
001
00
1
000
000
00
0
00
0
100
011
00
0
01
1
001
000
100
001
000
00
S4S0
S1 S3
S2 S4S0
S1 S3
S2
(a) (b)
State Description
S0 No progress on 100 No progress on 010
S1 Progress of 1 on 100 No progress on 010
S2 Progress of 10 on 100 Progress of 0 on 010 010 has never occurred
S3 No progress on 100 Progress of 0 on 010
S4 Progress of 1 on 100 Progress of 01 on 010
S5 Progress of 0 on 010
S6 Progress of 01 on 010 010 has occurred
S7 No progress on 010TABLE 14-5
State Descriptions
for Example 2An important question to ask at this point is, what does this circuit need to remember
to give the correct outputs? The circuit will need to remember how much progress hasbeen made on the sequence 010, so it will know when to output Z
2/H110051.The circuit will
also need to remember how much progress has been made on the sequence 100 andwhether 010 has ever occurred, so it will know when to output Z
1/H110051.
Keeping track of what is remembered by each state will help us make the correct
state graph. Table 14-5 will help us to do this. State S0is the initial state of the circuit, so
there is no progress on either sequence, and 010 has never occurred. State S1is the state
we go to when a 1 is received from S0, so in state S1, we have made progress on the
sequence 100 by getting a 1. In state S2, we have made progress on the sequence 100 by
getting 10. Similarly, states S3andS4represent progress of 0 and 01 toward 010. In S1,
442 Unit 14
there is no progress toward the sequence 010, and in S3, there is no progress toward the
sequence 100. However, in S2, we have received 10, so if the next two inputs are 1 and 0,
the sequence 010 will be completed. Therefore, in S2, we have not only made progress
of 10 toward 100, but we have also made progress of 0 toward 010. Similarly, in S4,w e
have made progress of 1 toward 100, as well as progress of 01 toward 010.
Using this information, we can fill in more of the state graph to get Figure 14-15(b).
If the circuit is in state S1and a 1 is received, then the last two inputs are 11. The pre-
vious 1 is of no use toward the sequence 100. However, the circuit will need to remem-ber the new 1, and there is a progress of 1 toward the sequence 100. There is noprogress on the sequence 010, and 010 has never occurred, but this is the same situa-tion as state S
1. Therefore, the circuit should return to state S1. Similarly, if a 0 is
received in state S3, the last two inputs are 00. There is a progress only of 0 toward the
sequence 010, there is no progress toward 100, and 010 has never occurred, so the cir-cuit should return to state S
3. In state S2, if a 0 is received, the sequence 100 is complete
and the circuit should output Z1/H110051. Then, there is no progress on another sequence
of 100, and 010 has still not occurred. However, the last input is 0, so there is progressof 0 toward the sequence 010. We can see from Table 14-5 that this is the same situa-tion as S
3, so the circuit should go to state S3. If, in state S2, a 1 is received, we have made
progress of 01 toward 010 and progress of 1 toward 100, and 010 has still not occurred.We can see from Table 14-5 that the circuit should go to state S
4.
If a 0 is received in state S4, the sequence 010 is complete, and we should output
Z2/H110051. At this point we must go to a new state ( S5) to remember that 010 has been
received so that Z1/H110051 can never occur again. When S5is reached, we stop looking
for 100 and only look for 010. Figure 14-16(a) shows a partial state graph that out-puts Z
2/H110051 when the input sequence ends in 010. In S5we have progress of 0 toward
010 and additional 0’s can be ignored by looping back to S5. In S6we have progress
of 01 toward 010. If a 0 is received, the sequence is completed, Z2/H110051 and we can go
back to S5because this 0 starts the 010 sequence again.
1
00
1
00
1
000
00
1
00
1
001
00
1
00
1
001
000
100
000
00
0
01
0
010
010
011
000
000
00
0
00
S4S0
S1 S3
S2S5
S6S7
S6S5
(a) Partial graph for 010 (b) Complete state graphFIGURE 14-16
State Graphs for
Example 2
If we receive a 1 in state S6, the 010 sequence is broken and we must add a new
state ( S7) to start looking for 010 again. In state S7we ignore additional 1’s, and
when a 0 is received, we go back to S5because this 0 starts the 010 sequence over
again. Figure 14-16(b) shows the complete state graph, and the corresponding tableis Table 14-6.
Derivation of State Graphs and Tables 443
TABLE 14-7Previous Output State
Input ( X1X2)( Z) Designation
00 or 11 0 S0
00 or 11 1 S1
01 0 S2
01 1 S3
10 0 S4
10 1 S5
Present Next State
State ZX1X2/H1100500 01 11 10
S0 0 S0S2S0S4
S1 1 S1S3S1S5
S2 0 S0S2S0S4
S3 1 S1S3S0S5
S4 0 S0S3S1S4
S5 1 S1S2S1S5A sequential circuit has two inputs ( X1,X2) and one output ( Z). The output remainsPresent Next State Output ( Z1Z2)
State X/H110050X/H110051 X/H110050X/H110051
S0 S3 S1 00 00
S1 S2 S1 00 00
S2 S3 S4 10 00
S3 S3 S4 00 00
S4 S5 S1 01 00
S5 S5 S6 00 00
S6 S5 S7 01 00
S7 S5 S7 00 00TABLE 14-6
Using this state designation, we can then set up a state table (Table 14-7). The six-row
table given here can be reduced to five rows, using the methods given in Unit 15.a constant value unless one of the following input sequences occurs:
(a) The input sequence X1X2/H1100501, 11 causes the output to become 0.
(b) The input sequence X1X2/H1100510, 11 causes the output to become 1.
(c) The input sequence X1X2/H1100510, 01 causes the output to change value.
(The notation X1X2/H1100501, 11 means X1/H110050,X2/H110051 followed by X1/H110051,X2/H110051.)
Derive a Moore state graph for the circuit.
Solution The only sequences of input pairs which affect the output are of length two.Therefore, the previous and present inputs will determine the output, and the circuitmust remember only the previous input pair. At first, it appears that three states arerequired, corresponding to the last input received being X
1X2/H1100501, 10 and (00 or 11).
Note that it is unnecessary to use a separate state for 00 and 11 because neither inputstarts a sequence which leads to an output change. However, for each of these statesthe output could be either 0 or 1, so we will initially define six states as follows:Example 3
444 Unit 14
The S4row of this table was derived as follows. If 00 is received, the input sequence
has been 10, 00, so the output does not change, and we go to S0to remember that the
last input received was 00. If 01 is received, the input sequence has been 10, 01, so theoutput must change to 1, and we go to S
3to remember that the last input received was
01. If 11 is received, the input sequence has been 10, 11, so the output should become1, and we go to S
1. If 10 is received, the input sequence has been 10, 10, so the output
does not change, and we remain in S4. Verify for yourself that the other rows in the
table are correct. The state graph is shown in Figure 14-17.
00, 11
00, 11
00, 1100, 1111
1110
00
0010
10010101
010101
10
1010S3
1S4
0
S1
1S5
1S0
0
S2
0FIGURE 14-17
State Graph for
Example 3
FIGURE 14-18
Serial Data
TransmissionSerial Data
ClockTransmitter Receiver
(a)
Serial Data
ClockTransmitter Receiver
(b)Clock
Recover y
Circuit14.4 Serial Data Code Conversion
As a final example of state graph construction, we will design a converter for serial
data. Binary data is frequently transmitted between computers as a serial stream ofbits.As shown in Figure 14-18(a), a clock signal is often transmitted along with the data,
so the receiver can read the data at the proper time. Alternatively [Figure 14-18(b)],
only the serial data is transmitted, and a clock recovery circuit (called a digital phase-locked loop) is used to regenerate the clock signal at the receiver.
Figure 14-19 shows four different coding schemes for serial data together with the
clock used to synchronize the data transmission. The example shows the transmissionof the bit sequence 0, 1, 1, 1, 0, 0, 1, 0. With the NRZ (non-return-to-zero) code, eachbit is transmitted for one bit time without any change.With the NRZI (non-return-to-zero-inverted) code, the data is encoded by the presence or absence of transitions inthe output signal. For each 0 in the original sequence, the bit transmitted is the sameas the previous bit transmitted. For each 1 in the original sequence, the bit transmit-ted is the complement of the previous bit transmitted.Thus, the preceding sequence isencoded as 0, 1, 0, 1, 1, 1, 0, 0. In other words, a 0 is encoded by no change in the trans-mitted value, and a 1 is encoded by inverting the previous transmitted value. For theRZ (return-to-zero) code, a 0 is transmitted as a 0 for one full bit time, but a 1 is trans-mitted as a 1 for the first half of the bit time and, then, the signal returns to 0 for thesecond half. For the Manchester code, a 0 is transmitted as 0 for the first half of the bittime and 1 for the second half, but a 1 is transmitted as 1 for the first half and 0 for thesecond half. Thus, the encoded bit always changes in the middle of the bit time. Whenthe original bit sequence has a long string of 1’s and 0’s, the Manchester code has moretransitions. This makes it easier to recover the clock signal.
We will design a sequential circuit which converts an NRZ-coded bit stream to
a Manchester-coded bit stream [Figure 14-20(a)]. In order to do this, we will use aclock, Clock2, that is twice the frequency of the basic clock [Figure 14-20(b)]. In thisway, all output changes will occur on the same edge of Clock2, and we can use thestandard synchronous design techniques which we have been using in this unit. First,we will design a Mealy circuit to do the code conversion. Note that if the NRZ bitis 0, it will be 0 for two Clock2 periods. Similarly, if the NRZ bit is 1, it will be 1 fortwo Clock2 periods. Thus, starting in the reset state [ S
0in Figure 14-20(c)], the only
two possible input sequences are 00 and 11. For the sequence 00, when the first 0 isreceived, the output is 0. At the end of the first Clock2 period, the circuit goes to S
1.
The input is still 0, so the output becomes 1 and remains 1 for one Clock2 period,and then the circuit resets to S
0. For the sequence 11, when the first 1 is received, theDerivation of State Graphs and Tables 445
FIGURE 14-19
Coding Schemes for
Serial Data
TransmissionBit Sequence 01 11 00 10
NRZ
NRZI
RZ
Manchester
Clock
1 bit
time
446 Unit 14
output is 1 for one Clock2 period and, then, the circuit goes to S2. Then, the output
is 0 for one Clock2 period, and the circuit resets to S0.
When we convert the Mealy graph to a state table [Figure 14-20(d)], the next state
ofS1with an input of 1 is not specified and is represented by a dash. Similarly, the next
state of S2with a 0 input is not specified. The dashes are like don’t-cares, in that we do
not care what the next state will be because the corresponding input sequence neveroccurs. A careful timing analysis for the Mealy circuit shows some possible glitches(false outputs) in the output waveform [Figure 14-20(b)]. The input waveform may
not be exactly synchronized with the clock, and we have exaggerated this condition in
the figure by shifting the input waveform to the right so that the input changes do notNRZ ( X)
Manchester
(Ideal)
Clock2
State
Z (Actual)0 0 00 00 00 1
0
S0S1S0S2S0S2S0S2S0S1S0S1S0S2S0S1000 00 0 0 11 1 1 1 1 1 111111 1 1
1 Clock PeriodZXNRZ Data
Clock2Manchester DataConversion
Circuit
(a) Conversion circuit
(b) Timing chart
(c) State graphS0
S2 S10
11
00
01
1FIGURE 14-20
Mealy Circuit for
NRZ to Manchester
Conversion
Present Next State Output ( Z)
State X/H110050X/H110051 X/H110050X/H110051
S0 S1 S2 01
S1 S0 –1 –
S2 – S0 –0
(d) State table
line up with the clock edges. For this situation, we will use the state table to analyze
the occurrence of glitches in the Zoutput. The first glitch shown in the timing chart
occurs when the circuit is in state S1, with an input X/H110050. The state table shows that
the output is Z/H110051, and when the clock goes low, the state changes to S0. At this time,
the input is still X/H110050, so Zbecomes 0. Then Xchanges to 1, Zbecomes 1 again, so a
glitch has occurred in the output during the time interval between the clock changeand the input change. The next glitch occurs in S
2with X/H110051 and Z/H110050. When the
clock goes low, the output momentarily becomes 1 until Xis changed to 0.
To overcome the possible glitch problem with the Mealy circuit, we will redesign
the circuit in Moore form (Figure 14-21). Because the output of a Moore circuit can-not change until after the active edge of the clock, the output will be delayed by oneclock period. Starting in S
0, the input sequence 00 takes us to state S1with a 0 out-
put and, then, to S2with a 1 output. Starting in S0,11 takes us to S3with a 1 output,
and the second 1 can take us back to S0which has a 0 output.To complete the graph,
we add the two arrows starting in S2. Note that a 1 input cannot occur in S1, and a 0
output cannot occur in S3, so the corresponding state table has two don’t-cares.Derivation of State Graphs and Tables 447
FIGURE 14-21
Moore Circuit for
NRZ to Manchester
Conversion
Present Next State Present
State X/H110050X/H110051 Output ( Z)
S0 S1 S3 0
S1 S2 –0
S2 S1 S3 1
S3 – S0 1
(c) State tableX (NRZ)
Clock2
State
Z0 0 00 00 00 1
0 0S0S1S2S3S0S3S0S3S0S1S2S1S2S3S0S1
000 00 0 0 11 1 1 1 1 111111 1 1
1 Clock Period
(a) Timing chart
(b) State graph11
10
00S0
0S1
0
S3
1S2
1
448 Unit 14
14.5 Alphanumeric State Graph Notation
When a state sequential circuit has several inputs, it is often convenient to label the
state graph arcs with alphanumeric input variable names instead of 0’s and 1’s. Thismakes it easier to understand the state graph and often leads to a simpler state graph.Consider the following example: A sequential circuit has two inputs ( F/H11005forward,
R/H11005reverse) and three outputs ( Z
1,Z2, and Z3). If the input sequence is all F’s, the
output sequence is Z1Z2Z3Z1Z2Z3. . . ; if the input sequence is all R’s, the output
sequence is Z3Z2Z1Z3Z2Z1....F i gure 14-22(a) shows a preliminary Moore state
graph that gives the specified output sequences. An arc label Fmeans that the corre-
sponding state transition occurs when F/H110051. The notation Z1within a state means
that the output Z1is 1, and the other outputs ( Z2andZ3) are 0. As long as Fis 1, the
graph cycles through the states S0,S1,S2,S0, . . . which gives the output sequence
Z1Z2Z3Z1. . . . When R/H110051 the state and output sequences occur in reverse order.
S0
Z1
FF
FR
RR
S2
Z3S1
Z2S0
Z1
FFF′R′
F′R′ F′R′ FF′RF′RF ′R
S2
Z3S1
Z2
(a) (b)FIGURE 14-22
State Graphs with
Variable Names on
Arc Labels
NS Output
PS FR/H1100500 01 10 11 Z1Z2Z3
S0 S0S2S1S1 100
S1 S1S0S2S2 010
S2 S2S1S0S0 001TABLE 14-8
State Table for
Figure 14-22At this point the state graph is not completely specified. What happens if both
inputs are 0? What happens if both are 1 at the same time? For example, in state S0
ifF/H11005R/H110051, does the circuit go to state S1or to S2? Because the circuit can only be
in one state at a time, we must assign a priority. We will assume that input Ftakes
priority over input R. We can then modify the state graph to implement this priori-
ty. By replacing Rwith F/H11032R, this means that the corresponding state transition only
occurs if R/H110051 and F/H110050. When F /H11005R/H110050, we will assume that the output should
not change. This can be accomplished by adding a self-loop to each state with an arclabel F/H11032R/H11032. The resulting state graph [Figure 14-22(b)] is completely specified for all
combinations of values of FandR, and if both inputs are 1, Ftakes precedence over
R. If we convert the graph to a table, the result is Table 14-8.
When we construct a state graph using input variable names on the arcs, we
should be careful to make sure that the graph is properly specified. To do this, we
can check the labels on all the arcs emanating from each state. For state S0, if we OR
together all of the arc labels, we simplify the result to get
F/H11001F/H11032R/H11001F/H11032R/H11032/H11005F/H11001F/H11032/H110051
This result indicates that for any combination of values of the input variables, one of the
labels must be 1.
If we AND together every possible pair of arc labels emanating from S0we get
F/H11080F/H11032R/H110050, F/H11080F/H11032R/H11032/H110050, F/H11032R/H11080F/H11032R/H11032/H110050
This result indicates that for any combination of input values, only one arc label can
have a value of 1.
In general, a completely specified state graph has the following properties: (1)
When we OR together all input labels on arcs emanating from a state, the resultreduces to 1. (2) When we AND together any pair of input labels on arcs emanatingfrom a state, the result is 0. Property (1) ensures that for every input combination, atleast one next state is defined. Property (2) ensures that for every input combination,no more than one next state is defined. If both properties are true, then exactly onenext state is defined, and the graph is properly specified. If we know that certain inputcombinations cannot occur, then an incompletely specified graph may be acceptable.
We will use the following notation on Mealy state graphs for sequential circuits:
X
iXj/ZpZqmeans if inputs XiandXjare 1 (we don’t care what the other input values
are), the outputs Zpand Zqare 1 (and the other outputs are 0). That is, for a circuit
with four inputs ( X1,X2,X3, and X4) and four outputs ( Z1,Z2,Z3, and Z4),X1X4/H11032/Z2Z3
is equivalent to 1--0/0110. This type of notation is very useful for large sequential cir-
cuits where there are many inputs and outputs.
We will use a dash to indicate that all inputs are don’t-cares. For example, an arc
label –/ Z1means that for any combination of input values, the indicated state transi-
tion will occur and the output Z1will be 1.
Programmed Exercise 14.1
Cover the lower part of each page with a sheet of paper and slide it down as you
check your answers. Write your answer in the space provided before looking at the
correct answers.
Problem :A clocked Mealy sequential circuit with one input ( X) and one output
(Z) is to be designed.The output is to be 0, unless the input is 0 following a sequence
of exactly two 0 inputs followed by a 1 input.
To make sure you understand the problem statement, specify the output
sequence for each of the following input sequences:
(a)X/H110050010
Z/H11005________________
(b)X/H11005... 1 0 0 1 0 (... means any input sequence not ending in 00)
Z/H11005... ________________Derivation of State Graphs and Tables 449
450 Unit 14
(c)X/H11005... 00010 Z/H11005... ________________
(d)X/H1100500100100010
Z/H11005________________
(e) Does the circuit reset after a 1 output occurs?
Answers (a)Z/H110050001 (b) Z/H11005... 00001 (c) Z/H11005... 00000
(d)Z/H1100500010010000 (e) No
Note that no 1 output occurs in answer (c) because there are three input 0’s 
in a row.
Add arrows to the following graph so that the sequence X/H110050010 gives the cor-
rect output (do not add another state).
AnswerS0 S1 S2 S3
S0 S1 S2 S30
1
0
01
00
0State Sequence Received
S0 (Reset)
S1 0 or 0010
S2
S3
S4
State Sequence Received
S0 (Reset)
S1 0 or 0010
S2 00
S3 001
S4 3 (or more)
consecutive 0’sNote that the arrow from S3returns to S1so that an additional input of 010 will
produce another 1 output.
Add a state to the preceding graph which corresponds to “three or more con-
secutive 0’s received.” Also complete the preceding table to indicate the sequencereceived which corresponds to each state.
S0 S1 S2
S4S30
1
0
0
0
0
0
01
00
0Answer
The preceding state graph is not complete because there is only one arrow leav-
ing most states. Complete the graph by adding the necessary arrows. Return to oneof the previously used states when possible.
Answer
Verify that this state graph gives the proper output sequences for the input
sequences listed at the start of this exercise. Write down the Mealy state table whichcorresponds to the preceding graph.
Answer
Present Next State Output
State 0 1 0 1
S0 S1 S0 00
S1 S2 S0 00
S2 S4 S3 00
S3 S1 S0 10
S4 S4 S0 00
Programmed Exercise 14.2
Problem :A clocked Moore sequential circuit should have an output of Z/H110051 if the
total number of 0’s received is an even number greater than zero, provided that twoconsecutive 1’s have never been received.S0 S1 S2
S4S30
1
0
0
0
0
0
01
0
1
01
01
0
1
0
0
0Derivation of State Graphs and Tables 451
452 Unit 14
To make sure that you understand the problem statement, specify the output
sequence for the following input sequence:
X/H11005 00001010110000
Z/H11005(0)_____________________________
a____this 0 is the initial output before any inputs have been received
Answer Z/H11005(0)01011001100000
Not e that onc e two cons ecutive 1’s have been received ,the output can n ever becom e
1a gain.
To start the state graph, consider only 0 inputs and construct a Moore state
graph which gives an output of 1 if the total number of 0’s received is an even num-ber greater than zero.
Answer
S00
0
00
1
110
S3
0S4
0S1
0S2
1State Sequence Received
S0 (Reset)
S1 Odd number of 0’s
S2 Even number of 0’s
S3 1
S4 11 (followed by 
any sequence)
S5
S6State Sequence received
S0 (Reset)
S1 Odd number of 0’s
S2
S3
S4S00
0 0
0S1
0S2
1
Now add states to the above graph so that starting in S0, if two consecutive 1’s are
received followed by any other sequence, the output will remain 0. Also, completethe preceding table to indicate the sequence received that corresponds to each state.
Answer
Derivation of State Graphs and Tables 453
Now complete the graph so that each state has both a 0 and 1 arrow leading
away from it. Add as few extra states to the graph as possible. Also, complete thepreceding table.
Answer
Verify that this state graph gives the proper output sequence for each input
sequence at the start of this exercise. Write down the Moore state table whichcorresponds to the preceding graph. (Note that a Moore table has only one out-put column.)
AnswerS000
0
00
00
1
1
111
11
0
S3
0S4
0S5
0S1
0S2
1S6
1
S5 — odd number of 0’s followed b y 1.
S6 — even number of 0’s followed b y 1.
Present Next State
State 0 1 Output
S0 S1S3 0
S1 S2S5 0
S2 S1S6 1
S3 S1S4 0
S4 S4S4 0
S5 S2S4 0
S6 S1S4 1
454 Unit 14
Programmed Exercise 14.3
Derive the state graph and table for a Moore sequential circuit which has an
output of 1 iff (1) an even number of 0’s have occurred as inputs and (2) an odd
number of (non overlapping) pairs of 1’s have occurred. For purposes of this
problem, a pair of 1’s consists of two consecutive 1’s. If three consecutive 1’soccur followed by a 0, the third 1 is ignored. If four consecutive 1’s occur, thiscounts as two pairs, etc.
(a) The first step is to analyze the problem and make sure that you understand
it. Note that both condition (1) and condition (2) must be satisfied in orderto have a 1 output. Consider condition (1) by itself. Would condition (1) besatisfied if zero 0’s occurred? ____________
If one 0 occurred? ____________ Two 0’s? ____________ Three 0’s?
____________.
(Hint : Is zero an even or odd number? ____________ )
(b) How many states would it take to determine if condition (1) by itself is sat-
isfied, and what would be the meaning of each state?
______________________________________________________
(c) Now consider condition (2) by itself. For each of the following patterns,
determine whether condition (2) is satisfied:
010____________ 0110 ____________ 01110 ____________
011110 ____________ 01010 ____________ 011010 ____________
0110110 ____________
Now check your answers to (a), (b), and (c).
Answers to (a) yes, no, yes, no, even
Answers to (b) two states: even number of 0’s, odd number of 0’s
Answers to (c) From left to right: no, yes, yes, no, no, yes, no
(d) Consider condition (2) by itself and consider an input sequence of
consecutive 1’s. Draw a Moore state diagram (with only 1 inputs) whichwill give a 1 output when condition (2) is satisfied. State themeaning of each of the four states in your diagram (for example, oddpairs of 1’s).
Answer to (d)
S0/H11005even pairs of 1’s, S1/H11005even pairs of 1’s /H11001one 1,
S2/H11005odd pairs of 1’s, S3/H11005odd pairs of 1’s /H11001one 1
(e) For the original problem, determine the sequence for Zfor the following
example:
X/H1100511001111100011110
Z/H110050 ________________________________
Now turn to the next page and check your answer.
Answer to (e) X/H1100511001111100011110
Z/H11005001011001101000001
(f) Considering that we must keep track of both even or odd 0’s, and even or odd
pairs of 1’s, how many states should the final graph have? ____________
(g) Construct the final Moore state graph. Draw the graph in a symmetric manner
with even 0’s on the top side and odd 0’s on the bottom side. List the meanings ofthe states such as
S
0/H11005even 0’s & even pairs of 1’s.
(h) Check your answer using the test sequence from part (e). Then, check your
answers below.
Answer to (f) Eight states1
11 1 S0
0S1
0S2
1S3
1Derivation of State Graphs and Tables 455
456 Unit 14
Answer to (g) S0/H11005even 0’s and even pairs of 1’s, S1/H11005even 0’s and even pairs of 1’s /H11001one 1,
S2/H11005even 0’s and odd pairs of 1’s, S3/H11005even 0’s and odd pairs of 1’s /H11001one 1,
S4/H11005odd 0’s and even pairs of 1’s, S5/H11005odd 0’s and even pairs of 1’s /H11001one 1,
S6/H11005odd 0’s and odd pairs of 1’s, S7/H11005odd 0’s and odd pairs of 1’s /H11001one 1
Problems
14.4 A sequential circuit has one input and one output. The output becomes 1 and
remains 1 thereafter when at least two 0’s and at least two 1’s have occurred as
inputs, regardless of the order of occurrence. Draw a state graph (Moore type) forthe circuit (nine states are sufficient). Your final state graph should be neatly drawnwith no crossed lines.
14.5 A sequential circuit has one input ( X) and two outputs ( Z
1andZ2). An output Z1/H110051
occurs every time the input sequence 010 is completed, provided that the sequence 100has never occurred. An output Z
2/H110051 occurs every time the input 100 is completed.
Note that once a Z2/H110051 output has occurred, Z1/H110051 can never occur but notvice versa.
Find a Mealy state graph and state table (minimum number of states is eight).
14.6 A sequential circuit has two inputs ( X1andX2) and one output ( Z).The output begins
as 0 and remains a constant value unless one of the following input sequences occurs:(a) The input sequence X
1X2/H1100501, 00 causes the output to become 0.
(b) The input sequence X1X2/H1100511, 00 causes the output to become 1.
(c) The input sequence X1X2/H1100510, 00 causes the output to change value.
Derive a Moore state table.
14.7 A sequential circuit has one input ( X) and one output ( Z).
Draw a Mealy state graph for each of the following cases:(a) The output is Z/H110051 iff the total number of 1’s received is divisible by 3. (Note :0 ,3 ,
6, 9, . . . are divisible by 3.)1
111 1
11 10
00 0 0 00
0S0
0
S4
0S1
0
S5
0S2
1
S6
0S3
1
S7
0
(b) The output is Z/H110051 iff the total number of 1’s received is divisible by 3 andthe
total number of 0’s received is an even number greater than zero (nine statesare sufficient).
14.8 A sequential circuit has two inputs and two outputs. The inputs ( X
1and X2) repre-
sent a 2-bit binary number, N. If the present value of Nis greater than the previous
value, then Z1is 1. If the present value of Nis less than the previous value, then Z2
is 1. Otherwise, Z1andZ2are 0. When the first pair of inputs is received, there is no
previous value of N, so we cannot determine whether the present Nis greater than
or less than the previous value; therefore, the “otherwise” category applies.(a) Find a Mealy state table or graph for the circuit (minimum number of states,
including starting state, is five).
(b) Find a Moore state table for the circuit (minimum number of states is 11).
14.9 (a) Derive the state graph and table for a Mealy sequential circuit which converts
a serial stream of bits from NRZ code to NRZI code. Assume that the clockperiod is the same as the bit time as in Figure 14-19.
(b) Repeat (a) for a Moore sequential circuit.(c) Draw a timing diagram for your answer to (a), using the NRZ waveform in
Figure 14-19 as the input waveform to your circuit. If the input changes occur slight-ly after the clock edge, indicate places in the output waveform where glitches (falseoutputs) can occur.
(d) Draw the timing diagram for your answer to (b), using the same input waveform
as in (c).
14.10 For the following state graph, construct the state table, and demonstrate that it is
completely specified.
14.11 Design a sequential circuit which will output Z/H110051 for exactly four clock cycles each
time a person pushes a button (which sets X/H110051). The clock for a digital circuit is
usually much faster than a person’s finger! The person probably will not have releasedthe button by the time four clock cycles have passed, so Xmay still be 1 when the four
Z/H110051 outputs have been generated. Therefore, after Zis 1 for four clock cycles, Z
should go to 0, until Xreturns to 0 and then becomes 1 again. Design a Mealy state
graph for this circuit, using the alphanumeric state graph notation given in Section 14.5.
14.12 (a) A Moore sequential circuit has one input ( x) and one output ( z).z/H110051 if and
only if the most recent input was
1 and it was preceded by exactly two 0’s.
Derive a state table for the circuit.
(b) Repeat for a Mealy circuit, i.e., z/H110051 if and only if the most recent input is 1 and
it was preceded by exactly two 0’s. Derive a state table for the circuit.S0 S1
AC′
DFA′C′
DE AB′
E
AB
FA′
D
C
0Derivation of State Graphs and Tables 457
458 Unit 14
14.13 (a) A Mealy sequential circuit has one input ( x) and one output ( z).zcan be 1 when
the fourth, eighth, twelfth, etc. inputs are present, and z/H110051 if and only if the
most recent input combined with the preceding three inputs was not a validBCD encoding for a decimal digit; otherwise, z/H110050. Assume the BCD digits are
received most
significant bit first. Derive a state table for the circuit. (Eight
states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if, after the fourth, eighth,
twelfth, etc. inputs have been received, the previous four inputs were not a validBCD digit. (Nine states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.14 (a) A Mealy sequential circuit has one input ( x) and one output ( z).z/H110051 if and
only if the most recent input, combined with the preceding three inputs, was nota valid BCD encoding of a decimal digit; otherwise, z/H110050.Assume the BCD dig-
its are received most
significant bit first. Derive a state table for the circuit.
(Seven states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if the previous four inputs
were not a valid BCD digit. (Thirteen states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.15 (a) A Mealy sequential circuit has one input ( x) and one output ( z).zcan be 1 when
the fourth, eighth, twelfth, etc. inputs are present, and z/H110051 if and only if the most
recent input combined with the preceding three inputs was not a valid BCD encod-ing of a decimal digit; otherwise, z/H110050. Assume the BCD digits are received least
significant bit first. Derive a state table for the circuit. (Six states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if, after the fourth, eighth, twelfth,
etc. inputs have been received, the previous four inputs were not a valid BCD digit.
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.16 (a) A Mealy sequential circuit has one input ( x) and one output ( z).z/H110051 if and
only if the most recent input, combined with the preceding three inputs, was nota valid BCD encoding of a decimal digit; otherwise, z/H110050.Assume the BCD dig-
its are received least
significant bit first. Derive a state table for the circuit.
(Three states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if the previous four inputs
were not a valid BCD digit. (Four states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.17 (a) A Mealy sequential circuit has one input ( x) and one output ( z).zcan be 1 when
the fourth, eighth, twelfth, etc. inputs are present, and z/H110051 if and only if the most
recent input, combined with the preceding three inputs, was not a valid excess-3
encoding of a decimal digit; otherwise, z/H110050. Assume the excess-3 digits are
received most significant bit first. Derive a state table for the circuit. (Ten states
are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if, after the fourth, eighth,
twelfth, etc. inputs have been received, the previous four inputs were not a validexcess-3 digit. (Eleven states are sufficient.)
(c) Is it possible to for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.18 (a) A Mealy sequential circuit has one input ( x) and one output ( z).z/H110051 if and
only if the most recent input, combined with the preceding three inputs, was nota valid excess-3 encoding of a decimal integer; otherwise, z/H110050. Assume the
excess-3 digits are received most
significant bit first. Derive a state table for the
circuit. (Eight states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if the previous four inputs
were not a valid excess-3 digit. (Fourteen states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.19 (a) A Mealy sequential circuit has one input ( x) and one output ( z).zcan be 1 when
the fourth, eighth, twelfth, etc. inputs are present, and z/H110051 if and only if the
most recent input, combined with the preceding three inputs, was not a validexcess-3 encoding of a decimal digit; otherwise, z/H110050. Assume the excess-3 dig-
its are received least
significant bit first. Derive a state table for the circuit.
(Nine states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if, after the fourth, eighth,
twelfth, etc. inputs have been received, the previous four inputs were not a validexcess-3 digit. (Ten states are sufficient.)
(c) Is it possible to for a Moore circuit to generate the correct output while the
fourth input bit is present rather than after it has been received? Explain youranswer.
14.20 (a) A Mealy sequential circuit has one input ( x) and one output ( z).z/H110051 if and
only if the most recent input combined with the preceding three inputs was nota valid excess-3 encoding of a decimal digit; otherwise, z/H110050. Assume the
excess-3 digits are received least
significant bit first. Derive a state table for the
circuit. (Six states are sufficient.)
(b) Repeat for a Moore circuit, i.e., z/H110051 if and only if the previous four inputs
were not a valid excess-3 digit. (Eight states are sufficient.)
(c) Is it possible for a Moore circuit to generate the correct output while the fourth
input bit is present rather than after it has been received? Explain your answer.
14.21 A sequential circuit has one input and one output.The output becomes 1 and remains
1 thereafter when at least one 1 and three 0’s have occurred as inputs, regardless ofthe order of occurrence. Draw a state graph (Moore type) for the circuit (eight statesare sufficient). Your final state graph should be neatly drawn with no crossed lines.Derivation of State Graphs and Tables 459
460 Unit 14
14.22 A sequential circuit has one input ( X) and two outputs ( Z1and Z2). An output
Z1/H110051 occurs every time the input sequence 100 is completed provided that the
sequence 011 has never occurred. An output Z2/H110051 occurs every time the input
011 is completed. Note that once a Z2/H110051 output has occurred, Z1/H110051 can never
occur but notvice versa. Find a Mealy state graph and state table (minimum num-
ber of states is eight).
14.23 A sequential circuit has two inputs ( X1and X2) and one output ( Z). The output
begins as 0 and remains a constant value unless one of the following inputsequences occurs:(a) The input sequence X
1X2/H1100511, 10 causes the output to become 0.
(b) The input sequence X1X2/H1100500, 10 causes the output to become 1.
(c) The input sequence X1X2/H1100501, 10 causes the output to toggle.
Derive a Moore state table and state graph.
14.24 A sequential circuit has one input ( X) and one output ( Z).
Draw a Mealy state graph for each of the following cases:(a) The output is Z/H110051 iff the total number of 1’s received is divisible by 4.
(Note : 0, 4, 8, 12, . . . are divisible by 4.)
(b) The output is Z/H110051 iff the total number of 1’s received is divisible by 4 and the
total number of 0’s received is an odd number (eight states are sufficient).
14.25 A sequential circuit has two inputs and two outputs. The inputs ( X
1and X2) repre-
sent a 2-bit binary number, N. If the present value of Nplus the previous value of N
is greater than 2, then the Z1is 1. If the present value of Ntimes the previous value
ofNis greater than 2, then Z2is 1. Otherwise, Z1and Z2are 0. When the first pair
of inputs is received, use 0 as the previous value of N.
(a) Find a Mealy state table or graph for the circuit (minimum number of states is four).(b) Find a Moore state table for the circuit (minimum number of states is 10, but
any correct answer with 16 or fewer states is acceptable).
14.26 A Moore sequential circuit has one input and one output. When the input sequence
011 occurs, the output becomes 1 and remains 1 until the sequence 011 occurs againin which case the output returns to 0. The output then remains 0 until 011 occurs athird time, etc. For example, the input sequence
X/H11005 01011010110100111
has the output
Z/H11005( 0 ) 00001111100000011
Derive the state graph (six states minimum).
14.27 Work Problem 14.26 if the input sequence 101 causes the output to change value. For
example, the input sequence
X/H11005 01010100101011010
has the output
Z/H11005( 0 ) 00011000001100011
(six states minimum)
14.28 A Mealy sequential circuit has two inputs and one output. If the total number of
0’s received is /H113504 and at least three pairs of inputs have occurred, then the out-
put should be 1 coincident with the last input pair in the sequence. Whenever a 1
output occurs, the circuit resets. Derive a state graph and state table. Specify themeaning of each state. For example, S
0means reset, S1means one pair of inputs
received but no 0’s received, etc.
Example:
Input sequence X1/H110051110001110001100010
X2/H110051000001111110100010
Output sequence: Z/H110050001001000001001001
14.29 A Moore sequential circuit has one input and one output. The output should be 1 if
the total number of 1’s received is odd and the total number of 0’s received is aneven number greater than 0. Derive the state graph and table (six states).
14.30 A Mealy sequential circuit has one input ( X) and two outputs ( Z
1and Z2). The cir-
cuit produces an output of Z1/H110051 whenever the sequence 011 is completed, and an
output of Z2/H110051 whenever the sequence 0111 is completed. Derive the state graph
and table.
14.31 A Moore sequential circuit has two inputs ( X1andX2) and one output ( Z).Zbegins
at 0. It becomes 1 when X1/H110051 and X2/H110051 either concurrently, or one after the
other (in either order). Zreturns to zero when X1/H11005X2/H110050.The following input and
output sequence should help you understand the problem:
X1/H11005 01001000110110
X2/H11005 00110011000100
Z/H11005( 0 ) 00111000110110
Give the Moore state graph and table.
14.32 A Mealy sequential circuit has one input ( X) and one output ( Z).The circuit should
transmit its input, except that it should prevent the sequence 00110 from occurring.SoZshould be the same as X, except that if the input sequence 00110 occurs, Z
should be 1 rather than 0 when the last 0 is received, so that the sequence X/H1100500110
is replaced with Z/H1100500111. Derive the state graph and table.
14.33 A Moore sequential circuit has one input and one output.The output is 1 if and only
if both of the following conditions are met:(a) The input sequence contains exactly two groups of 1’s, and(b) Each of these groups contains exactly two 1’s.Derivation of State Graphs and Tables 461
462 Unit 14
Each group of 1’s must be separated by at least one 0. A single 1 is considered a
group of 1’s containing one 1. For example, the sequence
X/H110050110001101110
satisfies both conditions after the first two pairs of 1’s. However, when more 1’s
appear, condition (a) is no longer satisfied. Therefore, the output sequence should be
Z/H11005( 0 )0000000110000
On the other hand, the sequence
X/H1100510110110
never satisfies condition (b), because the first group of 1’s contains only one 1.
Besides, after the second pair of 1’s, (a) is no longer satisfied because the inputsequence contains three groups of 1’s. Therefore, the output should always be 0.
Z/H11005( 0 )00000000
Derive a state graph and table.
14.34 A sequential circuit has an input ( X) and an output ( Z). The output is the same as
the input was two clock periods previously. For example,
X/H110050101101011010001
Z/H110050001011010110100
The first two values of Zare 0. Find a Mealy state graph and table for the circuit.
14.35 A sequential circuit has an input ( X) and an output ( Z). The output is the same as
the input was three clock periods previously. For example,
X/H110050101101011010001
Z/H110050000101101011010
The first three values of Zare 0. Find a Mealy state graph and table for the circuit.
14.36 (a) Construct a Moore state table for the circuit of Problem 14.34. The initial
outputs are 0.
(b) How many states are required in a Moore state table for the circuit of Problem
14.35? Explain
14.37 A sequential circuit has an input ( X) and two outputs ( SandV).Xrepresents a 4-bit
binary number Nwhich is input least significant bit first. Srepresents a 4-bit binary
number equal to N/H110012, which is output least significant bit first. At the time the
fourth input occurs, V/H110051 if N/H110012 is too large to be represented by four bits; other-
wise, V/H110050. The circuit always resets after the fourth bit of Xis received. Find a
Mealy state graph and table for the circuit.
Example: X/H110050111 (binary 14 with the least significant bit first)
S/H110050000 (because 14 /H110012/H1100516, and 16 requires 5 bits)
V/H110050001
Derivation of State Graphs and Tables 463
14.38 A sequential circuit has an input ( X) and two outputs ( DandB).Xrepresents a 4-bit
binary number Nwhich is input least significant bit first. Drepresents a 4-bit binary
number equal to N/H110022, which is output least significant bit first.At the time the fourth
input occurs, B/H110051 if N/H110022 is less than 0; otherwise B/H110050. The circuit always resets
after the fourth bit of Xis received. Find a Mealy state graph and table for the circuit.
Example: X/H110050001 1000 1100
D/H110050110 1111 1000
B/H110050000 0001 0000
14.39 A sequential circuit has an input ( X) and outputs ( Yand Z).YZrepresents a 2-bit
binary number equal to the number of 1’s that have been received as inputs. Thecircuit resets when the total number of 1’s received is 3, or when the total numberof 0’s received is 3. Find a Moore state graph and table for the circuit.
14.40 A sequential circuit has an input Xand outputs ( Yand Z).YZrepresents a 2-bit
binary number equal to the number of pairs of adjacent 1’s that have been receivedas inputs. For example, the input sequence 0110 contains one pair, the sequence01110 two pairs, and the sequence 0110111 contains three pairs of adjacent 1’s. Thecircuit resets when the total number of pairs of 1’s received reaches four. Find a
Moore state graph and table for the circuit.
Examples:
Input sequence: X/H110050 1 0 1 1 0 1 1 1 0 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 0 0 1 0
Output sequences: Y/H110050 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1
Z/H110050 0 0 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
Input sequence: X/H110051 1 1 1 1 1 1 1
Output sequences: Y/H110050 0 1 1 0 0 0 1
Z/H110050 1 0 1 0 0 1 0
(Hint : Be sure that the circuit resets as shown in the examples.)
14.41 A sequential circuit with one input and one output is used to stretch the first two
bits of a 4-bit sequence as follows:
Input Output
00XX 0000
01XX 001110XX 110011XX 1111
After every 4 bits, the circuit resets. Find a Mealy state graph and table for the cir-
cuit. The third and fourth bits of the input sequence can be either 1 or 0, so makesure that the circuit will work for all possible combinations.
14.42 A sequential circuit is to be used to control the operation of a vending machine which
dispenses a $0.25 product. The circuit has three inputs ( N,D, and Q) and two outputs
(RandC). The coin detector mechanism in the vending machine is synchronized with
464 Unit 14
the same clock as the sequential circuit you are to design. The coin detector outputs a
single 1 to the N,D, or Qinput for every nickel, dime, or quarter, respectively, that
the customer inserts. Only one input will be 1 at a time. When the customer hasinserted at least $0.25 in any combination of nickels, dimes, and quarters, the vendingmachine must give change and dispense the product. The coin return mechanismgives change by returning nickels to the customer. For every 1 output on C, the coin
return mechanism will return one nickel to the customer. The product is dispensedwhen the circuit outputs a single 1 on output R. The circuit should reset after dispens-ing the product.
Example: The customer inserts a nickel, a dime, and a quarter. The circuit inputs
and outputs could look like this:
Inputs: N/H1100500010000000000000
D/H1100500000001000000000
Q/H1100500000000001000000
Outputs: R/H1100500000000000000100
C/H1100500000000000111000
Note that any number of 0’s can occur between 1 inputs.Derive a Moore state table for the sequential circuit, and for each state indicate howmuch money the customer has inserted or how much change is due.
14.43 (a) Derive the state graph and table for a Mealy sequential circuit that converts a
serial stream of bits from Manchester code to NRZ code. Assume that a doublefrequency clock (Clock2) is available.
(b) Repeat (a) for a Moore sequential circuit.(c) Draw a timing diagram similar to Figure 14-20(b) for your answer to (a), using
the Manchester waveform in Figure 14-20(b) as the input waveform to yourcircuit. If the input changes occur slightly after the clock edge, indicate placesin the output waveform where glitches (false outputs) can occur. If possible,assign the don’t-cares in the output part of your state table to eliminate someof the glitches.
(d) Draw the timing diagram for your answer to (b), using the same input waveform
as in (c).
14.44 Design a sequential circuit to control a phone answering machine. The circuit
should have three inputs ( R,A, and S) and one output ( Z).R/H110051 for one clock
cycle at the end of each phone ring. A/H110051 when the phone is answered. Sselects
whether the machine should answer the phone after two rings ( S/H110050) or four
rings ( S/H110051). To cause the tape recorder to answer the phone, the circuit should
set the output Z/H110051 after the end of the second ( S/H110050) or fourth ( S/H110051) ring, and
hold Z/H110051 until the recorder circuit answers the phone (i.e., when Agoes to 1). If
a person answers the phone at any point, Awill become 1, and the circuit should
reset. Assume that Sis not changed while the phone is counting rings. Give a
Moore state graph for this circuit, using the alphanumeric state graph notationgiven in Section 14.5.
14.45 For the following state graph, derive the state table.
14.46 There are two errors in the state graph shown. One state is not completely specified
for one combination of X1and X2. In another state, there is a contradiction for one
combination of X1and X2. Correct the state graph by making two minor changes.
Demonstrate that the modified state graph is completely specified.
X2X1′ X2
X1′ X2′ S0
X1′ X2
X1Z1X1′ X2′ 
X1′ X2′ X1X2
X2S1
Z2S2
Z3S1 S2
X1′ X2/Z1Z2X1′ X2/0
X1′ X2′/0 X1′ X2′/0S0X1′ X2/Z1
X1′ X2′/Z2
X1/Z2
X1/0 X1/0Derivation of State Graphs and Tables 465
466CHAPTER
00Reduction of State Tables 
State Assignment
UNIT
15
Objectives
1.Define equivalent states, state several ways of testing for state equiva-
lence, and determine if two states are equivalent.
2.Define equivalent sequential circuits and determine if two circuits are
equivalent.
3.Reduce a state table to a minimum number of rows.
4.Specify a suitable set of state assignments for a state table, eliminating
those assignments which are equivalent with respect to the cost of realiz-ing the circuit.
5.State three guidelines which are useful in making state assignments, and
apply these to making a good state assignment for a given state table.
6.Given a state table and assignment, form the transition table and derive
flip-flop input equations.
7.Make a one-hot state assignment for a state graph and write the next-
state and output equations by inspection.
Reduction of State Tables State Assignment 467
1.Study Section 15.1, Elimination of Redundant States .
2.Study Section 15.2, Equivalent States .
(a) State in words the meaning of /H92611(p,X)/H11005/H92612(q,X).
(b) Assuming that N1and N2are identical circuits with the following state
graph, use Definition 15.1 to show that pisnotequivalent to q. [Calculate
/H9261(p,X) and /H9261(q,X) for X/H110050,X/H110051,X/H1100500,X/H1100501, etc.]
(c) Suppose you were given two sequential circuits ( N1andN2) in black boxes
with only input and output terminals available. Each box has a reset button.The button on N
1resets it to state pand the button on N2resets it to state q.
Could you experimentally determine if p/H11005qusing Definition 15.1? Explain.
(d) Apply Theorem 15.1 to show that in Table 15-6, S2[S3.
(e) Note the difference between the definition of state equivalence
(Definition 15.1) and the state equivalence theorem (Theorem 15.1). The
definition requires an examination of output sequences but notnext states,
while the theorem requires looking at both the output and next state for
each single input. Make sure that you know both the definition and thetheorem. Write out the definition of equivalent states:
Write out the state equivalence theorem:
When you check your answers, note that the theorem requires equal outputs
andequivalent next states. This distinction between equal and equivalent is
very important. For example, in the following state table, no two states haveequal next states, but we can still reduce the table to two states, becauser qp
1
1
1
01
00
0
0
00
0Study Guide
468 Unit 15
some next states are equivalent. Note that the state equivalence theorem
tells us that S3KS0ifS3KS0. When this happens, we may say S3KS0.W h a t
other pair of states are equivalent?
Present
State Next State Z
S0 S1 S0 0
S1 S0 S2 1
S2 S3 S2 1
S3 S1 S3 0
3.Study Section 15.3, Determination of State Equivalence Using an Implication Table .
(a) Fill in the following implication chart to correspond to the given table (first
pass only).
Your answer should have eight squares with X’s, two squares with one
implied pair, and four squares with two implied pairs. There should be acheck in square f-gbecause the only nontrivial implication of f-gisf-gitself.
(b) Now go through your chart and eliminate all nonequivalent pairs (several
passes may be required).What is the only equivalent state pair? Accordingto the state equivalence theorem, why is b[d? Why is a[b?
(c) Find all of the equivalent states in the following table using an implica-
tion table:a bc d fgfdcbPresent
Next State Output
X/H1100501 X/H1100501
aa b 00
bd a 01
ca b 01
dg f 00
fd g 01
gd f 01
Present
Next State Output
X/H1100501 X/H1100501
ab c 01
bd b 00
ce a 01
dd e 00
ee e 00
(You should have found four pairs of equivalent states. If you found only
two pairs, reread Section 15.3).Reduce the table to two rows.
Reduction of State Tables State Assignment 469
4.Study Section 15.4, Equivalent Sequential Circuits . Define equivalent sequential
circuits. (Make sure you know the difference between equivalent states and
equivalent circuits .)
5.Work Problems 15.1, 15.2, and 15.3 using the methods of Sections 15.3 and 15.4.
When forming the implication charts for state equivalence, follow the conventionused in the text. That is, label the bottom of the chart starting with the first stateand ending with the next-to-last state. Then, label the left side of the chart start-ing with the second state at the top and ending with the last state at the bottom.
6.Study Section 15.5, Incompletely Specified State Tables .
(a) State two reasons why a state table might be incompletely specified.
(b) For Table 15-5(a), fill in the don’t-care outputs in the X/H110050 column as 1 and
0 (instead of 0 and 1). Show that with this choice of outputs, the minimumnumber of states is three.
7.Read Section 15.6, Derivation of Flip-Flop Input Equations .
(a) Derive J
Cand KCfrom the C/H11001map of Figure 15-9(a).
(b) Plot the map for the output function ( Z) from the transition table of Table
15-6(b) and derive the minimum equation for Z.
00 01 11 10
00
01
11
1000 01 11 10
00
01
11
1000 01 11 10
00
01
11
10
470 Unit 15
(c) Derive the J-Kinput equations for flip-flop Afrom the next-state map of
Figure 15-10. Your answers should be
JA/H11005X2B, KA/H11005X2/H11032B/H11032
(d) Work Problem 15.4.
8.Study Section 15.7, Equivalent State Assignments .
(a) Fill in the missing assignments (numbered 8 through 18) in Table 15-8.
First, list the remaining assignments with 01 in the first row and then theassignments with 10 in the first row.
(b) Why is it unnecessary to try all possible state assignments to be assured of
finding a minimum cost circuit?
(c) For symmetrical flip-flops, why is it always possible to assign all 0’s to the
starting state and still obtain a minimum circuit?
(d) Complete the following transition table for Table 15-9 using assignment A.
Then, complete the next-state maps and derive D
1and D2.
Starting with the equations for assignment A, replace all of the 1’s with 2’s
and all 2’s with 1’s.Verify that the resulting equations are the same as thosefor assignment B.
Starting with the JandKequations for assignment A, replace each Qwith
Q/H11032and vice versa.Then, replace the equations for Jwith the corresponding
Kequations and vice versa. (This corresponds to the transformation given
in Figure 15-12.) Verify that the resulting equations are the same as forassignment C.
Complement the right-hand side of the Dequations for assignment Aand,
then, replace each Qwith Q/H11032and vice versa. (This corresponds to the01
XX00Q1Q2X
01
11
10
Q1  = D1+01
XX00Q1Q2X
01
11
10
Q2  = D2+Q1Q2 X/H1100501
00 00 10
0110
Reduction of State Tables State Assignment 471
transformation given in Figure 15-13.) Verify that the resulting equations
are the same as for assignment C.
(e) Show that each of the assignments in Table 15-8 is equivalent to one of the
assignments in Table 15-10.
(f) Why are the following two state assignments equivalent in cost?
A 000 011
B 001 111
C 011 101
D 101 110
E 100 010
F 010 001
G 110 000
(g) Show that each of the following assignments can be generated from Table
15-10 by permuting and/or complementing columns:
10 11 0101 01 1100 00 0011 10 10
(h) Why is the trial-and-error method of state assignment of limited usefulness?
(i) Read Problem 15.5, and then answer the following questions regarding
state assignments before you work the problem:(1) Why should a column notbe assigned all 0’s or all 1’s?
(2) Why should two columns notbe given the same assignment?
(3) Does interchanging two columns affect the cost of realizing the circuit?(4) Does interchanging two rows affect the cost?(5) Why is an assignment which has two identical rows invalid?(6) Consider the following two assignments (the number at the top of
each column is the decimal equivalent of the binary number in thecolumn):
(1) (3) (5) (3) (1) (5)
000 00 0001 00 1010 10 0111 11 1
If we try the column assignment (1) (3) (5), why is it unnecessary to try(3) (1) (5)?
472 Unit 15
Why is it desirable to assign the column values in increasing numerical order?
9.Study Section 15.8, Guidelines for State Assignment .
(a) Why do the guidelines for making state assignments help in making an
economical assignment?
(b) What should be done if all the adjacencies specified by the guidelines can-
not be satisfied?
(c) The state assignment guidelines for Figure 15-14(a) indicate that the fol-
lowing sets of states should be given adjacent assignments:
(1) ( S0,S1,S3,S5)(S3,S5)(S4,S6)(S0,S2,S4,S6)
(2) ( S1,S2)(S2,S3)(S1,S4)(S2,S5)2X(S1,S6)2X
Because the adjacencies from guideline 1 are generally most important, wewill start by placing one of the largest groups from guideline 1 in four adja-cent squares:
Note that ( S
3,S5) is also satisfied by this grouping. Place S2,S4, and S6in the
remaining squares to satisfy as many of the remaining guidelines as possible.Keeping in mind that groups labeled 2 Xshould be given preference over
groups which are not repeated. Compare your answer with Figure 15-14(b).
(d) Complete the transition table for the state table of Figure 15-16(a), using
the assignment of Figure 15-16(b).S0
S1
S3
S5
Q1/H11001Q2/H11001Q3/H11001
Q1Q2Q3 X/H1100501 0 1
a0 0 0 000 100 0 0
b1 1 1 011 110 0 1
c1 0 0 100 000 0 0
(e) Complete the next-state and output maps, and verify that the cost of real-
izing the corresponding equations with an AND-OR gate circuit is 13gates and 35 gate inputs.
(f) Find J
1and K1from the Q1/H11001map.
J1/H11005______________________
K1/H11005______________________
Reduction of State Tables State Assignment 473
10. Work Problems 15.6, 15.7, and 15.8.
11. Study Section 15.9, Using a One-Hot State Assignment .
(a) A one-hot state assignment does not usually give a solution that uses less
hardware because of the extra flip-flops required. In what situation is itoften advantageous to use it anyway?
(b) It is easy to derive flip-flop input equations directly from a state graph for
a one-hot state assignment by inspecting the arcs leading into a given state.Give the next-state equation for Q
5. Only the parts of the state graph which
are needed to find Q5/H11001are given.
(c) For the state graph in Figure 15-19 and the one-hot state assignment
shown, determine the next-state equations for Q2and Q3.
Q2/H11001/H11005____________ and Q3/H11001/H11005________________________
(d) For the state graph in Figure 15-19 and the one-hot state assignment
shown, determine the output equations for Adand Done.
Ad/H11005___________ and Done /H11005___________
(e) Work Problem 15.9.
12. When you are satisfied that you can meet all of the objectives, take the readi-
ness test.S2 S5X′
0X
0X′Y
P,Q2Q3
Q1+0 1 0 100 01 11 10
X X
0 100XQ1
01
11
10Q2Q3
Q2+0 0 0 000 01 11 10
X X
1 100XQ1
01
11
10
Q2Q3
Q3+0 0 0 000 01 11 10
X X
1 000XQ1
01
11
10Q2Q3
ZD1 =
0 0 0 000 01 11 10
X X
0 100XQ1
01
11
10D2 =
D3 =
Z =
474
Reduction of State Tables 
State Assignment
Given a description of the desired input-output behavior of a sequential circuit, the
first step in designing the circuit is to derive a state table using methods similar tothe ones discussed in the previous unit. Before we realize this state table using flip-flops and logic gates, reduction of the state table to a minimum number of states isdesirable. In general, reducing the number of states in a table will reduce theamount of logic required, and the number of flip-flops may also be reduced. Forexample, if a table with nine states is reduced to eight states, the number of flip-flopsrequired is reduced from four to three, with a possible corresponding reduction inthe amount of input logic for the flip-flops. If the table is further reduced to sixstates, three flip-flops are still required, but the presence of more don’t-cares in theflip-flop input equations will probably further reduce the required logic.
Given the reduced state table, the next step in synthesizing the circuit is to assign
binary flip-flop states to correspond to the circuit states. The way in which this assign-ment is made will determine the amount of logic required for the circuit.The problemof finding a good state assignment which leads to an economical circuit is a difficultone, but some guidelines for achieving this are discussed in Sections 15.7–15.8.
The next step in designing the sequential circuit is to derive the flip-flop input
equations. We have already done this for counters in Unit 12, and we will show howto apply these techniques to more general sequential circuits.
15.1 Elimination of Redundant States
In Unit 14, we were careful to avoid introducing unnecessary states when setting up astate graph or table. We will now approach the problem of deriving the state graphsomewhat differently. Initially, when first setting up the state table, we will not be over-ly concerned with inclusion of extra states, but when the table is complete, we will elim-inate any redundant states. In previous units, we have used the notation S
0,S1,S2,...t o
represent states in a sequential circuit. In this unit, we will frequently use A,B,C,...
(ora,b,c, . . . ) to represent these states.
We will rework Example 1 in Section 14.3. Initially, we will set up enough states
to remember the first three bits of every possible input sequence. Then, when thefourth bit comes in, we can determine the correct output and reset the circuit to the
Reduction of State Tables State Assignment 475
initial state. As indicated in Table 15-1, we will designate state Aas the reset state.
If we receive a 0, we go to state B; if we receive a 1, we go to state C. Similarly, start-
ing in state B, a 0 takes us to state Dto indicate that the sequence 00 has been
received, and a 1 takes us to state Eto indicate that 01 has been received. The
remaining states are defined in a similar manner. When the fourth input bit isreceived, we return to the reset state. The output is 0 unless we are in state JorL
and receive a 1, which corresponds to having received 0101 or 1001.
Next, we will attempt to eliminate redundant states from the table. The input
sequence information was only used in setting up the table and will now be disre-garded. Looking at the table, we see that there is no way of telling states Hand I
apart. That is, if we start in state H, the next state is Aand the output is 0; similarly,
if we start in state I, the next state is Aand the output is 0. Hence, there is no way
of telling states Hand Iapart, and we can replace Iwith Hwhere it appears in the
next-state portion of the table. Having done this, there is no way to reach state I,s o
row Ican be removed from the table. We say that Hisequivalent toI(HKI).
Similarly, rows K,M,N, and Phave the same next state and output as H, so K,M,
N, and Pcan be replaced by H, and these rows can be deleted. Also, the next states
and outputs are the same for rows Jand L, so JKL. Thus, Lcan be replaced with
Jand eliminated from the table. The result is shown in Table 15-2.
Having made these changes in the table, rows DandGare identical and so are rows
E
andF. Therefore, DKG, and EKF, so states FandGcan be eliminated. Figure 15-1
shows a state diagram for the final reduced table. Note that this is identical to the stategraph of Figure 14-14, except for the designations for the states. The procedure used tofind equivalent states in this example is known as row matching . In general, row match-
ing is notsufficient to find all equivalent states, except in the special case where the
circuit resets to the starting state after receiving a fixed number of inputs.Present
Input Present Next State Output
Sequence State X/H110050X/H110051 X/H110050X/H110051
reset AB C 00
0 BD E 00
1 CF G 00
00 DH I 00
01 EJ K 00
10 FL M 00
11 GN P 00
000 HA A 00
001 IA A 00
010 JA A 01
011 KA A 00
100 LA A 01
101 MA A 00
110 NA A 00
111 PA A 00TABLE 15-1
State Table for
Sequence Detector
476 Unit 15
Present
Present Next State Output
State X/H110050X/H110051 X/H110050X/H110051
AB C 00
BD E 00
CE D 00
DH H 00
EJ H 00
FJ H 00
GH H 00
HA A 00
IA A 00
JA A 01
KA A 00
LA A 01
MA A 00
NA A 00
PA A 00P NM LKIG FTABLE 15-2
State Table for
Sequence Detector
0
0
0
00
00
00
00
00
01
0
1
11
11
01
0
1
0 1
0A
B
D
H JEC
(b)FIGURE 15-1
Reduced State
Table and Graph
for Sequence
DetectorPresent Next State Output
State X/H110050X/H110051X/H110050X/H110051
AB C 00
BD E 00
CE D 00
DH H 00
EJ H 00
HA A 00
JA A 01
(a)
15.2 Equivalent States
As we have seen in the previous example, state tables can be reduced by eliminat-
ing equivalent states. A state table with fewer rows often requires fewer flip-flopsand logic gates to realize; therefore, the determination of equivalent states is impor-tant in order to obtain economical realizations of sequential circuits.
Reduction of State Tables State Assignment 477
Let us now consider the general problem of state equivalence. Basically, two states
are equivalent if there is no way of telling them apart through observation of thecircuit inputs and outputs. Consider two sequential circuits (these may be differentcircuits or two copies of the same circuit), one which is started in state pand one which
is started in state q(Figure 15-2): Let X
represent a sequence of inputs X1,X2,..., Xn.
Feed the same input sequence Xinto both circuits and observe the output sequences
Z1andZ2. If these output sequences are the same, so far so good. Then, reset the cir-
cuits to the states pandqand try a different input sequence for Xand again compare
output sequences. If, for every possible input sequence X, these output sequences are
the same, then there is no way of telling states pandqapart by observing the termi-
nal behavior of the circuits, and we say pis equivalent to q(pKq). On the other hand,
if, for some input sequence X, the output sequences Z1andZ2are different, then we
can distinguish between states pandq, and they are not equivalent. Because the out-
put sequence is a function of the initial state and the input sequence, we will write
Z1/H11005/H92611(p,X) Z2/H11005/H92612(q,X)
We can then state formally the definition of state equivalence as follows:
Definition 15.1 LetN1and N2be sequential circuits (not necessarily different). Let Xrepresent a
sequence of inputs of arbitrary length. Then state pinN1is equivalent to state qin
N2iff/H92611(p,X)/H11005/H92612(q,X) for every possible input sequence X.
To apply Definition 15.1 directly, we should first test the circuits with X/H110050 and
X/H110051. Then, we should test with all input sequences of length 2: X/H1100500, 01, 10, and 11.
Next, we should test with all input sequences of length 3: X/H11005000, 001, 010, 011, 100,
101, 110, and 111. We should then continue this process with all input sequences oflength 4, length 5, and so forth. Definition 15.1 is not practical to apply directly in prac-tice because it requires testing the circuit with an infinite number of input sequences inorder to prove that two states are equivalent. A more practical way of testing for stateequivalence uses the following theorem:
Theorem15.1
1Two states pandqof a sequential circuit are equivalent iff for every
single input X, the outputs are the same and the next states are equivalent, that is,
/H9261(p,X)/H11005/H9261(q,X) and /H9254(p,X)K/H9254(q,X)
where /H9261(p,X) is the output given the present state pand input X, and /H9254(p,X) is
the next state given the present state pand input X. Note that the next states do not
have to be equal, just equivalent. For example, in Table 15-1, DKG, but the next
states ( Hand NforX/H110050, and Iand PforX/H110051) are not equal.
The row matching procedure previously discussed is a special case of Theorem 15.1
where the next states are actually the same instead of just being equivalent. We will
1See Appendix D for proof.FIGURE 15-2
N1 Z1
Z2Xp
N2q
478 Unit 15
use this theorem to show that Table 13-4 has no equivalent states. By inspection of the
output part of the table, the only possible pair of equivalent states is S0and S2. From
the table,
S0KS2 iff ( S3KS3,S2KS0,S1KS1, and S0KS1)
But S0[S1(because the outputs differ), so the last condition is not satisfied and S0[S2.
15.3 Determination of State Equivalence 
Using an Implication Table
In this section we will discuss a procedure for finding all of the equivalent states in
a state table. If the equivalent states found by this procedure are eliminated, thenthe table can be reduced to a minimum number of states. We will use an implicationtable (sometimes referred to as a pair chart) to check each pair of states for possi-ble equivalence. The nonequivalent pairs are systematically eliminated until onlythe equivalent pairs remain.
We will use the example of Table 15-3 to illustrate the implication table method.The
first step is to construct a chart of the form shown in Figure 15-3.This chart has a squarefor every possible pair of states.A square in column iand row jcorresponds to state pair
i-j. Thus, the squares in the first column correspond to state pairs a-b,a-c, etc. Note that
the squares above the diagonal are not included in the chart because if iKj,jKi, and
only one of the state pairs i-jandj-iis needed. Also, squares corresponding to pairs a-a,
b-b, etc., are omitted. To fill in the first column of the chart, we compare row aof Table
15-3 with each of the other rows. Because the output for row ais different than the out-
put for row c, we place an Xin the a-csquare of the chart to indicate that a[c. Similarly,
we place X’s in squares a-e,a-f, and a-hto indicate that a[e,a[f, and a[hbecause of
output differences. States aandbhave the same outputs, and thus, by Theorem 15.1,
aKb iff d
Kf and cKh
To indicate this, we place the implied pairs ,d-fand c-h, in the a-bsquare. Similarly,
because aand dhave the same outputs, we place a-dand c-ein the a-dsquare to
indicate that
aKd iff aKd and cKe
Present Next State Present
State X/H110050 1 Output
ad c 0
bf h 0
ce d 1
da e 0
ec a 1
ff b 1
gb h 0
hc g 1TABLE 15-3
Reduction of State Tables State Assignment 479
The entries b-dand c-hin the a-gsquare indicate that
aKg iff bKd and cKh
Next, row bof the state table is compared with each of the remaining rows of the
table, and column bof the implication chart is filled in. Similarly, the remaining
columns in the chart are filled in to complete Figure 15-3. Self-implied pairs areredundant, so a-dcan be eliminated from square a-d, and c-efrom square c-e.
At this point, each square in the implication table has either been filled in with
anXto indicate that the corresponding state pair is not equivalent (because the out-
puts are different) or filled in with implied pairs. We now check each implied pair.If one of the implied pairs in square i-jis not equivalent, then by Theorem 15.1, i[j.
The a-bsquare of Figure 15-3 contains two implied pairs (d-fand c -h). Because d[f
(the d-fsquare has an Xin it), a[band we place an Xin the a-bsquare, as shown
in Figure 15-4. Continuing to check the first column, we note that the a-dsquare
contains the implied pair c-e. Because square c-
edoes not contain an X, we cannot
determine at this point whether or not aKd. Similarly, because neither square b-da bc d efgf
g
hedcb a/H11013 b iff d/H11013f and c/H11013 h
b/HS11013 c because the outputs diffe rd–f
c–h
a–d
c–ea–f
e–h
c–e
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–fFIGURE 15-3
Implication Chart
for Table 15-3
FIGURE 15-4
Implication Chart
After First Pass
a bc d efgf
g
hedcbd–f
c–h
c–ea–f
e–h
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–f
480 Unit 15
nor c-hcontains an X, we cannot determine immediately whether aKgor not.
Going on to the second column, we place X’s in squares b-dandb-gbecause we have
already shown a[fand b[f. In a similar manner, we check each of the remaining
columns and Xout squares c-f,d-g,e-f, and f-h. Figure 15-4 shows the resulting chart.
In going from Figure 15-3 to Figure 15-4, we found several additional nonequiva-
lent state pairs. Therefore, we must go through the chart again to see if the added X’s
make any other pairs nonequivalent. Rechecking column a, we find that we can place
anXin square a-gbecause square b-dhas an X. Checking the remaining columns, we X
out squares c-hande-hbecause d-ganda-ghave X’s. This completes the second pass
through the implication table, as shown in Figure 15-5. Because we added some X’s on
the second pass, a third pass is required.
No new X’s are added on the third pass through the table, so all squares which cor-
respond to nonequivalent state pairs have been Xed out.The coordinates of the remain-
ing squares must then correspond to equivalent state pairs. Because square a-d(in col-
umn a, row d)does not contain an X, we conclude that aKd. Similarly, square c-edoes
not contain an X, so cKe.All other squares contain X’s, so there are no other equivalent
state pairs. Note that we determined equivalent states from the column-row coordinatesof the squares without X’s,notby reading the implied pairs contained within the squares.
If we replace dwith aand ewith cin Table 15-3, we can eliminate rows dand e,
and the table reduces to six rows, as shown in Table 15-4.FIGURE 15-5
Implication Chart
After Second Pass
a bc d efgf
g
hedcbd–f
c–h
c–ea–f
e–h
a–d
e–f
b–dc–f
a–b
b–d
c–ha–b
e–h
c–e
d–gc–f
b–ga–gb–f
Present Next State
State X/H110050 1 Output
aa c 0
bf h 0
cc a 1
ff b 1
gb h 0
hc g 1TABLE 15-4
Reduction of State Tables State Assignment 481
The implication table method of determining state equivalence can be summa-
rized as follows:
1.Construct a chart which contains a square for each pair of states.
2.Compare each pair of rows in the state table. If the outputs associated with states i
andjare different, place an Xin square i-jto indicate that i[j. If the outputs are the
same, place the implied pairs in square i-j. (If the next states of iandjaremandn
for some input x, then m-n is an implied pair.) If the outputs and next states are the
same (or if i-jonly implies itself), place a check ( √) in square i-jto indicate that iKj.
3.Go through the table square-by-square. If square i-jcontains the implied pair m-n,
and square m-n contains an X, then i[j, and an Xshould be placed in square i-j.
4.If any X’s were added in step 3, repeat step 3 until no more X’s are added.
5.For each square i-jwhich does not contain an X,iKj.
If desired, row matching can be used to partially reduce the state table before con-
structing the implication table. Although we have illustrated this procedure for aMoore table, the same procedure applies to a Mealy table.
15.4 Equivalent Sequential Circuits
In the last section, we found the equivalent states within a single state table so that wecould reduce the number of rows in the table. Reducing the number of rows usuallyleads to a sequential circuit with fewer gates and flip-flops. In this section, we will con-sider equivalence between sequential circuits. Essentially, two sequential circuits areequivalent if they are capable of doing the same “work.” Equivalence between sequen-tial circuits is defined as follows:
Definition 15.2 Sequential circuit N1is equivalent to sequential circuit N2if for each state pinN1,
there is a state qinN2such that pKq, and conversely, for each state sinN2, there is
a state tinN1such that sKt.
Thus, if N1KN2, for every starting state pinN1, we can find a corresponding start-
ing state qsuch that /H92611(p,X)K/H92612(q,X) for all input sequences X(i.e., the output
sequences are the same for the same input sequence). Then, in a given application,N
1could be replaced with its equivalent circuit N2.
IfN1andN2have only a few states, one way to show that N1KN2is to match up
pairs of equivalent states by inspection and, then, show that Theorem 15.1 is satis-fied for each pair of equivalent states. If both N
1and N2have a minimum number
of states and N1KN2, then N1and N2must have the same number of states.
Otherwise, one circuit would have a state left over which was not equivalent to anystate in the other circuit, and Definition 15.2 would not be satisfied.
Figure 15-6 shows two reduced state tables and their corresponding state graphs. By
inspecting the state graphs, it appears that if the circuits are equivalent, we must haveAequivalent to either S
2orS3because these are the only states in N2with self-loops.
482 Unit 15
Because the outputs of AandS2correspond, the only possibility is AKS2. If we assume
thatAKS2, this implies that we must have BKS0which in turn implies that we must have
DKS1andCKS3. Using the state tables, we can verify that these assumptions are cor-
rect because for every pair of assumed equivalent states, the next states are equivalentand the outputs are equal when XK0 and also when XK1. This verifies that N
1KN2.
The implication table can easily be adapted for determining the equivalence of
sequential circuits. Because the states of one circuit must be checked for equivalenceagainst states of the other circuit, an implication chart is constructed with rows corre-sponding to states of one circuit and columns corresponding to states of the other. Forexample, for the circuits of Figure 15-6 we can set up the implication table of Figure15-7(a). The first column of Figure 15-7(a) is filled in by comparing row Aof the state
table in Figure 15-6(a) with each of the rows in Figure 15-6(b). Because states Aand
S
0have different outputs, an Xis placed in the A-S0square. Because states Aand S1
have the same outputs, the implied next-state pairs ( B-S3andA-S0) are placed in the
A-S1square, etc. The remainder of the table is filled in similarly.
In the next step [Figure 15-7(b)], squares corresponding to additional nonequiv-
alent state pairs are crossed out. Thus, square A-S1is crossed out because A[S0.
Similarly, square B-S3is crossed out because C[S2, square C-S0because A[S3, andS2S0
S1
S31
0
1
00
00
00
0
0
01
11
1CA
DB1
00
0
0
0
0
00
01
1
1
11
1
(b) (a)FIGURE 15-6
Tables and Graphs
for Equivalent
Circuits
FIGURE 15-7
Implication Tables
for Determining 
Circuit EquivalenceN1
X/H1100501 X/H1100501
AB A 00
BC D 01
CA C 01
DC B 00N2
X/H1100501 X/H1100501
S0 S3 S1 01
S1 S3 S0 00
S2 S0 S2 00
S3 S2 S3 01
ABCDS0
S1
S2
S3A–S3
C–S1C–S3
D–S1
B–S3
A–S0
B–S0
A–S2C–S0
B–S2
C–S2
D–S3A–S2
C–S3C–S3
B–S0
ABCDS0
S1
S2
S3A–S3
C–S1C–S3
D–S1
B–S3
A–S0
B–S0
A–S2C–S0
B–S2
C–S2
D–S3A–S2
C–S3C–S3
B–S0
(a) (b)
Reduction of State Tables State Assignment 483
square D-S2because B[S2. Another pass through the table reveals no additional
nonequivalent pairs; therefore, the remaining equivalent state pairs are
AKS2 BKS0 CKS3 DKS1
Because each state in N1has an equivalent state in N2and conversely, N1KN2.
15.5 Incompletely Specified State Tables
When a sequential circuit is used as part of a larger digital system, it frequently happens
that certain sequences will never occur as inputs to the sequential circuit. In other cases,the output of the sequential circuit is only observed at certain times rather than at everyclock time. Such restrictions lead to unspecified next states or outputs in the state table.When such don’t-cares are present, we say that the state table is incompletely specified.Just as don’t-cares in a truth table can be used to simplify the resulting combinationalcircuit, don’t-cares in a state table can be used to simplify the sequential circuit.
The following example illustrates how don’t-cares arise in a state table.Assume that
circuit A(Figure 15-8) can only generate two possible output sequences, X/H11005100 and
X/H11005110. Thus, the sequential circuit subsystem ( B) has only two possible input
sequences. When the third input in the sequence is received, the output of Bis to be
Z/H110050 if 100 was received and Z/H110051 if 110 was received. Assume that circuit Cignores
the value of Zat other times so that we do not care what Zis during the first two inputs
in the Xsequence. The possible input-output sequences for circuit Bare listed in the
following table, where t
0,t1, and t2represent three successive clock times:
t0t1t2 t0t1t2
X/H11005100 Z/H11005–– 0
110 – –1(– is a don’t-care output)
State Table 15-5(a) will produce the required outputs. Note that the next-state
entry for S0with X/H110050 is a don’t-care because 0 can never occur as the first input in
the sequence. Similarly, the next-state entries for S2andS3with X/H110051 are don’t-cares
because X/H110051 cannot occur as the third input in the sequence. If we fill in the don’t-
cares in the state table, as indicated in Table 15-5(b), we can use row matching toreduce the table to two states, as shown in Table 15-5(c).
XZ
Circuit A Circuit CB
Sequential Circuit
Subs ystem
X/H1100501 0 1
S0 (S0)S1(0) -
S1 S0S3(1) -
S2 S0(S1)0 -
S3 S0(S3)1 -
(b)
S0/H11013S2,S1/H11013S3S2X/H1100501 0 1
S0 S0S1 0-
S1 S0S1 1-
(c)X/H1100501 0 1
S0 -S1 --
S1 S2S3 --
S2 S0 - 0-
S3 S0 - 1-
(a)TABLE 15-5
Incompletely
Specified
State TableFIGURE 15-8
484 Unit 15
As illustrated in Table 15-5, one method of reducing incompletely specified state
tables is to fill in the don’t-cares in an appropriate manner and, then, reduce thetable, using one of the methods which apply to completely specified state tables. Thisprocedure may be applied to small tables or to tables with only a few don’t-cares, but,in general, it does not lead to a minimum-row reduced table. Determining the bestway to fill in the don’t-cares may require considerable trial and error, and even if thebest way of filling in the don’t-cares is found, the resulting table cannot always bereduced to a minimum-row table. General procedures are known which will reducean incompletely specified state table to a minimum number of rows,
2but the discus-
sion of such procedures is beyond the scope of this text.
15.6 Derivation of Flip-Flop Input Equations
After the number of states in a state table has been reduced, the following proce-dure can be used to derive the flip-flop input equations:
1.Assign flip-flop state values to correspond to the states in the reduced table.
2.Construct a transition table which gives the next states of the flip-flops as a
function of the present states and inputs.
3.Derive the next-state maps from the transition table.
4.Find flip-flop input maps from the next-state maps using the techniques devel-
oped in Unit 12 and find the flip-flop input equations from the maps.
As an example, we will design a sequential circuit to realize Table 15-6(a).
Because there are seven states, we will need three flip-flops. We will designate theflip-flop outputs as A,B, and C.
We could make a straight binary state assignment for which S
0is represented by
flip-flop states ABC /H11005000, S1byABC /H11005001, S2byABC /H11005010, etc. However,
because the correspondence between flip-flop states and the state names is arbitrary,we could use many different state assignments. Using a different assignment may
(a) State table
X/H1100501 0 1
S0 S1S2 00
S1 S3S2 00
S2 S1S4 00
S3 S5S2 00
S4 S1S6 00
S5 S5S2 10
S6 S1S6 01TABLE 15-6 (b) Transition table
A/H11001B/H11001C/H11001Z
ABC X /H1100501 0 1
000 110 001 0 0
110 111 001 0 0001 110 011 0 0
111 101 001 0 0
011 110 010 0 0101 101 001 1 0010 110 010 0 1
2See, for example, Edward I. McClushey, Logic Design Principles (Prentice-Hall, 1986), Chap. 9.
Reduction of State Tables State Assignment 485
lead to simpler or more complex flip-flop input equations.As an example, we will use
the following assignment for the states of flip-flops A,B, and C:
S0/H11005000, S1/H11005110, S2/H11005001, S3/H11005111, S4/H11005011, S5/H11005101, S6/H11005010 (15-1)
This state assignment is derived in Section 15.8, and the reasons why it leads to an
economical solution are given in that section. Starting with Table 15-6(a), we substitute000 for S
0, 110 for S1, 001 for S2, etc. Table 15-6(b) shows the resulting transition table.
This table gives the next states of flip-flops A,B, and Cin terms of the present states
and the input X. We can fill in the next-state maps, Figure 15-9(a), directly from this
table. For XABC /H110050000 the next-state entry is 110, so we fill in A/H11001/H110051,B/H11001/H110051, and
C/H11001/H110050; for XABC /H110051000 the next-state entry is 001, so we fill in A/H11001/H110050,B/H11001/H110050, and
C/H11001/H110051; etc. Because the state assignment ABC /H11005100 is not used, the map squares
corresponding to XABC /H110050100 and 1100 are filled with don’t-cares.
Once the next-state maps have been plotted from the transition table, the flip-flop
input equations can be derived using the techniques developed in Unit 12. As shownin Figure 15-9(a), the D flip-flop input equations can be derived directly from the next-state maps because D
A/H11005A/H11001,DB/H11005B/H11001, and DC/H11005C/H11001. If J-K flip-flops are used, the J
andKinput equations can be derived from the next-state maps as illustrated in Figure
15-9(b). As was shown in Section 12.5, the A/H110050 half of the JAmap is the same as the
A/H11001map and the A/H110051 half is all don’t-cares. The A/H110051 half of the KAmap is the com-
plement of the A/H110051 half of the A/H11001map, and the A/H110050 half is all don’t-cares. We can
A+ = DA = X ′1XX 000 01 11 10
1 1 0 0
1 1 0 0
100BCXA
01
11
10 1 0 0
JA = X ′1XX 000 01 11 10
1XX 0
1XX 0
100BCXA
01
11
10 XX 0
KA = XXXXX00 01 11 10
X 0 1X
X 0 1X
X00BCXA
01
11
10 0 1X
JB = X ′A′ + A′C1XX 000 01 11 10
1 1 0 0
XXX X00BCXA
01
11
10 XXX X
KB = AC + X AX XX X00 01 11 10
XXX X
11 0 0
100BCXA
01
11
10 0 0 0B+ = DB = X ′C′ + A′C + A′B1XX 000 01 11 10
1 0 0 1
1 0 0 1
100BCXA
01
11
10 1 0 1
C+ = DC = A + X B′0XX 100 01 11 10
0 1 1 1
0 1 1 0
000BCXA
01
11
10 1 1 0
(a) Derivation of D flip-flop input equations
(b) Derivation of J-K flip-flop input equationsA = 1A = 0 A = 0
B = 0
B = 0FIGURE 15-9 Next-State Maps for Table 15-6
486 Unit 15
plot the JBandKBin a similar manner by looking at the B/H110050 and B/H110051 halves of the
B/H11001map. Derivation of the JCandKCmaps from the C/H11001map is left as an exercise.
Table 15-7(a) represents a sequential circuit with two inputs ( X1andX2) and two
outputs ( Z1and Z2). Note that the column headings are listed in Karnaugh map
order because this will facilitate derivation of the flip-flop input equations. Becausethe table has four states, two flip-flops ( AandB) are required to realize the table.We
will use the state assignment AB/H1100500 for S
0,AB/H1100501 for S1,AB/H1100511 for S2, and
AB/H1100510 for S3. By substituting the corresponding values of ABfor the state names,
we obtain the transition table, Table 15-7(b). We can then fill in the next-state andoutput maps (Figure 15-10) from the transition table. For example, when X
1X2AB/H11005
0011, A/H11001B/H11001/H1100510, and Z1Z2/H1100511; therefore, we fill in the 0011 squares of the A/H11001,B/H11001,
Z1, and Z2maps with l, 0, 1, and 1, respectively. We can read the D flip-flop input
equations directly from the next-state maps.
FIGURE 15-10 Next-State Maps for Table 15-7(a) State table
Next State Outputs ( Z1Z2)
X1X2/H11005 X1X2/H11005
P.S. 00 01 11 10 00 01 11 10
S0S0S0S1S100 00 01 01
S1S1S3S2S100 10 10 00
S2S3S3S2S211 11 00 00
S3S0S3S2S000 00 00 00TABLE 15-7 (b) Transition table
A/H11001B/H11001Outputs ( Z1Z2)
X1X2/H11005 X1X2/H11005
AB 00 01 11 10 00 01 11 10
00 00 00 01 01 00 00 01 01
01 01 10 11 01 00 10 10 0011 10 10 11 11 11 11 00 00
10 00 10 11 00 00 00 00 00
DA = A+ = X2B +
AB + X2A0 0 0 000 01 11 10
0 1 1 0
1 1 1 1
000ABX1X2
01
11
10 1 1 0
DB = B+ = X1A′ +
X2A′B + X1B + X1X20 0 1 100 01 11 10
1 0 1 1
0 0 1 1
000ABX1X2
01
11
10 0 1 0
Z1 = X2A′B + X1AB0 0 0 000 01 11 10
0 1 1 0
1 1 0 0
000ABX1X2
01
11
10 0 0 0
Z2 = X1A′B′ + X1AB0 0 1 100 01 11 10
0 0 0 0
1 1 0 0
000ABX1X2
01
11
10 0 0 0
′ ′
If J-K, T, or S-R flip-flops are used, the flip-flop input maps can be derived from
the next-state maps using the techniques given in Section 12.6. As an example, theS-Requations for Table 15-7 are derived in Figure 15-11. The S
Aand RAmaps are
derived from the A/H11001map by applying Table 12-5(c) to the A/H110050 and A/H110051 halves
of the map. SBand RBare derived in a similar manner.
Reduction of State Tables State Assignment 487
15.7 Equivalent State Assignments
After the number of states in a state table has been reduced, the next step in realiz-
ing the table is to assign flip-flop states to correspond to the states in the table. Thecost of the logic required to realize a sequential circuit is strongly dependent on theway this state assignment is made. Several methods for choosing state assignmentsto obtain economical realizations are discussed in this chapter. The trial-and-errormethod described next is useful for only a small number of states. The guidelinemethod discussed in Section 15.8 produces good solutions for some problems, but itis not entirely satisfactory in other cases.
If the number of states is small, it may be feasible to try all possible state assign-
ments, evaluate the cost of the realization for each assignment, and choose the assign-ment with the lowest cost. Consider a state table with three states ( S
0,S1, and S2) as in
Table 14-1. Two flip-flops ( AandB) are required to realize this table. The four possible
assignments for state S0areAB/H1100500,AB/H1100501,AB/H1100510, and AB/H1100511. Choosing one
of these assignments leaves three possible assignments for state S1because each state
must have a unique assignment. Then, after state S1is assigned, we have two possible
assignments for state S2. Thus, there are 4 /H110033/H110032/H1100524 possible state assignments for
the three states, as shown in Table 15-8. As an example, for assignment 7, the entry 01in the S
0row means that flip-flops AandBare assigned values 0 and l, respectively.
Trying all 24 of these assignments is not really necessary. If we interchange two
columns in one of the given assignments, the cost of realization will be unchangedbecause interchanging columns is equivalent to relabeling the flip-flop variables. Forexample, consider assignment 1 in Table 15-8. The first column of this assignmentshows that flip-flop Ais assigned the values 0, 0, and 1 for states S
0,S1, and S2,
respectively. Similarly, the second column shows that Bis assigned the values 0, 1,
and 0. If we interchange the two columns, we get assignment 3, for which Ahas the
TABLE 15-8
State Assignments
for 3-Row Tables1234567 1 9 2 0 2 1 2 2 2 3 2 4
S0 00 00 00 00 00 00 01 · · · 11 11 11 11 11 11
S1 01 01 10 10 11 11 00 00 00 01 01 10 10
S2 10 11 01 11 01 10 10 01 10 00 10 00 01FIGURE 15-11 Derivation of S-R Equations for Table 15-7
SA= X2B0 0 0 000 01 11 10
0 1 1 0
XXXX
000ABX1X2
01
11
10 XX 0
RA= X2B′XXXX00 01 11 10
X 0 0X
0 0 0 0
100ABX1X2
01
11
10 0 0 1
SB= X1X2+X1A′0 0 1 100 01 11 10
X 0XX
0 0XX
000ABX1X2
01
11
10 0 1 0
RB= X1X2+ X1AXX 0 000 01 11 10
0 1 0 0
1 1 0 0
X00ABX1X2
01
11
10 X 0X
′′ ′A = 0
B = 1B = 0
B = 0A = 1
488 Unit 15
values 0, 1, and 0 and Bhas the values 0, 0, and 1. We could have achieved the same
result by using assignment 1 and labeling the flip-flop variables BAinstead of AB.
If we interchange the columns of assignment 2, we get assignment 4, so assignments2 and 4 have the same cost. Similarly, assignments 5 and 6 have the same cost.Interchanging rows, however, will usually change the cost of realization. Thus,assignments 4 and 6 will have a different cost for many state tables.
If symmetrical flip-flops such as T, J-K, or S-R are used, complementing one or
more columns of the state assignment will have no effect on the cost of realization.Consider a J-K flip-flop imbedded in a circuit, Figure 15-12(a). Leave the circuitunchanged and interchange the JandKinput connections and the Q
kandQ/H11032koutput
connections, Figure 15-12(b). If circuit Ais started with Qk/H11005pand circuit Bwith
Qk/H11005p/H11032, the behavior of the two circuits will be identical, except the value of Qkwill
always be complemented in the second circuit because whenever Jis 1 in the first
circuit, Kwill be 1 in the second and conversely. The state table for the second circuit
is therefore the same as for the first, except the value of Qkis complemented for the
second circuit. This implies that complementing one or more columns in the stateassignment will not affect the cost of the realization when J-K flip-flops are used.Similar reasoning applies to T and S-R flip-flops. Thus, in Table 15-8, assignments 2and 7 have the same cost, and so do assignments 6 and 19.
If unsymmetrical flip-flops are used such as a D flip-flop, it is still true that permut-
ing (i.e., rearranging the order of) columns in the state assignment will not affect thecost; however, complementing a column may require adding an inverter to the circuit,as shown in Figure 15-13. If different types of gates are available, the circuit can gener-ally be redesigned to eliminate the inverter and use the same number of gates as theoriginal. If circuit Ain Figure 15-13 is started with Q
k/H11005pand circuit Bwith Qk/H11005p/H11032, thep′f1 Qk
Qk′J
Kf2pf1 Qk
Qk′J
Kf2
(a) Circuit A (b) Circuit B
(identical to A except leads to
flip-flop Qk are crossed)FIGURE 15-12
Equivalent Circuits
Obtained by
Complementing Qk
FIGURE 15-13
Equivalent Circuits
Obtained by
Complementing Qkp′f Qk
Qk′D pf Qk
Qk′D
(a) Circuit A (b) Circuit B
(identical to A except for
connections to flip-flop Qk)
Reduction of State Tables State Assignment 489
behavior of the two circuits will be identical, except the value of Qkwill always be com-
plemented in circuit Bbecause fis the same in both circuits and D/H11005f/H11032for circuit B.
Table 15-9 illustrates the effect of interchanging or complementing state assign-
ment columns on the equations for realizing a specific state table.
The J-K and D flip-flop input equations for the three assignments can be
derived, using Karnaugh maps as explained in Unit 12 and Section 15.6. The result-ing J and K input equations are:
Assignment A Assignment B Assignment C
J
1/H11005XQ2/H11032 J2/H11005XQ1/H11032 K1/H11005XQ2
K1/H11005X/H11032 K2/H11005X/H11032 J1/H11005X/H11032
J2/H11005X/H11032Q1 J1/H11005X/H11032Q2 K2/H11005X/H11032Q1/H11032
K2/H11005XK1/H11005XJ2/H11005X
Z/H11005X/H11032Q1/H11001XQ2 Z/H11005X/H11032Q2/H11001XQ1 Z/H11005X/H11032Q1/H11032/H11001 XQ2/H11032
______________ ______________ _______________D
1/H11005XQ2/H11032 D2/H11005XQ1/H11032 D1/H11005X/H11032/H11001 Q2/H11032
D2/H11005X/H11032(Q1/H11001Q2)D1/H11005X/H11032(Q2/H11001Q1)D2/H11005X/H11001Q1Q2
Note that assignment Bin Table 15-9 was obtained by interchanging the columns
ofA.The corresponding equations for assignment Bare the same as for A, except that
subscripts 1 and 2 are interchanged. Assignment Cwas obtained by complementing
the columns of A. The Zequation for Cis the same as for A, except that Q1and Q2
are complemented. The Kand Jequations for Care the same, respectively, as the J
and Kequations for Awith the Q/H11032s complemented. The Dequations for Ccan be
obtained by complementing those for Aand, then, complementing the Q’s. Thus, the
cost of realizing Table 15-9 using J-K flip-flops and any kind of logic gates will beexactly the same for all three assignments. If both AND and OR (or NAND andNOR) gates are available, the cost of realizing the three sets of Dequations will be
the same. If only NOR gates are available, for example, then realizing D
1andD2for
assignment Cwould require two additional inverters compared with AandB.
By complementing one or more columns, any state assignment can be converted to
one in which the first state is assigned all 0’s. If we eliminate assignments whichcan be obtained by permuting or complementing columns of another state assign-ment, Table 15-8 reduces to three assignments (Table 15-10). Thus, when realizing a
3-State Assignments 4-State Assignments
States 1 2 3 1 2 3
a 00 00 00 00 00 00
b 01 01 11 01 01 11
c 10 11 01 10 11 01
d –––1 1 1 0 1 0TABLE 15-10
Nonequivalent
Assignments for
Three and Four
StatesAssignments Present Next State Output
A3B3C3 State X/H1100501 0 1
00 00 11 S1 S1S3 00
01 10 10 S2 S2S1 01
10 01 01 S3 S2S3 10TABLE 15-9
490 Unit 15
three-state sequential circuit with symmetrical flip-flops, it is only necessary to try three
different state assignments to be assured of a minimum cost realization. Similarly, onlythree different assignments must be tried for four states.
We will say that two state assignments are equivalent if one can be derived from the
other by permuting and complementing columns. Two state assignments which are notequivalent are said to be distinct . Thus, a four-row table has three distinct state assign-
ments, and any other assignment is equivalent to one of these three. Unfortunately, thenumber of distinct assignments increases very rapidly with the number of states, asshown in Table 15-11. Hand solution is feasible for two, three, or four states; computersolution is feasible for five through eight states; but for more than nine states it is notpractical to try all assignments even if a high-speed computer is used.
15.8 Guidelines for State Assignment
Because trying all nonequivalent state assignments is not practical in most cases,other methods of state assignment are needed. The next method to be discussedinvolves trying to choose an assignment which will place the 1’s on the flip-flopinput maps in adjacent squares so that the corresponding terms can be combined.This method does not apply to all problems, and even when applicable, it does notguarantee a minimum solution.
Assignments for two states are said to be adjacent if they differ in only one vari-
able. Thus, 010 and 011 are adjacent, but 010 and 001 are not. The following guide-
lines are useful in making assignments which will place 1’s together (or 0’s together)
on the next-state maps:
1.States which have the same next state for a given input should be given adjacent
assignments.
2.States which are the next states of the same state should be given adjacent
assignments.Minimum Number of
Number of Number of Distinct
States State Variables Assignments
21 1
32 342 35 3 140
6 3 420
7 3 8408 3 8409 4 10,810,800
16 4 /H110155.5/H110031010·········TABLE 15-11
Number of Distinct
(Nonequivalent)
State Assignments 
Reduction of State Tables State Assignment 491
A third guideline is used for simplification of the output function:
3.States which have the same output for a given input should be given adjacent
assignments.
The application of Guideline 3 will place 1’s together on the output maps.
When using the state assignment guidelines, the first step is to write down all of
the sets of states which should be given adjacent assignments according to theguidelines. Then, using a Karnaugh map, try to satisfy as many of these adjacenciesas possible. A fair amount of trial and error may be required to fill in the map sothat the maximum number of desired state adjacencies is obtained. When filling inthe map, keep in mind the following:
(a) Assign the starting state (reset state) to the “0” square on the map. (For an
exception to this rule, see the one-hot assignment in Section 15.9.) Nothing isto be gained by trying to put the starting state in different squares on the mapbecause the same number of adjacencies can be found no matter where youput the starting state. Usually, assigning “0” to the starting state simplifies theinitialization of the circuit using the clear inputs on the flip-flops.
(b) Adjacency conditions from Guideline 1 and adjacency conditions from
Guideline 2 that are required two or more times should be satisfied first.
(c) When guidelines require that three or four states be adjacent, these states should
be placed within a group of four adjacent squares on the assignment map.
(d) If the output table is to be considered, then Guideline 3 should also be applied.
The priority given to adjacency conditions from Guideline 3 should generally beless than that given to Guidelines 1 and 2 if a single output function is beingderived. If there are two or more output functions, a higher priority forGuideline 3 may be appropriate.
The following example should clarify the application of Guidelines 1 and 2. The
state table from Table 15-6 is repeated in Figure 15-14(a) so that we can illustratederivation of the state assignment. According to Guideline 1, S
0,S2,S4, and S6
should be given adjacent assignments because they all have S1as a next state (with
input 0). Similarly, S0,S1,S3, and S5should have adjacent assignments because they
have S2as a next state (with input 1); also, S3and S5should have adjacent assign-
ments and so should S4and S6. The application of Guideline 2 indicates that S1and
01
00BCA
01
11
10S0
S2
S4
S6S0
S1
S3
S5S5
S3
S1S6
S4
S201
00BCA
01
11
10
(b) Assi gnment mapsABC X /H1100501 0 1
000 S0 S1S2 00
110 S1 S3S2 00
001 S2 S1S4 00
111 S3 S5S2 00
011 S4 S1S6 00
101 S5 S5S2 10
010 S6 S1S6 01
(a) State tableFIGURE 15-14
492 Unit 15
S2should be given adjacent assignments because they are both next states of S0.
Similarly, S2and S3should have adjacent assignments because they are both next
states of S1. Further application of Guideline 2 indicates that S1and S4,S2and S5
(two times), and S1and S6(two times) should be given adjacent assignments. In
summary, the sets of adjacent states specified by Guidelines 1 and 2 are
1.(S0,S1,S3,S5)(S3,S5)(S4,S6)(S0,S2,S4,S6)
2.(S1,S2)(S2,S3)(S1,S4)(S2,S5)2x(S1,S6)2x
We will attempt to fulfill as many of these adjacency conditions as possible. A
Karnaugh map will be used to make the assignments so that states with adjacentassignments will appear in adjacent squares on the map. If the guidelines requirethat three or four states be adjacent, these states should be placed within a group offour adjacent squares on the assignment map. Two possible ways of filling in theassignment maps are shown in Figure 15-14(b). These maps were filled in by trialand error, attempting to fulfill as many of the preceding adjacency conditions aspossible. The conditions from Guideline 1 are given preference to conditions fromGuideline 2. The conditions which are required two times (such as S
2adjacent to S5,
andS1adjacent to S6) are given preference over conditions which are required only
once (such as S1adjacent to S2, and S2adjacent to S3).
The left assignment map in Figure 15-14(b) implies an assignment for the states
of flip-flops A,B, and Cwhich is listed to the left of the state table in Figure 15-14(a).
This assignment is the same as the one given in Equations (15-1). We derived the Dflip-flop input equations and Jand Kinput equations for this assignment in Section
15.6.The cost of realizing the D flip-flop input equations given in Figure 15-9(a) is sixgates and 13 inputs. If a straight binary assignment ( S
0/H11005000, S1/H11005001, S2/H11005010, etc.)
were used instead, the cost of realizing the flip-flop input equations would be 10gates and 39 inputs. Although application of the guidelines gives good results in thisexample, this is not always the case.
Next, we will explain why the guidelines help to simplify the flip-flop equations
when the assignment of Figure 15-14(a) is used. Figure 15-15 shows a next-state mapwhich was constructed using this assignment. Note that if X/H110050 and ABC /H11005000, the
next state is S
1; if X/H110051 and ABC /H11005000, the next state is S2. Because Guideline 1
was used in making the state assignment, S1appears in four adjacent squares on the
next-state map, S5appears in two adjacent squares, etc.
The next-state maps for the individual flip-flops, Figure 15-15(b), can be derived in
the usual manner from a transition table, or they can be derived directly from Figure 15-15(a). Using the latter approach, wherever S
1appears in Figure 15-15(a), it is replaced
with 110 so that 1, 1, and 0 are plotted on the corresponding squares of the A/H11001,B/H11001, and
C/H11001maps, respectively. The other squares on the next-state maps are filled in similarly.
Because four S1’s are adjacent in Figure 15-15(a), the corresponding squares on
theA/H11001,B/H11001, and C/H11001maps have four adjacent 1’s or four adjacent 0’s as indicated by
the blue shading. This illustrates why Guideline 1 helps to simplify the flip-flopequations. Each time Guideline 2 is applied, two out of the three next-state mapswill have an additional pair of adjacent 1’s or adjacent 0’s. This occurs because twoof the three state variables are the same for adjacent assignments.
Reduction of State Tables State Assignment 493
XX00 01 11 10
00BC
S1 S2
S1 S5 S2 S4
S1 S5 S2 S6
S1 S3 S2 S6XA
01
1110Adjacent because S1,S3, and
S5 have adjacent
assignments
Adjacent because S4 and
S6 have adjacent
assignments
Adjacent because S3 and S5
have adjacent assignmentsAdjacent because S0,S2,S4, and S6
have adjacent assignments
(a) Next-state maps for Figure 15-14
(b) Next-state maps for Figure 15-14 (cont.)1 XX 100 01 11 10
1001
1001
100
01
11
10 1010 XX 100 01 11 10
0111
0110
000
01
11
10 1101 XX 000 01 11 10
1100
1100
100BCXA
A+ = DA = X′ B+ = DB = X′C′ + A′C + A′BC+ = DC = A + XB′01
11
10 100These pairs are adjacent because S2
and S5 have adjacent assignmentsFIGURE 15-15 Next-State Maps for Figure 15-14
Next, we will apply the state assignment guidelines to Figure 15-16(a). First, we
list the sets of adjacent states specified by each Guideline:
1.(b,d)(c,f)(b,e)
2.(a,c)2x(d,f)(b,d)(b,f)(c,e)
3.(a,c)(b,d)(e,f)
Next, we try to arrange the states on a map so as to satisfy as many of these pairs
as possible, but giving preference to the duplicated pairs ( b,d) and ( a,c). Two such
arrangements and the corresponding assignments are given in Figures 15-16(b) and(c). For Figure 15-16(c), all adjacencies are satisfied except ( b,f), (c,e), and ( e,f).
We will derive D flip-flop input equations for this assignment. First, we construct thetransition table (Table 15-12) from the state table [Figure 15-16(a)] by replacing a
with 100, bwith 111, cwith 000, etc. Then, we plot the next-state and output maps
(Figure 15-17) from the transition table. The D flip-flop input equations can be read
directly from these maps:
D1/H11005Q1/H11001/H11005X/H11032Q1Q/H110322/H11001XQ/H110321
D2/H11005Q2/H11001/H11005Q3
D3/H11005Q3/H11001/H11005XQ/H110321Q2/H11001X/H11032Q3
and the output equation is
Z/H11005XQ2Q3/H11001X/H11032Q/H110322Q3/H11001X Q2Q/H110323
The cost of realizing these equations is 10 gates and 26 gate inputs.494 Unit 15
FIGURE 15-16 State Table and Assignments
01
00
01
11
10a
dc a
d
fec
b
fe
b01
00
01
11
10
(b) (c)a = 000
b = 111
c = 100
d = 011
e = 101
f= 110a = 100
b = 111
c = 000
d = 011
e = 101
f= 010Q1
Q2Q3Q1
Q2Q3X/H1100501 X/H1100501
aa c 00
bd f 01
cc a 00
dd b 01
eb f 10
fc e 10
(a)
FIGURE 15-17 Next-State and Output Maps for Table15-12Q1/H11001Q2/H11001Q3/H11001
Q1Q2Q3 X/H1100501 X/H1100501
1 0 0 100 000 0 0
1 1 1 011 010 0 10 0 0 000 100 0 0
0 1 1 011 111 0 1
1 0 1 111 010 1 00 1 0 000 101 1 0TABLE 15-12
Transition Table for
Figure 15-16(a)
Q1= D10 1 0 100 01 11 10
X 1 0X
0 0 0 1
000XQ1
Q2Q3
01
11
10 XX 1
+Q2= D20 0 0 000 01 11 10
X 1 1X
1 1 1 1
000XQ1
Q2Q3
01
11
10 XX 0
+Q3= D30 0 0 000 01 11 10
X 1 0X
1 1 0 1
000XQ1
Q2Q3
01
11
10 XX 1
+Z0 0 0 000 01 11 10
X 1 0X
0 0 1 1
100XQ1
Q2Q3
01
11
10 XX 0
The assignment of Figure 15-16(b) satisfies all of the guidelines except ( d,f) and
(e,f). Using this assignment, the cost of realizing the state table with D flip-flops is
13 gates and 35 gate inputs. We would expect that this assignment would producebetter results than Figure 15-16(c) because it satisfies one more of the adjacenciesgiven by the guidelines, but just the opposite is true. As illustrated by this example,the assignment which satisfies the most guidelines is not necessarily the best assign-ment. In general, it is a good idea to try several assignments which satisfy most ofthe guidelines and choose the one which gives the lowest cost solution.
The guidelines work best for D flip-flops and J-K flip-flops. They do not work as
well for T and S-R flip-flops. In general, the best assignment for one type of flip-flopis not the best for another type.
15.9 Using a One-Hot State Assignment
When designing with CPLDs and FPGAs, we should keep in mind that each logiccell contains one or more flip-flops. These flip-flops are there whether we use themor not. This means that it may not be important to minimize the number of flip-flops used in the design. Instead, we should try to reduce the total number of logiccells used and try to reduce the interconnections between cells. When several cellsmust be cascaded to realize a function as in Figure 9-36(b), the propagation delayis longer, and the logic runs slower. In order to design faster logic, we should try toreduce the number of cells required to realize each equation. Using a one-hot state
assignment may help to accomplish this.
The one-hot assignment uses one flip-flop for each state, so a state machine with
Nstates requires Nflip-flops. Exactly one of the flip-flops is set to one in each state.
For example, a system with four states ( S
0,S1,S2, and S3) could use four flip-flops
(Q0,Q1,Q2, and Q3) with the following state assignment:
S0:Q0Q1Q2Q3/H110051000, S1: 0100, S2: 0010, S3: 0001 (15-2)
The other 12 combinations are not used.
We can write next-state and output equations by inspecting the state graph.
Consider the partial state graph given in Figure 15-18. Because four arcs lead into S3,
there are four conditions under which the next state is S3. These conditions are asReduction of State Tables State Assignment 495
S0 S1
S3S2
X1Z1X3Z1X2Z2
X4Z2FIGURE 15-18
Partial State Graph
496 Unit 15
follows: present state (PS) /H11005S0andX1/H110051, PS /H11005S1andX2/H110051, PS /H11005S2andX3/H110051,
PS/H11005S3andX4/H110051.The next state of flip-flop Q3is 1 under these four conditions (and
0 otherwise). Therefore, the next-state equation for Q3can be written as:
Q3/H11001/H11005X1(Q0Q1/H11032Q2/H11032Q3/H11032)/H11001X2(Q0/H11032Q1Q2/H11032Q3/H11032)/H11001
X3(Q0/H11032Q1/H11032Q2Q3/H11032)/H11001X4(Q0/H11032Q1/H11032Q2/H11032Q3)
However, because Q0/H110051 implies Q1/H11005Q2/H11005Q3/H110050, the Q1/H11032Q2/H11032Q3/H11032term is
redundant and can be eliminated. Similarly, all of the primed state variables can beeliminated from the other terms, so the next-state equation reduces to
Q
3/H11001/H11005X1Q0/H11001X2Q1/H11001X3Q2/H11001X4Q3
In general, when a one-hot state assignment is used, each term in the next-state
equation for each flip-flop contains exactly one state variable, and the reducedequation can be written by inspecting the state graph.
Similarly, each term in each reduced output equation contains exactly one
state variable. Because Z
1/H110051 when PS /H11005S0andX1/H110051, and also when PS /H11005S2and
X3/H110051, we can write Z1/H11005X1Q0/H11001X3Q2. By inspecting the state graph, we can also
write Z2/H11005X2Q1/H11001X4Q3.
When a one-hot assignment is used, resetting the system requires that one flip-
flop be set to 1 instead of resetting all flip-flops to 0. If the flip-flops used do nothave a preset input, then we can modify the one-hot assignment by replacing Q
0
with Q0/H11032throughout. For the Assignment (15-2), the modification is
S0:Q0Q1Q2Q3/H110050000, S1: 1100, S2: 1010, S3: 1001 (15-3)
and the modified equations are:
Q3/H11001/H11005X1Q0/H11032/H11001 X2Q1/H11001X3Q2/H11001X4Q3
Z1/H11005X1Q0/H11032/H11001 X3Q2,Z2/H11005X2Q1/H11001X4Q3
For the Moore machine of Figure 14-22(b), we will make the following one-
hot assignment for flip-flops Q0Q1Q2:S0/H11005100, S1/H11005010, and S2/H11005001. When
Q0/H110051, the state is S0; when Q1/H110051, the state is S1; and when Q2/H110051, the state
isS2. By inspection, because three arcs lead into each state, the next-state
equations are
Q0/H11001/H11005F/H11032R/H11032Q0/H11001FQ2/H11001F/H11032RQ1
Q1/H11001/H11005F/H11032R/H11032Q1/H11001FQ0/H11001F/H11032RQ2
Q2/H11001/H11005F/H11032R/H11032Q2/H11001FQ1/H11001F/H11032RQ0
The output equations are trivial because each output occurs in only one state:
Z1/H11005Q0,Z2/H11005Q1,Z3/H11005Q2
As another example, consider the state graph in Figure 15-19, which repre-
sents a sequential circuit that controls a binary multiplier. The circuit has threeinputs ( St, M , and K), and four outputs (Load, Ad, Sh , and Done). Starting
in state S
0, if St/H110050, then the circuit stays in S0. If St/H110051, the circuit outputs
Reduction of State Tables State Assignment 497
DoneS0 S1
S2 S3K'M'
_St'
0St
LoadSh
M
AdKM'
Sh
K'
Sh
K
ShQ0Q1Q2Q3
=1000
00010100
0010
Load /H110051 (the other outputs are 0), and the next state is S1. In S1, if M/H110051, then
Ad/H110051 and the next state is S2. If M/H110050 and K/H110050, the output is Sh/H110051 and the
next state is S1. If M/H110050 and K/H110051, the output is Sh/H110051 and the next state is S3.
InS2, the output is Sh/H110051 for both K/H110050 and K/H110051. If K/H110050, the next state is
S1, and if K/H110051, the next state is S3. In S3, the output is Done /H110051 and the next
state is S0.
Because there are four states, a one-hot state assignment requires four flip-
flops. The one-hot assignments for each state are shown on the state graph.Only Q
0is 1 in S0and the other Q’s are 0. Similarly, only Q1is 1 in S1and the
other Q’s are 0, etc. To determine the next-state equation for Q0, note that two
arrows lead into state S0. The loop from state S0back to itself indicates Q0/H11001/H110051
ifQ0/H110051 and St/H110050. The arrow from S3toS0indicates Q0/H11001/H110051 if Q3/H110051.
Therefore,
Q0/H11001/H11005Q0St/H11032/H11001Q3
Because three arrows lead into S1,Q1/H11001has three terms:
Q1/H11001/H11005Q0St/H11001Q1K/H11032M/H11032/H11001Q2K/H11032
We can also determine the output functions by inspection of the state graph. In
S0, Load /H110051 when St/H110051 and Load /H110050 for all other states and inputs; therefore,
Load /H11005Q0St. The output Shappears in four places on the graph. Sh/H110051 in S1if
K/H11032M/H11032/H110051 or if KM/H11032/H110051; also, Sh/H110051 in S2ifK/H11032/H110051 or K/H110051. Therefore,
Sh/H11005Q1(K/H11032M/H11032/H11001KM/H11032)/H11001Q2(K/H11032/H11001K)/H11005Q1M/H11032/H11001Q2
When designing with CPLDs or FPGAs, you should try both an assignment
with a minimum number of state variables and a one-hot assignment to see whichone leads to a design with the smallest number of logic cells. Alternatively, if thespeed of operation is important, the design which leads to the fastest logic shouldbe chosen. When a one-hot assignment is used, more next-state equations arerequired, but for some state graphs both the next-state and output equations maycontain fewer variables. An equation with fewer variables may require fewer logiccells to realize. The more cells which are cascaded, the longer the propagationdelay, and the slower the operation.FIGURE 15-19
Multiplier Control
State Graph
498 Unit 15
Problems
15.1 (a) Reduce the following state table to a minimum number of states.
Present Next State Present Output
State X/H110050X/H110051 X/H110050 X/H110051
AA E 10
BC F 00
CB H 00
DE F 00
ED A 00
FB F 10
GD H 00
HH G 10
(b) You are given two identical sequential circuits which realize the preceding state
table. One circuit is initially in state Band the other circuit is initially in state G.
Specify an input sequence of length three which could be used to distinguishbetween the two circuits and give the corresponding output sequence from eachcircuit.
15.2 Reduce the following state table to a minimum number of states.
Present Next State Present
State X/H110050 1 Output ( Z)
ae e 1
bc e 1
ci h 0
dh a 1
ei f 0
fe g 0
gh b 1
hc d 0
if b 1
15.3 Digital engineer B. I. Nary has just completed the design of a sequential circuit
which has the following state table:
Present Next State Output
State X/H1100501 01
S0 S5 S1 00
S1 S5 S6 00
S2 S2 S6 00
S3 S0 S1 10
S4 S4 S3 00
S5 S0 S1 00
S6 S5 S1 10
Reduction of State Tables State Assignment 499
His assistant, F. L. Ipflop, who has just completed this course, claims that his design can
be used to replace Mr. Nary’s circuit. Mr. Ipflop’s design has the following state table:
Next State Output
X/H1100501 01
aa b 00
ba c 00
ca b 10
(a) Is Mr. Ipflop correct? (Prove your answer.)
(b) If Mr. Nary’s circuit is always started in state S0, is Mr. Ipflop correct? (Prove
your answer by showing equivalent states, etc.)
15.4 Realize the following state table using a minimum number of AND and OR gates
together with(a) a D flip-flop(b) an S-R flip-flop
X1X2X3
000 001 010 011 100 101 110 111 Z
A AABBBBAA 0
B ABBA ABBA 1
15.5 It is sometimes possible to save logic by using more than the minimum number of flip-
flops. For both (a) and (b), fill in each state assignment by columns and, then, check forduplicate rows instead of filling in the assignments by rows and checking for permutedcolumns. If the columns are assigned in ascending numerical order and the first row isall 0’s, then equivalent assignments will not be generated. Do not list degenerate assign-ments for which two columns are identical or complements of each other, or assign-ments where one column is all 0’s or all 1’s.(a) Consider a state table with three states to be realized using three J-K flip-flops.
To be sure of getting the minimum amount of logic, how many different stateassignments must be tried? Enumerate these assignments.
(b) For four states and three flip-flops, 29 assignments must be tried. Enumerate 10
of these, always assigning 000 to the first state.
15.6 A sequential circuit with one input and one output has the following state table:
Present Next State Present
State X/H110050X/H110051 Output
S1 S5 S4 0
S2 S1 S6 1
S3 S7 S8 1
S4 S7 S1 0
S5 S2 S3 1
S6 S4 S2 0
S7 S6 S8 0
S8 S5 S3 1
500 Unit 15
(a) For this part of the problem, do not consider the flip-flop input equations (this
means that you can ignore the next-state part of the table). Make a state assign-ment which might minimize the output equation, and derive the minimum outputequation for your assignment.
(b) Forget about your solution to (a). Apply Guidelines 1 and 2 to make a state
assignment, assigning 000 to S
1. Derive input equations for D flip-flops using
this assignment.
15.7 The following table is to be realized using D flip-flops.
(a) Find a good state assignment using the three guidelines (do not reduce the table
first.) Try to satisfy as many of the adjacency conditions as possible.
(b) Using this assignment, derive the D flip-flop input equations and the output
equations.
Z
X/H1100501 X/H1100501
AF D 00
BD B 00
CA C 01
DF D 00
EA C 01
FF B 00
15.8 (a) For the following state table, use the three guidelines to determine which of the
three possible nonequivalent state assignments should give the best solution.
Z1Z2
X1X2/H1100500 01 11 10 X1X2/H1100500 01 11 10
AA C B D 00 00 00 00
BB B D D 00 00 10 10
CC A C A 01 01 01 01
DB B C A 01 01 10 10
(b) Using your answer to (a), derive the T flip-flop input equations and the output
equations.
15.9 Implement the given state graph using D flip-flops and gates. Use a one-hot assign-
ment and write down the logic equations by inspecting the state graph.
S0
S2 S1X′
S
X
P
X
P
Y
0X′
0XY′
PS
X′Y′
P
Reduction of State Tables State Assignment 501
15.10 (a) Reduce the following state table to a minimum number of states.
Present Next State Present Output
State X/H1100501 X/H1100501
ah c 10
bc d 01
ch b 00
df h 00
ec f 01
ff g 00
gg c 10
ha c 10
(b) You are given two identical sequential circuits which realize this state table.
One circuit is initially in state d, and the other circuit is initially in state c.
Specify an input sequence of length two which could be used to distinguishbetween the two circuits, and give the corresponding output sequence fromeach circuit.
15.11 For the following state table:
(a) Reduce the table to a minimum number of states.(b) Using the basic definition of state equivalence, show that state ais not equiva-
lent to state b.
Present Next State Present Output
State X/H110050X/H110051 X/H110050X/H110051
ae g 01
bd f 01
ce c 10
db f 01
eg f 01
fb d 10
ge c 10
15.12 A Moore sequential circuit has a single input ( X) and a single output ( Z).Zis 1 if the
most recent four inputs contained exactly two consecutive 1’s or exactly two consec-utive 0’s, i.e., the input sequences 0011, 1001, 1100, 0110, 0100, 1011, and 1101. (Theinitial state S
0acts as if the preceding inputs were all 0’s.) The following state table
was constructed using a sufficient number of states to remember the last four inputsand the output for each state assigned according to the sequence remembered bythat state.(a) Reduce the table to a minimum number of states. ( Hint: First use the simple exam-
ple of state equivalence used in Section 15.1 to eliminate as many states as possible.)
(b) For each state in the reduced table, give the input pattern remembered by that state.(c) Convert the reduced table from Part (a) into a Mealy state table that produces
the same outputs.
(d) Reduce the Mealy state table to a minimum number of states.
502 Unit 15
15.13 A sequential circuit has a single input ( X) and a single output ( Z).The circuit exam-
ines each disjoint block of four inputs and determines whether the block is a validBCD representation of a decimal digit; if not, Z/H110051. State S
0is the initial state, and
the circuit enters state S0after the fourth input. The BCD digits are received most
significant bit first. The following state table was constructed as a Mealy table usinga sufficient number of states to remember the last three inputs with the output pro-duced when the fourth input bit of a block is received.(a) Does the resulting table specify a Mealy or a Moore circuit?(b) Reduce the state table to a minimum number of states. ( Hint: Use the simple exam-
ple of state equivalence used in Section 15.1 to eliminate as many states as possible.)
(c) For each state in the reduced table, give the input pattern remembered by that state.
Input Present Next State Present Output Z
Pattern State X/H110050X/H110051 X/H110050X/H110051
– S1 S2 S3 00
0 S2 S4 S5 00
1 S3 S6 S7 00
00 S4 S8 S9 00
01 S5 S10 S11 00
10 S6 S12 S13 00
11 S7 S14 S15 00
000 S8 S1 S1 00
001 S9 S1 S1 00
010 S10 S1 S1 00
011 S11 S1 S1 00
100 S12 S1 S1 00
101 S13 S1 S1 11
110 S14 S1 S1 11
111 S15 S1 S1 11Input Present Next State Output 
Pattern State X/H110050X/H110051 Z
0000 S0 S0 S1 0
0001 S1 S2 S3 0
0010 S2 S4 S5 0
0011 S3 S6 S7 1
0100 S4 S8 S9 1
0101 S5 S10 S11 0
0110 S6 S12 S13 1
0111 S7 S14 S15 0
1000 S8 S0 S1 0
1001 S9 S2 S3 1
1010 S10 S4 S5 0
1011 S11 S6 S7 1
1100 S12 S8 S9 1
1101 S13 S10 S11 1
1110 S14 S12 S13 0
1111 S15 S14 S15 0
Reduction of State Tables State Assignment 503
15.14 A sequential circuit has a single input ( X) and a single output ( Z). The circuit
examines each disjoint block of four inputs and determines whether the block is avalid BCD representation of a decimal digit; if not, Z/H110051. State S
0is the initial
state, and the circuit enters state S0after the fourth input. The BCD digits are
received least significant bit first. A Mealy state table can be constructed using asufficient number of states to remember the last three inputs with the output pro-duced when the fourth input bit of a block is received.(a) Using the method indicated by Problem 15.13, construct a state table for this
circuit.
(b) Reduce the state table to a minimum number of states. ( Hint: Use the simple
example of state equivalence used in Section 15.1 to eliminate as many states aspossible.)
(c) For each state in the reduced table, give the input pattern(s) remembered by
that state.
15.15 Reduce each of the following state tables to a minimum number of states:
15.16 Reduce each of the following tables to a minimum number of states:
(a) XY/H1100500 01 11 10 Z
ab i c g 0
bb c f g 0
c hddf 1
dh c e g 1
eb c i g 0
ff i i k 0
gj k g h 0
he f c g 0
i iii d 0
jb f c g 0
ka c e g 1(a) XY/H1100500 01 11 10 Z
aa c e d 0
bd e e a 0
ce a f b 1
db c c b 0
ec d f a 1
ff b a d 1(b) X/H1100501 0 1
ab c 10
be d 10
cg d 11
de b 10
ef g 10
fh b 11
gh i 01
hg i 01
ia a 01
504 Unit 15
(b) XY/H1100500 01 11 10 XY/H1100500 01 11 10
aa a g k 1000
bc f g d 0000
cg c a i 1000
da d g i 1000
ef h g a 0000
fg c d k 1000
gc j g e 0100
hg h d k 1000
ih h g d 0000
jj j g k 1000
kc c g d 0000
15.17 Circuits Nand Mhave the state tables that follow.
(a) Without first reducing the tables, determine whether circuits Nand Mare
equivalent.
(b) Reduce each table to a minimum number of states, and then show that Nis
equivalent to Mby inspecting the reduced tables.
M
X/H1100501
S0 S3 S1 0
S1 S0 S1 0
S2 S0 S2 1
S3 S0 S3 1N
X/H1100501
AE A 1
BF B 1
CE D 0
DE C 0
EB D 0
FB C 0
15.18 Below is an incompletely specified state table.
Present Next State Present
State X/H110050 1 Output ( Z)
S0 S1 S0 0
S1 S0 S2 0
S2 S3 S4 1
S3 S0 S3 0
S4 S0 –0
(a) Reduce the state table to four states in two different ways by filling in the don’t-
care in the state table in different ways.
(b) Show that your two state tables in Part (a) are not equivalent, using an implica-
tion table similar to Figure 15-7.
(c) Show that your two state tables in (a) are not equivalent by giving a short input
sequence which gives different outputs for the two state tables.
Reduction of State Tables State Assignment 505
15.19 Repeat 15.18 for this state table (four states).
Present Output
Present Next State ( Z)
State X/H1100501 X/H1100501
S0 S1 S5 00
S1 S3 S2 11
S2 S2 S4 01
S3 S4 S2 11
S4 S4 S2 –1
S5 S5 S2 01
15.20 The following are possible state assignments for a six-state sequential circuit.
(i) (ii) (iii) (iv) (v)
S0 000 010 100 110 001
S1 001 111 101 010 111
S2 010 001 000 111 101
S3 011 110 001 011 011
S4 100 000 111 000 000
S5 101 100 110 100 010
(a) Which two state assignments are equivalent?
(b) For each assignment (except (i)), give an equivalent assignment for which state
S0is assigned to 000.
(c) Give a state assignment which is not equivalent to any of the assignments.
15.21 (a) For an eight-state sequential circuit using three flip-flops, give three state assign-
ments that assign 000 to S0and are equivalent to a straight binary assignment.
(b) Give three state assignments that assign 111 to S0and are not equivalent to a
straight binary assignment or to each other.
15.22 A sequential circuit with one input and one output has the following state table:
Present Next State Present
State X/H110050X/H110051 Output
AD G 1
BE H 0
CB F 1
DF G 0
EC A 1
FH C 0
GE A 1
HD B 0
(a) For this part of the problem, do not consider the flip-flop input equations (this
means that you can ignore the next-state part of the table). Make a state assign-ment which will minimize the output equation, and derive the minimum outputequation for your assignment.
506 Unit 15
(b) Forget about your solution to (a). Apply Guidelines 1 and 2 to make a state
assignment, assigning 000 to A. Derive input equations for D flip-flops using
this assignment.
15.23 (a) For the following state table, use the three guidelines to determine which
of the three possible nonequivalent state assignments should give the bestsolution.
Z1Z2
X1X2/H1100500 01 11 10 X1X2/H1100500 01 11 10
AA A C C 01 01 01 01
BB D B D 11 11 11 11
CA A B D 11 11 00 00
DD B A C 01 01 01 01
(b) Using your answer to (a), derive J-K flip-flop input equations and the output
equations.
15.24 Consider the following Moore sequential circuit.
(a) Derive the equations for a one-hot state assignment.(b) Use Guidelines 1 and 2 to make a “good” state assignment using three state
variables. Derive the next-state equations assuming D flip-flops are used.
Present Next State Present
State X/H110050 X/H110051 Output Z
AB A 0
BC A 0
CE D 0
DB A 1
EE A 0
15.25 (a) Reduce the following state table to a minimum number of states using implica-
tion charts.
(b) Use the guideline method to determine a suitable state assignment for the
reduced table.
(c) Realize the table using D flip-flops.(d) Realize the table using J-K flip-flops.
X/H1100501 Z
AA B 1
BC E 0
CF G 1
DC A 0
EI G 1
FH I 1
GC F 0
HF B 1
IC E 0
Reduction of State Tables State Assignment 507
15.26 Repeat Problem 15.25 for the following table:
X/H1100501 Z
AI C 1
BB I 1
CC G 1
DI C 0
ED E 0
FI C 0
GE F 0
HH A 1
IA C 1
15.27 Make a suitable state assignment and realize the state graph of Figure 14-9 using:
(a) D flip-flops (b) S-R flip-flops
15.28 Make a suitable state assignment and realize the state graph of Figure 14-12 using:
(a) J-K flip-flops (b) T flip-flops
15.29 Make a suitable state assignment and realize the state table of Problem 14.22 using
D flip-flops and NAND gates.
15.30 Make a suitable state assignment and realize the state table of Problem 14.5 using
J-K flip-flops and NAND gates.
15.31 Reduce the state table of Problem 14.6 to a minimum number of rows. Then, make
a suitable state assignment and realize the state table using D flip-flops.
15.32 Reduce the state table of Problem 14.23 to a minimum number of rows. Then, make
a suitable state assignment and realize the state table using D flip-flops.
15.33 A logic designer who had not taken this course designed a sequential circuit with
an input Wusing three T flip-flops, A,B, and C. The input equations for these flip-
flops are
TA/H11005W/H11032A/H11032B/H11001W/H11032BC/H11032/H11001A/H11032BC/H11032/H11001AB/H11032C/H11001WB/H11032C/H11001WAC
TB/H11005W/H11032A/H11032C/H11001W/H11032A/H11032B/H11001A/H11032BC/H11001AB/H11032C/H11032/H11001WB/H11032C/H11032/H11001WAC /H11032
TC/H11005W/H11032AC/H11001W/H11032B/H11032C/H11032/H11001WBC /H11001WA/H11032C/H11032
and the output equation is Z/H11005W/H11032BC/H11032. Find an equivalent sequential circuit which
uses fewer states. Realize it, trying to minimize the amount of logic required.
15.34 Modify the given state graph so that it is completely specified. Assume that if
X=Y=1 ,Xtakes precedence. Then implement the state graph using D flip-flops
and gates. Use a one-hot assignment and write down the logic equations by inspect-
ing the state graph.
15.35 Implement the following state graph using D flip-flops and gates. Use a one-hot
assignment and write down the logic equations by inspecting the state graph.
15.36 A state graph for a single-input sequential circuit is given. Implement the circuit
using a three-bit parallel loading counter that has the given operation table.Label the counter outputs Q
2,Q1,Q0, where Q0is the least significant bit and the
parallel inputs P2,P1,P0.(Hint : Because the Ld signal overrides the Cnt signal, the
counting sequence can easily be changed by doing a parallel load at the appro-priate times.)S0X′Y
S1 S20
XY′
0X′Y′
0
X′Y
ZX′Y
Z
XY
0XY
0,
XY
ZY′
0
Y′
0X′Y
0
XY′
0XY
S
X
SY
S
X′Y′
PY
0X
0
S1 S2
S3S0508 Unit 15
000
0,1
001 011
0100
0,10,11Clr Ld Cnt Function
0 — — Clear
1 1 — Parallel Load1 0 1 Increment
1 0 0 Hold (No change)  
15.37 Consider the following Mealy sequential circuit.
Present Next State Present Output
State X/H110050X/H110051 X/H110050X/H110051
AB A 00
BC A 00
CD A 01
DD A 00
(a) Use a one-hot state assignment, and implement the circuit using D flip-flops.
(b) Use the state assignment A/H1100500,B/H1100501,C/H1100511, and D/H1100510, and implement
the circuit using D flip-flops.
(c) Implement the circuit using a 4-bit parallel loading counter instead of flip-flops
for memory. Assume the synchronous counter controls are as follows:
s1 s0 Function
0 0 Hold
0 1 Increment1 0 Parallel load
1 1 Clear
Q3Q2Q1Q0are the outputs; P3P2P1P0are the parallel inputs; and Q0is the least
significant bit of the counter. (With the proper state assignment, this can bedone without using the parallel load function of the counter.)
(d) Implement the circuit using a 4-bit parallel loading shift register instead of
flip-flops for memory. Assume the synchronous shift register controls are asfollows:
s1 s0 Function
0 0 Hold
0 1 Shift right1 0 Parallel load
1 1 Clear
Sinis the input for the shift; Q3Q2Q1Q0are the outputs; P3P2P1P0are the parallel
inputs. When shifting, Sin→Q3,Q3→Q2,Q2→Q1,Q1→Q0. (With the proper
state assignment, this can be done without using the parallel load function of theshift register.)
15.38 A sequential circuit contains two D flip-flops; the excitation equations for the flip-
flops are D
1/H11005XQ1/H11001XQ2and D2/H11005XQ1/H11001XQ2/H11032
(a) Convert the circuit into an equivalent one where each D flip-flop is replaced by
a T flip-flop. Do this by converting the next-state equations into the form for aT flip-flop. [ Hint: MQ /H11001NQ/H11032/H11005(M/H11032Q/H11001NQ/H11032)/H11032Q/H11001(M/H11032Q/H11001NQ/H11032)Q/H11032.]
(b) Repeat Part (a) by constructing an excitation table for the T flip-flops, i.e., a
truth table for T
1and T2as a function of X, Q1, and Q2.
(c) Convert the circuit into an equivalent one where each D flip-flop is replaced by
a J-K flip-flop. Do this by converting the next-state equations into the form for a J-K flip-flop.Reduction of State Tables State Assignment 509
(d) Repeat Part (c) by constructing an excitation table for the J-K flip-flops, i.e., a
truth table for the J and K flip-flop inputs as a function of X, Q1, and Q2.
15.39 A sequential circuit contains two J-K flip-flops; the excitation equations for the flip-
flops are J1/H11005Q2,K1/H11005Q1,J2/H11005X/H11001Q1/H11032, and K2/H110051.
(a) Convert the circuit into an equivalent one where each J-K flip-flop is replaced
by a T flip-flop. Do this by converting the next-state equations into the form fora T flip-flop. [ Hint: MQ /H11001NQ/H11032/H11005(M/H11032Q/H11001NQ/H11032)/H11032Q/H11001(M/H11032Q/H11001NQ/H11032)Q/H11032.]
(b) Repeat Part (a) by constructing an excitation table for the T flip-flops, i.e., a
truth table for T
1and T2as a function of X, Q1, and Q2.
(c) Convert the circuit into an equivalent one where each D flip-flop is replaced by
an S-R flip-flop. Do this by converting the next-state equations into the form fora S-R flip-flop.
(d) Repeat Part (c) by constructing an excitation table for the S-R flip-flops, i.e., a
truth table for the S and R flip-flop inputs as a function of X, Q
1, and Q2.510 Unit 15
511CHAPTER
00Sequential Circuit Design
Objectives
1.Design a sequential circuit using gates and flip-flops.
2.Test your circuit by simulating it and by implementing it in lab.
3.Design a unilateral iterative circuit. Explain the relationship between iter-
ative and sequential circuits, and convert from one to the other.
4.Show how to implement a sequential circuit using a ROM or PLA and flip-
flops.
5.Explain the operation of CPLDs and FPGAs and show how they can be
used to implement sequential logic.
UNIT
16
1.Study Sections 16.1, Summary of Design Procedure for Sequential Circuits , and
16.2, Design Example—Code Converter .
(a) Why are the states in the next-state part of Table 16-2 listed in a different
order from the states in Table 15-1?
(b) Consider the design of a sequential circuit to convert an 8-4-2-1 code to a 
6-3-1-1 code (see Table 1-2). If the least significant bit of an 8-4-2-1 coded digitis fed into the circuit at t
0, can the least significant bit of the 6-3-1-1 coded digit
be determined immediately? Explain. Why can the technique described inthis section not be used to design the 8-4-2-1 to 6-3-1-1 code converter?
2.Study Section 16.3, Design of Iterative Circuits
(a) Draw a state graph for the comparator of Table 16-4. Compare several
pairs of binary numbers using the scheme represented by Table 16-4 andmake sure you understand why this method works. Draw a circuit similarto Figure 16-6 with five cells. Show the values of all the cell inputs and out-puts if X/H1100510101 and Y/H1100510011.
(b) If the state table for a typical cell of an iterative circuit has nstates, what is the
minimum number of signals required between each pair of adjacent cells?
(c) Work Problem 16.17.
3.Study Section 16.4, Design of Sequential Circuits Using ROMs and PLAs .
(a) Review Section 9.5, Read-Only Memories , and Section 9.6, Programmable
Logic Devices .
(b) What size ROM would be required to realize a state table with 13 states,
two input variables, and three output variables?
(c) In going from Table 16-6(b) to 16-6(c), note that for X/H110050,Q
1Q2Q3/H11005000,
Z/H11005l, and Q1/H11001Q2/H11001Q3/H11001/H11005D1D2D3/H11005001; therefore, 1001 is entered in the first
row of the truth table. Verify that the other truth table entries are correct.
(d) Continue the analysis of the PLA realization of the code converter which
was started in the paragraph following Table 16-7. In particular, ifQ
1Q2Q3/H11005100 and X/H110051, what will be the PLA outputs? What will the
state be after the clock?512 Unit 16
Study Guide
(e) Work Problems 16.15 and 16.16.
4.Study Section 16.5, Sequential Circuit Design Using CPLDs , and Section 16.6,
Sequential Circuit Design Using FPGAs .
(a) How many macrocells of a CoolRunner-II are needed to implement a Moore
machine with six states, one input, and two outputs? With two inputs?
(b) How many LUT’s of a Virtex/Spartan II are needed to implement each of
these Moore machines? How many CLB’s?
(c) Rewrite the equations for Q2/H11001,Q1/H11001, and Q0/H11001of Equations 12-1 to fit into one
LUT each, as we did for Q3/H11001in Equation (16-2), using CE /H11005Ld/H11001Sh.
5.Study Section 16.7, Simulation and Testing of Sequential Circuits .
(a) Observe the simulator output of Figure 16-23(b), and note the times at
which the Zoutput changes. Assuming that each gate and flip-flop in
Figure 16-22 has a 10-ns delay, explain the Zwaveform.
(b) Suppose that you are testing the circuit of Figure 16-4, and that when you set
X/H110050 and Q1Q2Q3/H11005011 and pulse the clock, the circuit goes to state 100
instead of 000.What would you do to determine the cause of the malfunction?
6.Read Section 16.8, Overview of Computer-Aided Design , for general information.
7.Work out your assigned design problem by hand. Then, use LogicAid to check
your state table using the state table checker, and then verify that your logicequations are correct.Try at least two different state assignments and choose theone which requires the smallest number of logic gates.
8.Answer the following questions before you simulate your circuit or test it in lab.
At which of the following times will the output of your circuit be correct? (Ifyou are not absolutely sure that your answer is correct, review Section 13.2, pay-ing particular attention to the timing charts for Mealy circuits.)
(a) Just before the rising clock edge
(b) Just after the rising clock edge (after the state has changed but before the
input is changed to the next value)
(c) After the input has been changed to the next value, but before the next ris-
ing edge occurs
9.(a) Explain how it is possible to get false outputs from your circuit even
though the circuit is correctly designed and working properly.Sequential Circuit Design 513
(b) If the output of your circuit was fed into another sequential circuit using
the same clock, would the false outputs cause any problems? Explain.
10. When you get your circuit working properly, determine the output sequences
for the given test sequences. Demonstrate the operation of your circuit to aproctor and have him or her check your output sequences.After successful com-pletion of the project, turn in your design and the test results. (No readiness testis required.)514 Unit 16
We have already studied the various steps in sequential circuit design—derivationof state tables (Unit 14), state table reduction (Unit 15), state assignment (Unit 15),and derivation of flip-flop input equations (Units 12 and 15). This unit contains asummary of the design procedure, a comprehensive design example, and proce-dures for testing your circuit in lab.
16.1 Summary of Design Procedure
for Sequential Circuits
1.Given the problem statement, determine the required relationship between the
input and output sequences and derive a state table. For many problems, it iseasiest to first construct a state graph.
2.Reduce the table to a minimum number of states. First, eliminate duplicate
rows by row matching and, then, form an implication table and follow the pro-cedure in Section 15.3.
Sequential Circuit Design
3.If the reduced table has mstates (2n/H110021/H11021m/H113492n),nflip-flops are required.
Assign a unique combination of flip-flop states to correspond to each state inthe reduced table. The guidelines given in Section 15.8 may prove helpful infinding an assignment which leads to an economical circuit.
4.Form the transition table by substituting the assigned flip-flop states for each
state in the reduced state table. The resulting transition table specifies the nextstates of the flip-flops, and the output in terms of the present states of the flip-flops and the input.
5.Plot next-state maps and input maps for each flip-flop and derive the flip-flop
input equations. (Depending on the type of gates to be used, either determine thesum-of-products form from the 1’s on the map or the product-of-sums form fromthe 0’s on the map.) Derive the output functions.
6.Realize the flip-flop input equations and the output equations using the available
logic gates.
7.Check your design by signal tracing, computer simulation, or laboratory testing.
16.2 Design Example–Code Converter
We will design a sequential circuit to convert BCD to excess-3 code. This circuit
adds three to a binary-coded-decimal digit in the range 0 to 9. The input and outputwill be serial with the least significant bit first. A list of allowed input and outputsequences is shown in Table 16-1.
Table 16-1 lists the desired inputs and outputs at times t
0,tl,t2, and t3. After
receiving four inputs, the circuit should reset to the initial state, ready to receiveanother group of four inputs. It is not clear at this point whether a sequential cir-cuit can actually be realized to produce the output sequences as specified inTable 16-1 without delaying the output.Sequential Circuit Design 515
XZ
Input Output
(BCD) (excess-3)
t3t2t1t0 t3t2t1t0
0000 0011
0001 0100
0010 01010011 01100100 01110101 1000
0110 1001
0111 10101000 10111001 1100TABLE 16-1
For example, if at t0some sequences required an output Z/H110050 for X/H110050 and
other sequences required Z/H110051 for X/H110050, it would be impossible to design the cir-
cuit without delaying the output. For Table 16-1 we see that at t0if the input is 0 the
output is always 1, and if the input is 1 the output is always 0; therefore, there is noconflict at t
0. At time tlthe circuit will have available only the inputs received at tl
and t0. There will be no conflict at tlif the output at tlcan be determined only from
the inputs received at tlandt0. If 00 has been received at tlandt0, the output should
be 1 at tlin all three cases where 00 occurs in the table. If 01 has been received, the
output should be 0 at tlin all three cases where 01 occurs. For sequences 10 and 11
the outputs at tlshould be 0 and 1, respectively. Therefore, there is no output con-
flict at tl. In a similar manner we can check to see that there is no conflict at t2, and
att3all four inputs are available, so there is no problem.
We will now proceed to set up the state table (Table 16-2), using the same pro-
cedure as in Section 15.1. The arrangement of next states in the table is differentfrom that in Table 15-1 because in this example the input sequences are receivedwith least significant bit first, while for Table 15-1 the first input bit received islisted first in the sequence. Dashes (don’t-cares) appear in this table because only10 of the 16 possible 4-bit sequences can occur as inputs to the code converter.Theoutput part of the table is filled in, using the reasoning discussed in the precedingparagraph. For example, if the circuit is in state Batt
land a 1 is received, this
means that the sequence 10 has been received and the output should be 0.
Next, we will reduce the table using row matching. When matching rows
which contain dashes (don’t-cares), a dash will match with any state or with anyoutput value. By matching rows in this manner, we have H≡I≡J≡K≡Land
M≡N≡P. After eliminating I,J,K,L,N, and P, we find E≡F≡Gand the table
reduces to seven rows (Table 16-3).516 Unit 16
Input Sequence 
Received Present 
(Least Significant Present Next State Output ( Z)
Time Bit First) State X/H1100501 X/H1100501
t0 reset AB C 10
t10 BD F 10
1 CE G 01
00 DH L 01
t201 EI M 10
10 FJ N 10
11 GK P 10
000 HA A 01
001 IA A 01
010 JA –0 –
t3011 KA –0 –
100 LA –0 –
101 MA –1 –
110 NA –1 –
111 PA –1 –TABLE 16-2
State Table
for Code 
Converter
An alternate approach to deriving Table 16-2 is to start with a state graph. The
state graph (Figure 16-1) has the form of a tree. Each path starting at the reset staterepresents one of the ten possible input sequences. After the paths for the inputsequences have been constructed, the outputs can be filled in by working backwardsalong each path. For example, starting at t
3, the path 0 0 0 0 has outputs 0 0 1 1
and the path 1 0 0 0 has outputs 1 0 1 1. Verify that Table 16-2 corresponds to thisstate graph.
Three flip-flops are required to realize the reduced table because there are
seven states. Each of the states must be assigned a unique combination of flip-flopstates. Some assignments will lead to economical circuits with only a few gates, whileother assignments will require many more gates. Using the guidelines given inSection 15.8, states BandC,DandE, and HandMshould be given adjacent assign-
ments in order to simplify the next-state functions. To simplify the output function,states ( A,B,E, and M) and ( C,D, and H) should be given adjacent assignments. A
good assignment for this example is given on the map and table in Figure 16-2.Afterthe state assignment has been made, the transition table is filled in according to theassignment, and the next-state maps are plotted as shown in Figure 16-3. The D
input equations are then read off the Q
/H11001maps as indicated. Figure 16-4 shows the
resulting sequential circuit.Sequential Circuit Design 517
Next Present 
Present State Output ( Z)
Time State X/H1100501 X/H1100501
t0 AB C 10
t1 BD E 10
CE E 01
t2 DH H 01
EH M 10
t3 HA A 01
MA –1 –TABLE 16-3
Reduced State
Table for Code
Converter
t0
t1
t2
t3A
N I J L H PGC
E FB
D
K MReset0
1
0
1
0
0
0
00
00
00
00
00
0
0
10
10
10
1
0
10
11
01
0
1
01
01
0
1
11
1
1
11
1FIGURE 16-1
State Graph
for Code 
Converter
518 Unit 16
D3= Q3 = Q1Q2Q3 + X′Q1Q3 + XQ1Q2D1= Q1 = Q2′1 1 1 100 01 11 10
X 1 1X
0 0 0 0
00000XQ1
Q2Q3
01
11
10 X
+D2= Q2 = Q10 1 1 000 01 11 10
X 1 1X
0 1 1 0
01100XQ1
Q2Q3
01
11
10 X
+
′′ ′0 1 0 100 01 11 10
X 0 0X
0 1 1 0
01000XQ1
Q2Q3
01
11
10 X
+Z= X′Q3 + XQ3 ′1 1 0 000 01 11 10
X 0 1X
0 0 1 1
11000XQ1
Q2Q3
01
11
10 XFIGURE 16-3
Karnaugh
Maps for Code
Converter Design
FIGURE 16-4
Code Converter
Circuit
Q3 A6A5
Z
Q2D
FF1 G1
G2
G3G4G5
G6Q′Q
D
FF2 I1
Q′Q
D
FF3
Q′QQ1
Q1
CLKQ1
Q1A1
A2
A3D3X
X′Q1′
′Q1Q2Q3
Q3
X′
X′Q2
Q2
Q3′
Q2′′
′G7Q1/H11545Q2/H11545Q3/H11545Z
Q1Q2Q3X/H110050 X/H110051 X/H110050 X/H110051
A 0 0 0 1 0 0 1 0 1 1 0
B 1 0 0 1 1 1 1 1 0 1 0
C 1 0 1 1 1 0 1 1 0 0 1
D 1 1 1 0 1 1 0 1 1 0 1
E 1 1 0 0 1 1 0 1 0 1 0
H 0 1 1 0 0 0 0 0 0 0 1
M 0 1 0 0 0 0 x x x 1 x
–0 0 1 x x x x x x x x
(b) Transition table01
00Q2Q3Q1
01
1110AB
HD
MEC
(a) Assignment mapFIGURE 16-2
Assignment Map
and Transition
Table for Flip-Flops
16.3 Design of Iterative Circuits
Many of the design procedures used for sequential circuits can be applied to the design
of iterative circuits. An iterative circuit consists of a number of identical cells intercon-nected in a regular manner. Some operations, such as binary addition, naturally lendthemselves to realization with an iterative circuit because the same operation is per-formed on each pair of input bits. The regular structure of an iterative circuit makes iteasier to fabricate in integrated circuit form than circuits with less regular structures.
The simplest form of an iterative circuit consists of a linear array of combinational
cells with signals between cells traveling in only one direction (Figure 16-5). Each cellis a combinational circuit with one or more primary inputs ( x
i) and possibly one or
more primary outputs ( zi). In addition, each cell has one or more secondary inputs ( ai)
and one or more secondary outputs ( ai/H110011). The aisignals carry information about the
“state” of one cell to the next cell.
The primary inputs to the cells ( x1,x2, ... ,xn) are applied in parallel; that is, they are
all applied at the same time. The aisignals then propagate down the line of cells.
Because the circuit is combinational, the time required for the circuit to reach a steady-state condition is determined only by the delay times of the gates in the cells. As soonas steady state is reached, the outputs may be read. Thus, the iterative circuit can func-tion as a parallel-input, parallel-output device, in contrast with the sequential circuit inwhich the input and output are serial. One can think of the iterative circuit as receiv-ing its inputs as a sequence in space in contrast with the sequential circuit whichreceives its inputs as a sequence in time. The parallel adder of Figure 4-3 is an exampleof an iterative circuit that has four identical cells. The serial adder of Figure 13-12 usesthe same full adder cell as the parallel adder, but it receives its inputs serially and storesthe carry in a flip-flop instead of propagating it from cell to cell.
Design of a Comparator
As an example, we will design a circuit which compares two n-bit binary numbers and
determines if they are equal or which one is larger if they are not equal. Direct designas a 2 n-input combinational circuit is not practical for nlarger than 4 or 5, so we will
try the iterative approach. Designate the two binary numbers to be compared as
X/H11005x
1x2...xn and Y/H11005y1y2...yn
We have numbered the bits from left to right, starting with x1as the most significant
bit because we plan to do the comparison from left to right.Sequential Circuit Design 519
a1a2
Z1X1
Cell
1a3
Z2X2
Cell
2a4
Z3X3
Cell
3aiai + 1
ZiXi
Cell
ianan + 1
ZnXn
Cell
n... ...FIGURE 16-5
Unilateral
Iterative Circuit
Figure 16-6 shows the form of the iterative circuit, although the number of leads
between each pair of cells is not yet known. Comparison proceeds from left to right.The first cell compares x
1andy1and passes on the result of the comparison to the next
cell, the second cell compares x2andy2, etc. Finally, xnandynare compared by the last
cell, and the output circuit produces signals to indicate if X/H11005Y,X/H11022Y, or X/H11021Y.
We will now design a typical cell for the comparator. To the left of cell i, three
conditions are possible: X/H11005Yso far ( x1x2...xi/H110021/H11005y1y2...yi/H110021),X/H11022Yso far, and
X/H11021Yso far.We designate these three input conditions as states S0,S1, and S2, respec-
tively. Table 16-4 shows the output state at the right of the cell ( Si/H110011) in terms of the
xiyiinputs and the input state at the left of the cell ( Si). If the numbers are equal to
the left of cell iand xi/H11005yi, the numbers are still equal including cell i, so Si/H110011/H11005S0.
However, if Si/H11005S0andxiyi/H1100510, then x1x2...xi/H11022y1y2...yiandSi/H110011/H11005S1. If X/H11022Y
to the left of cell i, then regardless of the values of xiand yi,x1x2...xi/H11022y1y2...yi
andSi/H110011/H11005S1. Similarly, if X/H11021Yto the left of cell i, then X/H11021Yincluding the inputs
to cell i, and Si/H110011/H11005S2.520 Unit 16
a1a2x1
Cell
1a3x2
Cell
2y1 y2
aiai + 1Z1(X < Y)
Z2(X = Y)
Z3(X > Y)xiyi
Cell
ixnyn
Cell
nanan + 1Output
Cir-
cuit...
b1b2 b3 bi ......
bi + 1 bnbn + 1...FIGURE 16-6
Form of Iterative
Circuit for Compar-
ing Binary Numbers
Si/H110011
Si xiyi/H1100500 01 11 10 Z1Z2Z3
X/H11005Y S0 S0 S2 S0S1 01 0
X/H11022Y S1 S1 S1 S1S1 00 1
X/H11021Y S2 S2 S2 S2S2 10 0TABLE 16-4
State Table
for Comparator
The logic for a typical cell is easily derived from the state table. Because there
are three states, two intercell signals are required. Using the guidelines fromSection 15.8 leads to the state assignment a
ibi/H1100500 for S0, 01 for S1, and 10 for S2.
Substituting this assignment into the state table yields Table 16-5. Figure 16-7shows the Karnaugh maps, next-state equations, and the realization of a typicalcell using NAND gates. Inverters must be included in the cell because only a
iand
biand not their complements are transmitted between cells.
The a1b1inputs to the left end cell must be 00 because we must assume that the
numbers are equal (all 0) to the left of the most significant bit.The equations for thefirst cell can then be simplified if desired:
a
2/H11005a1/H11001x/H110321y1b/H110321/H11005x/H110321y1
b2/H11005b1/H11001x1y/H110321a/H110321/H11005x1y/H110321
ai/H110011bi/H110011
aibi xiyi/H1100500 01 11 10 Z1Z2Z3
0  0 0 0 1 00 00 1 0 1 0
0  1 0 1 0 10 10 1 0 0 11  0 1 0 1 01 01 0 1 0 0TABLE 16-5
Transition Table
for Comparator
Sequential Circuit Design 521
For the output circuit, let Z1/H110051 if X/H11021Y,Z2/H110051 if X/H11005Y,Z3/H110051 if X/H11022Y.
Figure 16-8 shows the output maps, equations, and circuit.
Conversion to a sequential circuit is straightforward. If xiandyiinputs are received
serially instead of in parallel, Table 16-4 is interpreted as a state table for a sequentialcircuit, and the next-state equations are the same as in Figure 16-7. If D flip-flops areused, the typical cell of Figure 16-7 can be used as the combinational part of thesequential circuit, and Figure 16-9 shows the resulting circuit. After all of the inputshave been read in, the output is determined from the state of the two flip-flops.xi yi
ai
biai
bi′′ai + 1
bi + 1010000 01 11 10
0000
XXXX
100aibi
ai + 1 = ai+xiyibi′′ bi + 1 = bi+xiyiai′′xiyi
01
1110 111000100 01 11 10
1111
XXXX
000aibixiyi
01
1110 000
Z1(X < Y)
Z2(X = Y)
Z3(X > Y)Z1 = an + 1 Z2 = an + 1bn + 1 ′′ Z3 = bn + 101
1
X0bn + 1
bn + 1an + 1
an + 1101
1
X0bn + 1an + 1
101
1 X0bn + 1an + 1
1FIGURE 16-7
Typical Cell
for Comparator
FIGURE 16-8
Output Circuit
for Comparator
This example indicates that the design of a unilateral iterative circuit is very sim-
ilar to the design of a sequential circuit. The principal difference is that for the iter-ative circuit the inputs are received in parallel as a sequence in space, while for thesequential circuit the inputs are received serially as a sequence in time. For the iter-ative circuit, the state table specifies the output state of a typical cell in terms of itsinput state and primary inputs, while for the corresponding sequential circuit, thesame table specifies the next state (in time) in terms of the present state and inputs.If D flip-flops are used, the typical cell for the iterative circuit can serve as the com-binational logic for the corresponding sequential circuit. If other flip-flop types areused, the input equations can be derived in the usual manner.
16.4 Design of Sequential Circuits Using
ROMs and PLAs
A sequential circuit can easily be designed using a ROM (read-only memory) and flip-
flops. Referring to the general model of a Mealy sequential circuit given in Figure 13-17,the combinational part of the sequential circuit can be realized using a ROM. TheROM can be used to realize the output functions ( Z
1,Z2,..., Zn) and the next-state
functions ( Q1/H11001,Q2/H11001,..., Qk/H11001). The state of the circuit can then be stored in a register of
D flip-flops and fed back to the input of the ROM.Thus, a Mealy sequential circuit withminputs, noutputs, and kstate variables can be realized using kD flip-flops and a
ROM with m/H11001kinputs (2
m/H11001kwords) and n/H11001koutputs. The Moore sequential circuit
of Figure 13-19 can be realized in a similar manner. The next-state and output combi-national subcircuits of the Moore circuit can be realized using two ROMs.Alternatively,a single ROM can be used to realize both the next-state and output functions.
Use of D flip-flops is preferable to J-K flip-flops because use of two-input flip-
flops would require increasing the number of outputs from the ROM. The fact thatthe D flip-flop input equations would generally require more gates than the J-Kequations is of no consequence because the size of the ROM depends only on thenumber of inputs and outputs and not on the complexity of the equations being522 Unit 16
Clock
ClockDa
CKai ai + 1Z1(X < Y)
Z2(X = Y)
Z3(X > Y)xi yi
Typical Cell
(see Fig. 16-7)
biai
bi bi + 1Db
CKFIGURE 16-9
Sequential
Comparator for
Binary Numbers
realized. For this reason, the state assignment which is used is also of little impor-
tance, and, generally, a state assignment in straight binary order is as good as any.
In Section 16.2, we realized a code converter using gates and D flip-flops. We will
now realize this converter using a ROM and D flip-flops. The state table for the con-verter is reproduced in Table 16-6(a). Because there are seven states, three D flip-flops are required. Thus, a ROM with four inputs (2
4words) and four outputs is
required, as shown in Figure 16-10. Using a straight binary state assignment, we canconstruct the transition table, seen in Table 16-6(b), which gives the next state of theflip-flops as a function of the present state and input. Because we are using D flip-flops, D
1/H11005Q1/H11001,D2/H11005Q2/H11001, and D3/H11005Q3/H11001.The truth table for the ROM, shown in Table
16-6(c), is easily constructed from the transition table. This table gives the ROM out-puts ( Z,D
1,D2, and D3) as functions of the ROM inputs ( X,Q1,Q2, and Q3).
Sequential circuits can also be realized using PLAs (programmable logic
arrays) and flip-flops in a manner similar to using ROMs and flip-flops. However,in the case of PLAs, the state assignment may be important because the use of aSequential Circuit Design 523
(a) State table
Present
Present Next State Output ( Z)
State X/H110050     1 X/H110050     1
AB C 10
BD E 10
CE E 01
DH H 01
EH M 10
HA A 01
MA –1 –TABLE 16-6 (b) Transition table
Q1/H11545Q2/H11545Q3/H11545Z
Q1Q2Q3X/H110050 X/H110051X/H110050 X/H110051
A0 0 0 001 010 1 0
B0 0 1 011 100 1 0
C0 1 0 100 100 0 1
D0 1 1 101 101 0 1
E1 0 0 101 110 1 0
H1 0 1 000 000 0 1
M1 1 0 000 – 1 –
(c) Truth table
XQ1Q2Q3 ZD1D2D3
0000 1001
0001 1011
0010 01000011 01010100 11010101 0000
0110 1000
0111 x xxx1000 00101001 0100
1010 1100
1011 11011100 01101101 10001110 x xxx1111 x xxx
good state assignment can reduce the required number of product terms and,
hence, reduce the required size of the PLA.
As an example, we will consider realizing the state table of Table 16-6(a) using a
PLA and three D flip-flops. The circuit configuration is the same as Figure 16-10,except that the ROM is replaced with a PLA of appropriate size. Using a straight bina-ry assignment leads to the truth table given in Table 16-6(c). This table could be storedin a PLA with four inputs, 13 product terms, and four outputs, but this would offer lit-tle reduction in size compared with the 16-word ROM solution discussed earlier.
If the state assignment of Figure 16-2 is used, the resulting output equation and
D flip-flop input equations, derived from the maps in Figure 16-3, are
D
1/H11005Q1/H11001/H11005Q/H110322
D2/H11005Q2/H11001/H11005Q1 (16-1)
D3/H11005Q3/H11001/H11005Q1Q2Q3/H11001X/H11032Q1Q/H110323/H11001XQ/H110321Q/H110322
Z/H11005X/H11032Q/H110323/H11001XQ3
The PLA table which corresponds to these equations is in Table 16-7. Realization of
this table requires a PLA with four inputs, seven product terms, and four outputs.524 Unit 16
ClockD1
CKQ1
Q1Z
Q2
Q2
Q3
Q3++
+ ROM
16 Words
/H11003 4 BitsD2
CKX
D3
CKFIGURE 16-10
Realization of
Table 16.6(a)
Using a ROM
XQ1Q2Q3 ZD1D2D3
–– 0 – 01 0 0–1 – – 00 1 0
–1 1 1 00 0 1
01– 0 0001100 – 00010–– 0 10001–– 1 1000TABLE 16-7
Sequential Circuit Design 525
FIGURE 16-11
Segment of 
a Sequential PALClockEn
D Q
Q′Q′
Q′
QQ′ A
AA′B
BB′ Q
Inverting
Tri-State
Output
Buffer
Programmable AND Arra yNext, we will verify the operation of the circuit of Figure 16-4 using a PLA which
corresponds to Table 16-7. Initially, assume that X/H110050 and Q1Q2Q3/H11005000. This
selects rows --0- and 0--0 in the table, so Z/H110051 and D1D2D3/H11005100. After the active
clock edge, Q1Q2Q3/H11005100. If the next input is X/H110051, then rows --0- and -1-- are
selected, so Z/H110050 and D1D2D3/H11005110. After the active clock edge, Q1Q2Q3/H11005110.
Continuing in this manner, we can verify the transition table of Figure 16-2.
PALs also provide a convenient way of realizing sequential circuits. PALs are
available which contain D flip-flops that have their inputs driven from programma-ble array logic. Figure 16-11 shows a segment of a sequential PAL. The D flip-flopis driven from an OR gate which is fed by two AND gates.The flip-flop output is fedback to the programmable AND array through a buffer. Thus, the AND gate inputscan be connected to A,A/H11032,B,B/H11032,Q, or Q/H11032. The X’s on the diagram show the con-
nections required to realize the next-state equation
Q
/H11001/H11005D/H11005A/H11032BQ/H11032/H11001 AB/H11032Q
The flip-flop output is connected to an inverting tri-state buffer, which is enabled
when En /H110051.
16.5 Sequential Circuit Design Using CPLDs
As discussed in Section 9.7, a typical CPLD contains a number of macrocells that
are grouped into function blocks. Connections between the function blocks aremade through an interconnection array. Each macrocell contains a flip-flop and anOR gate, which has its inputs connected to an AND gate array. Some CPLDs arebased on PALs, in which case each OR gate has a fixed set of AND gates associat-ed with it. Other CPLDs are based on PLAs, in which case any AND gate outputwithin a function block can be connected to any OR gate input in that block.
Figure 16-12 shows the structure of a Xilinx CoolRunner II CPLD, which uses a
PLA in each function block. This CPLD family is available in sizes from two to 32function blocks (32 to 512 macrocells). Each function block has 16 inputs from theAIM (advanced interconnection matrix) and up to 40 outputs to the AIM. Eachfunction block PLA contains the equivalent of 56 AND gates.
The basic CoolRunner II architecture is similar to that shown in Figure 9-29.
Figure 16-13 represents a CoolRunner-II macrocell and the associated AND array.Box (1) represents the AND array which is driven by signals from the AIM. Each ofthe 56 product terms (P-terms) generated by the AND array (2) can have up to 40 vari-ables. Box (3) represents the OR array which selects the AND gates for each macro-cell. The OR gate (4) in a specific macrocell can have any subset of the P-terms asinputs. The MUXes on the diagram do not have control inputs shown because eachMUX is programmed to select one of its inputs. For example, MUX (5) can be pro-grammed to select a product term, the complement of a product term, a logic 1, or alogic 0 for the MUX output. If logic 1 is selected, the XOR gate complements the ORgate output; if logic 0 is selected, the XOR gate passes the OR gate output withoutchange. By complementing or not complementing the OR gate output, a function canbe implemented as either a product of sums or as a sum of products.
The XOR gate output can be routed directly to an I/O block or to the macro-
cell flip-flop input. The flip-flop can be programmed as a D-CE flip-flop or as a Tflip-flop. The flip-flop can be programmed as an ordinary flip-flop (F/F), a latch,or a dual-edge triggered flip-flop, which can change state on either clock edge.TheCK input and the asynchronous Sand Rinputs can each be programmed to come
from several different sources. MUX (6) can invert the clock input or not, so thatthe flip-flop can trigger on either clock edge. MUX (7) selects either the flip-flopoutput or the XOR gate output and passes it to an I/O block.
Figure 16-14 shows how a Mealy sequential machine with two inputs, two outputs,
and two flip-flops can be implemented by a CPLD. Four macrocells are required, two to526 Unit 16
Function
Block 1Function
Block n
PLA PLAI/O Blocks
I/O Blocks16 16
40 4016 FB 16 FB
16 16I/O Pin MC1
MC2
MC16MC1
MC2
MC16AIMI/O Pin
I/O Pin
Fast Inputs
BSC and ISPClock and Control SignalsBSC Path
Fast InputsI/O PinI/O Pin
I/O Pin
JTAGFIGURE 16-12 CoolRunner-II Architecture1(Figure based on figures and text owned by Xilinx, Inc., Courtesy
of Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
1Additional data on Xilinx CPLDs and FPGAs is available from www.Xilinx.com.
generate the D inputs to the flip-flops and two to generate the Zoutputs. The flip-flop
outputs are fed back to the AND array inputs via the interconnection matrix (notshown).The number of product terms required depends on the complexity of the equa-tions for the D’s and the Z’s.
Figure 16-15 shows how the 4-bit loadable right-shift register of Figure 12-15 can be
implemented using four macrocells of a CPLD. The four OR-gate outputs implementtheDinputs specified by Equations (12-1).A total of 12 product terms are required.The
Qoutputs are fed back to the AND array via the interconnection matrix (not shown).Sequential Circuit Design 527
GCK0
GCK1
GCK2CTCPTC
PTC49 P-terms
To PTA, PTB, PTC of 
other macrocells
CTC, CTR,
CTS, CTEFrom AIM
4 P-terms
PTAFast Input
from
I/O BlockFeed back
to AIM
PTB
PTC
PLA OR TermPTA
CTS
GSR
GND
GNDVCC
RD/T
CE
CKF/F
Latch
DualEDGEQS40
To I/O Bloc k
PTA
CTR
GSR
GND(1)2
2222
(3)
45
67FIGURE 16-13 CoolRunner-II Macrocell (Figure based on figures and text owned by Xilinx, Inc., Courtesy of
Xilinx, Inc. © Xilinx, Inc. 1999–2003. All rights reserved.)
FIGURE 16-14
CPLD
Implementation
of a Mealy 
Machine
FFFF
AND
Arra yX1X2
Q1Macrocells
Q2
Z1
Z2D1
D2
Figure 16-16 shows how three bits of the parallel adder with accumulator of
Figure 12-5 can be implemented using a CPLD. Each bit of the adder requires twomacrocells. One of the macrocells implements the sum function and an accumulatorflip-flop. The other macrocell implements the carry, which is fed back into the ANDarray. The Adsignal can be connected to the CE input of each flip-flop via an AND
gate (not shown). Each bit of the adder requires eight product terms (four for thesum, three for the carry, and one for CE). If the flip-flops are programmed as T flip-flops, then the logic for the sum can be simplified. For each accumulator flip-flop
X
i/H11001/H11005Xi⊕Yi⊕Ci
Then, the Tinput is
Ti/H11005Xi/H11001⊕Xi/H11005Yi⊕Ci
which requires only two product terms.528 Unit 16
FFFF
FF
FFAND
Arra ySI
D3
D2
D1
D0
Sh
LdQ3
Q1
Q0Macrocells
Q2FIGURE 16-15
CPLD
Implementation
of a Shift Register
S0
S1
S2FF
FF
FFAND
Arra yC0C1
X0
C2
X1
C3
X2Y0
Y1
Y2FIGURE 16-16
CPLD
Implementation
of a Parallel
Adder with
Accumulator
The add signal can be ANDed with the Tiinput so that the flip-flop state can change
only when Ad/H110051:
Ti/H11005Ad(Yi⊕Ci)/H11005Ad YiC/H11032i/H11001Ad Y /H11032iCi
16.6 Sequential Circuit Design Using FPGAs
As discussed in Section 9.8, an FPGA usually consists of an array of configurable
logic blocks (CLBs) surrounded by a ring of I/O blocks. The FPGA may also con-tain other components such as memory blocks, clock generators, tri-state buffers,etc. A typical CLB contains two or more function generators, often referred to aslook-up tables or LUTs, programmable multiplexers, and D-CE flip-flops (seeFigure 9-33). The I/O blocks usually contain additional flip-flops for storing inputsor outputs and tri-state buffers for driving the I/O pins.
Figure 16-17 shows a simplified block diagram for a Xilinx Virtex or Spartan II
CLB. This CLB is divided into two nearly identical slices . Each slice contains two 
4-variable function generators (LUTs), two D-CE flip-flops, and additional logic forcarry and control.This additional logic includes MUXes for selecting the flip-flop inputsand for multiplexing the LUT outputs to form functions of five or more variables.
Figure 16-18 shows how a Mealy sequential machine with two inputs, two outputs,
and two flip-flops can be implemented by a FPGA. Four LUTs (FGs or functiongenerators) are required, two to generate the Dinputs to the flip-flops and two to
generate the Zoutputs. The flip-flop outputs are fed back to the CLB inputs via
interconnections external to the CLB.The entire circuit fits into one Virtex CLB.Thisimplementation works because each Dand Zis a function of only four variables Sequential Circuit Design 529
F1F2F3F4G1G2G3G4
Carry &
ControlCarry &
Control
Carry &
ControlCarry &
ControlLUT
CIN CINCOUT COUT
YQ
XQ XQYQ
XXBYYB YB
Y
BXBY
BXBYG1G2G3G4
F1F2F3F4
Slice 1 Slice 0XB
X
LUT LUTLUT D
CEQ
RCSP
D
CEQ
RCSPD
CEQ
RCSP
D
CEQ
RCSPFIGURE 16-17
Xilinx Virtex/
Spartan II CLB
(Figure based on
figures and text
owned by Xilinx,
Inc., Courtesy of 
Xilinx, Inc. © Xilinx,
Inc. 1999–2003. All
rights reserved.)
(X1,X2,Q1, and Q2). If more flip-flops or inputs are needed, the DorZfunctions may
have to be decomposed to use additional function generators as in Figure 9-36.
Figure 16-19 shows how the 4-bit loadable right-shift register of Figure 12-15 can
be implemented using an FPGA. Four LUTs are used to generate the Dinputs to
the flip-flops, and a fifth LUT generates the CE input. If we had implementedEquations (12-1) directly without using the CE input, we would need to implementfour 5-variable functions. This would require eight LUTs because each 5-variablefunction requires two 4-variable function generators (see Figure 9-36(a)). However,if we set CE /H11005Ld/H11001Sh, then CE /H110050 when Ld/H11005Sh/H110050 and the flip-flops hold
their current values. Therefore, we do not need the first term in each of Equations(12-1), and the flip-flop Dinput equations fit into 4-variable function generators.We
can rewrite Equation (12-1(a)) in terms of CE as follows:
Q
3/H11001/H11005CE/H11032Q3/H11001CED3f/H11005Ld/H11032Sh/H11032Q3/H11001(Ld/H11001Sh)(Sh/H11032D3/H11001ShSI) (16-2)
where D3fis the Dinput to flip-flop 3. The Dinput to the Q3flip-flop is therefore
D3f/H11005Sh/H11032D3/H11001ShSI530 Unit 16
X1
Q1 D1
CK FF
CE
CE 11FG1
Q2
Z1X2
Z2D2
CK FFFG2
FG3
FG4FIGURE 16-18
FPGA
Implementation
of a Mealy 
Machine
CE CE DD DD CE CE
FG4
D3ShSI D2Q3 Q2 Q1 Q0
D1 D0CKFF FF FF FF
CK CK CK
FG3 FG2 FG1 FG0
LdFIGURE 16-19
FPGA
Implementation
of a Shift Register
which is a 3-variable function. We can determine the other three flip-flop Dinputs in a
similar way.
Figure 16-20 shows how three bits of the parallel adder with accumulator of
Figure 12-5 can be implemented using an FPGA. Each bit of the adder can be imple-mented with two 3-variable function generators, one for the sum and one for thecarry. The Adsignal can be connected to the CE input of each flip-flop so that the
sum is loaded by the rising clock edge when Ad/H110051.The arrangement for generating
the carries, shown in Figure 16-20, is rather slow because the carry signal must prop-agate through a function generator and its external interconnections for each bit.Because adders are frequently used in FPGAs, most FPGAs have built-in fast carrylogic in addition to the function generators. If the fast carry logic is used, the bottomrow of function generators in Figure 16-20 is not needed, and a parallel adder withan accumulator can be implemented using only one function generator for each bit.
16.7 Simulation and Testing of Sequential Circuits
Simulation of a digital system can take place at several levels of detail. At the func-tional level, system operation is described in terms of a sequence of transfers betweenregisters, adders, memories, and other functional units. Simulation at this level may beused to verify the high-level system design. At the logic level, the system is describedin terms of logic elements such as gates and flip-flops and their interconnections. Logiclevel simulation may be used to verify the correctness of the logic design and to ana-lyze the timing. At the circuit level, each gate is described in terms of its circuit com-ponents such as transistors, resistances, and capacitances. Circuit level simulation givesdetailed information about voltage levels and switching speeds. In this text, we will con-sider simulation at the logic level as well as system level simulation using VHDL.
Simulation of sequential circuits is similar to the simulation of combinational
circuits described in Section 8.5. However, for sequential circuits, the propagationdelays associated with the individual logic elements must be taken into account, andSequential Circuit Design 531
CE CE DD D CE
C1 C2S2 S1 S0
C3
Y0 Y1 Y2X2 X1 X0
C0(Cin)CKFF FF FF
CK CK
Ad
FG3a
FG2b FG3b FG1bFG2a FG1aFIGURE 16-20
FPGA
Implementation
of a Parallel Adder
with Accumulator
the presence of feedback may cause complications. The simulator output usually
includes timing diagrams which show the times at which different signals in the cir-cuit change. The delays in the gates and flip-flops may be modeled in several ways.The simplest method is to assume that each element has one unit of delay. The useof this unit delay model is generally sufficient to verify that the design is logicallycorrect. If a more detailed timing analysis is required, each logic element may beassigned a nominal delay value. The nominal or typical delays for a device are usu-ally provided by the device manufacturer on the specification sheets.
In practice, no two gates of a given type will have exactly the same delay, and the
value of the delay may change depending on temperature and voltage levels. Forthese reasons, manufacturers often specify a minimum and maximum delay valuefor each type of logic element. Some simulators can take the minimum and maxi-mum delay values into account. Instead of showing the exact time at which a signalchanges, the simulator output indicates a time interval in which the signal maychange. Figure 16-21 shows the output from an inverter which has a nominal delayof 10 ns, a minimum delay of 5 ns, and a maximum delay of 15 ns. The shaded regionindicates that the inverter output may change at any time during the interval. Min-max delay simulators can be used to verify that a digital system will operate cor-rectly as long as the delay in each element is within its specified range.
Testing of sequential circuits is generally more difficult than testing combination-
al circuits. If the flip-flop outputs can be observed, then the state table can be verifieddirectly on a row-by-row basis. The state table can be checked out with a simulator orin lab as follows:
1.Using the direct set and clear inputs, set the flip-flop states to correspond to one
of the present states in the table.
2.For a Moore machine, check to see that the output is correct. For a Mealy
machine, check to see that the output is correct for each input combination.
3.For each input combination, clock the circuit and check to see that the next state
of the flip-flops is correct. (Reset the circuit to the proper state before eachinput combination is applied.)
4.Repeat steps 1, 2, and 3 for each of the present states in the table.
In many cases when a sequential circuit is implemented as part of an integrated cir-
cuit, only the inputs and outputs are available at the IC pins, and observing the state ofthe internal flip-flops is impossible. In this case, testing must be done by applying inputsequences to the circuit and observing the output sequences. Determining a small setof input sequences which will completely test the circuit is generally a difficult problem532 Unit 16
AAB
Nominal Dela y B
Min-Max Dela y B
0 1 02 03 04 05 06 0 t(ns)FIGURE 16-21
Simulator Output
for an Inverter
that is beyond the scope of this text. The set of test sequences must traverse all arcs on
the state graph, but this is generally not a sufficient test.
Figure 16-22 shows a simulator screen for testing the Mealy sequential circuit of
Figure 13-7. To step through the circuit one input at a time, switches are used for theClock and Xinputs. Another switch is used to reset both flip-flops, and two switch-
es are used to set flip-flops Aand B. Probes are used to observe the Zoutput and
the state of the flip-flops. After Xhas been set to the desired value, the clock cycle
is simulated by flipping the Clock switch to 1 and back to 0. For a Mealy machine,the output should be read just before the active edge of the clock.
If an incorrect Zoutput is found in the process of verifying the state table, the out-
put circuit can be checked using the techniques discussed in Section 8.5. If one of thenext states is wrong, this may be due to an incorrect flip-flop input. After determiningwhich flip-flop goes to the wrong state, the circuit should be reset to the proper presentstate, and the flip-flop inputs should be checked before applying another clock pulse.Sequential Circuit Design 533
FIGURE 16-22
Simulation Screen
for Figure 13.7
ExampleAssume that you have built the circuit of Figure 16-4 to implement the state table
of Figure 16-2. Suppose that when you set the flip-flop states to 100, set X/H110051, and
pulse the clock, the circuit goes to state 111 instead of 110. This indicates that flip-flop Q
3went to the wrong state. You should then reset the flip-flops to state 100 and
observe the inputs to flip-flop Q3. Because the flip-flop is supposed to remain in
state 0, D3should be 0. If D3/H110051, this indicates that either D3was derived wrong or
that the D3circuit has a problem. Check the D3map and equation to make sure that
D3/H110050 when X/H110051 and Q1Q2Q3/H11005100. If the map and equation are correct, then
theD3circuit should be checked using the procedure in Section 8.5.
After you have verified that the circuit works according to your state table, you
must then check the circuit to verify that it works according to the problem statement.To do this, you must apply appropriate input sequences and observe the resulting out-put sequence. When testing a Mealy circuit, you must be careful to read the outputs atthe proper time to avoid reading false outputs (see Section 13.2).The output should beread just before the active edge of the clock. If the output is read immediately follow-ing the active clock edge, a false output may be read. See Figure 13-8 for an example.
Instead of manually stepping through the input sequence, simulated input wave-
forms may be defined for Xand Clock. Figure 16-23 shows the simulator input wave-
form for the example of Figure 16-22, using the test sequence X/H1100510101. When the
simulator is run, the timing chart for A,B, and Zwill be generated as shown. Note
that the simulator output is very similar to the timing chart of Figure 13-8. The sim-ulator output in Figure 16-23(a) assumes the unit delay model, that is, each gate orflip-flop has one unit of delay. Figure 16-23(b) shows the same simulation using anominal delay of 10 ns for each gate and flip-flop.
So far in our discussion of sequential circuits, we have assumed that the inputs are
properly synchronized with the clock.This means that one input in the sequence occursfor each clock cycle, and all input changes satisfy setup and hold time specifications.Synchronization is no problem in the laboratory if we use a manual clock because wecan easily change the inputs between active clock edges. However, if we operate ourcircuits at a high clock rate, then synchronization becomes a problem. We must eithergenerate our input sequences in synchronization with the clock, or we must use a spe-cial circuit to synchronize the inputs with the clock. The former can be accomplished534 Unit 16
X
Clk
A
B
Z200 400
(a) Simulator output with a unit dela y model
X
Clk
A
B
Z200 400
(b) Simulator output with a nominal dela y of 10 nsFIGURE 16-23
by loading the inputs into a shift register, and then using the circuit clock to shift them
into the circuit one at a time, as shown in Figure 16-24.
If the input changes are not synchronized with the clock, edge-triggered D flip-
flops can be used to synchronize them, as shown in Figure 16-25(a). In this figure,although X
1and X2change at arbitrary times with respect to the clock, X1Sand X2S
change after the rising clock edge, and the inputs to the sequential circuit should
be properly synchronized, as shown in Figure 16-25(b). However, this design has aninherent problem and may occasionally fail to operate properly. If a Dinput
changes very close to the rising clock edge so that setup and hold times are not sat-isfied (see Figure 11-16), one of the flip-flops may malfunction.
Figure 16-26 shows a more reliable synchronizer
2that uses two D flip-flops to syn-
chronize a single asynchronous input, X. If Xchanges from 0 to 1 in the critical region
where the setup or hold time is not satisfied, several outcomes could occur: the flip-flopQ
1output might change to 1; it might remain 0; it might start to change to 1 and then
change back or it might oscillate between 0 and 1 for a short time and then settle downto 0 or 1. This region of uncertainty is indicated by the shading on the Q
1waveform.
We will assume that the clock period is chosen so that Q1will be settled in either the 0
or 1 state by t2. If Q1/H110051,Q2will change to 1 shortly after t2. If Q1/H110050,Q1will change
to 1 shortly after t2, and Q2will change to 1 shortly after t3. Because Xis an asynchro-
nous input, normally it will not matter whether X1Sis delayed by one or two clock peri-
ods.The important thing is that X1Sis a clean signal that is synchronized with the clock.Sequential Circuit Design 535
0 1 1 0 0 1 0 1 1 1Synchronous
Sequential
Circuit
Clock
InputShift
clock
ClockX
X1
X2
X1S
X2SDSynchronous
Sequential
Circuit
Clock
Input
ClockClockX1
X1S
X2SX2D
(a) S ynchronizer circuit (b) S ynchronizer inputs and outputsFIGURE 16-25
2For more detailed discussion of synchronizer design, see John F. Wakerly, Digital Design Principles and
Practices , 4th ed, (Prentice-Hall, 2006).FIGURE 16-24
Using a Shift
Register to
Generate
Synchronized
Inputs
16.8 Overview of Computer-Aided Design
A wide variety of computer-aided design (CAD) software tools are available to
assist in the design of digital systems. Many of these CAD programs will run on apersonal computer, but others require a more powerful workstation for execution.Several functions performed by these CAD tools are discussed below.
Generation and minimization of logic equations . Programs of this type accept truth
tables, state tables, or state graphs as input and generate minimized logic equations.LogicAid is an example of this type of program.
Generation of bit patterns for programming PLDs . These programs generate a file
which can be downloaded to a PLD programmer to program PALs and other pro-grammable logic devices.
Schematic capture . This type of program allows the designer to interactively enter
and edit a logic diagram for a digital design. The program provides libraries of stan-dard logic components such as gates, flip-flops, registers, adders, counters, etc., whichcan be selected for inclusion in the diagram. In addition to a plot of the logic dia-gram, the output from a schematic capture program may include a parts list, a list ofinterconnections between the ICs, and a circuit description file.This file may be usedas input to a simulator, PC board layout program, or other CAD programs.
Simulation . We have already discussed several types of simulators in Sections 10.3 and
16.5. By using such simulators at various points in the design process, designers cancorrect many errors and resolve critical timing problems before any hardware is actual-ly built. Use of a simulator is essential when an IC is being designed, because the correc-tion of design errors after the IC has been fabricated is very time-consuming and costly.536 Unit 16
Q1
t1 t2 t3X1S = Q2X1SX
XD1 Q1Synchronous
Sequential
Circuit
Clock
InputClock
01
0
ClockCKD2 Q2
CKFIGURE 16-26
Synchronizer with
Two D Flip-flops
SimUaid performs the schematic capture and simulation functions for small digital sys-
tems. It also automatically generates a structural VHDL description from the schematic.
Synthesis tools . Synthesis software accepts as input a description of a desired digital
system written in VHDL,Verilog, or another hardware description language.The HDLcode is analyzed and translated into a circuit description that specifies the needed logiccomponents and the connections between these components.The synthesizer output isthen fed into software that implements the circuit for a specific target device such asan FPGA, CPLD, or ASIC (application-specific integrated circuit). More details of syn-thesis and implementation of VHDL code are given in Section 17.5.
IC design and layout . A digital integrated circuit is typically composed of intercon-
nected transistors which are fabricated on a chip of silicon. Such ICs are usuallymade of several layers of conducting material separated by layers of insulatingmaterial with appropriate connections between layers. The patterns for paths oneach layer are transferred into the layers during the fabrication process using maskswhich are similar to photographic negatives. CAD tools for IC design facilitate theprocess of specifying the geometries of the transistors, placing the transistors on thechip, and routing the interconnections between them. Libraries of standard modulesare available for inclusion in the chip designs. Automatic checking of the designs isprovided to verify consistency with design rules. The output from the IC design pro-gram includes the mask patterns necessary for fabricating the IC.
Test generation . As digital systems become more complex, testing the finished prod-
uct becomes increasingly difficult. It is not practical to test the system using all pos-sible combinations or sequences of inputs. Automatic test generation programs areavailable which attempt to generate a relatively small set of input patterns that willadequately test the system in a reasonable length of time.
PC board layout . Most digital systems are built by mounting the integrated circuit
components on a printed circuit board. The wiring on such PC boards is made up ofthin metallic strips which interconnect the ICs. In order to make all of the requiredconnections, these boards typically have two, three, or more layers of interconnectwiring. PC board layout programs perform two main functions—they determine theplacement of the ICs on the board, and they route the connections between the ICs.The output of the layout program includes a set of plots which show the wiring oneach layer of the PC board.
Many CAD systems integrate several of these CAD tools into a single package
so that you can, for example, input a logic diagram, simulate its operation, and thenlay out a PC board or IC. The design of large, complex integrated circuits and digi-tal systems would not be feasible without the use of appropriate CAD tools.
One method of designing a small digital system with an FPGA uses the follow-
ing steps:
1.Draw a block diagram of the digital system. Define the required control signals
and construct a state graph that describes the required sequence of operations.
2.Work out a detailed logic design of the system using gates, flip-flops, registers,
counters, adders, etc.Sequential Circuit Design 537
3.Construct a logic diagram of the system, using a schematic capture program.
4.Simulate and debug the logic diagram and make any necessary corrections to
the design.
5.Run an implementation program that fits the design into the target FPGA. This
program carries out the following steps:(a) Partition the logic diagram into pieces that will fit into CLBs of the target
FPGA.
(b) Place the CLBs within the logic cell array of the FPGA and route the con-
nections between the logic cells.
(c) Generate the bit pattern necessary to program the FPGA.
6.Run a timing simulation of the completed design to verify that it meets specifi-
cations. Make any necessary corrections and repeat the process as necessary.
7.Download the bit pattern into the internal configuration memory cells in the
FPGA and test the operation of the FPGA.
When a hardware description language is used, steps 2 and 3 are replaced with writ-
ing HDL code. The HDL code is then simulated and debugged in step 4.
Design Problems
The following problems require the design of a Mealy sequential circuit of the formshown in Figure 16-27. For purposes of testing, the input Xwill come from a toggle
switch, and the clock pulse will be supplied manually from a push button or switch.538 Unit 16
FIGURE 16-27
X(From Toggle
Switch)
Manual ClockCircuit
to Be
DesignedZ
16.1 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence
Xand will produce an output of Z/H110051 for any input sequence ending in 0010 or 100.
Example:
X/H110051 10010010100101
Z/H110050 00101101001010
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method for manually resetting the flip-flops to the start state.A minimum solutionrequires six states. Design your circuit using NAND gates, NOR gates, and three Dflip-flops. Any solution which is minimal for your state assignment and uses 10 orfewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input.Then,
starting in the proper initial state, determine the output sequence for each of the
following input sequences:
( 1 )001101001010100010010010
( 2 )110011001010100101010010
16.2 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence
Xand will produce an output of Z/H110051 for any input sequence ending in 1101 or 011.
Example:
X/H110050 01101101011010
Z/H110050 00101101001010
Notice that the circuit does not reset to the start state when an output of 
Z/H110051 occurs. However, your circuit should have a start state and should be pro-
vided with a method for manually resetting the flip-flops to the start state. A min-imum solution requires six states. Design your circuit using NAND gates, NORgates, and three D flip-flops. Any solution which is minimal for your state assign-ment and uses nine or fewer gates and inverters is acceptable. (Assign 000 to thestart state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,starting in the proper initial state, determine the output sequence for each of thefollowing input sequences:
( 1 )110010110101011101101101
( 2 )001100110101011010101101
16.3 Design a sequential circuit (Figure 16-27) to convert excess-3 code to BCD code.
The input and output should be serial with the least significant bit first. The input X
represents an excess-3 coded decimal digit, and the output Zrepresents the corre-
sponding BCD code. Design your circuit using three D flip-flops, NAND gates, andNOR gates. Any solution which is minimal for your state assignment and uses eightor fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,starting in the reset state, determine the output sequence for each of the ten possi-ble input sequences and make a table.
16.4 Design a sequential circuit (Figure 16-27) which adds six to a binary number in the
range 0000 through 1001. The input and output should be serial with the least sig-nificant bit first. Find a state table with a minimum number of states. Design the cir-cuit using NAND gates, NOR gates, and three D flip-flops. Any solution which isminimal for your state assignment and uses 10 or fewer gates and inverters is accept-able. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,Sequential Circuit Design 539
starting in the reset state, determine the output sequence for each of the ten possi-
ble input sequences and make a table.
16.5 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence
Xand will produce an output of Z/H110051 for any input sequence ending in 0110 or 101.
Example:
X/H110050 101101
Z/H110050 001011
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method for manually resetting the flip-flops to the start state.A minimum solutionrequires six states. Design your circuit using NAND gates, NOR gates, and three Dflip-flops. Any solution which is minimal for your state assignment and uses eight orfewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input.Then, starting in the proper initial state, determine the output sequence for eachof the following input sequences:
( 1 )0011011110010100
( 2 )1010001111011000
16.6 Design a Mealy sequential circuit which investigates an input sequence Xand which
will produce an output of Z/H110051 for any input sequence ending in 0101 provided that
the sequence 110 has never occurred.
Example:
X/H110050 1010110101
Z/H110050 0010100000
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method for manually resetting the flip-flops to the start state.A minimum solutionrequires six states. Design your circuit using NAND gates, NOR gates, and three Dflip-flops. Any solution which is minimal for your state assignment and uses eight orfewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input.Then, starting in the proper initial state, determine the output sequence for thefollowing input sequences:
(1) X/H110050 10100010110
(2) X/H110051 01010110101
16.7 Design a Mealy sequential circuit which investigates an input sequence Xand which
will produce an output of Z/H110051 if the total number of 1’s received is even (consider540 Unit 16
zero 1’s to be an even number of 1’s) and the sequence 00 has occurred at least once.
Note : The total number of 1’s received includes those received before and after 00.
Example:
X/H110051 0101001101
Z/H110050 0000001001
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method of manually resetting the flip-flops to the start state.A minimum solutionrequires six states. Design your circuit using NAND gates, NOR gates, and threeD flip-flops.Any solution which is minimal for your state assignment and uses 12 orfewer gates and inverters is acceptable; the best known solution uses seven. (Assign000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,starting in the proper initial state, determine the output sequence for each of the fol-lowing input sequences:
(1) X/H110050110 010 1 0 0
(2) X/H110051011 110 0 1 110
16.8 Design a Mealy sequential circuit (Figure 16-27) which investigates an input sequence
Xand will produce an output of Z/H110051 for any input sequence ending in 0011 or 110.
Example:
X/H110051 0100110011
Z/H110050 0000011001
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method for manually resetting the flip-flops to the start state. Design your circuitusing NAND gates, NOR gates, and three D flip-flops. Any solution which is mini-mal for your state assignment and uses 10 or fewer gates and inverters is acceptable;the best known solution uses six. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input.Then, starting in the reset state, determine the output sequence for each of the fol-lowing input sequences:
(1) X/H110050 00100011010
(2) X/H110051 11001000110
16.9 Design a Mealy sequential circuit which investigates an input sequence Xand pro-
duces an output Zwhich is determined by two rules. The initial output from the cir-
cuit is Z/H110050. Thereafter, the output Zwill equal the preceding value of X(rule 1)
until the input sequence 001 occurs. Starting with the next input after 001, the out-putZwill equal the complement of the present value of X(rule 2) until the sequenceSequential Circuit Design 541
100 occurs. Starting with the next input after 100, the circuit output is again deter-
mined by rule 1, etc. Note that overlapping 001 and 100 sequences may occur.
Example:
Rule: 1 1 1 1 2 2 2 2 2 1 1 2
X/H110051 00110100011
Z/H110050 10001011000
Design your circuit using NAND gates, NOR gates, and three D flip-flops. Your
circuit should be provided with a method for manually resetting the flip-flops to thestart state. A minimum solution requires six states. Any solution which is minimalfor your state assignment and uses 12 or fewer gates and inverters is acceptable.(Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input.Then, starting in the reset state, determine the output sequence for each of the fol-lowing input sequences:
(1) X/H110051 00100100011
(2) X/H110050 11000011011
16.10 The 8, 4, /H110022,/H110021 BCD code is similar to the 8-4-2-1 BCD code, except that the weights
are negative for the two least significant bit positions. For example, 0111 in 8, 4, /H110022,/H110021
code represents
8/H110030/H110014/H110031/H11001(/H110022)/H110031/H11001(/H110021)/H110031/H110051
Design a Mealy sequential circuit to convert 8, 4, /H110022,/H110021 code to 8-4-2-1 code.
The input and output should be serial with the least significant bit first. The input X
represents an 8, 4, /H110022,/H110021 coded decimal digit and the output Zrepresents the corre-
sponding 8-4-2-1 BCD code. After four time steps the circuit should reset to thestarting state regardless of the input sequence. Design your circuit using three D flip-flops, NAND gates, and NOR gates. Any solution which is minimal for your stateassignment and uses eight or fewer gates is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and next state are correct for each input. Then,starting in the reset state, determine the output sequence for each of the 10 possibleinput sequences and make a table.
16.11 Design a Mealy sequential circuit (Figure 16-27) which adds five to a binary num-
ber in the range 0000 through 1010. The input and output should be serial with theleast significant bit first. Find a state table with a minimum number of states. Designthe circuit using NAND gates, NOR gates, and three D flip-flops. Any solutionwhich is minimal for your state assignment and uses nine or fewer gates and invert-ers is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and the next state are correct for each input.542 Unit 16
Then, starting in the reset state, determine the output sequence for each of the 11
possible input sequences and make a table.
16.12 Design a Mealy sequential circuit (Figure 16-27) to convert a 4-bit binary number
in the range 0000 through 1010 to its 10’s complement. (The 10’s complement of anumber Nis defined as 10 /H11002N.) The input and output should be serial with the least
significant bit first. The input Xrepresents the 4-bit binary number, and the output
Zrepresents the corresponding 10’s complement. After four time steps, the circuit
should reset to the starting state regardless of the input sequence. Find a state tablewith a minimum number of states. Design the circuit using NAND gates, NOR gates,and three D flip-flops. Any solution which is minimal for your state assignment anduses nine or fewer gates and inverters is acceptable. (Assign 000 to the reset state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and the next state are correct for each input.Then, starting in the reset state, determine the output sequence for each of the 11possible input sequences and make a table.
16.13 Design a Mealy sequential circuit which investigates an input sequence Xand which
will produce an output of Z/H110051 for any input sequence ending in 1010, provided
that the sequence 001 has occurred at least once.
Example:
X/H110051 0100101010
Z/H110050 0000000101
Notice that the circuit does not reset to the start state when an output of Z/H110051
occurs. However, your circuit should have a start state and should be provided witha method of manually resetting the flip-flops to the start state. A minimum solutionrequires six states. Design your circuit using NAND gates, NOR gates, and three Dflip-flops. Any solution which is minimal for your state assignment and uses nine orfewer gates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and the next state are correct for each input.Then, starting in the proper initial state, determine the output sequence for thefollowing input sequences:
(1) X/H110051 00100110101
(2) X/H110051 01000101010
16.14 Design a Mealy sequential circuit which investigates an input sequence Xand will
produce an output of Z/H110051 whenever the total number of 0’s in the sequence is odd,
provided that the sequence 01 has occurred at least once.
Example:
X/H110051 100011010
Z/H110050 000011001Sequential Circuit Design 543
A minimum solution requires five states. Design your circuit using NAND gates,
NOR gates, and three D flip-flops. Your circuit should have a start state and shouldbe provided with a method of manually resetting the flip-flops to the start state.Anysolution which is minimal for your state assignment and which uses 11 or fewergates and inverters is acceptable. (Assign 000 to the start state.)
Test Procedure: First, check out your state table by starting in each state and
making sure that the present output and the next state are correct for each input.Then, starting in the proper initial state, determine the output sequence for the fol-lowing input sequences:
(1) X/H110051 0001101001
(2) X/H110050 0001010001
Additional Problems
16.15 Draw a block diagram that shows how a ROM and D flip-flops could be connected to
realize Table 13-4 (p. 405). Specify the truth table for the ROM using a straight bina-ry state assignment. (Note that a truth table, not a transition table, is to be specified.)
16.16 The state table of Figure 15-14(a) is to be realized using a PLA and D flip-flops.
(a) Draw a block diagram.(b) Specify the contents of the PLA in tabular form using the state assignment of
Figure 15-14(a). (See Figure 15-15(b) for the Dequations.)
16.17 An iterative circuit has a form similar to Figure 16-6. The output Zis to be 1 if the
total number of Xinputs that are 1 is an odd number greater than 2.
(a) Draw a state graph for a typical cell.(b) Derive the equations and a NAND-gate circuit for a typical cell and for the output
circuit.
(c) Specify a
1and b1, and simplify the first cell.
(d) Show how a sequential circuit can be constructed using the typical cell and output
circuit.
16.18 Design a sequential circuit having one input and one output that will produce an
output of 1 for every second 0 it receives and for every second 1 it receives.
Example:
X(input) /H110050 1 1 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 1 1 0 1 0
Z(output) /H110050 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
(a) Design a Mealy sequential circuit using D flip-flops, showing a reduced state
graph, and equations for the output and Dinputs. It should be a reasonably eco-
nomical design.
(b) Repeat Part (a) for J-K flip-flops.544 Unit 16
(c) Design a Moore sequential circuit using T flip-flops to do the same task, show-
ing a state graph and input equations for a reasonably economical design.
16.19 Design a sequential circuit to multiply an 8-4-2-1 binary-coded decimal digit by 3 to
give a 5-bit binary number. For example, if the input is 0111, the output should be10101. The input and output to the circuit should be serial with the least significantbit first. Assume that the input will be 0 at the fifth clock time and reset the circuitafter the fifth output bit. [ Hint: As each bit is received, multiply it by 3, giving a
product of either 00 or 11. Thus we either output 0 and carry 0 to the next column,or output 1 and carry 1 to the next column. If we carry a 1 to the next column, thenthe sum of the carry and the next product is either 01 or 100. In this case, we eitheroutput 1 and carry 0 or output 0 and carry 10 (2) to the next column. What happensif we carry 10 (2) to the next column?](a) Derive a state table with a minimum number of states (3 states).(b) Design the circuit using J-K flip-flops and NAND and NOR gates.(c) Design the circuit using a PLA and D flip-flops. Give the PLA table.
16.20 A Moore sequential circuit has three inputs ( X
2,X1, and X0) that specify a temper-
ature range in a room. The circuit has two outputs ( Iand D) that control a heater
for the room; I/H110051 causes the heater to increase its heat output, and D/H110051 causes
the heater to decrease its heat output. If the temperature range is 0, 1, or 2 for threesuccessive clock cycles, the circuit generates I/H110051, and conversely if the temperature
range is 5, 6, or 7 for three successive clock cycles, the circuit generates D/H110051;
otherwise, I/H110050 and D/H110050.
(a) Construct a state diagram for the circuit.(b) Encode the states using a one-hot state assignment and derive the D flip-flop
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.21 Repeat Problem 16.20 using a Mealy circuit.
16.22 A Moore sequential circuit has two inputs ( XandY) and three outputs ( Z
2,Z1, and
Z0). The outputs are a 1’s complement number specifying the number of successive
times Xand Yhave been equal or not equal as follows: In decimal, the outputs are
1, 2, and 3 if Xand Yhave been equal for one time, two successive times, and three
or more successive times, and the outputs are, /H110021,/H110022, and /H110023 if XandYhave been
not equal for one time, two successive times, and three or more successive times.Initially, the outputs are all 0.(a) Construct a state diagram for the circuit.(b) Encode the states using a one-hot state assignment and derive the D flip-flop
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.23 Repeat Problem 16.22 using a Mealy sequential circuit.Sequential Circuit Design 545
16.24 A Moore sequential circuit has two inputs ( XandY) and three outputs ( Z2,Z1, and
Z0). The outputs are a 2’s complement number specifying the number of successive
times Xand Yhave been equal or not equal as follows: In decimal, the outputs are
1, 2, and 3 if Xand Yhave been equal for one time, two successive times, and three
or more successive times, and the outputs are /H110021,/H110022,/H110023, and /H110024 if Xand Yhave
been not equal for one time, two successive times, three successive times, and fouror more successive times. Initially, the outputs are all 0.(a) Construct a state diagram for the circuit.(b) Encode the states using a one-hot state assignment and derive the D flip-flop
input equations and the output equations.
(c) Use a minimum number of D flip-flops and derive the D flip-flop input equa-
tions and the output equations.
16.25 Repeat Problem 16.24 using a Mealy sequential circuit.
16.26 The block diagram for an elevator controller for a two-floor elevator follows. The
inputs FB
1andFB2are 1 when someone in the elevator presses the first or second floor
buttons, respectively. The inputs CALL1andCALL2are 1 when someone on the first
or second floor presses the elevator call button. The inputs FS1andFS2are 1 when the
elevator is at the first or second floor landing. The output UPturns on the motor to
raise the elevator car; DOWN turns on the motor to lower the elevator. If neither UP
norDOWN is 1, then the elevator will not move. R1andR2reset the latches (described
below); and when DO goes to 1, the elevator door opens. After the door opens and
remains open for a reasonable length of time (as determined by the door controllermechanism), the door controller mechanism closes the door and sets DC/H110051. Assume
that all input signals are properly synchronized with the system clock.(a) If we were to realize a control circuit that responded to all of the inputs FB
1,
FB2,CALL1,CALL2,FS1,FS2, and DC, we would need to implement logic
equations with nine or more variables (seven inputs plus at least two state vari-ables). However, if we combine the signals FB
iand CALLiinto a signal Ni(i/H11005
1 or 2) that indicates that the elevator is needed on the specified floor, we canreduce the number of inputs into the control circuit. In addition, if the signal N
i546 Unit 16
FB1
N1R1
R2
UP
DOWN
DON2FB2
DCFS1
FS2CALL1
CALL2Storage
Circuit
Control
CircuitStorage
Circuit
Door
Mechanism
is stored so that a single pulse on FBiorCALLiwill set Nito 1 until the control
circuit clears it, then the control circuit will be simplified further. Using a D flip-flop and a minimum number of added gates, design a storage circuit that willhave an output 1 when either input ( FB
iorCALLi) becomes 1 and will stay 1
until reset with a signal Ri.
(b) Using the signals N1andN2that indicate that the elevator is needed on the first
or second floor (to deliver a passenger or pick one up or both), derive a stategraph for the elevator controller. (Only four states are needed.)
(c) Realize the storage circuits for N
1and N2and the state graph.
16.27 An older model Thunderbird car has three left and three right taillights which flash
in unique patterns to indicate left and right turns.
Design a Moore sequential circuit to control these lights. The circuit has three
inputs LEFT ,RIGHT , and HAZ. LEFT andRIGHT come from the driver’s turn sig-
nal switch and cannot be 1 at the same time. As indicated above, when LEFT /H110051 the
lights flash in a pattern LAon;LAandLBon;LA,LB, and LCon; all off; and then
the sequence repeats.When RIGHT /H110051, the light sequence is similar. If a switch from
LEFT toRIGHT (or vice versa) occurs in the middle of a flashing sequence, the cir-
cuit should immediately go to the IDLE (lights off) state and, then, start the new
sequence. HAZ comes from the hazard switch, and when HAZ /H110051, all six lights flash
on and off in unison. HAZ takes precedence if LEFT orRIGHT is also on. Assume
that a clock signal is available with a frequency equal to the desired flashing rate.(a) Draw the state graph (eight states).(b) Realize the circuit using six D flip-flops and make a state assignment such that
each flip-flop output drives one of the six lights directly. (Use LogicAid .)
(c) Realize the circuit using three D flip-flops, using the guidelines to determine a
suitable state assignment. Note the trade-off between more flip-flops and moregates in (b) and (c).
16.28 Design a sequential circuit to control the motor of a tape player. The logic circuit,
shown as follows, has five inputs and three outputs. Four of the inputs are the con-trol buttons on the tape player. The input PLis 1 if the play button is pressed, the
input REis 1 if the rewind button is pressed, the input FFis 1 if the fast forward but-
ton is pressed, and the input STis 1 if the stop button is pressed. The fifth input to
the control circuit is M, which is 1 if the special music sensor detects music at the
current tape position. The three outputs of the control circuit are P,R, and F, which
make the tape play, rewind, and fast forward, respectively, when 1. No more thanLC LB LA RA RB RCLEFT turn pattern:
LC LB LA RA RB RCRIGHT turn pattern:Sequential Circuit Design 547
one output should ever be on at a time; all outputs off cause the motor to stop. The
buttons control the tape as follows: If the play button is pressed, the tape player willstart playing the tape (output P/H110051). If the play button is held down and the rewind
button is pressed and released, the tape player will rewind to the beginning of thecurrent song (output R/H110051 until M/H110050) and then start playing. If the play button is
held down and the fast forward button is pressed and released, the tape player willfast forward to the end of the current song (output F/H110051 until M/H110050) and then start
playing. If rewind or fast forward is pressed while play is released, the tape playerwill rewind or fast forward the tape. Pressing the stop button at any time should stopthe tape player motor.
(a) Construct a state graph chart for the tape player control circuit.
(b) Realize the control circuit using a PLA and D flip-flops.
16.29 An iterative circuit has an output of 1 from the last cell if and only if the input pat-
tern 1011 or 1101 has occurred as inputs to any four adjacent cells in the circuit.(a) Find a Moore state graph or table with a minimum number of states.(b) Make a suitable state assignment, and derive one of the equations for a typical cell.(c) Derive the output equation.
16.30 An iterative circuit has a form similar to Figure 16-6.The output Zis to be 1 iff at least
one of the Xinputs is 1, and no group of two or more consecutive 1 inputs occurs.
Example:
00101000100 gives an output Z/H110051
00101100000 gives an output Z/H110050
(a) Draw a state graph for a typical cell.
(b) Derive the equations and a NOR-gate circuit for a typical cell and for the out-
put circuit.
(c) Specify a
1and b1, and simplify the first cell.
(d) Show how a sequential circuit can be constructed using the typical cell and out-
put circuit.PL
RE
FF
ST
MFRP548 Unit 16
549VHDL for Sequential Logic
Objectives:
1.Represent flip-flops, shift registers, and counters using VHDL processes.
2.Write sequential VHDL statements including if-then-else, case, and wait
statements.
3.Explain the sequence of execution for sequential statements and the order
in which signals are updated when a process executes.
4.Represent combinational logic using a process.
5.Represent a sequential logic circuit with VHDL code.
(a)Use two processes.
(b)Use logic equations and a process that updates the flip-flops.
(c)Use a ROM and flip-flops.
6.Given VHDL code for sequential logic, draw the corresponding logic circuit.
7.Compile, simulate, and synthesize a sequential logic module.
UNIT
17
1.Study Section 17.1, Modeling Flip-Flops Using VHDL Processes .
(a) Under what condition is the expression CLK’event and CLK/H11005‘0’true?
(b) If the first line of a process is Process (St, Q1,V), under what condition will
the process execute?
(c) In Figure 17-4, if C1 and C3 are false and C2 is true, which statements will
execute?
(d) What device does the following VHDL code represent? What happens if
ClrN /H11005SetN /H11005'0'?
process (CLK, ClrN, SetN)
ifClrN /H11005‘0’then Q/H11021/H11005 ‘0’;
elsif SetN /H11005‘0’then Q/H11021/H11005 ‘1’;
elsif CLK’event and CLK/H11005‘1’then
Q/H11021/H11005 D;
end if ;
end process ;
(e) In Figure 17-6, why are RN and SN tested before CLK? If J /H11005'1', K /H11005'0',
and RN changes to '0', and then CLK changes to '0' 10 ns later, what willbe the Q output ?
(f) In Figure 17-6, if the statements Q/H11021/H11005 Qint; and QN/H11021/H11005 not Qint ; are moved
inside the process just before the end-process statement, why will Q and QNhave the wrong values?
(g) Modify the VHDL code in Figure 17-3 to add a clock enable (CE) to the
flip-flop. ( Hint :ifCLK’event and CLK/H11005‘1’and________ .)
(h) Work Problem 17.1.
2.Study Section 17.2, Modeling Registers and Counters Using VHDL Processes .
(a) Add the necessary VHDL code to Figure 17-9 to make a complete VHDL
module.
(b) In Figure 17-10, if CLK changes to '1' at time 10 ns, at what time will Q
change? (Remember that it takes /H9004time to update a signal).
(c) What change should be made to Figure 17-10 to cause the register to
rotate left one place instead of shifting left? (Do not use shift operators.)
(d) In Figure 17-11, what changes would be needed to make the clear asyn-
chronous?550 Unit 17
Study Guide
(e) In Figure 17-12, under what conditions does Carry2 /H110051?
(f) In Figure 17-11, note that Q is a std_logic vector. Why would the code fail
to compile if Q is a bit_vector?
(g) In Figure 17-14, if Qout1 /H11005"1111", Qout2 /H11005"1001", P /H11005T1/H11005LdN /H11005
ClrN /H11005'1', what will Qout1 and Qout2 be after the rising edge of CLK?
(h) If the process in Figure 17-13 is replaced with
process (CK)
begin
ifCK’event and CK/H11005‘1’then
ifLd/H11005‘1’then Q/H11021/H11005 D;
elsif (P and T) /H11005‘1’then Q/H11021/H11005 Q/H110011;
elsif Clr/H11005‘1’then Q/H11021/H11005 “0000”;
end if ;
end if ;
end process ;
Modify Table 17-1 to properly represent the corresponding counter operation.
Control Signals Next State
Clr Ld PT Q3/H11545Q2/H11545Q1/H11545Q0/H11545
(i) Work Problems 17.2, and 17.3.
3.Study Section 17.3, Modeling Combinational Logic Using VHDL Processes .
(a) For Figure 17-15, if the circuit is represented by a single sequential state-
ment, make the necessary changes in the VHDL code. Assume that theAND gate delay is negligible and the OR gate delay is 5 ns. ( Hint :T h e
process sensitivity list should only have three signals on it.)
(b) Work Problem 17.4.
4.Study Section 17.4, Modeling a Sequential Machine .
(a) If Figure 17-16 implements the state table of Table 17-2, what will
NextState and Zbe if State /H11005S2 and X/H11005'1'?VHDL for Sequential Logic 551
(b) For the VHDL code of Figure 17-17:
(1) Why is the integer range 0 to 6?
(2) Assume that initially Clock /H11005'0', State /H110050, and X/H11005'0'. Trace the
code to answer the following:
IfXchanges to '1', what happens?
If CLK then changes to '1', what happens? ( Hint: Both processes execute.)
Work Problem 17.5.
(c) Explain how the waveform of Figure 17-18 relates to Table 17-2.
Why is there a glitch in the nextstate waveform between next states
0 and 2?
Why does this glitch not cause the state to go to the wrong value?
(d) For the VHDL code of Figure 17-19:
Why do Q1, Q2, and Q3 not appear on the sensitivity list?
If CLK changes from 0 to 1 at time 5 ns, at what time are the new values
of Q1, Q2, and Q3 computed? At what time do Q1, Q2, and Q3 change tothese new values?
(e) Recall that component instantiation statements are concurrent state-
ments. For the VHDL code of Figure 17-20, if Q1 changes, which of thesestatements will execute immediately? Relate your answer to the circuit ofFigure 16-4.
(f) For Figure 17-22, what value will be read from the ROM array when X /H11005'1'
and Q /H11005"010"?
(g) Work Problem 17.6.
5.Study Section 17.5, Synthesis of VHDL Code .
(a) Implement the following process using only a D-CE flip-flop:552 Unit 17
process (CLK)
begin
ifCLK’event and CLK/H11005‘1’then
ifEn/H11005‘1’then Q/H11021/H11005 A;end if;
end if;
end process ;
(b) Implement the same code using a D flip-flop without a clock enable and a
MUX.
(c) Implement the following VHDL code using only D-CE flip-flops:
signal A: bit_vector(3 downto 0)
-------------------------------------------process (CLK)
begin
ifCLK’event and CLK/H11005‘1’then
ifASR/H11005‘1’then
A/H11021/H11005 A(3)& A(3 downto 1);
end if ;
end if ;
end process ;
(d) Work Problem 17.7.
6.Study Section 17.6, More About Processes and Sequential Statements .
(a) Write an equivalent process that has no sensitivity list on the first line. Use
a wait statement instead.
process (B, C)
begin
A/H11021/H11005 BorC;
end process ;
(b) For the following process, if B changes at time 2 ns, at what time does state-
ment (2) execute? (The answer is not7 ns.)
process (B, D);
A/H11021/H11005 Bafter 5 ns; --(1)
C/H11021/H11005 D; --(2)
end process ;
(c) Work Problem 17.8.
7.Complete the assigned lab exercises before you take the test on Unit 17.VHDL for Sequential Logic 553
VHDL for Sequential Logic
554In Unit 10 we learned how to represent combinational logic in VHDL by using con-
current signal assignment statements. In this unit, we will learn how to representsequential logic by using VHDL processes.
17.1 Modeling Flip-Flops Using VHDL Processes
A flip-flop can change state either on the rising or on the falling edge of the clockinput. This type of behavior is modeled in VHDL by a process. For a simple D flip-flop with a Q output that changes on the rising edge of CLK, the correspondingprocess is given in Figure 17-1.
The expression in parentheses after the word process is called a sensitivity list,
and the process executes whenever any signal in the sensitivity list changes. Forexample, if the process begins with process (A, B, C) , then the process executes when-
ever any one of A, B, or C changes. When a process finishes executing, it goes backto the beginning and waits for a signal on the sensitivity list to change again.
In Figure 17-1, whenever CLK changes, the process executes once through and,
then, waits at the start of the process until CLK changes again. The ifstatement tests
for a rising edge of the clock, and Q is set equal to D when a rising edge occurs. Theexpression CLK'event (read as clock tick event) is TRUE whenever the signal CLKchanges. If CLK /H11005'1' is also TRUE, this means that the change was from '0' to '1',
which is a rising edge. If the flip-flop has a delay of 5 ns between the rising edge of theclock and the change in the Q output, we would replace the statement Q/H11021/H11005 D; with Q
/H11021/H11005 Dafter 5 ns; in the process in Figure 17-1.
The statements between begin andendin a process are called sequential statements.
In the process in Figure 17-1, Q/H11021/H11005 D;is a sequential statement that only executes
process  (CLK)
begin
if CLK'event and CLK = '1' -- rising edge of CLK
then  Q <= D;
end if ;
end process ;DFF
CLK DQ FIGURE 17-1
VHDL Code for a
Simple D Flip-Flop
following the rising edge of CLK. In contrast, the concurrent statement Q/H11021/H11005 D;exe-
cutes whenever D changes. If we synthesize the process, the synthesizer infers that Qmust be a flip-flop because it only changes on the rising edge of CLK. If we synthesizethe concurrent statement Q/H11021/H11005 D;the synthesizer will simply connect D to Q with a
wire or with a buffer.
In Figure 17-1 note that D is not on the sensitivity list because changing D will not
cause the flip-flop to change state. Figure 17-2 shows a transparent latch and its VHDLrepresentation. Both G and D are on the sensitivity list because if G /H11005'1', a change in
D causes Q to change. If G changes to '0', the process executes, but Q does not change.VHDL for Sequential Logic 555
process  (G,D)
begin
if G = '1' then  Q <= D; end if ;
end process ;Q D
GFIGURE 17-2
VHDL Code for a
Transparent Latch
ClrNprocess  (CLK, ClrN)
begin
if ClrN = '0' then  Q <= '0';
else if  CLK'event and CLK = '1'
then  Q <= D;
                    end if ;
end if ;
end process ;DFF
CLK DQFIGURE 17-3
VHDL Code for a
D Flip-flop with
Asynchronous ClearIf a flip-flop has an active-low asynchronous clear input (ClrN) that resets the
flip-flop independently of the clock, then we must modify the process of Figure 17-1so that it executes when either CLK or ClrN changes. To do this, we add ClrN to thesensitivity list. The VHDL code for a D flip-flop with asynchronous clear is given inFigure 17-3. Because the asynchronous ClrN signal overrides CLK, ClrN is testedfirst, and the flip-flop is cleared if ClrN is '0'. Otherwise, CLK is tested, and Q isupdated if a rising edge has occurred.
A basic process has the following form:
process (sensitivity-list)
begin
sequential-statements
end process ;
Whenever one of the signals in the sensitivity list changes, the sequential statements
in the process body are executed in sequence one time. The process then goes backto the beginning and waits for a signal in the sensitivity list to change.
In the previous examples, we have used two types of sequential statements—signal
assignment statements and ifstatements. The basic ifstatement has the form
ifcondition then
sequential statements1
else sequential statements2
end if ;
The condition is a Boolean expression which evaluates to TRUE or FALSE. If it is
TRUE, sequential statements1 are executed; otherwise, sequential statements2 areexecuted. VHDL ifstatements are sequential statements that can be used within a
process, but they cannot be used as concurrent statements outside of a process. Onthe other hand, conditional signal assignment statements are concurrent statementsthat cannot be used within a process.
The most general form of the ifstatement is
ifcondition then
sequential statements
{elsif condition then
sequential statements}-- 0 or more elsif clauses may be included
[else sequential statements]
end if ;
The curly brackets indicate that any number of elsif clauses may be included, and the
square brackets indicate that the else clause is optional. The example of Figure 17-4
shows how a flow chart can be represented using nested ifs or the equivalent using
elsifs. In this example, C1, C2, and C3 represent conditions that can be TRUE or
FALSE, and S1, S2, . . . S8 represent sequential statements. Each ifrequires a corre-
sponding end if , but an elsif does not.
Next, we will write a VHDL module for a J-K flip-flop (Figure 17-5). This flip-
flop has active-low asynchronous preset (SN) and clear (RN) inputs. State changesrelated to J and K occur on the falling edge of the clock. In this chapter, we use asuffix N to indicate an active-low (negative-logic) signal. For simplicity, we willassume that the condition SN /H11005RN/H110050 does not occur.556 Unit 17
FIGURE 17-4
Equivalent
Representations
of a Flow Chart
Using Nested
Ifs and ElsifsC1T
S1; S2; C2T
S3; S4; C3TF
F
F
S5; S6; S7; S8;
if (C1) then  S1; S2;
else if  (C2) then  S3; S4;
else if  (C 3) then  S5; S6;
else S7; S8;
end if ;
end if ;
end if ;if (C1) then  S1; S2;
elsif (C2) then  S3; S4;
elsif (C 3) then  S5; S6;
else S7; S8;
end if ;
The VHDL code for the J-K flip-flop is given in Figure 17-6. The port declara-
tion in the entity defines the input and output signals. Within the architecture wedefine a signal Qint that represents the state of the flip-flop internal to the module.The two concurrent statements after begin transmit this internal signal to the Q and
QN outputs of the flip-flop.We do it this way because an output signal in a port can-not appear on the right side of an assignment statement within the architecture. Theflip-flop can change state in response to changes in SN, RN, and CLK, so these threesignals are in the sensitivity list of the process. Because RN and SN reset and set theflip-flop independently of the clock, they are tested first. If RN and SN are both '1',then we test for the falling edge of the clock. The condition (CLK’event and CLK/H11005‘0’)
is TRUE only if CLK has just changed from '1' to '0'. The next state of the flip-flopis determined by its characteristic equation:
Q
/H11001/H11005JQ/H11032/H11001 K/H11032Q
The 8-ns delay represents the time it takes to set or clear the flip-flop output
after SN or RN changes to 0. The 10-ns delay represents the time it takes for Q tochange after the falling edge of the clock.VHDL for Sequential Logic 557
1 entity JKFFis
2 port (SN, RN, J, K, CLK: inbit; --inputs
3 Q, QN: out bit);
4 end JKFF;
5 architecture JKFF1 ofJKFFis
6 signal Qint: bit; -- internal value of Q
7 begin
8Q /H11021/H11005 Qint; -- output Q and QN to port
9Q N /H11021/H11005notQint;
10 process (SN, RN, CLK)
11 begin
12 ifRN/H11005‘0’then Qint/H11021/H11005 ‘0’after 8 ns; -- RN /H11005’0’ will clear the FF
13 elsif SN/H11005‘0’then Qint/H11021/H11005 ‘1’after 8 ns; -- SN /H11005’0’ will set the FF
14 elsif CLK’event and CLK/H11005‘0’then -- falling edge of CLK
15 Qint /H11021/H11005 (Jand not Qint) or(notKand Qint) after 10 ns;
16 end if ;
17 end process ;
18 end JKFF1;FIGURE 17-6
J-K Flip-Flop ModelJKFF
ClkRN SN
J KQ QN FIGURE 17-5
J-K Flip-Flop
17.2 Modeling Registers and Counters
Using VHDL Processes
When several flip-flops change state on the same clock edge, the statements
representing these flip-flops can be placed in the same clocked process. Figure 17-7shows three flip-flops connected as a cyclic shift register. These flip-flops all changestate following the rising edge of the clock. We have assumed a 5-ns propagationdelay between the clock edge and the output change. Immediately following theclock edge, the three statements in the process execute in sequence with no delay.The new values of the Q’s are then scheduled to change after 5 ns. If we omit thedelay and replace the sequential statements with
Q1/H11021/H11005 Q3; Q2 /H11021/H11005 Q1; Q3 /H11021/H11005 Q2;
the operation is basically the same. The three statements execute in sequence in zero
time, and, then, the Q’s change value after /H9004delay. In both cases the old values of Q1, Q2,
and Q3 are used to compute the new values.This may seem strange at first, but that is theway the hardware works. At the rising edge of the clock, all of the D inputs are loadedinto the flip-flops, but the state change does not occur until after a propagation delay.
Next we will write structural VHDL code for the cyclic shift register using a D flip-
flop as a component. In the writing of structural VHDL code, instantiation statementsare used to specify how components are connected together. Components may bedeclared and defined either in a library or within the architecture part of the VHDLcode. Each copy of a component requires a separate instantiation statement to specifyhow it is connected to other components and to the port inputs and outputs.Instantiation statements are concurrent statements, not sequential statements, andtherefore they cannot be used within a process. A component can be as simple as a sin-gle gate or as complex as a digital system that contains many internal signals, registers,control circuits, and other components. Each instantiation statement represents a copyof a hardware component. The instantiation statement connects the component inputsand outputs, and the component computes new outputs whenever one of its inputschanges. This is exactly how the real hardware component works. Instantiating a558 Unit 17
Q1 D
Q2 D
Q3 DCLK
process  (CLK)
begin
if CLK'event and CLK = '1' then
             Q1 <= Q 3 after  5 ns;
             Q2 <= Q1 after  5 ns;
             Q 3 <= Q2 after  5 ns;
end if ;
end process ;FIGURE 17-7
Cyclic Shift Register
VHDL for Sequential Logic 559
component is different from calling a function in a computer program. A function
returns a new value whenever it is called, but an instantiated component computes anew output value whenever its input changes.
The VHDL code of Figure 17-8 has two modules.The first one models a simple D
flip-flop.The second module instantiates three copies of the D flip-flop component tomodel the cyclic shift register of Figure 17-7. Qout represents a 3-bit output from theregister. The internal signals (Q1, Q2, and Q3) that are declared within the architec-ture are used to connect the flip-flop inputs and outputs. Lines 21, 22, and 23 instanti-ate three copies of the D flip-flop component. Even though the DFF module has aclock input and internal sequential statements, each instantiation statement is still aconcurrent statement and must notbe placed in a process. If clk changes, this change
is passed to the D flip-flop components, and the effect of the clock change is handledwithin the components.
Figure 17-9 shows a simple register that can be loaded or cleared on the rising edge
of the clock. If CLR /H110051, the register is cleared, and if Ld /H110051, the D inputs are loaded
into the register.This register is fully synchronous so that the Q outputs only change inresponse to the clock edge and not in response to a change in Ld or Clr. In the VHDLcode for the register, Q and D are bit vectors dimensioned 3 downto 0. Because the
register outputs can only change on the rising edge of the clock, CLR is not on the
1 entity DFFis --simple DFF
2 port (D, clk: inbit, q: outbit),
3 end DFF;
4 architecture DFF_simple ofDFFis
5 begin
6 process (clk)
7 begin
8 ifclk'event and clk = '1' then
9 Q <= D after 5 ns; end if ;
10 end process;
11 end DFF_simple;
12 entity cyclicSR is -- 3-bit cyclic shift register
13 port (clk:inbit; Qout: outbit-vector(1 to3) ) ;
14 end cyclicSR;
15 architecture cyclicSR3 ofcyclicSR is
16 component DFF
17 port (D, clk: inbit; Q: outbit);
18 end component;
19 signal Q1, Q2, Q3: bit;
20 begin
21 FF1: DFF port map (Q3, clk, Q1);
22 FF2: DFF port map (Q1, clk, Q2);
23 FF3: DFF port map (Q2, clk, Q3) ;
24 Qout <= Q1&Q2&Q3;
25 end cyclicSR3;FIGURE 17-8
Structural VHDL
Code for Cyclic
Shift Register
sensitivity list. It is tested after the rising edge of the clock instead of being tested first
as in Figure 17-3. If Clr /H11005Ld/H11005'0', Q does not change. Because Clr is tested before Ld,
if Clr /H11005'1', the elsif prevents Ld from being tested and Clr overrides Ld.
Next, we will model a left-shift register using a VHDL process. The register in
Figure 17-10 is similar to that in Figure 17-9, except we have added a left-shift controlinput (LS).When LS is '1', the contents of the register are shifted left and the rightmostbit is set equal to Rin. The shifting is accomplished by taking the rightmost three bitsof Q, Q(2 downto 0) and concatenating them with Rin. For example, if Q /H11005"1101" and
Rin/H11005'0', then Q(2 downto 0) &Rin /H11005"1010", and this value is loaded back into the
Q register on the rising edge of CLK. The code implies that if CLR /H11005Ld/H11005LS/H11005'0',
then Q remains unchanged.
Figure 17-11 shows a simple synchronous counter. On the rising edge of the
clock, the counter is cleared when ClrN /H11005'0', and it is incremented when ClrN /H11005
En/H11005'1'. In this example, the signal Q represents the 4-bit value stored in the count-
er. Because addition is not defined for bit_vectors, we have declared Q to be of typestd_logic_vector. Then, we can increment the counter using the overloaded “ /H11001”
operator that is defined in the ieee.std_logic_unsigned package. The statementQ/H11021/H11005 Q/H110011; increments the counter. When the counter is in state "1111", the next
increment takes it back to state "0000".560 Unit 17
Q3Q2Q1
RegisterQ0Ld
D3 D2 D1 D0CLKCLRprocess  (CLK)
begin
if CLK'event and CLK = '1' then
if CLR = '1' then  Q <= "0000";
elsif Ld = '1' then  Q <= D;
end if ;
end if ;
end process ;FIGURE 17-9
Register with 
Synchronous
Clear and Load
Q3Q2Q1
Left SR RinQ0 Ld
D3 D2 D1 D0CLKLS
CLRprocess  (CLK)
begin  if CLK'event and CLK = '1' then
if CLR = '1' then  Q <= "0000";
elsif Ld = '1' then  Q <= D;
      elsif  LS = '1' then  Q <= Q(2 downto  0)& Rin;
end if ;
  end if ;
end process ;FIGURE 17-10
Left-Shift Register
with Synchronous
clear and Load
Q3Q2Q1
CounterQ
Q0 En
CLKClr ClrNsignal  Q: std_logic_vector( 3 downto  0);
------------process  (CLK)
begin
if CLK'event and CLK = '1' then
if ClrN = '0' then  Q <= "0000";
elsif En = '1' then  Q <= Q + 1;
end if ;
end if ;
end process ;FIGURE 17-11
VHDL Code for a
Simple Synchronous
Counter
The 74163 (see Figure 17-12) is a 4-bit fully synchronous binary counter which is
available in both TTL and CMOS logic families. Although rarely used in newdesigns at present, it represents a general type of counter that is found in manyCAD design libraries. In addition to performing the counting function, it can becleared or loaded in parallel. All operations are synchronized by the clock, and allstate changes take place following the rising edge of the clock input.
This counter has four control inputs: ClrN, LdN, P , and T. Inputs P and T are used
to enable the counting function. Operation of the counter is as follows:
1.If ClrN /H110050, all flip-flops are set to 0 following the rising clock edge.
2.If ClrN /H110051 and LdN /H110050, the D inputs are transferred in parallel to the flip-
flops following the rising clock edge.
3.If ClrN /H11005LdN /H110051 and P /H11005T/H110051, the count is enabled and the counter state
will be incremented by 1 following the rising clock edge.
If T /H110051, the counter generates a carry (C
out) in state 15, so
Cout/H11005Q3Q2Q1Q0T
Table 17-1 summarizes the operation of the counter. Note that ClrN overrides
the load and count functions in the sense that when ClrN /H110050, clearing occurs
regardless of the values of LdN, P , and T. Similarly, LdN overrides the count func-tion. The ClrN input on the 74163 is referred to as a synchronous clear input
because it clears the counter in synchronization with the clock, and no clearing canoccur if a clock pulse is not present.
The VHDL description of the counter is shown in Figure 17-13. Q represents the
four flip-flops that make up the counter. The counter output, Q
out, changes whenever
Q changes. The carry output is computed whenever Q or T changes. The first if
statement in the process tests for a rising edge of Clk. Because clear overrides loadand count, the next ifstatement tests ClrN first. Because load overrides count, LdN isVHDL for Sequential Logic 561
Control Signals Next State
ClrN LdN PT Q3/H11545Q2/H11545Q1/H11545Q0/H11545
0 X X 0 0 0 0 (Clear)
10 X D3 D2D1D0(Parallel load)
11 0 Q3 Q2Q1Q0(No change)
1 1 1 Present state /H110011 (Increment count)TABLE 17-1
74163 Counter
OperationQ3Q2Q1Qout2
Din2Q0
D3D2D174163
D0P P
Clr ClrNLd LdNT Cout Carr y2Q3Q2Q1Qout1
Din1Q0
D3D2D174163
D0P
Clr ClrN
ClkLd LdNTP
T1 CoutCarr y1FIGURE 17-12
Two 74163
Counters Cascaded
to Form an
8-Bit Counter
tested next. Finally, the counter is incremented if both P and T are 1. Because Q is
type std_logic_vector, we can use the overloaded “ /H11001” operator from the
ieee.std_logic_unsigned library to add 1 to increment the counter. The expression Q/H110011 would not be legal if Q were a bit_vector because addition is not defined for
bit_vectors.
To test the counter, we have cascaded two 74163’s to form an 8-bit counter (Figure
17-12). When the counter on the right is in state 1111 and T1 /H110051, the T input to the
left counter is Carry1 /H110051. Then, if P /H110051, on the next clock the right counter is incre-
mented to 0000 at the same time the left counter is incremented. Figure 17-14 showsthe VHDL code for the 8-bit counter. In this code we have used the c74163 model asa component and instantiated two copies of it. For convenience in reading the output,we have defined a signal Count which is the integer equivalent of the 8-bit countervalue. The function Conv_integer converts a std_logic_vector to an integer.
The two instantiation statements (lines 21 and 22) connect the inputs and outputs
of two copies of the 4-bit counter component. Each of these concurrent statementswill execute when one of the counter inputs changes, and then the correspondingcounter module computes new values of the counter outputs. Although the 4-bit562 Unit 17
-- 74163 FULLY SYNCHRONOUS COUNTER
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity c74163 is
6 port(LdN, ClrN, P , T, ClK: instd_logic;
7D : instd_logic_vector(3 downto 0);
8 Cout: outstd_logic; Qout: outstd_logic_vector(3 downto 0) );
9 end c74163;
10 architecture b74163 ofc74163 is
11 signal Q: std_logic_vector(3 downto 0); -- Q is the counter register
12 begin
13 Qout /H11021/H11005 Q;
14 Cout /H11021/H11005 Q(3)and Q(2)and Q(1)and Q(0)andT;
15 process (Clk)
16 begin
17 ifClk’event and Clk/H11005‘1’then -- change state on rising edge
18 ifClrN /H11005‘0’then Q/H11021/H11005 “0000”;
19 elsif LdN/H11005‘0’then Q/H11021/H11005 D;
20 elsif (PandT)/H11005‘1’then Q/H11021/H11005 Q/H110011;
21 end if ;
22 end if ;
23 end process ;
24 end b74163;FIGURE 17-13
74163 Counter
Model
VHDL for Sequential Logic 563
-- Test module for 74163 counter
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity c74163test is
6 port(ClrN, LdN, P , T1, Clk: instd_logic;
7 Din1, Din2: instd_logic_vector (3 downto 0);
8 Count: outinteger range 0to255;
9 Carry2: outstd_logic);
10 end c74163test;
11 architecture tester ofc74163test is
12 component c74163
13 port(LdN, ClrN, P , T, Clk: instd_logic;
14 D: instd_logic_vector(3 downto 0);
15 Cout: outstd_logic; Qout: outstd_logic_vector (3 downto 0) );
16 end component ;
17 signal Carry1: std_logic;
18 signal Qout1, Qout2: std_logic_vector (3 downto 0);
19 begin
20 ct1: c74163 port map (LdN, ClrN, P , T1, Clk, Din1, Carry1, Qout1);
21 ct2: c74163 port map (LdN, ClrN, P , Carry1, Clk, Din2, Carry2, Qout2);
22 Count /H11021/H11005 Conv_integer(Qout2 & Qout1);
23 end tester;FIGURE 17-14
VHDL for 8-Bit
Counter
counter module (Figure 17-13) contains a process and sequential statements, each
statement that instantiates a counter module is nevertheless a concurrent statementand cannot be placed within a process.
17.3 Modeling Combinational Logic
Using VHDL Processes
Although processes are most useful for modeling sequential logic, they can also be
used to model combinational logic.The circuit of Figure 10-1 can be modeled by theprocess shown in Figure 17-15.
For a combinational process, every signal that appears on the right side of a
signal assignment must appear on the sensitivity list. Suppose that initially A /H110051,
and B /H11005C/H11005D/H11005E/H110050. If B changes to 1 at time /H110054 ns, the process executes,
and the two sequential assignment statements execute in sequence. The new value
564 Unit 17
process  (A, B, C, D)
begin      C <= A and B after  5 ns;
      E <= C or D after  5 ns;
end process ;A
BDC
EFIGURE 17-15
VHDL Code for
Gate Circuit
of C is computed to be '1', and C is scheduled to change 5 ns later. Meanwhile, E
is immediately computed using the old value of C, but it does not change becauseC has not yet changed. After 5 ns, C changes, and because it is on the sensitivitylist, the process executes again, and the sequential statements again execute insequence. This time C does not change, but E is scheduled to change after 5 ns.Because E is not on the sensitivity list, no further execution of the process occurs.The following listing summarizes the operation:
time A B C D E
01 0 0 0 041 1 0 0 0
process executes (C ←1 after 5 ns; E ←0, no change)
91 1 1 0 0
process executes (C ←1, no change; E ←1 after 5 ns)
14 1 1 1 0 1
no further execution until A, B, C, or D changes
In Section 10.2, we modeled a MUX using a conditional signal assignment
statement and a selected signal assignment statement. Because these are con-current statements, they cannot be used inside a process. However, the case
statement is a sequential statement that can be used to model a MUX within aprocess. The 4-to-1 MUX of Figure 10-7 can be modeled as follows:
signal sel: bit_vector(0 to1);
----------------------------------------------------------------------
sel/H11021/H11005 A&B; -- a concurrent statement, outside of the process
process (sel, I0, I1, I2, I3)
begin
case selis -- a sequential statement in the process
when “00” /H11005/H11022 F/H11021/H11005 I0;
when “01” /H11005/H11022 F/H11021/H11005 I1;
when “10” /H11005/H11022 F/H11021/H11005 I2;
when “11” /H11005/H11022 F/H11021/H11005 I3;
when others /H11005/H11022null; -- required if sel is a std_logic_vector;
-- omit if sel is a bit_vector
end case ;
end process ;
VHDL for Sequential Logic 565
The case statement has the general form:
case expression is
when choice1 /H11005/H11022 sequential statements1
when choice2 /H11005/H11022 sequential statements2
...[when others /H11005/H11022 sequential statements]
end case ;
The “expression” is evaluated first. If it is equal to “choice1”, then “sequential
statements1” are executed; if it is equal to “choice2”, then “sequential state-ments2” are executed, etc. All possible values of the expression must be includedin the choices. If all values are not explicitly given, a “ when others ” clause is
required in the case statement. If no action is specified for the other choices, theclause should be
when others /H11005/H11022null;
17.4 Modeling a Sequential Machine
In this section we will discuss several ways of writing VHDL descriptions for
sequential machines. First, we will write a behavioral model for a Mealy sequentialcircuit based on the state table of Table 17-2. This table is the same as Table 16-3with the states renamed. It represents a BCD to excess-3 code converter withinputs and outputs LSB first.
As shown in Figure 17-16, a Mealy machine consists of a combinational cir-
cuit and a state register. The VHDL model of Figure 17-17 uses two processes torepresent these two parts of the circuit. Because X and Z are external signals, theyare declared in the port. State and Nextstate are internal signals that represent the
state and next state of the sequential circuit, so they are declared at the start of the
architecture.At the behavioral level, we represent the state and next state of the cir-cuit by integer signals with a range of 0 to 6.
NS Z
PS X /H110050X /H110051X /H110050X /H110051
S0 S1 S2 1 0
S1 S3 S4 1 0
S2 S4 S4 0 1
S3 S5 S5 0 1S4 S5 S6 1 0S5 S0 S0 0 1S6 S0 – 1 –TABLE 17-2
State Table for
Code Converter
The first process represents the combinational circuit of Figure 17-16. Because
the circuit outputs, Z and Nextstate, can change when either the State or X changes,the sensitivity list includes both State and X. The case statement tests the value ofState, and then for each state, the ifstatement tests X to determine the new values
of Z and Nextstate. For state S6, we assigned values to the don’t-cares so that Z andNextstate are independent of X. The second process represents the state register.Whenever the rising edge of the clock occurs, the State is updated to the Nextstatevalue, so CLK appears in the sensitivity list. A typical sequence of execution for the
two processes is as follows:
1.X changes and the first process executes. New values of Z and NextState are
computed.
2.The clock falls, and the second process executes. Because CLK /H11005‘0’, nothing
happens.
3.The clock rises, and the second process executes again. Because CLK /H11005‘1’,
State is set equal to the Nextstate value.
4.If State changes, the first process executes again. New values of Z and Nextstate
are computed.
A simulator command file which can be used to test Figure 17-17 follows:
add wave CLK X State Nextstate Z
force CLK 0 0, 1 100 -repeat 200force X 0 0, 1 350, 0 550, 1 750, 0 950, 1 1350run 1600
The first command specifies the signals which are to be included in the waveform
output. The next command defines a clock with period of 200 ns. CLK is '0' at time0 ns, '1' at time 100 ns, and repeats every 200 ns. In a command of the form
force signal_name v1 t1, v2 t2, . . .
signal_name gets the value v1 at time t1, the value v2 at time t2, etc. X is '0' at time
0 ns, changes to '1' at time 350 ns, changes to '0' at time 550 ns, etc. The X inputcorresponds to the sequence 0010 1001, and only the times at which X changes are566 Unit 17
Combinational
Circuit
State
RegInputs (X) Outputs (Z)
Nextstate
State
ClockFIGURE 17-16
General Model of
Mealy Sequential
Machine
VHDL for Sequential Logic 567
-- This is a behavioral model of a Mealy state machine (Table 17-2) based on its state
-- table. The output (Z) and next state are computed before the active edge of the clock.-- The state change occurs on the rising edge of the clock.
1 entity SM17_2 is
2 port (X, CLK: inbit;
3Z : outbit);
4 end SM17_2;
5 architecture Table ofSM17_2 is
6 signal State, Nextstate: integer range 0to6 :/H110050;
7 begin
8 process (State, X) -- Combinational Circuit
9 begin
10 case State is
11 when 0/H11005/H11022
12 ifX/H11005‘0’then Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 1;
13 else Z/H11021/H11005 ‘0’; Nextstate /H11021/H11005 2;end if ;
14 when 1/H11005/H11022
15 ifX/H11005‘0’then Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 3;
16 else Z/H11021/H11005 ‘0’; Nextstate /H11021/H11005 4;end if ;
17 when 2/H11005/H11022
18 ifX/H11005‘0’then
Z/H11021/H11005 ’0’; Nextstate /H11021/H11005 4;
19 else Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 4;end if ;
20 when 3/H11005/H11022
21 ifX/H11005‘0’then Z/H11021/H11005 ‘0’; Nextstate /H11021/H11005 5;
22 else Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 5;end if ;
23 when 4/H11005/H11022
24 ifX/H11005‘0’then Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 5;
25 else Z/H11021/H11005 ‘0’; Nextstate /H11021/H11005 6;end if ;
26 when 5/H11005/H11022
27 ifX/H11005‘0’then Z/H11021/H11005 ‘0’; Nextstate /H11021/H11005 0;
28 else Z/H11021/H11005 ‘1’; Nextstate /H11021/H11005 0;end if ;
29 when 6/H11005/H11022
30 Z /H11021/H11005 ‘1’; Nextstate /H11021/H11005 0;
31 end case ;
32 end process ;
33 process (CLK) -- State Register
34 begin
35 ifCLK’event and CLK/H11005‘1’then -- rising edge of clock
36 State /H11021/H11005 Nextstate;
37 end if ;
38 end process ;
39 endTable;FIGURE 17-17
Behavioral Model
for Table 17-2
specified. Execution of the preceding command file produces the waveforms shown
in Figure 17-18.
The behavioral VHDL model of Figure 17-17 is based on the state table. After
we have derived the next-state and output equations from the state table, we canwrite a data flow VHDL model based on these equations. The VHDL model ofFigure 17-19 is based on the next-state and output equations that are derived inFigure 16-3 using the state assignment of Figure 16-2. The flip-flops are updated568 Unit 17
0 500 1000 1500/clk
/x
/z/state
/nextstate0
113502450
3501 2 4502FIGURE 17-18 Waveforms for Figure 17-17
-- The following is a description of the sequential machine of Table 17-2 in terms
-- of its next-state equations. The following state assignment was used:-- S0-- /H110220; S1-- /H110224; S2-- /H110225; S3-- /H110227; S4-- /H110226; S5-- /H110223; S6-- /H110222
1 entity SM1_2 is
2 port (X, CLK: inbit;
3Z : outbit);
4 end SM1_2;
5 architecture Equations1_4 ofSM1_2 is
6 signal Q1, Q2, Q3: bit;
7 begin
8 process (CLK)
9 begin
10 ifCLK’event and CLK/H11005‘1’then -- rising edge of clock
11 Q1 /H11021/H11005notQ2after 10 ns;
12 Q2 /H11021/H11005 Q1after 10 ns;
13 Q3 /H11021/H11005 (Q1and Q2and Q3) or ( notXand Q1and not Q3)or
14 (X and not Q1and not Q2)after 10 ns;
15 end if ;
16 end process ;
17 Z /H11021/H11005 (notXand not Q3)
or(Xand Q3)after 20 ns;
18 end Equations1_4;FIGURE 17-19
Sequential Machine
Model Using
Equations
in a process which is sensitive to CLK. When the rising edge of the clock occurs,
Q1, Q2, and Q3 are all assigned new values. A 10-ns delay is included to representthe propagation delay between the active edge of the clock and the change of theflip-flop outputs. Even though the assignment statements in the process are exe-cuted sequentially, Q1, Q2, and Q3 are all scheduled to be updated at the sametime, T /H1100110 ns, where T is the time at which the rising edge of the clock occurred.
Thus, the old value of Q1 is used to compute Q2
/H11001, and the old values of Q1, Q2,
and Q3 are used to compute Q3/H11001. The concurrent assignment statement for Z
causes Z to be updated whenever a change in X or Q3 occurs. The 20-ns delay rep-resents two gate delays.
After we have designed a sequential circuit using components such as gates
and flip-flops, we can write a structural VHDL model based on the actual inter-connection of these components. Figure 17-20 shows a structural VHDL repre-sentation of the circuit of Figure 16-4. Seven NAND gates, three D flip-flops, andone inverter are used. All of these components are defined in a library namedVHDL for Sequential Logic 569
-- The following is a STRUCTURAL VHDL description of the circuit of Figure 16-4.
1 library BITLIB;
2 useBITLIB.bit_pack. all;
3 entity SM17_1 is
4 port (X, CLK: inbit;
5Z : outbit);
6 end SM17_1;
7 architecture Structure ofSM17_1 is
8 signal A1, A2, A3, A5, A6, D3: bit: /H11005‘0’;
9 signal Q1, Q2, Q3: bit: /H11005‘0’;
10 signal Q1N, Q2N, Q3N, XN: bit: /H11005‘1’;
11 begin
12 I1: Inverter port map (X, XN);
13 G1: Nand3 port map (Q1, Q2, Q3, A1);
14 G2: Nand3 port map (Q1, Q3N, XN, A2);
15 G3: Nand3 port map (X, Q1N, Q2N, A3);
16 G4: Nand3 port map (A1, A2, A3, D3);
17 FF1: DFF port map (Q2N, CLK, Q1, Q1N);
18 FF2: DFF port map (Q1, CLK, Q2, Q2N);
19 FF3: DFF port map (D3, CLK, Q3, Q3N);
20 G5: Nand2 port map (X, Q3, A5);
21 G6: Nand2 port map (XN, Q3N, A6);
22 G7: Nand2 port map (A5, A6, Z);
23 end Structure;FIGURE 17-20
Structural Model of
Sequential Machine
BITLIB. The component declarations and definitions are contained in a package
called bit_pack. The library and use statements are explained in Section 10.7.
Because the NAND gates and D flip-flops are declared as components inbit_pack, they are not explicitly declared in the VHDL code. Because Q1, Q2,and Q3 are initialized to '0', the complementary flip-flop outputs (Q1N, Q2N, andQ3N) are initialized to '1'. G1 is a 3-input NAND gate with inputs Q1, Q2, Q3,and output A1. FF1 is a D flip-flop (see Figure 17-1) with the D input connectedto Q2N. All of the gates and flip-flops in the bit_pack have a default delay of 10ns. Executing the following simulator command file produces the waveforms ofFigure 17-21.
add wave CLK X Q1 Q2 Q3 Z
force CLK 0 0, 1 100 –repeat 200force X 0 0, 1 350, 0 550, 1 750, 0 950, 1 1350run 1600
Next, we will implement the state machine of Table 16-6(a) using a ROM, as
shown in Figure 16-10. In the VHDL code (Figure 17-22), we have used packagesfrom the IEEE library and IEEE Standard Logic because synthesis tools often usestd_logic and std_logic_vector as default types. The constant array ROM1 repre-sents the truth table of Table 16-6(c), which is stored in the ROM. Reading datafrom the ROM is accomplished by four concurrent statements. First, the ROMaddress, which is the index into the array, is formed by concatenating X and Q toform a 4-bit vector. The index is converted from a std_logic_vector to an integer bycalling the conv_integer function. The ROM1 output is split into the D vector thatrepresents the next state and the Z output. The process updates the state registeron the rising edge of the clock.
Next, we will write behavioral VHDL code for the state table given in Table
13-4. We will use a two-process model as we did in Figure 17-17. We will use nest-ed case statements instead of using if-then-else because the state table has morecolumns. Figure 17-23 shows a portion of the VHDL code for the combinationalpart of the circuit. The first case statement branches on the state, and the nestedcase statement for each state defines the Nextstate and outputs by branching onX12 ( /H11005X1&X2). The second process (not shown) that updates the state register
is identical to the one in Figure 17-17.570 Unit 17
0 500 1000 1500/clk
/x
/q1/q2/q3
/zFIGURE 17-21 Waveforms for Figure 16-4
A Moore machine can be modeled using two processes just like a Mealy
machine. For example, the first row of the Moore table of Table 14-3 could be mod-eled within the combinational process as follows:
case state is
when 0/H11005/H11022
Z/H11021/H11005 ‘0’;
ifX/H11005‘0’then Nextstate /H11021/H11005 0;else Nextstate /H11021/H11005 1;end if ;
...
Note that the Z output is specified before X is tested because the Moore output
only depends on the state and not on the input.VHDL for Sequential Logic 571
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity SM16_6 is
6 Port ( X :instd_logic;
7 CLK : instd_logic;
8Z  : outstd_logic);
9 end SM16_5;
10 architecture ROM ofSM16_6 is
11 type ROM16X4 is array (0to15)ofstd_logic_vector (0 to3);
12 constant ROM1: ROM16X4 : /H11005(“1001”, “1011”, “0100”, “0101”,
13 “1101”, “0000”, “1000”, “0000”,14 “0010”, “0100”, “1100”, “1101”,15 “0110”, “1000”, “0000”, “0000”);16 signal Q, D: std_logic_vector (1 to3) :/H11005“000”;
17 signal Index, Romout: std_logic_vector (0 to3);
18 begin
19 Index /H11021/H11005 X&Q; -- X&Q is a 4-bit vector: X Q1 Q2 Q3
20 Romout /H11021/H11005 ROM1 (conv_integer(Index));
-- this statement reads the output from the ROM
-- conv_integer converts Index to an Integer
21 Z /H11021/H11005 Romout(0);
22 D /H11021/H11005 Romout(1 to3);
23 process (CLK)
24 begin
25 ifCLK’event and CLK/H11005‘1’then
Q/H11021/H11005 D;end if ;
26 end process ;
27 end ROM;FIGURE 17-22
Sequential Machine
Using a ROM
17.5 Synthesis of VHDL Code
The synthesis software for VHDL translates the VHDL code to a circuit description
that specifies the needed components and the connections between the components.When writing VHDL code, you should always keep in mind that you are designing hard-ware, not simply writing a computer program. Each VHDL statement implies certainhardware requirements. So poorly written VHDL code may result in poorly designedhardware. Even if VHDL code gives the correct result when simulated, it may not resultin hardware that works correctly when synthesized. Timing problems may prevent thehardware from working properly even though the simulation results are correct.
The synthesis software tries to infer the components needed by “looking” at the
VHDL code. In order for code to synthesize correctly, certain conventions must befollowed. In order to infer flip-flops or registers that change state on the rising edgeof a clock signal, an ifclause of the form
ifclock’event and clock /H11005‘1’then ...end if ;
is required by most synthesizers. For every assignment statement between then and
end if in the preceding statement, a signal on the left side of the assignment will cause572 Unit 17
1 entity Table_13_4 is
2 port(X1, X2, CLK: inbit; Z1, Z2: o utbit);
3 endTable_13_4;
4 architecture T1ofTable_13_4 is
5 signal State, Nextstate: integer range 0to3:/H110050;
6 signal X12: bit_vector(0 to1);
7 begin
8 X12 /H11021/H11005 X1&X2;
9 process (State, X12)
10 begin
11 case State is
12 when 0/H11005/H11022
13 case X12is
14 when “00” /H11005/H11022 Nextstate /H11021/H11005 3; Z1 /H11021/H11005 ‘0’; Z2 /H11021/H11005 ‘0’;
15 when “01” /H11005/H11022 Nextstate /H11021/H11005 2; Z1 /H11021/H11005 ‘1’; Z2 /H11021/H11005 ‘0’;
16 when “10” /H11005/H11022 Nextstate /H11021/H11005 1; Z1 /H11021/H11005 ‘1’; Z2 /H11021/H11005 ‘1’;
17 when “11” /H11005/H11022 Nextstate /H11021/H11005 0; Z1 /H11021/H11005 ‘0’; Z2 /H11021/H11005 ‘1’;
18 when others /H11005/H11022null; -- not required since X is a bit_vector
19 end case ;
20 when 1/H11005/H11022 -- code for state 1 goes here, etc.FIGURE 17-23
Partial VHDL Code
for the Table of
Figure 13-4
creation of a register or flip-flop. The moral to this story is: If you do not want to cre-
ate unnecessary flip-flops, do not put the signal assignments in a clocked process. Ifclock' event is omitted, the synthesizer may produce latches instead of flip-flops.
Before synthesis is started, we must specify a target device so that the synthesizer
knows what components are available. We will assume that the target is a CPLD orFPGA that has D flip-flops with clock enable (D-CE flip-flops).We will synthesize theVHDL code for a left-shift register (Figure 17-10). Q and D are 4-bit vectors. Becauseupdates to Q follow “CLK'event and CLK /H11005'1' then”, this infers that Q must be a
register composed of four flip-flops, which we will label Q3, Q2, Q1, and Q0. Becausethe flip-flops can change state when Clr, Ld, or Ls is '1', we connect the clock enablesto an OR gate whose output is Clr /H11001Ld/H11001Ls. Then, we connect gates to the D inputs
to select the data to be loaded into the flip-flops. If Clr /H110050 and Ld /H110051, D is loaded
into the register on the rising clock edge. If Clr /H11005Ld/H110050 and Ls /H110051, then Q2 is
loaded into Q3, Q1 is loaded into Q2, etc. Figure 17-24 shows the logic circuit for thefirst two flip-flops. If Clr /H110051, the D flip-flop inputs are 0, and the register is cleared.
A VHDL synthesizer cannot synthesize delays. Clauses of the form “ after time-
expression” will be ignored by most synthesizers, but some synthesizers require thatafter clauses be removed. Although the initial values for signals may be specified in
port and signal declarations, these initial values are ignored by the synthesizer. Areset signal should be provided if the hardware must be set to a specific initial state.Otherwise, the initial state of the hardware may be unknown, and the hardware maymalfunction. When an integer signal is synthesized, the integer is represented inhardware by its binary equivalent. If the range of an integer is not specified, the syn-thesizer will assume the maximum number of bits, usually 32. Thus,
signal count: integer range 0to7;
would result in a 3-bit counter, but
signal count: integer;
could result in a 32-bit counter.VHDL for Sequential Logic 573
CE DQ3
CLK
Clr′LdLdClr
Ls
Ld′Ls D3Clr′ Q2CE DQ2
CLK
Clr′Ld Ld ′Ls D2Clr′ Q1...FIGURE 17-24
Synthesis of
VHDL Code From
Figure 17-10
VHDL signals retain their current values until they are changed. This can result
in the creation of unwanted latches when the code is synthesized. For example, in acombinational process, the statement
ifX/H11005‘1’then B/H11021/H11005 1;end if ;
would create latches to hold the value of B when X changed to '0'. To avoid the cre-
ation of unwanted latches in a combinational process, always include an else clause
in every if statement. For example,
ifX/H11005‘1’then B/H11021/H11005 1else B/H11021/H11005 2;end if ;
would create a MUX to switch the value of B from 1 to 2.
Figure 17-25 shows the VHDL code for a 4-bit adder with accumulator. When
the synthesizer analyses this code, it infers the presence of a 4-bit adder with carryin and carry out from line 14. When it analyses the clocked process, it infers from574 Unit 17
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_UNSIGNED. ALL;
4 entity adder is
5 Port (B:instd_logic_vector(3 downto 0);
6 Ld, Ad, Cin, CLK : instd_logic;
7 Aout : outstd_logic_vector(3 downto 0);
8 Cout : outstd_logic);
9 end adder;
10 architecture Behavioral ofadder is
11 signal A : std_logic_vector(3 downto 0);
12 signal Addout : std_logic_vector(4 downto 0);
13 begin
14 Addout /H11021/H11005 (‘0’ & A) /H11001B/H11001Cin;
15 Cout /H11021/H11005 Addout(4);
16 Aout /H11021/H11005 A;
17 process (CLK)
18 begin
19 ifCLK’event and CLK/H11005‘1’then
20 ifLd/H11005‘1’then A/H11021/H11005 B;
21 elsif Ad/H11005‘1’
22 then A/H11021/H11005 Addout(3 downto 0);
23 end if ;
24 end if ;
25 end process ;
26 end Behavioral;FIGURE 17-25 VHDL Code and Synthesis Results for 4-Bit Adder with Accumulator
A (3:0)
0 1
4-bit AdderCE
CLK 44
44
B440
CinCoutAout
Ld
LdAd
lines 11, 19, and 20 that A is a 4-bit register that changes state on the rising clock
edge. It also infers the presence of a 4-wide 2-to-1 multiplexer to select either B orthe adder output to load into A. Because A is loaded when Ld/H110051 or Ad/H110051, the
CE input to the register is Ld/H11001Ad. At this point, a block diagram of the synthe-
sized code resembles that shown in Figure 17-25. The synthesizer output is thenoptimized and fit into a specific target device.
17.6 More About Processes 
and Sequential Statements
An alternative form for a process uses wait statements instead of a sensitivity list. A
process cannot have both a wait statement and a sensitivity list. A process with waitstatements may have the form
process
begin
sequential-statementswait-statementsequential-statementswait-statement...
end process;
This process will execute the sequential-statements until a wait statement is
encountered. Then, it will wait until the specified wait condition is satisfied. It willthen execute the next set of sequential-statements until another wait is encoun-tered. It will continue in this manner until the end of the process is reached. Then,it will start over again at the beginning of the process.
Wait statements can be of three different forms:
wait on sensitivity-list;
wait for time-expression;
wait until Boolean-expression;
The first form waits until one of the signals on the sensitivity list changes. For
example, wait on A,B,C; waits until A, B, or C changes and, then, execution pro-
ceeds. The second form waits until the time specified by time expression has lapsed.Ifwait for 5 ns is used, the process waits for 5 ns before continuing. If wait for 0 ns
is used, the wait is for one /H9004time.Wait statements of the form wait for xx ns are use-
ful for writing VHDL code for simulation; however, they should not be used whenwriting VHDL code for synthesis because they are not synthesizable. For the thirdform of wait statement, the Boolean expression is evaluated whenever one of thesignals in the expression changes, and the process continues execution when theexpression evaluates to TRUE. For example,
wait until A/H11005B;VHDL for Sequential Logic 575
will wait until either A or B changes. Then, A /H11005B is evaluated, and if the result
is TRUE, the process will continue, or else the process will continue to wait untilA or B changes again and A /H11005B is TRUE.
After a VHDL simulator is initialized, it executes each process with a sensitivi-
ty list one time through, and then waits at the beginning of the process for a changein one of the signals on the sensitivity list. If a process has a wait statement, it willinitially execute until a wait statement is encountered. Therefore, the followingprocess is equivalent to the one in Figure 17-15:
process
begin
C/H11021/H11005 Aand Bafter 5 ns;
E/H11021/H11005 CorDafter 5 ns;
wait on A, B, C, D;
end process ;
The wait statement at the end of the process replaces the sensitivity list at the begin-
ning. In this way both processes will initially execute the sequential statements onetime and, then, wait until A, B, C, or D changes.
The order in which sequential statements are executed in a process is not neces-
sarily the order in which the signals are updated. Consider the following example:
process
begin
wait until clk’event and clk/H11005‘1’;
A/H11021/H11005 Eafter 10 ns; -- (1)
B/H11021/H11005 Fafter 5 ns; -- (2)
C/H11021/H11005 G; -- (3)
D/H11021/H11005 Hafter 5 ns; -- (4)
end process ;
This process waits for a rising clock edge. Suppose the clock rises at time /H1100520 ns.
Statements (1), (2), (3), (4) immediately execute in sequence. A is scheduled tochange to E at time /H1100530 ns; B is scheduled to change to F at time /H1100525 ns; C is
scheduled to change to G at time /H1100520/H11001/H9004 ns; and D is scheduled to change to H at
time 25 ns. As simulated time advances, first, C changes. Then, B and D change attime /H1100525 ns, and finally A changes at time 30 ns. When clk changes to '0', the wait
statement is re-evaluated, but it keeps waiting until clk changes to '1', and then theremaining statements execute again.
If several VHDL statements in a process update the same signal at a given time,
the last value overrides. For example,
process (CLK)
begin
ifCLK’event and CLK/H11005‘0’then
Q/H11021/H11005 A; Q /H11021/H11005 B; Q/H11021/H11005 C;
end if ;
end process;
Every time CLK changes from '1' to '0', after /H9004
time, Q will change to C.576 Unit 17
In this unit, we have introduced processes with sensitivity lists and processes
with wait statements. The statements within a process are called sequential state-ments because they execute in sequence, in contrast with concurrent statementsthat execute only when a signal on the right-hand side changes. Signal assignmentstatements can be either concurrent or sequential. However, ifand case state-
ments are always sequential, yet conditional signal assignment statements andselected signal assignment statements can only be concurrent.
Problems
17.1 Write VHDL code for a T flip-flop with an active-low asynchronous clear.
17.2 Write VHDL code for the following right-shift register with synchronous clear.
17.3 A 4-bit up/down binary counter with output Q works as follows: All state changes
occur on the rising edge of the CLK input, except the asynchronous clear (ClrN).When ClrN /H110050, the counter is reset regardless of the values of the other inputs.
If the LOAD input is 0, the data input D is loaded into the counter.
If LOAD /H11005ENT /H11005ENP /H11005UP/H110051, the counter is incremented.
If LOAD /H11005ENT /H11005ENP /H110051 and UP /H110050, the counter is decremented.
If ENT /H11005UP/H110051, the carry output (CO) /H110051 when the counter is in state 15.
If ENT /H110051 and UP /H110050, the carry output (CO) /H110051 when the counter is in state 0.
(a) Write a VHDL description of the counter.
(b) Draw a block diagram and write a VHDL description of an 8-bit binary
up/down counter that uses two of these 4-bit counters.
17.4 Represent the given circuit using a process with a case statement.
I0
I1 CC′
D
C′
D
D′
ABZI2
I3Q3 Q2 Q1
Right SRQ0 Ld
D3 D2 D1 D0CLKRS
CLR LinVHDL for Sequential Logic 577
17.5 Write a VHDL module for the sequential machine of Table 14-1. Use two process-
es as in Figure 17-17.
17.6 (a) Draw a block diagram showing how Table 13-4 can be realized using a ROM
and D flip-flops (rising-edge trigger).
(b) Write VHDL code for the circuit of part (a). Use a straight binary state assign-
ment and form the ROM address as X1&X2&Q1&Q2.
17.7 (a) Draw a circuit that implements the following VHDL code using gates and D-
CE flip-flops.
signal A,B,Q: bit_vector(1 to 2);
---------------------------------process (CLK)
ifCLK’event and CLK/H11005‘0’then
ifLdA/H11005‘1’then Q/H11021/H11005 A;
elsif LdB/H11005‘1’then Q/H11021/H11005 B;
end if ;
end if ;
end process ;
(b) Show how your circuit can be simplified if LdA /H11005LdB /H11005'1' can never occur.
Use MUXes and D-CE flip-flops in your simplified circuit.
17.8 In the following VHDL process, A, B, C, and D are all integers that have a value of
0 at time /H1100510 ns. If E changes from '0' to '1' at time 20 ns, specify the time at which
each signal will change and the value to which it will change.
p1:process
wait on E;
A/H11021/H11005 1after 15 ns;
B/H11021/H11005 A/H110011;
C/H11021/H11005 B/H110011after 10 ns;
D/H11021/H11005 B/H110012after 3 ns;
A/H11021/H11005 A/H110015after 15 ns;
B/H11021/H11005 B/H110017;
end process p1;
17.9 Write the VHDL code for an S-R flip-flop with a rising-edge clock. Use standard
logic, and output 'X' if 
S/H11005R/H11005'1' at a rising clock edge.
17.10 Write a VHDL module for a D-G latch, using the code of Figure 17-2. Then, write a
VHDL module to implement the D flip-flop shown in Figure 11-15, using twoinstances of the D-G latch module you wrote.
17.11 What device is described by the following VHDL code?578 Unit 17
process (CLK, CLR, PRE)
ifCLR/H11005‘1’then Q/H11021/H11005 ‘0’;
elsif PRE/H11005‘1’then Q/H11021/H11005 ‘1’;
elsif CLK’event and CLK/H11005‘1’and CE/H11005‘1’then Q/H11021/H11005 D;
end if ;
end process;
17.12 Write the VHDL code for an 8-bit register with data inputs and tri-state outputs.
Use control inputs Ld (Load) and En (tri-state output enable).
17.13 Implement a 4-to-2 priority encoder using ifand elsif statements.
17.14 Write a VHDL module for a 4-bit comparator. The comparator has two inputs, A
and B, which are 4-bit std_logic vectors; and three std_logic outputs,AGB,ALB, andAEB. AGB /H11005'1' if A is greater than B, ALB /H11005'1' if A is less than B, AEB /H11005'1' if
A and B are equal.
17.15 Write the VHDL code for a 6-bit Super-Register with a 3-bit control input A. The
register operates according to the following table:
A Action
000 Hold State
001 Shift Left010 Shift Right011 Synchronous Clear100 Synchronous Preset
101 Count Up
110 Count Down111 Load
The register also has a 6-bit output (Q), a 6-bit input (D), a Right-Shift-In input
(RSI), and a Left-Shift-In input (LSI). Use a case statement.
17.16 Write VHDL code that will display the value of a BCD input on a seven-segment
display. Use a single process with a case statement to model this combinational cir-
cuit. Refer to Figure 8-14 for a diagram of the seven-segment display.
17.17 The Mealy and Moore circuits shown both produce an output that is the exclusive-
OR of two consecutive inputs.Assume each of the flip-flops has a propagation delayof 10 ns both from the clock edge and from ClrN, and the exclusive-OR gate has a10 ns propagation delay. ClrN is an asynchronous clear.(a) Create a VHDL dataflow model for the Mealy circuit. Assign type std_logic to
all signals.
(b) Simulate your code for 400 ns, and record the waveforms for the following input
patterns:
ClrN 0 at 0 ns, 1 at 20 nsx1 at 0 ns, 0 at 60 ns, 1 at 140 ns, 0 at 220 ns
CLK symmetrical 80 ns period starting at 0VHDL for Sequential Logic 579
(c) Repeat Part (a) for the Moore circuit.
(d) Repeat Part (b) for the Moore circuit.(e) Explain the differences in the outputs from the two circuits. On the waveforms,
show the input and output sequences for the two circuits.580 Unit 17
CLKx
CkD Q
Q′
clrqz
ClrNCkD Q
Q′
clrQ2Z
CLKX
CkD Q
Q′
clr
ClrNQ1
17.18 A modulo 8 counter cycles through the states Q0Q1Q2Q3/H110051000, 1100, 0100, 0110,
0010, 0011, 0001, 1001. The counter has eight outputs: Z0/H110051 when the counter is in
state 1000 and the CLK is 0 and Z0/H110050 otherwise; Z1/H110051 when the counter is in
state 1100 and the CLK is 0 and Z1/H110050 otherwise, . . .; Z7/H110051 when the counter is
in state 1001 and the CLK is 0 and Z7/H110050 otherwise. The counter has an asynchro-
nous, active-low reset input ClrN.(a) Derive minimum equations for the counter outputs.(b) Assume the counter is implemented using D flip-flops. Find minimum
input
equations for the flip-flops.
(c) Assume the counter is implemented using D-CE flip-flops. Find minimum input
equations for the flip-flops.
(d) Write a VHDL behavioral description of the counter. Assume the flip-flops are
positive edge triggered.
(e) Write a VHDL dataflow description of the counter using the equations from
Part (b). Simulate the counter for a cycle to verify your code.
(f) Write a VHDL dataflow description of the counter using the equations from
Part (c). Simulate the counter for a cycle to verify your code.
17.19 Repeat Problem 17.18 for a modulo 8 counter that cycles through the states
Q0Q1Q2Q3/H110051000, 1100, 1110, 0110, 0010, 0011, 1011, 1001.
17.20 Shown is an iterative circuit for comparing two 4-bit positive numbers. All of the
Cmp modules in the circuit are the same. With the proper inputs for ig and ie, theoutputs are og /H110051 and oe /H110050 if the xis larger than y,o g/H110050 and oe /H110051 if xand y
are equal, and og /H110050 and oe /H110050 if yis larger than x.
(a) Derive the logic equations that describe the Cmp module.(b) Using your equations from Part (a), write VHDL code that gives a dataflow
description of a Cmp module.
(c) Using the VHDL module defined in Part (b), write structural VHDL code that
specifies the 4-bit comparator.
(d) Use the Direct VHDL simulator to obtain the signal values for the three input
combinations: x/H110050100 y/H110050011, x/H110050011 y/H110050100, and x/H110050001 y/H110050001.
Record the waveform report from the simulator.VHDL for Sequential Logic 581
Present Next State Z
State X /H110050X /H110051X /H110050X /H110051
S0 S1 S0 0 0
S1 S0 S2 1 0S2 S3 S2 1 1S3 S0 S1 0 1x3y3 x2y2 x1y1 x0y0
Cmp3ig
ieCmp2og
oeCmp1 Cmp0
17.21 The following iterative circuit is a priority selection circuit.When one or more of the
inputs is 1, osel /H110050 and yi/H110051 where iis the largest index such that xi/H110051. If none
of the inputs is 1, then all outputs are 0 and osel /H110051. The four modules in the circuit
are identical.(a) Derive the logic equations that describe the Pr module.(b) Using your equations from Part (a), write VHDL code that gives a dataflow
description of the Pr module.
(c) Using the VHDL module defined in Part (b), write structural VHDL code that
specifies the 4-bit priority selector.
(d) Use the Direct VHDL simulator to obtain the signal values for the three input
combinations: x/H110051000, x/H110050111, and x/H110050000. Record the waveform report
from the simulator.
17.22 A Mealy sequential machine with one input (X) and one output (Z) has the follow-
ing state table.Pr3 isel Pr2 osel Pr1 Pr0x3x2x1x0
y3y2y1y0
Write a VHDL module for the sequential machine using a ROM (as in Figure 17-22)
and a straight binary assignment.
17.23 Repeat Problem 17.22 using equations as in Figure 17-19 and using a one-hot state
assignment. ( Hint : It may be easier to do the one-hot state assignment properly if you
draw the state graph first.)
17.24 The following VHDL code is for a 2-to-1 MUX, but it contains mistakes. What are
the mistakes?
library IEEE;
useIEEE.STD_LOGIC_1164. ALL;
entity mux2 is
port (d0, d1 : inbit;
sel :inBoolean;
z :outbit);
end mux2;
architecture bvhrofmux2 is
signal muxsel : integer range 0to1;
begin
process (d0, d1, select)
begin
muxsel /H11021/H11005 0;
ifselthen muxsel /H11021/H11005 muxsel /H110011;end if ;
case muxsel is
when 0/H11005/H11022 z/H11021/H11005 d0after 2ns;
when 1/H11005/H11022 z/H11021/H11005 d1after 2ns;
end case ;
end process ;
end bvhr;
17.25 Give the state table implemented by the following VHDL code.
entity Problem17_25 is
port(X, CLK: inbit;
Z1, Z2: outbit);
end Problem17_25;
architecture Table ofProblem17_25 is
signal State, Nextstate: integer range 0to3 :/H110050;
begin
process (State, X) --Combinational Circuit
begin
case State is
when 0/H11005/H11022582 Unit 17
ifX/H11005’0’then Z1/H11021/H11005 ’1’; Z2 /H11021/H11005 ’0’; Nextstate /H11021/H11005 0;
else Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’0’; Nextstate /H11021/H11005 1;end if ;
when 1/H11005/H11022
ifX/H11005’0’then Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’1’; Nextstate /H11021/H11005 1;
else Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’1’; Nextstate /H11021/H11005 2;end if ;
when 2/H11005/H11022
ifX/H11005’0’then Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’1’; Nextstate /H11021/H11005 2;
else Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’1’; Nextstate /H11021/H11005 3;end if ;
when 3/H11005/H11022
ifX/H11005’0’then Z1/H11021/H11005 ’0’; Z2 /H11021/H11005 ’0’; Nextstate /H11021/H11005 0;
else Z1/H11021/H11005 ’1’; Z2 /H11021/H11005 ’0’; Nextstate /H11021/H11005 0;end if ;
end case ;
end process ;
process (CLK) -- State Register
begin
ifCLK’event and CLK/H11005’1’then -- rising edge of clock
State /H11021/H11005 Nextstate;
end if ;
end process ;
endTable;
17.26 Give the state table implemented by the following VHDL code.
entity Problem17_26 is
port(X, CLK: inbit;
Z:outbit);
end Problem17_26;
architecture Table ofProblem17_26 is
signal State, Nextstate: integer range 0to3 :/H110050;
begin
process (State, X) --Combinational Circuit
begin
case State is
when 0/H11005/H11022 Z/H11021/H11005 ‘1’;
ifX/H11005’0’then Nextstate /H11021/H11005 1;
else Nextstate /H11021/H11005 2;end if ;
when 1/H11005/H11022 Z/H11021/H11005 ‘0’;
ifX/H11005’0’then Nextstate /H11021/H11005 3;
else Nextstate /H11021/H11005 2;end if ;
when 2/H11005/H11022 Z/H11021/H11005 ‘0’;
ifX/H11005’0’then Nextstate /H11021/H11005 1;
else Nextstate /H11021/H11005 0;end if ;
when 3/H11005/H11022 Z/H11021/H11005 ‘0’;
ifX/H11005’0’then Nextstate /H11021/H11005 0;
else Nextstate /H11021/H11005 1;end if ;VHDL for Sequential Logic 583
end case ;
end process ;
-- the clocked process goes here, same as in Problem 17.25endTable;
17.27 Give the state table implemented by the following VHDL code.
entity Problem17_27 is
port(X1, X2, CLK: inbit;
Z:outbit);
end Problem17_27;
architecture Table ofProblem17_27 is
signal State, Nextstate: integer range 0to2 :/H110050;
signal X12: bit_vector(0 to 1);
begin
X12/H11021/H11005 X1&X2;
process (State, X12) --Combinational Circuit
begin
case State is
when 0/H11005/H11022 Z/H11021/H11005 ‘0’;
case X12is
when “00” /H11005/H11022 Nextstate /H11021/H11005 0;
when “01” /H11005/H11022 Nextstate /H11021/H11005 1;
when “10” /H11005/H11022 Nextstate /H11021/H11005 2;
when “11” /H11005/H11022 Nextstate /H11021/H11005 0;
end case ;
when 1/H11005/H11022 Z/H11021/H11005 ‘0’;
case X12is
when “00” /H11005/H11022 Nextstate /H11021/H11005 0;
when “01” /H11005/H11022 Nextstate /H11021/H11005 1;
when “10” /H11005/H11022 Nextstate /H11021/H11005 2;
when “11” /H11005/H11022 Nextstate /H11021/H11005 1;
end case ;
when 2/H11005/H11022 Z/H11021/H11005 ‘1’;
case X12is
when “00” /H11005/H11022 Nextstate /H11021/H11005 0;
when “01” /H11005/H11022 Nextstate /H11021/H11005 1;
when “10” /H11005/H11022 Nextstate /H11021/H11005 2;
when “11” /H11005/H11022 Nextstate /H11021/H11005 2;
end case ;
end case ;
end process ;
-- the clocked process goes here, same as in Problem 17.25.endTable;584 Unit 17
17.28 The VHDL specification for a state machine follows. It has one binary input (plus a
clock and reset) and one binary output.(a) Construct a state table for this state machine.(b) Simulate the circuit for the input sequence xin /H11005010111011, record the wave-
form and list the output sequence produced.
(c) Find a minimum row state table that describes this state machine.(d) What input sequences cause the output to become 1? ( Hint : The machine rec-
ognizes sequences ending in two different patterns.)
library IEEE;
useIEEE.STD_LOGIC_1164. ALL;
entity pttrnrcg is
port (clk, rst, xin : instd_logic;
zout : outstd_logic);
end pttrnrcg;
architecture sttmchn ofpttrnrcg is
type mchnstate is(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10);
signal state, nextstate: mchnstate;
begin
cmb_lgc: process (state, xin)
begin
case state is
when s1/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s2;else nextstate /H11021/H11005 s10;end if ;
when s2/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s2;else nextstate /H11021/H11005 s3;end if ;
when s3/H11005/H11022
zout /H11021/H11005 ‘1’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s4;
else nextstate /H11021/H11005 s6;end if ;
when s4/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s7;else nextstate /H11021/H11005 s8;end if ;
when s5/H11005/H11022
zout /H11021/H11005 ‘1’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s9;else nextstate /H11021/H11005 s10;end if ;
when s6/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s9;else nextstate /H11021/H11005 s10;end if ;
when s7/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s2;else nextstate /H11021/H11005 s3;end if ;
when s8/H11005/H11022VHDL for Sequential Logic 585
zout /H11021/H11005 ‘1’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s4;else nextstate /H11021/H11005 s5;end if ;
when s9/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s7;else nextstate /H11021/H11005 s8;end if ;
when s10/H11005/H11022
zout /H11021/H11005 ‘0’;
ifxin/H11005‘0’then nextstate /H11021/H11005 s9;else nextstate /H11021/H11005 s10;end if ;
end case ;
end process cmb_lgc;
stt_trnstn: p rocess (clk,rst)
begin
ifrst/H11005‘1’then
state /H11021/H11005 s1;
elsif Rising_Edge (clk) then
state /H11021/H11005 nextstate;
end if ;
end process stt_trnstn;
end sttmchn;
17.29 The VHDL specification for a sequential circuit follows. It has one binary input
(plus a clock and reset) and one binary output. Four architectures are given for thesequential circuit.(a) For each of these architectures, draw the schematic described by the architec-
ture. Use D flip-flops and AND, OR, and NOT gates.
(b) What differences exist in the outputs produced by these architectures?
library IEEE;
useIEEE.STD_LOGIC_1164. ALL;
entity diff1 is
port (clk, rst, xin :
instd_logic;
zout : outstd_logic);
end diff1;
architecture df1ofdiff1 is
signal y0,y1,nxty0,nxty1 : std_logic;
begin
process (y0,y1,xin)
begin
zout /H11021/H11005 y0AND (xinXOR y1); nxty0 /H11021/H11005NOT y0; nxty1 /H11021/H11005 xin;
end process ;
process (clk,rst)
begin
ifrst/H11005‘1’then
y0/H11021/H11005 ‘0’; y1 /H11021/H11005 ‘0’;
elsif Rising_Edge (clk) then586 Unit 17
y0/H11021/H11005 nxty0; y1 /H11021/H11005 nxty1;
end if ;
end process ;
end df1;
architecture df2ofdiff1 is
signal y0,y1,nxty0,nxty1 : std_logic;
begin
zout /H11021/H11005 y0AND (xinXOR y1); nxty0 /H11021/H11005NOT y0; nxty1 /H11021/H11005 xin;
process (clk,rst)
begin
ifrst/H11005‘1’then
y0/H11021/H11005 ‘0’; y1 /H11021/H11005 ‘0’;
elsif Rising_Edge (clk) then
y0/H11021/H11005 nxty0; y1 /H11021/H11005 nxty1;
end if ;
end process ;
end df2;
architecture df3ofdiff1 is
signal y0,y1 : std_logic;
begin
zout /H11021/H11005 y0AND (xinXOR y1);
process (clk,rst)
begin
ifrst/H11005‘1’then
y0/H11021/H11005 ‘0’; y1 /H11021/H11005 ‘0’;
elsif Rising_Edge (clk) then
y0/H11021/H11005NOT y0; y1 /H11021/H11005 xin;
end if ;
end process ;
end df3;
architecture df4ofdiff1 is
signal y0,y1 : std_logic;
begin
process (clk,rst)
begin
ifrst/H11005‘1’then
y0/H11021/H11005 ‘0’; y1 /H11021/H11005 ‘0’; zout /H11021/H11005 ‘0’;
elsif Rising_Edge (clk) then
y0/H11021/H11005NOT y0; y1 /H11021/H11005 xin; zout /H11021/H11005 y0AND (xinXOR y1);
end if ;
end process ;
end df4;VHDL for Sequential Logic 587
17.30 Write a VHDL module for an 8-bit mask circuit. When the signal Store /H110051, the 
8-bit input X is stored in an 8-bit mask register M. The 8-bit output Z of the maskcircuit is always the AND of the bits of M with the corresponding bits of X.The cir-cuit should also have an asynchronous active-high signal Set, which will set all thebits of M to 1.
17.31 Write a VHDL module for the sequential machine of Table 14-3. Use two process-
es as in Figure 17-17.
Simulation Problems
17.A Write a behavioral VHDL module that implements the 8-bit shift register of
Figure 12-8. Do not use individual flip-flops in your code. Add an active-low asyn-chronous reset input, ClrN. Simulate the module to obtain a timing diagram similarto Figure. 12-9. Then, write VHDL code for a 16-bit serial-in, serial-out shift registerusing two of these modules.
17.B Write a VHDL module for a 4-bit counter with enable that increments by different
amounts, depending on the control input C. If En /H110050, the counter holds its state.
Otherwise, if C /H110050, the counter increments by 1 every rising clock edge, and if C /H110051,
the counter increments by 3 every rising clock edge. The counter also has an active-low asynchronous preset signal, PreN.
17.C Write a VHDL module to implement a counter that counts in the following
sequence: 000, 010, 100, 110, 001, 011, 101, 111, (repeat) 000, etc. Use a ROM and Dflip-flops.
17.D Write a VHDL module to implement a circuit that can generate a clock signal
whose time period is a multiple of the input clock. A control signal F determines
the multiplying factor. If F /H110050, the output signal has a time period twice that of the
input clock. If F /H110051, the output signal has a time period three times that of the
input clock. The portion of the clock cycle when the clock is 1 may be longer thanthe portion when it is 0, or vice versa. Use a counter with an active-high synchro-nous clear input.
17.E Write a VHDL module to implement an 8-bit serial-in, serial-out right-left
shift register with inputs RSI, LSI, En, R, and Clk. RSO and LSO are the serial out-puts, so they should be the rightmost and leftmost bits of the register. However, thevalues of the other flip-flops inside the register should not appear on the outputs.When En /H110051, at the rising edge of the clock, the register shifts right if R /H110051 or left
if R /H110050. RSI should be the shift-in input if R /H110051, and LSI should be the shift-in588 Unit 17
input if R /H110050. When En /H110050, the register holds its state. There should also be an
asynchronous active-low clear input ClrN.
17.F Work Problem 17.E, but change the register to 6 bits, remove the input En, and add
an input L. At the rising edge of the clock, if R /H110051 and L /H110050, the register shifts
right. If R /H110050 and L /H110051, the register shifts left. If R /H11005L/H110050 or R /H11005L/H110051, the reg-
ister holds its state.
17.G Write a VHDL module for a 6-bit accumulator with carry-in (CI) and carry-out
(CO). When Ad /H110050, the accumulator should hold its state. When Ad /H110051, the accu-
mulator should add the value of the data inputs D (plus CI) to the value already inthe accumulator. The accumulator should also have an active-low asynchronousclear signal ClrN.
17.H Write a VHDL module for a 4-bit up-down counter. If En /H110050, the counter will hold
its state. If En /H110051, the counter will count up if U /H110051 or down if U /H110050. The count-
er should also have an asynchronous active-low clear signal ClrN.
17.I Write a VHDL module for a 6-bit up-down counter. If U /H110051 and D /H110050, the
counter will count up, and if U /H110050 and D /H110051, the counter will count down. If
U/H11005D/H110050 or U /H11005D/H110051, the counter will hold its state. The counter should also
have an asynchronous active-low preset signal PreN that sets all flip-flops to 1.
17.J Write a VHDL module for a memory circuit.The memory stores four 6-bit words in
registers. The output Memout is always the value of the memory register selectedby the 2-bit select signal Sel. Use tri-state buffers to connect the register outputs. IfLd/H110051, the register specified by Sel will load the value of the 6-bit input signal
Memin at the next rising clock edge.
17.K Write a VHDL module for the Parallel-in, Parallel-out right-shift register of
Figure 12-10, but add an active-low asynchronous clear signal ClrN. Do not useindividual flip-flops in your code. Simulate the module to obtain a timing diagramsimilar to Figure 12-11.
17.L Write a VHDL module for an 8-bit accumulator which can also shift the bits in
the accumulator register to the left. If Ad /H110051, the accumulator should add the
value of the data inputs D to the value already in the accumulator. If Ad /H110050
and Sh /H110051, the bits in the accumulator should shift left (i.e., multiply by 2). If
Ad/H11005Sh/H110050, the accumulator should hold its state. The accumulator should also
have an active-low asynchronous clear signal ClrN. Assume that carry-in andcarry-out signals are unnecessary for this application. Use an overloaded “ /H11001”
operator for addition.VHDL for Sequential Logic 589
17.M Write a VHDL module for an 8-bit accumulator for subtraction, which can also
shift the accumulator bits to the right. There are two control inputs, A and B. IfA/H11005B/H110051, the value of the data inputs D are subtracted from the accumulator.
If A /H110051 and B /H110050, the value of the data inputs D are loaded directly into the
register. If A /H110050 and B /H110051, the accumulator should shift right with zero
fill. If A /H11005B/H110050, the accumulator should hold its state. Use an overloaded “ /H11002”
operator for subtraction.590 Unit 17
591Circuits for Arithmetic 
Operations
Objectives
1.Analyze and explain the operation of various circuits for adding, subtract-
ing, multiplying, and dividing binary numbers and for similar operations.
2.Draw a block diagram and design the control circuit for various circuits for
adding, subtracting, multiplying, and dividing binary numbers and forsimilar operations.
UNIT
18
1.Study Section 18.1, Serial Adder with Accumulator .
(a) Study Figure 18-2 carefully to make sure you understand the operation of
this type of adder. Work out a table similar to Table 18-1 starting with X/H110056
andY/H110053:
XY ci si ci/H11001
t0 0110 0011
t1
t2
t3
t4
(b) What changes would be made in this table if the SIinput to the addend
register (Figure 18-1) was connected to a logic 0 instead of to y0?
(c) Note in Table 18-1 that when the adding has finished, the full adder still gen-
erates a sum and a carry output.The full adder consists of combinational logic,so it will still automatically do the work of calculating its outputs even whenthey are not needed. What bits are added to generate the last values of s
iand
ci/H11001? [See Figure 18-2(e).] Are the last values of siandci/H11001useful for anything?
(d) Work Problem 18.3.
2.Study Section 18.2, Design of a Parallel Multiplier .
(a) For the binary multiplier of Figure 18-7, if the initial contents of the accu-
mulator is 000001101 and the multiplicand is 1111, show the sequence ofadd and shift signals and the contents of the accumulator at each time step.
(b) For the state diagram of Figure 18-8, what is the maximum number of clock
cycles required to carry out the multiplication? The minimum number?592 Unit 18
Study Guide
(c) For the state diagram of Figure 18-9(c), assuming the counter sets K/H110051
when the counter is in state 3 (112), what is the maximum number of clock
cycles required to carry out the multiplication? The minimum number?
(d) For Figure 18-7, how many bits would be required for the product register
if the multiplier was 6 bits and the multiplicand was 8 bits?
(e) Work Problems 18.4 and 18.5.
(f) Consider the design of a binary multiplier which multiplies 8 bits by 8 bits to
give a 16-bit product. What changes would need to be made in Figure 18-7?
If a multiplier control of the type shown in Figure 18-8 were used, how
many states would be required?
If a control of the type shown in Figure 18-9 is used, how many bits should
the counter have? Kshould equal 1 in what state of the counter? How
many states will the control state graph have?
(g) Work Programmed Exercise 18.1.
3.Study Section 18.3, Design of a Binary Divider.
(a) Using the state diagram of Figure 18-11 to determine when to shift or sub-
tract, work through the division example given at the start of this section.
(b) What changes would have to be made in Figure 18-12 if the subtraction
was done using full adders rather than full subtracters?
(c) For the block diagram of Figure 18-10, under what conditions will an over-
flow occur and why?
(d) Work Programmed Exercise 18.2.
(e) Derive the control circuit equations, Equations (18-1).
(f) In Figure 18-13, why is one of the inputs to the bus merger at the 0 input
of the MUX set to 1?
(g) For a binary multiplier of the type described in Section 18.2, addition is
done before shifting. Division requires a series of shift and subtract oper-ations. Since division is the inverse of multiplication, which operationshould be done first, subtract or shift?
(h) Work Problems 18.6, 18.7, and 18.8.Circuits for Arithmetic Operations 593
This unit introduces the concept of using a sequential circuit to control a sequence
of operations in a digital system. Such a control circuit outputs a sequence of con-trol signals that cause operations such as addition or shifting to take place at theappropriate times. We will illustrate the use of control circuits by designing a serialadder, a multiplier, and a divider.
18.1 Serial Adder with Accumulator
In this section we will design a control circuit for a serial adder with an accumu-lator. Figure 18-1 shows a block diagram for the adder. Two shift registers areused to hold the 4-bit numbers to be added, Xand Y. The Xregister serves as an4.Optional simulation exercises:
(a) Simulate the serial adder of Figure 13-12 and test it.
(b) Connect two 4-bit shift registers to the inputs of the adder that you simu-
lated in (a) to form a serial adder with accumulator (as in Figure 18-1).Supply the shift signal and clock signal from switches so that a control cir-cuit is unnecessary. Test your adder using the following pairs of binarynumbers:
0101 /H110010110, 1011 /H110011101
(c) Input the control circuit from the equations of Figure 18-4, connect it to
the circuit which you built in (b), and test it.
5.When you are satisfied that you can meet all of the objectives, take the readi-
ness test.594 Unit 18
Circuits for Arithmetic 
Operations
accumulator and the Yregister serves as an addend register. When the addition
is completed, the contents of the Xregister are replaced with the sum of Xand
Y. The addend register is connected as a cyclic shift register so that after shifting
four times it is back in its original state, and the number Yis not lost. The box at
the left end of each shift register shows the inputs: Sh(shift signal), SI (serial
input), and Clock . When Sh/H110051 and an active clock edge occurs, SI is entered
into x3(ory3) at the same time as the contents of the register are shifted one
place to the right. The additional connections required for initially loading the Xand Yregisters and clearing the carry flip-flop are not shown in the block
diagram.
The serial adder, highlighted in blue in the diagram, is the same as the one in
Figure 13-12, except the D flip-flop has been replaced with a D flip-flop with clockenable. At each clock time, one pair of bits is added. Because the full adder is acombinational circuit, the sum and carry appear at the full adder output after thepropagation delay. When Sh/H110051, the falling clock edge shifts the sum bit into the
accumulator, stores the carry bit in the carry flip-flop, and rotates the addend regis-ter one place to the right. Because Shis connected to CE on the flip-flop, the carry
is only updated when shifting occurs.
Figure 18-2 illustrates the operation of the adder. Shifting occurs on the
falling clock edge when Sh/H110051. In this figure, t
0is the time before the first shift,
tlis the time after the first shift, t2is the time after the second shift, etc. Initially,
at time t0, the accumulator contains Xand the addend register contains Y.
Because the full adder is a combinational circuit, x0,y0, and c0are added inde-
pendently of the clock to form the sum s0and carry c1. When the first falling clock
edge occurs, s0is shifted into the accumulator and the remaining accumulator
digits are shifted one position to the right. The same clock edge stores c1in the
carry flip-flop and rotates the addend register right. The next pair of bits, x1and
y1, are now at the full adder input, and the adder generates the sum and carry, s1Circuits for Arithmetic Operations 595
Control
CircuitSIAccumulator
Full
Adder
Addend Register
Serial AdderShx3
St (Start Signal)
Clockx2 x1 x0
SI
CKSh
D
CEQ
Q′Sh y3
ciyisi
ci + 1xi
y2 y1 y0FIGURE 18-1
Block Diagram for
Serial Adder with
Accumulator
596 Unit 18
Full
Adder
(a) At time t0x3x2x1x0
y3y2y1y0
Dc0 = 0c1s0
Full
Adder
unused
unused(c) At time t2s1s0x3x2
y1y0y3y2
Dc2c3s2Full
Adder
(b) At time t1s0x3x2x1
y0y3y2y1
Dc1c2s1
Full
Adder
(d) At time t3s2 s1 s0x3
y2y1y0y3
Dc3c4s3
Full
Adder
(e) At time t4s3 s2 s1 s0
y3y2y1y0
Dc4FIGURE 18-2
Operation of Serial
Adder
and c2, as seen in Figure 18-2(b). The second falling edge shifts s1into the accu-
mulator, stores c2in the carry flip-flop, and cycles the addend register right. Bits
x2and y2are now at the adder input, as seen in Figure 18-2(c), and the process
continues until all bit pairs have been added, as shown in Figure 18-2(e).
Table 18-1 shows a numerical example of the serial adder operation. Initially, the
accumulator contains 0101 and the addend register contains 0111. At t0, the full
adder computes 1 /H110011/H110010/H1100510, so si/H110050 and ci/H11001/H110051. After the first falling clock
XY CiSiCi/H11545
t0 0101 0111 0 0 1
t1 0010 1011 1 0 1
t2 0001 1101 1 1 1
t3 1000 1110 1 1 0
t4 1100 0111 0 (1) (0)TABLE 18-1
Operation of
Serial Adder
Circuits for Arithmetic Operations 597
edge (time tl) the first sum bit has been entered into the accumulator, the carry has
been stored in the carry flip-flop, and the addend has been cycled right. After fourfalling clock edges (time t
4), the sum of Xand Yis in the accumulator, and the
addend register is back to its original state.
The control circuit for the adder must now be designed so that after receiving a
start signal, the control circuit will put out four shift signals and then stop. Figure 18-3shows the state graph and table for the control circuit. The circuit remains in S
0until a
start signal is received, at which time the circuit outputs Sh/H110051 and goes to S1.Then, at
successive clock times, three more shift signals are put out. It will be assumed that thestart signal is terminated before the circuit returns to state S
0so that no further output
occurs until another start signal is received. Dashes appear on the graph because onceS
1is reached, the circuit operation continues regardless of the value of St. Starting with
the state table of Figure 18-3 and using a straight binary state assignment, the controlcircuit equations are derived in Figure 18-4.
A serial processing unit, such as a serial adder with an accumulator, processes data
one bit at a time. A typical serial processing unit (Figure 18-5) has two shift registers.The output bits from the shift register are inputs to a combinational circuit. Thecombinational circuit generates at least one output bit. This output bit is fed into theinput of a shift register.When the active clock edge occurs, this bit is stored in the firstbit of the shift register at the same time the register bits are shifted to the right.
The control for the serial processing unit generates a series of shift signals.When
the start signal ( St) is 1, the first shift signal ( Sh) is generated. If the shift registers
–/Sh
–/Sh –/ShSt/ShSt′/0
S1S0
S3
S2Next State Sh
St/H1100501 01
S0 S0 S1 01
S1 S2 S2 11
S2 S3 S3 11
S3 S0 S0 11FIGURE 18-3
State Graph for
Serial Adder
Control
A+
DA = A′B + AB′
= A ⊕ B0001
11
00100ABSt
01
1110 1
B+
DB = St B′ + AB′0101
00
00100ABSt
01
1110 1
Sh
Sh = St + A + B0101
11
11100ABSt
01
1110 1FIGURE 18-4
Derivation of
Control Circuit
EquationsA/H11001B/H11001
AB 01
S0 00 00 01
S1 01 10 10
S2 10 11 11
S3 11 00 00
have nbits, then a total of nshift signals must be generated. If Stis 1 for only one
clock time, then the control state graph [Figure 18-6(a)] stops when it returns tostate S
0. However, if Stcan remain 1 until after the shifting is completed, then a sep-
arate stop state is required, as shown in Figure 18-6(b). The control remains in thestop state until Streturns to 0.
18.2 Design of a Parallel Multiplier
Next, we will design a parallel multiplier for positive binary numbers. As illustrated
in the example in Section 1.3, binary multiplication requires only shifting and adding.The following example shows how each partial product is added in as soon as it is
formed.This eliminates the need for adding more than two binary numbers at a time.
Multiplicand 1101 (13)
Multiplier 1011 (11)
1101
1101
Partial 100111Products 0000
100111
1101
Product 10001111 (143)
The multiplication of two 4-bit numbers requires a 4-bit multiplicand register,
a 4-bit multiplier register, and an 8-bit register for the product. The product598 Unit 18
Sn–1S0
S2S1–/Sh
–/Sh –/Sh–/Sh
–/Sh–/ShSt/Sh St/ShSt′/0
(a)Sn–1StopS0
S2S1St′/0
St/0
St′/0
(b)FIGURE 18-6
State Graphs for
Serial Processing
Unit
⎯→
⎯→⎯→⎯→a≈
a≈≈a≈≈
¸˝˛Control StSh
Combinational
CircuitShift Register
Shift RegisterFIGURE 18-5
Typical Serial
Processing Unit
register serves as an accumulator to accumulate the sum of the partial products.
Instead of shifting the multiplicand left each time before it is added, as wasdone in the previous example, it is more convenient to shift the product registerto the right each time. Figure 18-7 shows a block diagram for such a parallel mul-tiplier. As indicated by the arrows on the diagram, 4 bits from the accumulatorand 4 bits from the multiplicand register are connected to the adder inputs; the4 sum bits and the carry output from the adder are connected back to theaccumulator. (The actual connections are similar to the parallel adder with accu-mulator shown in Figure 12-5.) The adder calculates the sum of its inputs, andwhen an add signal ( Ad) occurs, the adder outputs are stored in the accumulator
by the next rising clock edge, thus causing the multiplicand to be added to theaccumulator. An extra bit at the left end of the product register temporarilystores any carry ( C
4) which is generated when the multiplicand is added to the
accumulator.
Because the lower four bits of the product register are initially unused, we will
store the multiplier in this location instead of in a separate register. As each mul-tiplier bit is used, it is shifted out the right end of the register to make room foradditional product bits.
The Load signal loads the multiplier into the lower four bits of ACC and at the
same time clears the upper 5 bits. The shift signal ( Sh) causes the contents of the
product register (including the multiplier) to be shifted one place to the rightwhen the next rising clock edge occurs. The control circuit puts out the propersequence of add and shift signals after a start signal ( St/H110051) has been received. If
the current multiplier bit ( M) is 1, the multiplicand is added to the accumulator
followed by a right shift; if the multiplier bit is 0, the addition is skipped and onlythe right shift occurs. The multiplication example at the beginning of this section(13/H1100311) is reworked below showing the location of the bits in the registers at
each clock time.Circuits for Arithmetic Operations 599
ACCProduct
C
o
n
t
r
o
lLoad
Sh
Done
St
MAd876543210
Clk
4-Bit Adder
MultiplicandMultiplier
C4FIGURE 18-7
Block Diagram for
Parallel Binary
Multiplier
initial contents of product register 000001011 dM (11)
(add multiplicand because M/H110051 ) 1101 (13)
after addition 011011011
after shift 001101101 dM
(add multiplicand because M/H110051 ) 1101
after addition 100111101
after shift 010011110 dM
(skip addition because M/H110050)
after shift 001001111 dM
(add multiplicand because M/H110051 ) 1101
after addition 100011111
after shift (final answer) 010001111 (143)
dividing line between product and multiplier
The control circuit must be designed to output the proper sequence of add and shift
signals. Figure 18-8 shows a state graph for the control circuit. The notation used onthis graph is defined in Section 14.5. M/Admeans if M/H110051, then the output Adis 1
(and the other outputs are 0). M/H11032/Shmeans if M/H11032/H110051 (M/H110050), then the output Shis
1 (and the other outputs are 0). In Figure 18-8, S
0is the reset state, and the circuit stays
inS0until a start signal ( St/H110051) is received. This generates a Load signal, which caus-
es the multiplier to be loaded into the lower 4 bits of the accumulator (ACC) and theupper 5 bits of ACC to be cleared on the next rising clock edge. In state S
1, the low
order bit of the multiplier ( M) is tested. If M/H110051, an add signal is generated and, then,
a shift signal is generated in S2. If M/H110050 in S1, a shift signal is generated because
adding 0 can be omitted. Similarly, in states S3,S5, and S7,Mis tested to determine
whether to generate an add signal followed by shift or just a shift signal. A shift signalis always generated at the next clock time following an add signal (states S
2,S4,S6, and
S8).After four shifts have been generated, all four multiplier bits have been processed,
and the control circuit goes to a Done state and terminates the multiplication process.600 Unit 18
⎯⎯⎯⎯→
S5 S4S3S2S1S0 S9
S8
S7
S6–/Sh–/Done
–/Sh
–/Sh–/ShM/AdM′/Sh
M′/Sh
M′/ShM′/Sh
M/Ad M/AdM/AdSt/LoadSt′/0 FIGURE 18-8
State Graph for
Multiplier Control
As the state graph indicates, the control performs two functions—generating
add or shift signals as needed and counting the number of shifts. If the number ofbits is large, it is convenient to divide the control circuit into a counter and an add-shift control, as shown in Figure 18-9(a). First, we will derive a state graph for theadd-shift control which tests MandStand outputs the proper sequence of add and
shift signals (Figure 18-9(b)). Then, we will add a completion signal ( K) from the
counter which stops the multiplier after the proper number of shifts have beencompleted. Starting in S
0in Figure 18-9(b), when a start signal ( St/H110051) is received,
a Load signal is generated. In state S1, if M/H110050, a shift signal is generated and the
circuit stays in S1. If M/H110051, an add signal is generated and the circuit goes to state
S2. In S2a shift signal is generated because a shift always follows an add. Back in
S1, the next multiplier bit ( M) is tested to determine whether to shift, or add and
then shift. The graph of Figure 18-9(b) will generate the proper sequence of addand shift signals, but it has no provision for stopping the multiplier.
In order to determine when the multiplication is completed, the counter is incre-
mented on the active clock edge each time a shift signal is generated. If the multipli-er is nbits, a total of nshifts are required. We will design the counter so that a
completion signal ( K) is generated after n– 1 shifts have occurred. When K/H110051, the
circuit should perform one more addition if necessary and then do the final shift.Thecontrol operation in Figure 18-9(c) is the same as Figure 18-9(b) as long as K/H110050.
In state S
1, if K/H110051, we test Mas usual. If M/H110050, we output the final shift signal
and stop; however, if M/H110051, we add before shifting and go to state S2. In state S2,i f
K/H110051, we output one more shift signal and then go to S3. The last shift signal will
reset the counter to 0 at the same time the add-shift control goes to the Done state.
As an example, consider the multiplier of Figure 18-7, but replace the control circuit
with Figure 18-9(a). Because n/H110054, a 2-bit counter is needed, and K/H110051 when the
counter is in state 3 (112). Table 18-2 shows the operation of the multiplier when 1101
is multiplied by 1011. S0,S1, and S2represent states of the control circuit [Figure 18-9(c)].
The contents of the product register at each step is the same as given on p. 600.
At time t0the control is reset and waiting for a start signal. At time tl, the start
signal St/H110051, and a Load signal is generated.At time t2,M/H110051, so an Adsignal is gen-
erated. When the next clock occurs, the output of the adder is loaded into the accu-mulator and the control goes to S
2.A t  t3, an Shsignal is generated, so, shifting occurs
and the counter is incremented at the next clock. At t4,M/H110051, so Ad/H110051, and theCircuits for Arithmetic Operations 601
Counter
(a) Multiplier control (b) State graph for
add-shift control–/ShSt
M
KM/AdAdd-Shift
ControlDone
ClkLoad
Ad
ShS0 S1
S2St′/0 M′/Sh
St/Load
(c) Final state graph for
add-shift controlK′/Sh
K/ShM/AdKM′/ShS0 S1
S2St′/0 K′M′/Sh
St/Load
–/Done
S3FIGURE 18-9
adder output is loaded into the accumulator at the next clock.At t5andt6, shifting and
counting occurs. At t7, three shifts have occurred and the counter state is 11, so K/H110051.
Because M/H110051, addition occurs, and the control goes to S2.At t8,Sh/H11005K/H110051, so at the
next clock the final shift occurs, and the counter is incremented back to state 00. At t9,
a Done signal is generated.
The multiplier design given here can easily be expanded to 8, 16, or more bits
simply by increasing the register size and the number of bits in the counter.The add-shift control would remain unchanged.
18.3 Design of a Binary Divider
We will consider the design of a parallel divider for positive binary numbers. As anexample, we will design a circuit to divide an 8-bit dividend by a 4-bit divisor toobtain a 4-bit quotient. The following example illustrates the division process:
1010 quotient
divisor 1101 10000111 dividend
1101
01110000
11111101
010100000101 remainder
Just as binary multiplication can be carried out as a series of add and shift
operations, division can be carried out by a series of subtraction and shift opera-tions. To construct the divider, we will use a 9-bit dividend register and a 4-bitdivisor register, as shown in Figure 18-10. During the division process, instead of602 Unit 18
Product
Time State Counter Register St M K Load Ad Sh Done
t0 S0 00 000000000 0 0 0 0 0 0 0
t1 S0 00 000000000 1 0 0 1 0 0 0
t2 S1 00 000001011 0 1 0 0 1 0 0
t3 S2 00 011011011 0 1 0 0 0 1 0
t4 S1 01 001101101 0 1 0 0 1 0 0
t5 S2 01 100111101 0 1 0 0 0 1 0
t6 S1 10 010011110 0 0 0 0 0 1 0
t7 S1 11 001001111 0 1 1 0 1 0 0
t8 S2 11 100011111 0 1 1 0 0 1 0
t9 S3 00 010001111 0 1 0 0 0 0 1TABLE 18-2
Operation of a
Multiplier Using
a Counter
(135 /H1100413/H1100510 with
a remainder of 5)
shifting the divisor to the right before each subtraction as shown in the preced-
ing example, we will shift the dividend to the left. Note that an extra bit isrequired on the left end of the dividend register so that a bit is not lost when the
dividend is shifted left. Instead of using a separate register to store the quotient,we will enter the quotient bit-by-bit into the right end of the dividend register asthe dividend is shifted left. Circuits for initially loading the dividend into the reg-ister will be added later.
The preceding division example (135 divided by 13) is now reworked, showing
the location of the bits in the registers at each clock time. Initially, the dividend anddivisor are entered as follows:
Subtraction cannot be carried out without a negative result, so we will shift before
we subtract. Instead of shifting the divisor one place to the right, we will shift thedividend one place to the left:
10000111 0Dividing line between dividend and quotient
1101 Note that after the shift, the rightmost position
in the dividend register is “empty”.
Subtraction is now carried out, and the first quotient digit of 1 is stored in the
unused position of the dividend register:
00011111 1  first quotient digit
Next, we shift the dividend one place to the left:
001111110
110101000
11010111Circuits for Arithmetic Operations 603
Sh
Ld X8 X7 X6 X5 X4
Y3 Y2 Y1 Y0CSuSh
St (Start Signal)
V
(Overflow
Indicator)X3 X2 X1 X0
Subtractor
and
ComparatorDividend Register
Control
Clock0FIGURE 18-10
Block Diagram for
Parallel Binary
Divider
Because subtraction would yield a negative result, we shift the dividend to the left
again, and the second quotient bit remains 0:
011111 100
1101
Subtraction is now carried out, and the third quotient digit of 1 is stored in the
unused position of the dividend register:
000101101  third quotient digit
A final shift is carried out and the fourth quotient bit is set to 0:
00101 1010
remainder quotient
The final result agrees with that obtained in the first example. Note that in the first
step the leftmost 1 in the dividend is shifted left into the leftmost position ( X8) in
theXregister. If we did not have a place for this bit, the division operation would
have failed at this step because 0000 /H110211101. However, by keeping the leftmost bit
inX8, 10000 /H113501101, and subtraction can occur.
If as a result of a division operation, the quotient would contain more bits than
are available for storing the quotient, we say that an overflow has occurred. Forthe divider of Figure 18-10 an overflow would occur if the quotient is greater than15, because only 4 bits are provided to store the quotient. It is not actually neces-sary to carry out the division to determine if an overflow condition exists, becausean initial comparison of the dividend and divisor will tell if the quotient will be toolarge. For example, if we attempt to divide 135 by 7, the initial contents of the reg-isters would be:
010000111
0111
Because subtraction can be carried out with a nonnegative result, we should sub-
tract the divisor from the dividend and enter a quotient bit of 1 in the rightmostplace in the dividend register. However, we cannot do this because the rightmostplace contains the least significant bit of the dividend, and entering a quotient bithere would destroy that dividend bit. Therefore, the quotient would be too large tostore in the 4 bits we have allocated for it, and we have detected an overflow con-dition. In general, for Figure 18-10, if initially X
8X7X6X5X4/H11350Y3Y2YlY0(i.e., if the
left five bits of the dividend register exceed or equal the divisor), the quotient willbe greater than 15 and an overflow occurs. Note that if X
8X7X6X5X4/H11350Y3Y2YlY0,
the quotient is
The operation of the divider can be explained in terms of the block diagram of
Figure 18-10. A shift signal ( Sh) will shift the dividend one place to the left on the
next rising clock edge. Because the subtracter is a combinational circuit, it computesX8X7X6X5X4X3X2X1X0
Y3Y2Y1Y0/H11350X8X7X6X5X4 0000
Y3Y2Y1Y0/H11005X8X7X6X5X4/H1100316
Y3Y2Y1Y0/H11350 16604 Unit 18
¯˚˘˚˙ ¯ ˚˘˚˙
X8X7X6X5X4/H11002Y3Y2Y1Y0, and this difference appears at the subtracter output after
a propagation delay. A subtract signal ( Su) will load the subtracter output into
X8X7X6X5X4and set the quotient bit (the rightmost bit in the dividend register) to 1
on the next rising clock edge.To accomplish this, Suis connected to both the Ldinput
on the shift register and the data input on flip-flop X0. If the divisor is greater than
the five leftmost dividend bits, the comparator output is C/H110050; otherwise, C/H110051. The
control circuit generates the required sequence of shift and subtract signals.Whenever C/H110050, subtraction cannot occur without a negative result, so a shift signal
is generated. Whenever C/H110051, a subtract signal is generated, and the quotient bit is
set to one.
Figure 18-11 shows the state diagram for the control circuit. When a start signal
(St) occurs, the 8-bit dividend and 4-bit divisor are loaded into the appropriate reg-
isters. If Cis 1, the quotient would require five or more bits. Because space is only
provided for a 4-bit quotient, this condition constitutes an overflow, so the divideris stopped, and the overflow indicator is set by the Voutput. Normally, the initial
value of Cis 0, so a shift will occur first, and the control circuit will go to state S
2.
Then, if C/H110051, subtraction occurs. After the subtraction is completed, Cwill always
be 0, so the next active clock edge will produce a shift. This process continues untilfour shifts have occurred, and the control is in state S
5. Then, a final subtraction
occurs if C/H110051, and no subtraction occurs if C/H110050. No further shifting is required,
and the control goes to the stop state. For this example, we will assume that whenthe start signal ( St) occurs, it will be 1 for one clock time, and, then, it will remain
0 until the control circuit is back in state S
0. Therefore, Stwill always be 0 in states
Slthrough S5.
We will now design the control circuit using a one-hot assignment (see
Section 15.9) to implement the state graph. One flip-flop is used for each state withQ
0/H110051 in S0,Q1/H110051 in S1,Q2/H110051 in S2, etc. By inspection, the next-state and output
equations are
Q0/H11001/H11005St/H11032Q0/H11001CQ1/H11001Q5 Q1/H11001/H11005StQ0 (18-1)
Q2/H11001/H11005C/H11032Q1/H11001CQ2 Q3/H11001/H11005C/H11032Q2/H11001CQ3
Q4/H11001/H11005C/H11032Q3/H11001CQ4 Q5/H11001/H11005C/H11032Q4
Load /H11005St Q0 V/H11005CQ1
Sh/H11005C/H11032(Q1/H11001Q2/H11001Q3/H11001Q4)/H11005C/H11032(Q0/H11001Q5)/H11032
Su/H11005C(Q2/H11001Q3/H11001Q4/H11001Q5)/H11005C(Q0/H11001Q1)/H11032Circuits for Arithmetic Operations 605
S5S0
(stop)S1 S2
S4 S3St′/0St/Load
C/V
C/Su
C′/0
C′/Sh
C/SuC′/ShC′/ShC′/Sh
C/SuC/SuFIGURE 18-11
State Graph for
Divider Control
Circuit
Because there are three arrows leading into S0,Q0/H11001has three terms.The equation for
Shhas been simplified by noting that if the circuit is in state S1orS2orS3orS4, it is
not in state S0orS5.
The subtracter in Figure 18-10 can be constructed using five full subtracters, as
shown in Figure 18-12. Because the subtracter is a combinational circuit, wheneverthe numbers in the divisor and dividend registers change, these changes will propa-gate to the subtracter outputs. The borrow signal will propagate through the fullsubtracters before the subtracter output is transferred to the dividend register. If thelast borrow signal ( b
9) is 1, this means that the result is negative. Hence, if b9is 1, the
divisor ( Y3Y2Y1Y0) is greater than X8X7X6X5X4, and C/H110050. Therefore, C/H11005b9/H11032, and
a separate comparator circuit is unnecessary. Under normal operating conditions(no overflow) for this divider, we can also show that C/H11005d
8/H11032.At any subtraction step,
because the divisor is only four bits, d8/H110051 would allow a second subtraction with-
out shifting. However, this can never occur because the quotient digit cannot begreater than 1. Therefore, if subtraction is possible, d
8will always be 0 after the sub-
traction, so d8/H110050 implies X8X7X6X5X4is greater than Y3Y2Y1Y0and C/H11005d8/H11032.
The block diagram of Figure 18-10 does not show how the dividend is initially
loaded into the Xregister.This can be accomplished by adding a MUX at the Xreg-
ister inputs, as shown in Figure 18-13. This diagram uses bus notation to avoid draw-ing multiple wires. When several busses are merged together to form a single bus, abus merger is used. For example, the symbol
means that the 5-bit subtracter output is merged with bits X
3X2X1and a logic 1 to
form a 9-bit bus. Thus, the MUX output will be d8d7d6d5d4X3X2X11 when Load /H110050.
Similarly, the symbol 
953X0X (3:1)
X (8:4)5
319606 Unit 18
Full
Subtracterd8
b9b8 b7 b6 b5b4 = 0
X8 0Full
Subtracterd7
X7 Y3Full
Subtracterd6
X6 Y2Full
Subtracterd5
X5 Y1Full
Subtracterd4
X4 Y0FIGURE 18-12
Logic Diagram for
5-Bit Subtracter
represents a bus splitter that splits the 9 bits from the Xregister into X8X7X6X5X4
and X3X2X1;X0is not used. Bus mergers and splitters do not require any actual
hardware; they are just a symbolic way of showing bus connections.
The Xregister is a left-shift register with parallel load capability, similar to the
register in Figure 12-10. On the rising clock edge, it is loaded when Ld /H110051
and shifted left when Sh/H110051. Because the register must be loaded with the divi-
dend when Load /H110051 and with the subtracter output when Su/H110051, Load and
Suare ORed together and connected to the Ld input. The MUX selects the
dividend (preceded by a 0) when Load /H110051. When Load /H110050, it selects the bus
merger output which consists of the subtracter output, X3X2X1, and a logic 1.
When Su/H110051 and the clock rises, this MUX output is loaded into X. The net
result is that X8X7X6X5X4gets the subtracter output, X3X2X1is unchanged, and
X0is set to 1.
Programmed Exercise 18.1
Cover the lower part of each page with a sheet of paper and slide it down as youcheck your answers. Write your answer in the space provided before looking at thecorrect answers.Circuits for Arithmetic Operations 607
X (8:0)
1 09-Wide
2-to-1 MUXLd
Sh
Clock0
99
9
8
Dividend (7:0)9
5 1
0Load
LoadSu
Sh
5-bit
Subtracter0
5
43
X (3:1)X (8:4)
Y (3:0)
(Divisor)X0Bus
Merger
Bus
Splitter
9FIGURE 18-13
Block Diagram for
Divider Using Bus
Notation
This exercise concerns the design of a circuit which forms the 2’s complement of
a 16-bit binary number. The circuit consists of three main components—a 16-bitshift register which initially holds the number to be complemented, a control circuit,and a counter which counts the number of shifts. The control circuit processes thenumber in the shift register one bit at a time and stores the 2’s complement back inthe shift register. Draw a block diagram of the circuit. Show the necessary inputsand outputs for the control circuit including a start signal ( N) which is used to initi-
ate the 2’s complement operation.
Answer
State a rule for forming the 2’s complement which is appropriate for use with thepreceding block diagram.
Answer Starting with the least significant bit, complement all of the bits to the left of the
first 1.
Draw a state graph for the control circuit (three states) which implements the pre-
ceding rule. The 2’s complement operation should be initiated when N/H110051. (Assume
that Nwill be 1 for only one clock time.) When drawing your graph, do not include
any provision for stopping the circuit. (In the next step you will be asked to add thesignal Kto your state graph so that the circuit will stop after 16 shifts.) Explain the
meaning of each state in your graph.SI
CKCK
N
ShControl
Circuit ShXZ
K
CounterCK608 Unit 18
Answer
The counter will generate a completion signal ( K) when it reaches state 15. Modify
your state graph so that when K/H110051, the circuit will complete the 2’s complement oper-
ation and return to the initial state. Also, add the Shoutput in the appropriate places.
Answer Check the input labels on all arrows leaving each state of your graph. Make sure that
two of the labels on arrows leaving a given state cannot have the value 1 at the same
time. Make any necessary corrections to your graph, and then check your final answer.
Final Answer
(Note: Sh should be added to the graph everywhere ZorZ/H11032appears.)S2 S1S0N′/0
K′X/Z′
K′X′/ZK′X′/Z′
K′X/Z     KX /Z
KX′/Z′X′N/Z′XN/Z
XK/Z′
     X ′K/ZS0   Reset
S1   No 1 received, do
       not complement X
S2   A 1 has been received ,
       complement XN′/0
X′/Z
X/Z′X′/Z′
X/ZXN/ZX′N/Z′S0
S2 S1Circuits for Arithmetic Operations 609
Programmed Exercise 18.2
This exercise concerns the design of a binary divider to divide a 6-bit number by a 3-bit
number to find a 3-bit quotient. The right 3 bits of the dividend register should be usedto store the quotient. Draw a block diagram for the divider. Omit the signals requiredto initially load the dividend register and assume the dividend is already loaded.
Answer
If the contents of the dividend register is initially 0100010 and the divisor is 110,show the contents of the dividend register after each of the first three rising clockedges. Also, indicate whether a shift or a subtraction should occur next.
0 1 0 0 0 1 0 shif tSh
Ld X6 X5 X4 X3 X2
Y2 Y1 Y0CSuSh
St (Start Signal)
V
(Overflow
Indicator)X1 X0
Subtracter
and
ComparatorDividend Register
Control
Clock0610 Unit 18
Answer 0 1 0 0 0 1 0 shift
1 0 0 0 1 0 0 subtract0 0 1 0 1 0 1 shift
0 1 0 1 0 1 0 shift
Now, show the remaining steps in the computation and check your answer by con-
verting to decimal.
Answer 1 0 1 0 1 0 0 subtract
0 1 0 0 1 0 1 (finished)
If the dividend register initially contained 0011001 and the divisor is 010, can divi-
sion take place? Explain.
Answer No. Because 011 /H11022010, subtraction should occur first, but there is no place to
store the quotient bit. In other words, the quotient would be greater than three
bits, so an overflow would occur.
Draw a state graph for the divider which will produce the necessary sequence of Su
andShsignals. Assume that the comparator output is C/H110051 if the upper four bits of
the dividend register is greater than the divisor. Include a stop state in your graphwhich is different than the reset state. Assume that the start signal ( St) will remain 1
until the division is completed. The circuit should go to the stop state when division iscomplete or when an overflow is detected. The circuit should then reset when St/H110050.Circuits for Arithmetic Operations 611
Answer
Problems
18.3 Design a serial subtracter with accumulator for 5-bit binary numbers. Assume that
negative numbers are represented by 2’s complement. Use a circuit of the form ofFigure 18-1, except implement a serial subtracter using a D-CE flip-flop and anykind of gates. Give the state graph for the control circuit.Assume that Stwill remain
1 until the subtraction is complete, and the circuit will not reset until Streturns to 0.
18.4 Design a parallel binary multiplier which multiplies two 3-bit binary numbers to
form a 6-bit product. This multiplier is to be a combinational circuit consisting of anarray of full adders and AND gates (no flip-flops). Demonstrate that your circuitworks by showing all of the signals which are present when 111 is multiplied by 111.(Hint : The AND gates can be used to multiply by 0 or 1, and the full adders can be
used to add 2 bits plus a carry. Six full adders are required.)
18.5 The binary multiplier of Figure 18-7 has been redesigned so that whenever addition
occurs the multiplier bit ( M) will be set to 0. Specifically, the Adsignal is now connect-
ed to a synchronous clear input on only the rightmost flip-flop of the product registerBinar y Multiplier
to Be Designedx3x2x1 y3y2y1
Z6Z5Z4Z3Z2Z1S3S4
(stop)S1S0
(reset)
S2St/0St′/0
StC/V
C/Su
C/SuStC′/Sh
St′/0
C/Su
C′/0
C′/ShC′/Sh612 Unit 18
of Figure 18-7. Thus, if Mis 1 at a given clock time and addition takes place, Mwill be
0 at the next clock time. Now, we can always add when M/H110051 and always shift when
M/H110050. This means that the control circuit does not have to change state when M/H110051,
and the number of states can be reduced from ten to six. Draw the resulting state graphfor the multiplier control with six states.
18.6 In order to allow for a larger number of bits, the control circuit of the binary divider
(Figure 18-10) is to be redesigned so that it uses a separate counter and a subtract-shift control which is analogous to Figure 18-9(a). Draw the state graph for thesubtract-shift control.
18.7 Below is the block diagram of a divider which will divide a 5-bit binary number
X
4X3X2X1X0by a 5-bit binary number Y4Y3Y2Y1Y0. Initially, the 5-bit dividend is loaded
into bits X4through X0, and 0’s are loaded into bits X9through X5. Because of its design,
overflow will only occur if the divisor is 0. This divider operates similarly to the onegiven in Figures 18-10 and 18-11, except for the starting placement of the dividend.Circuits for Arithmetic Operations 613
Sh
Ld X8 X7 X9 X6 X5 X4
Y3 Y2 Y4 Y1 Y0C
VSuSh
StX3 X2 X1 X0
Subtracter
and
Comparator
Control
ClockOverflow
Indicator
(a) Give the equation for the overflow signal V, generated by the overflow indicator.
(b) Illustrate the operation of the divider when 26 is divided by 5. Specify the
sequence of Suand Shoutputs and the contents of the dividend register, and
specify the quotient and the remainder.
(c) Draw the state graph for the control circuit. If there is an overflow, the circuit
should remain in the starting state. Otherwise, when St/H110051, the circuit should
begin operation. Assume that Stwill be 1 for only one clock cycle.
(d) In Figure 18-10, the subtracter-comparator and the dividend register have one
more bit on the left than the divisor register. Why is that not necessary here?
18.8 A serial logic unit has two 8-bit shift registers, Xand Y, shown as follows. Inputs
K1and K2determine the operation to be performed on Xand Y. When St/H110051,X
and Yare shifted into the logic circuit one bit at a time and replaced with new val-
ues. If K1K2/H1100500,Xis complemented and Yis unchanged. If K1K2/H1100501,Xand Y
are interchanged. If K1K2/H1100510,Yis set to 0 and each bit of Xis replaced with the
exclusive-OR of the corresponding bits of Xand Y, that is, the new xiisxi⊕yi.I f
K1K2/H1100511,Xis unchanged and Yis set to all 1’s.
(a) Derive logic equations for xinand yin.
(b) Derive a state graph for the control circuit.Assume that once Stis set to 1 it will
remain 1 until all 8 bits have been processed. Then, Stwill be changed back to
0 some time before the start of the next computation cycle.
(c) Realize the logic circuit using two 4-to-1 multiplexers and a minimum number
of added gates.
18.9 A circuit for adding one to the contents of a shift register has the following form:
The adder circuit has an internal flip-flop that can be used to store a carry from the
adder operation.The control unit has a counter available to determine when the addoperation is complete. The counter input Lenables a parallel load of the counter
with the length of the shift register. The counter input Dec causes the counter to
decrement. The counter output Zbecomes 1 when the counter value is zero. When
Stbecomes 1, the control unit generates Shand Cthe required number of times to
cause 1 to be added to the shift register contents.The control unit also generates thesignals Land Dec to control the counter.
Design the adder and the control unit, using D flip-flops and NOR gates.ClockSI
ShAdder   Shift
RegisterX Y
L
DecCounterZSt
Z ControlSh StSh
CCSIK1xin yin
K2Logic
CircuitShXa
Control
ClockStSI
ShYb
Sh614 Unit 18
18.10 Repeat Problem 18.9 so that 2 is added to the shift register contents rather than 1.
18.11 Repeat Problem 18.9 so that 3 is added to the shift register contents rather than 1.
18.12 A sequential circuit receives decimal numbers encoded in BCD one digit (4 bits)
at a time, starting with the least significant digit. The circuit outputs are the 10’scomplement of the input number, also encoded in BCD least significant digitfirst. Input decimal numbers are separated by one or more inputs of all 1’s, dur-ing which the circuit outputs all 1’s. Once valid BCD digits of a new number start,the circuit resumes computing and outputting the 10’s complement of the newnumber.(a) Construct a state table and output table for the circuit. (Two states are sufficient.)(b) Realize the circuit using a minimum number of flip-flops.
18.13 Repeat Problem 18.12 assuming the decimal digits are encoded in excess-3 and the
separator between decimal numbers is all 0’s, which produces all 0’s on the outputs.
18.14 A circuit that adds one to the contents of a shift register has the following form:
The control circuit outputs I, which should set the ONE ADDER to the proper ini-
tial state, and then outputs Shto the shift register the required number of times.
Design the box labeled “ONE ADDER” using NOR gates and a D flip-flop withpreset and clear inputs.
EXAMPLE:
Contents of shift register before: 000001011Contents of shift register after Iand 9 Shoutputs: 000001100
18.15 (a) Draw a block diagram for a parallel multiplier that can multiply two binary
numbers, where the multiplier is 3 bits and the multiplicand is 4 bits. Use an 8-bit shift register along with other necessary blocks.
(b) Draw a state graph for the multiplier control.(c) Illustrate the operation of the multiplier when 11 is multiplied by 5. Specify the
sequence of add and shift outputs generated by the control circuit and specifythe contents of the 8-bit register at each clock time.
(d) Draw the logic diagram for the multiplier using an 8-bit shift register of
the form of Figure 12-10, a 4-bit adder, three J-K flip-flops, and any neces-sary gates.SI
ClockOne
Adder ShXZ
Sh
ControlI
St
ClockCircuits for Arithmetic Operations 615
18.16 Work Problem 18.15 if the multiplier is 3 bits and the multiplicand is 5 bits, and show
20 multiplied by 6. Use a 9-bit shift register similar to Figure 12-10, five full adders,three D flip-flops, and a PLA for Part (d). Show the PLA table.
18.17 The block diagram for a parallel multiplier for positive binary numbers follows. The
counter counts the number of shifts and outputs a signal K/H110051 after two shifts.
(a) Draw the state graph for the control circuit. Assume that Stis 1 for one clock
period to start the multiplier.
(b) Complete the following table showing the operation of the circuit if the multi-
plicand is 11001 and the multiplier is 111:
State Counter XS t M K A d S h
S0 00 000000111 1 1 0
18.18 Design a binary divider which divides a 7-bit dividend by a 2-bit divisor to give a 5-
bit quotient. The system has an input Stthat starts the division process.
(a) Draw a block diagram for the subtracter-comparator. You may use full adders
or full subtracters.
(b) Draw a block diagram for the rest of the system (do not show the adders or sub-
tracters in the subtracter-comparator block).
(c) Draw the state graph for the control circuit. Assume that the start signal ( St) is
present for one clock period.
(d) Give the contents of the dividend register and the value of Cat each time step
if initially the dividend is 01010011 and the divisor is 11.
18.19 (a) Draw a block diagram for a parallel divider that is capable of dividing a positive
6-bit binary number by a positive 4-bit binary number to give a 2-bit quotient.Use a dividend register, a divisor register, a subtracter-comparator block, and acontrol block.KAdM
St
ShAdderX Register
LdShSI
Clock0
Cloc kAdd-Shift
Control
Counter616 Unit 18
(b) Draw a state graph for the control circuit. Assume that the start signal St
remains 1 for one or more clock times after the division is complete, and Stmust
be set to 0 to reset the circuit.
(c) Show how the subtracter-comparator could be realized using full adders and
inverters.
(d) Show the contents of the registers and the value of Cafter each time step if ini-
tially the dividend is 101101 and the divisor is 1101.
18.20 Design a controller for an odd-parity generator. The circuit should transmit 7 bits
from a shift register onto the output X.Then, on the next clock cycle, the eighth value
ofXshould be chosen to make the number of 1’s be odd. In other words, the last
value of Xshould be 1 if there was an even number of 1’s in the shift register, so that
the 8-bit output word will have odd parity. (Parity was discussed in Section 13.1.) Thecircuit is shown. Kwill be 1 when the counter reaches 111.
(a) Give the state graph for the control circuit. Assume St/H110051 for one clock cycle
(three states).
(b) Implement the controller using D flip-flops and any necessary gates. Use a one-
hot state assignment.
18.21 Design a serial logic unit to multiply a 6-bit number Xby/H110021. Assume negative num-
bers are represented by their 2’s complements. Recall that one way to find the 2’scomplement is to invert all of the bits to the left of the rightmost 1. If the number is/H1100232/H11005100000, there is no 6-bit 2’s complement representation of /H1100132, so an error
signal Ershould be generated.
(a) Give a block diagram for the circuit, using a control block, a 6-bit right-shift reg-
ister, and a 3-bit counter.The controller has inputs St,K, and S
O, and outputs Er,
Clr,Sh, and SI. The shift register is like the register of Figure 12-7, but it has 6
bits. The counter has a Clrinput and an output Kwhich is 1 when the counter
reaches 6. Assume the shift register contains Xat the beginning of the opera-
tion. The shift register should contain /H11002Xwhen the operation is complete.
(b) Give the state graph for the control circuit. Be sure the circuit will work prop-
erly when taking the 2’s complement of 0. (0 /H11003/H11002 1/H110050.)
(c) Implement the controller using a one-hot state assignment and D flip-flops.ControlB
K
X R
ShSt
CounterShSI
Clock
Clock
Cloc k0
K
ClrCircuits for Arithmetic Operations 617
18.22 A serial Boolean logic unit has two 16-bit shift registers, AandB. A control signal ( C)
is used to select the Boolean operation to be performed. If C/H110050, the contents of Aare
serially replaced by the bit-by-bit Boolean AND of AandB. If C/H110051, the contents of
Aare serially replaced by the bit-by-bit exclusive-OR of AandB. After the numbers
have been placed in AandB, and Cis set to 0 or 1, a start signal ( St) sets the circuit in
operation. A counter is used to count the number of shifts. When the counter reachesstate 15, it outputs a signal K/H110051, which causes the control circuit to stop after one
more shift.Assume that Stremains 1 and Cdoes not change until the operation is com-
pleted. The control then remains in the stop state until Stis changed back to 0.
(a) Draw a block diagram of the system, which includes the shift registers, the
counter, the control circuit, and a logic circuit that generates the serial input(SI) to the Aregister.
(b) Draw a state graph for the control circuit (three states).(c) Design the control circuit using a PLA and D flip-flops.(d) Design a logic circuit that generates SI.
18.23 Repeat 18.22, but assume that St/H110051 for only one clock cycle, and that Cmay change
during the operation of the circuit. Therefore, the circuit should operate according towhat the value of Cwas when St/H110051. Use a one-hot state assignment for (c). [ Hint :
Cshould be an input to the control circuit, and you will need another output of the
control circuit to take the place of Cin the logic circuit of Part (d) of 18.22.]
18.24 A serial logic unit consists of a 4-bit shift register Xand a control unit. The control
unit has a start input ( St), a shift output ( Sh), and an output Mwhich is the serial
input to the shift register. In addition, signals C
1and C2are used to select the logic
operation performed on the shift register. When St/H110051, then
IfC1C2/H1100500, the contents of register Xis serially replaced by all 0’s.
IfC1C2/H1100501, the contents of register Xis serially replaced by all 1’s.
IfC1C2/H1100511, the contents of register Xis serially replaced by its bit-by-bit comple-
ment. Assume that C1C2does not change until the selected operation is complete.
(a) Draw a block diagram for the system.(b) Specify the state graph for the control unit. Assume that Ststays 1 for one clock
period.
(c) Design the control unit (not the shift register) using J-K flip-flops and any kind
of gates. Also, design the logic inside the control unit which generates the serialinput Mto the shift register. [ Hint: M depends only on C
1,C2, and X.]
18.25 Design a circuit which sets a specified number of bits on the right side of a shift reg-
ister to 0. The number of bits to be set to 0 is in register Nbefore the start of the
operation. When St/H110051, the controller should shift right Ntimes, and then shift left
Ntimes. The counter only counts down, and K/H110051 when the counter reaches 000.
(a) Give the circuit. Use a control block, a 3-bit Nregister, a 3-bit down counter
with load input ( Ld) and Koutput (which is 1 when the counter reaches 000),
and an 8-bit right/left shift register which functions according to the table inProblem 12.3 (except that it has 8 bits). Note that the counter does not count618 Unit 18
up, so you will have to load Ninto the counter twice. The controller has inputs
Stand K, and outputs A,B, and Ld.
(b) Give the state graph for the control circuit. Assume St/H110051 for one clock period.
(c) Implement the controller using two D flip-flops. Use a straight binary assignment.
18.26 Design a controller for the circuit of Problem 12.35 that will add three numbers.
Assume each number (including the first one) appears on the 8-bit input data line fortwo consecutive clock cycles.You may notassume that the registers begin with a value
of 0.When St/H110051, the first input appears on the input data line for that clock cycle and
the next one. The circuit should halt when the answer goes into the accumulator, andoutput a signal Done /H110051. Done should remain 1 until Streturns to 0.You may assume
St/H110051 for enough time for the operation to complete. Give the block diagram and the
state graph (seven states), but you do not need to implement the state graph.
18.27 The given multiplier uses only counters to multiply a 4-bit multiplicand by a 4-bit
multiplier to obtain an 8-bit product. This Ultra-Slow Multiplier is based on theprinciple that multiplication is repeated addition and that addition is repeatedincrementing. The multiplier works as follows: When the Stsignal is received, the
8-bit up counter is cleared, N
1is loaded into 4-bit counter A, and N2is loaded into
4-bit counter B. Then, the controller decrements Aand increments the up count-
er until Areaches zero.When Areaches zero, Bis decremented and Ais reloaded
with N1. Then, the process is repeated until Breaches zero. When Breaches zero,
the 8-bit up counter contains the product.(a) Draw the state graph for the controller. Assume St/H110051 for only one clock period.
(b) Realize the state graph using one or two J-K flip-flops and a minimum number
of gates.
(c) If the multiplier is N
1and the multiplicand is N2, how many clock periods does
it take for the Ultra-Slow Multiplier to calculate the product?
18.28 The following circuit is a multiplier circuit for 4-bit positive numbers. Multiplication is
performed by adding the multiplicand to a partial product while decrementing themultiplier. This is continued until the multiplier is decremented to zero. (If the8-Bit Up CounterCLR
LD1
CT1
LD2
CT2
ZER2
ZER1Product
ClearControl
St
DoneCount
Load
4Count
Zero Zero
Ultra-Slow Multiplier4-Bit Down
Counter AMultiplicand
Load
Count4-Bit Down
Counter BMultiplier
N14
N2Circuits for Arithmetic Operations 619
multiplier is initially zero, no additions are done.) When the start input ( S) changes to
1, the multiplicand and multiplier are available; the multiplier circuit loads them intoA Reg and B Counter, respectively. The partial product register, implemented in twoparts (PU and PL), is cleared, as is the carry-out FF for the adder (C FF). To avoidhaving an adder twice as long as the operands, the addition of the multiplicand to thepartial product is done in two steps: First, the multiplicand is added to the lower halfof the partial product; second, the carry from the first addition is added to the upperhalf of the partial product. The multiplier in the B counter is decremented for eachaddition, and the additions continue until the multiplier has been decremented tozero. Then the done signal (D) is generated, with the product available in the partialproduct register; D remains asserted and the product available until S returns to 0.
The control signals that the controller must generate are
LB Load B Counter
DB Decrement B CounterCP Clear PU and PLLPU Load PULPL Load PLLA Load A RegMS MUX Select SignalEA Signal ANDed with A Reg outputCC Clear C FFD Done
The input signals to the controller are start, S, and BZ; BZ /H110050 when the B counter
is zero.(a) Determine the contents of the partial product register for each addition step
when the multiplicand is 1011 and the multiplier is 0101.
(b) Draw a state graph for the controller. (Four states are sufficient.)(c) Realize the controller using D FFs and a one-hot state assignment. Give the
next-state equations and the controller output equations.
(d) Realize the controller using a minimum number of D FFs.620 Unit 18
B Counter
Zero Detect4Multiplier
LB
DB
BZ
ControllerS
DPU Reg4
CP
LPUPL Reg4
A Reg4
CP
LPLLAMultiplicand
MUX
AdderAND Arra yMS EA4
C FF0 1
CC
18.29 A few modifications of the circuit of Problem 18.28 are necessary so that it will mul-
tiply 2’s complement numbers. For example, the Controller must have inputs thatare the sign bits of the multiplier and multiplicand; the B Counter must be able toincrement a negative multiplier to 0; and the AND Array must be changed so thatits outputs can be the Multiplicand, all 0’s or all 1’s.(a) Redesign the multiplier so that it can multiply 2’s complement numbers using
these suggested modifications.
(b) Determine the contents of the partial product register for each addition step
when the multiplicand is 1011 and the multiplier is 0101. Repeat when the mul-tiplicand is 0101 and the multiplier is 1011.
(c) Draw a state graph for the controller. (At most, five states are required.)(d) Realize the controller using D FFs and a one-hot state assignment. Give the
next-state equations and the controller output equations.
(e) Realize the controller using a minimum number of D FFs.
18.30 The Ultra-Slow Divider, shown in the following block diagram, works on a
principle similar to the Ultra-Slow Multiplier in Problem 18.27. When the Stsig-
nal is received, the 8-bit down counter is loaded with the dividend ( N
1), the 
4-bit down counter is loaded with the divisor ( N2), and the 4-bit quotient up counter
is cleared. The dividend counter and the divisor counter are decremented together,and every time the 4-bit divisor counter reaches zero, it is reloaded with the divisorand the quotient up counter is incremented. When the dividend counter reacheszero, the process terminates and the quotient counter contains the result.(a) Draw the state graph for the controller.(b) Realize the state graph using one or two D flip-flops and a minimum number
of gates.
(c) If the dividend is N
1and the divisor is N2, how many clock cycles does it take to
calculate the quotient?
(d) How can you tell if an overflow occurs during division?(e) What will happen in your circuit if the divisor is zero?
CLR
EZEROIZERO
LOAD
DOWNUPDividend
Load
Control
ST
DoneCount
Clear
CountZero
Ultra-Slow Divider4-Bit Up
Counter8-Bit Down
Counter
Quotient Load
Count4-Bit Down
CounterDivisor8
N1
4
N2Circuits for Arithmetic Operations 621
18.31 This problem involves the design of a circuit that finds the integer part of the
square root of an 8-bit unsigned binary number Nusing the method of subtracting
out odd integers. To find the square root of N, we subtract 1, then 3, then 5, etc.,
until we can no longer subtract without the result going negative. The number oftimes we subtract is equal to the integer part of the square root of N. For example,
to find
w¬27: 27 /H110021/H1100526; 26 /H110023/H1100523; 23 /H110025/H1100518; 18 /H110027/H1100511; 11 /H110029/H110052; 2/H1100211
(cannot subtract). Because we subtracted five times, w¬27:/H110055. Note that the final
odd integer is 1110/H1100510112, and this consists of the square root (1012/H11005510)
followed by a 1.622 Unit 18
623State Machine Design 
with SM Charts
Objectives
1.Explain the different parts of an SM chart.
2.Given the input sequence to a state machine, determine the output
sequence from its SM chart and construct a timing diagram.
3.Convert a state graph to an SM chart.
4.Construct an SM chart for the control circuit for a multiplier, divider,
or other simple digital system.
5.Determine the next-state and output equations for a state machine
by tracing link paths on its SM chart.
6.Realize an SM chart using a PLA or ROM and flip-flops.
UNIT
19
1.Study Section 19.1, State Machine Charts .
(a) For the example of Figure 19-2, if X1/H110050 and X2/H110051 when the machine is
in state S1, specify the values of all of the outputs and the exit path number.
(b) For Figures 19-6(a) and (b), trace the link paths and determine the outputs
when X1/H11005X3/H110051.
(c) Verify that the SM chart and state graph of Figure 19-7 are equivalent.
(d) Construct a timing chart for Figure 19-7(b) when the input sequence is 
X/H110050, 1, 1, 0.
(e) Work Problems 19.1, 19.2, and 19.3.
2.Study Section 19.2, Derivation of SM Charts .
(a) Using the SM chart of Figure 19-9 to determine when to subtract and when
to shift for the binary divider of Figure 18-10, show the contents of the div-idend register at each time step when 28 is divided by 5.
(b) Compare the SM chart of Figure 19-10 with the state graph of Figure 18-9(c)
and verify that in each state they will generate the same outputs when theinputs are the same.
(c) Compare the flowchart for the dice game (Figure 19-12) with the SM chart
(Figure 19-13). Note that the Roll Dice box on the flowchart requires twostates to implement on the SM chart. In the first state, the machine waits forthe roll button to be pressed; in the second state, it generates a roll signalwhich lasts until the roll button is released. In state S
13 variables are test-
ed; if they are all 0, Spis generated so that the sum will be stored in the
point register at the same time the transition from S1toS4occurs.
(d) Work Problems 19.4, 19.5, and 19.6.
3.Study Section 19.3, Realization of SM Charts .
(a) For Figure 19-7(b) find simplified equations for A/H11001and B/H11001.
(b) Verify Tables 19-1 and 19-2. For Table 19-2, why is Sp/H110051 only in row 4,
and Win /H110051 in both rows 7 and 8?
(c) Expand row 16 of Table 19-2 to give the corresponding rows of the ROM table.
(d) Work Problems 19.7, 19.8, 19.9, and 19.10.624 Unit 19
Study Guide
625State Machine Design 
with SM Charts
Another name for a sequential circuit is an algorithmic state machine or simply a state
machine. These names are often used when the sequential circuit is used to control adigital system that carries out a step-by-step procedure or algorithm. The state graphsin Figures 18-3, 18-8, 18-9, and 18-11 define state machines for controlling adders, mul-tipliers, and dividers.As an alternative to using state graphs, a special type of flowchart,called a state machine flowchart or SM chart, may be used to describe the behavior ofa state machine. This unit describes the properties of SM charts and how they are usedin the design of state machines.
19.1 State Machine Charts
Just as flowcharts are useful in software design, flowcharts are useful in the hard-ware design of digital systems. In this section we introduce a special type of flow-chart called a state machine flowchart, or SM chart for short. SM charts are alsocalled ASM (algorithmic state machine) charts. We will see that the SM chart offersseveral advantages. It is often easier to understand the operation of a digital systemby inspection of the SM chart instead of the equivalent state graph. A given SMchart can be converted into several equivalent forms, and each form leads directlyto a hardware realization.
An SM chart differs from an ordinary flowchart in that certain specific rules
must be followed in constructing the SM chart. When these rules are followed, theSM chart is equivalent to a state graph, and it leads directly to a hardware realiza-tion. Figure 19-1 shows the three principal components of an SM chart. The state ofthe system is represented by a state box . The state box contains a state name, and it
may contain an output list .A  state code may be placed outside the box at the top. A
decision box is represented by a diamond-shaped symbol with true and false
branches. The condition placed in the box is a Boolean expression that is evaluat-
ed to determine which branch to take.The conditional output box , which has curved
ends, contains a conditional output list . The conditional outputs depend on both the
state of the system and the inputs.
An SM chart is constructed from SM blocks . Each SM block (Figure 19-2) con-
tains exactly one state box together with the decision boxes and conditional outputboxes associated with that state. An SM block has exactly one entrance path and
one or more exit paths . Each SM block describes the machine operation during the
time that the machine is in one state. When a digital system enters the state associ-ated with a given SM block, the outputs on the output list in the state box becometrue. The conditions in the decision boxes are evaluated to determine which path
(or paths) is (are) followed through the SM block. When a conditional output box
is encountered along such a path, the corresponding conditional outputs becometrue.A path through an SM block from entrance to exit is referred to as a link path .
For the example of Figure 19-2, when state S
1is entered, outputs Z1and Z2
become 1. If inputs X1and X2are both equal to 0, Z3and Z4are also 1, and at the
end of the state time, the machine goes to the next state via exit path 1. On the otherhand, if X
1/H110051 and X3/H110050, the output Z5is 1, and an exit to the next state will occur
via exit path 3.
A given SM block can generally be drawn in several different forms. Figure 19-3
shows two equivalent SM blocks. In both Figure 19-3(a) and (b), the output Z2/H110051 if
X1/H110050; the next state is S2ifX2/H110050 and S3ifX2/H110051.626 Unit 19
S1/Z1Z2
Z3Z4
Z5One Entrance Path
One State
0Link
Path a
Link
Path b
0
12 3 n11
01
n exit pathsSM
Bloc k
X1
X3
X2FIGURE 19-2
Example of an
SM Blockstate_name/
Output List
(a) State boxConditional
Output List
(c) Conditional
output boxxxxOptional
State Code
(b) Decision boxCondition(True
branch)(False
branch) 10FIGURE 19-1
Components of 
an SM Chart
The SM chart of Figure 19-4(a) represents a combinational circuit because there is
only one state and no state change occurs. The output is Z1/H110051 if A/H11001BC/H110051; or else
Z1/H110050. Figure 19-4(b) shows an equivalent SM chart in which the input variables are
tested individually. The output is Z1/H110051 if A/H110051 or if A/H110050,B/H110051, and C/H110051. Hence,
Z1/H11005A/H11001A/H11032BC/H11005A/H11001BC
which is the same output function realized by the SM chart of Figure 19-4(a).
Certain rules must be followed when constructing an SM block. First, for every
valid combination of input variables, there must be exactly one exit path defined.This is necessary because each allowable input combination must lead to a singlenext state. Second, no internal feedback within an SM block is allowed. Figure 19-5shows an incorrect and correct way of drawing an SM block with feedback.
As shown in Figure 19-6(a), an SM block can have several parallel paths which
lead to the same exit path, and more than one of these paths can be active at thesame time. For example, if X
1/H11005X2/H110051 and X3/H110050, the link paths marked withState Machine Design with SM Charts 627
S1/Z1
S2/ S3/ S2/ S3/Z2
Z2 Z2X1
X201
01
(a)S1/Z1
X2
X1 X10
1
0011
(b)FIGURE 19-3
Equivalent
SM Blocks
S0/
Z1Z1A + BC
011
1
(a)S0/
A
C
B0
0
01
(b)FIGURE 19-4
Equivalent
SM Charts for a
Combinational
Circuit
dashed lines are active, and the outputs Z1,Z2, and Z3will be l. Although Figure 
19-6(a) would not be a valid flowchart for a program for a serial computer, it pres-ents no problems for a state machine implementation. The state machine can havea multiple-output circuit that generates Z
1,Z2, and Z3at the same time. Figure 
19-6(b) shows a serial SM block, which is equivalent to Figure 19-6(a). In the serialblock only one active link path between entrance and exit is possible.
For any combination of input values the outputs will be the same as in the equivalent
parallel form.The link path for X
1/H11005X2/H110051 and X3/H110050 is shown with a dashed line, and
the outputs encountered on this path are Z1,Z2, and Z3. Regardless of whether the SM
block is drawn in serial or parallel form, all of the tests take place within one clock time.
A state graph for a sequential machine is easy to convert to an equivalent SM
chart. The state graph of Figure 19-7(a) has both Moore and Mealy outputs. Theequivalent SM chart has three blocks—one for each state. The Moore outputs(Z
a,Zband Zc) are placed in the state boxes because they do not depend on the628 Unit 19
S0/Z1S0/Z1
Z21
01
010
0
(a) (b)X1
Z3X2
Z4Z2
X3X1
0Z3X2
0111
Z4X3FIGURE 19-6
Equivalent
SM BlocksS0/
X0
1
(a) IncorrectS0/
X0
1
(b) CorrectFIGURE 19-5
SM Block with
Feedback
input. The Mealy outputs ( Z1and Z2) appear in conditional output boxes because
they depend on both the state and input. In this example, each SM block has onlyone decision box because only one input variable must be tested. For both thestate graph and SM chart, Z
cis always 1 in state S2. If X/H110050 in state S2,Z1/H110051
and the next state is S0. If X/H110051,Z2/H110051 and the next state is S2.
Figure 19-8 shows a timing chart for the SM chart of Figure 19-7 with an input
sequence X/H110051, 1, 1, 0, 0, 0. In this example, all state changes occur immediately after
the rising edge of the clock. Because the Moore outputs ( Za,ZbandZc) depend on the
state, they can only change immediately following a state change. The Mealy outputsState Machine Design with SM Charts 629
S0/Za
S1/Zb
Z2 Z101Link 100
1/0 1/0
0/00/0 1/ Z2
0/Z101
11
(b) Equivalent SM chart (a) State graphX
S2/Zc01X
01Link 3Link 2
XS0
ZaS1
ZbS2
ZcFIGURE 19-7
Conversion
of a State Graph
to an SM Chart
Z2S0 S1 S2 S2 S0 S0
Z1ZcZbZaXStateClockFIGURE 19-8
Timing Chart for
Figure 19-7
(Z1and Z2) can change immediately after a state change or an input change. In any
case, all outputs will have their correct value during the active edge of the clock.
19.2 Derivation of SM Charts
The method used to derive an SM chart for a sequential control circuit is similar tothat used to derive the state graph. First, we should draw a block diagram of the sys-tem we are controlling. Next, we should define the required input and output signalsto and from the control circuit. Then, we can construct an SM chart that tests theinput signals and generates the proper sequence of output signals.
In this section we will give several examples of SM charts. The first example is
an SM chart for control of the parallel binary divider, as shown in Figure 18-10. Asdescribed in Section 18.3, binary division requires a series of subtract and shift oper-ations. Derivation of an SM chart to generate the proper sequence of subtract andshift signals is very similar to derivation of the state graph of Figure 18-11. For theSM chart of Figure 19-9, S
0is the starting state. In S0, the start signal ( St) is tested,630 Unit 19
010 10 100110
1St
C
CS0/
S2/S1/ Load
Sh
Su Sh
CS3/
Su Sh
CS4/
Su
CS5/
SuShVFIGURE 19-9
SM Chart for
Binary Divider
and if St/H110051, the Load signal is turned on and the next state is S1. In S1, the compare
signal ( C) is tested. If C/H110051, the quotient would be larger than 4 bits, so an overflow
signal ( V/H110051) is generated and the state changes back to S0. If C/H110050,Shbecomes
1, so at the next clock the dividend is shifted to the left and the state changes to S2.
Cis tested again in state S2. If C/H110051, subtraction is possible, so Subecomes 1 and
no state change occurs. If C/H110050,Sh/H110051, and the dividend is shifted as the state
changes to S3. The action in states S3andS4is identical to that in state S2. In state S5
the next state is always S0, and C/H110051 causes subtraction to occur.
Next, we will derive the SM chart for the multiplier control of Figure 18-9(a). This
control generates the required sequence of add and shift signals for a binary multipli-er of the type shown in Figure 18-7. The counter counts the number of shifts and out-puts K/H110051 just before the last shift occurs. The SM chart for the multiplier control
(Figure 19-10) corresponds closely to the state graph of Figure 18-9(c). In state S
0,
when the start signal Stis 1, Load is turned on and the next state is S1. In S1, the mul-
tiplier bit Mis tested to determine whether to add or shift. If M/H11005l, an add signal is
generated and the next state is S2. If M/H110050, no addition is required, so a shift signal is
generated and Kis tested. If K/H110051, the circuit goes to the Done state, S3, at the time
of the last shift; otherwise, the next state is S1. In S2a shift signal is generated because
a shift must always follow an add, and Kis tested to determine the next state.
As a third example of SM chart construction, we will design an electronic dice
game. Figure 19-11 shows the block diagram for the dice game. Two counters areused to simulate the roll of the dice. Each counter counts in the sequence 1, 2, 3, 4,5 ,6 ,1 ,2 ,.... T h u s , after the “roll” of the dice, the sum of the values in the two coun-
ters will be in the range 2 through 12.State Machine Design with SM Charts 631
0100101
1St
M
KS0/
S1/
S3/Done KS2/ShLoad
Ad ShFIGURE 19-10
SM Chart for
Binary Multiplier
The rules of the game are as follows:
1.After the first roll of the dice, the player wins if the sum is 7 or 11. He loses if
the sum is 2, 3, or 12. Otherwise, the sum which he obtained on the first roll isreferred to as his point, and he must roll the dice again.
2.On the second or subsequent roll of the dice, he wins if the sum equals his point,
and he loses if the sum is 7. Otherwise, he must roll again until he finally winsor loses.
The inputs to the dice game come from two push buttons, Rb(roll button) and
Reset. Reset is used to initiate a new game.When the roll button is pushed, the dicecounters count at a high speed, so the values cannot be read on the display. Whenthe roll button is released, the values in the two counters are displayed and thegame can proceed. Because the button is released at a random time, this simulatesa random roll of the dice. If the Win light or Lose light is not on, the player mustpush the roll button again. We will assume that the push buttons are properlydebounced and that the changes in Rbare properly synchronized with the clock.
Methods for debouncing and synchronization were discussed previously.
Figure 19-12 shows a flowchart for the dice game. After rolling the dice, the sum
is tested. If it is 7 or 11, the player wins; if it is 2, 3, or 12, he loses. Otherwise, the sumis saved in the point register, and the player rolls again. If the new sum equals thepoint, he wins; if it is 7, he loses. Otherwise, he rolls again. After winning or losing,he must push Reset to begin a new game.
The components for the dice game shown in the block diagram (Figure 19-11)
include an adder which adds the two counter outputs, a register to store the point,test logic to determine conditions for win or lose, and a control circuit.The input sig-nals to the control circuit are defined as follows:
D
7/H110051 if the sum of the dice is 7
D711/H110051 if the sum of the dice is 7 or 11632 Unit 19
Displa y
Win
Lose1-to-6
Counter
Point
RegisterDispla y
Comparator1-to-6
Counter
ControlTest
LogicAdder
D2312
SpRb
Reset
EqRoll
SumD711D7Dice Game ModuleFIGURE 19-11
Block Diagram for
Dice Game
D2312/H110051 if the sum of the dice is 2, 3, or 12
Eq/H110051 if the sum of the dice equals the number stored in the point
register
Rb/H110051 when the roll button is pressed
Reset /H110051 when the reset button is pressed
The outputs from the control circuit are defined as follows:
Roll /H110051 enables the dice counters
Sp/H110051 causes the sum to be stored in the point register
Win /H110051 turns on the win light
Lose /H110051 turns on the lose lightState Machine Design with SM Charts 633
Roll Dice
Roll DiceStore sum in
point registerSum =
7 or 11
Sum =
Point
Sum = 7
ResetSum =
2, 3, or 12
Win
ResetLoseYN
NYNYNNYN
Y
YFIGURE 19-12
Flowchart for
Dice Game
We can now convert the flowchart for the dice game to an SM chart for the control
circuit using the defined control signals. Figure 19-13 shows the resulting SM chart.Thecontrol circuit waits in state S
0until the roll button is pressed ( Rb/H110051).Then, it goes to
state S1, and the roll counters are enabled as long as Rb/H110051. As soon as the roll button634 Unit 19
Sp0
1
1
1
10
0
0
00
1
1
0
0
0
1101
1Rb
RollRb
D711
D2312
Rb
Eq
D7RbS0/
S1/Roll
S4/
S2/WinS5/
ResetS3/Lose
ResetFIGURE 19-13
SM Chart for
Dice Game
is released ( Rb/H110050),D711is tested. If the sum is 7 or 11, the circuit goes to state S2and
turns on the Win light; otherwise, D2312is tested. If the sum is 2, 3, or 12, it goes to state
S3and turns on the Lose light; otherwise, the signal Spbecomes 1, and the sum is stored
in the point register. It then enters S4and waits for the player to “roll the dice” again.
InS5, after the roll button is released, if Eq/H11005l, the sum equals the point and state S2is
entered to indicate a win. If D7/H110051, the sum is 7 and S3is entered to indicate a loss.
Otherwise, the control returns to S4so that the player can roll again. When in S2orS3,
the game is reset to S0when the Reset button is pressed.
Instead of using an SM chart, we could construct an equivalent state graph from
the flowchart. Figure 19-14 shows a state graph for the dice game controller. The stategraph has the same states, inputs, and outputs as the SM chart. The arcs have beenlabeled consistently with the rules for proper alphanumeric state graphs given inSection 14.5. Thus, the arcs leaving state S
1are labeled Rb,Rb/H11032D711,Rb/H11032D/H11032711D2312, and
Rb/H11032D/H11032711D/H110322312.With these labels, only one next state is defined for each combination of
input values. Note that the structure of the SM chart automatically defines only onenext state for each combination of input values.State Machine Design with SM Charts 635
Rb′/0
Rb/0
S1Rb′D′711D2312/0
Rb′Eq′D′7/0Rb′Eq′D7/0 Rb′Eq/0Rb′/0
Rb/0
Rb/RollReset′/0 Reset′/0Reset/0 Reset/0
Rb′D′′711D2312/SpRb′D711/0Rb/RollS0
S2
Win
S4
S5S3
LoseFIGURE 19-14
State Graph for
Dice Game
Controller
19.3 Realization of SM Charts
The methods used to realize SM charts are similar to the methods used to realize
state graphs. As with any sequential circuit, the realization will consist of a combi-national subcircuit together with flip-flops for storing the state of the circuit (seeFigure 13-17). In some cases, it may be possible to identify equivalent states in anSM chart and eliminate redundant states using the same method as was used forreducing state tables. However, an SM chart is usually incompletely specified in the
sense that all inputs are not tested in every state, which makes the reduction proce-
dure more difficult. Even if the number of states in an SM chart can be reduced, itis not always desirable to do so because combining states may make the SM chartmore difficult to interpret.
Before deriving next-state and output equations from an SM chart, a state
assignment must be made. The best way of making the assignment depends on howthe SM chart is realized. If gates and flip-flops (or the equivalent PLD realization)are used, the guidelines for state assignment given in Section 15.8 may be useful.
As an example of realizing an SM chart, consider Figure 19-7(b). We have made
the state assignment AB/H1100500 for S
0,AB/H1100501 for S1, and AB/H1100511 for S2.After a state
assignment has been made, output and next-state equations can be read directly fromthe SM chart. Because the Moore output Z
ais 1 only in state 00, Za/H11005A/H11032B/H11032. Similarly,
Zb/H11005A/H11032B and Zc/H11005AB. The conditional output Z1/H11005ABX /H11032because the only link
path through Z1starts with AB/H1100511 and takes the X/H110050 branch. Similarly, Z2/H11005
ABX . There are three link paths (labeled link 1, link 2, and link 3), which terminate in
a state that has B/H110051. Link 1 starts with a present state AB/H1100500, takes the X/H110051
branch, and terminates on a state in which B/H110051. Therefore, the next state of B(B/H11001)
equals 1 when A/H11032B/H11032X/H110051. Link 2 starts in state 01, takes the X/H110051 branch, and ends
in state 11, so B/H11001has a term A/H11032BX. Similarly, B/H11001has a term ABX from link 3. The
next-state equation for Bthus has three terms corresponding to the three link paths:
B/H11001/H11005A/H11032B/H11032X/H11001A/H11032BX /H11001ABX
link 1 link 2 link 3
Similarly, two link paths terminate in a state with A/H110051, so
A/H11001/H11005A/H11032BX /H11001ABX
These output and next-state equations can be simplified with a Karnaugh map,
using the unused state assignment ( AB/H1100510) as a don’t-care condition.
As illustrated, the next-state equation for a flip-flop Qcan be derived from the
SM chart as follows:
1.Identify all of the states in which Q/H110051.
2.For each of these states, find all of the link paths that lead into the state.
3.For each of these link paths, find a term that is 1 when the link path is followed.
That is, for a link path from SitoSj, the term will be 1 if the machine is in state
Siand the conditions for exiting to Sjare satisfied.
4.The expression for Q/H11001(the next state of Q) is formed by ORing together the
terms found in step 3.
Next, we will implement the multiplier control SM chart of Figure 19-10 using a
PLA and two D flip-flops connected, as shown in Figure 19-15. The PLA has fiveinputs and six outputs.We will use a straight binary state assignment ( S
0/H1100500,S1/H1100501,
etc.). Each row in the PLA table (Table 19-1) corresponds to one of the link paths inthe SM chart. Because S
0has two exit paths, the table has two rows for present state
S0. Because only Stis tested in S0,MandKare don’t-cares as indicated by dashes.The
first row corresponds to the St/H110050 exit path, so the next state is 00 and all outputs636 Unit 19
¯˘˙ ¯˘˙ ¯˘˙
are 0. In the second row, St/H110051, so the next state is 01 and the other PLA outputs are
1000. Because Stis not tested in states S1,S2, and S3,Stis a don’t-care in the corre-
sponding rows. The outputs for each row can be filled in by tracing the correspondinglink paths on the SM chart. For example, the link path from S
1toS2passes through
conditional output Adwhen M= 1, so Ad/H110051 in this row. Because S2has a Moore
output Sh,Sh/H110051 in both of the rows for which AB/H1100510.
The SM chart for the dice game controller can be implemented using a PLA and
three D flip-flops, as shown in Figure 19-16. The PLA has nine inputs and sevenoutputs, which are listed at the top of Table 19-2. In state ABC /H11005000, the next state
isA
/H11001B/H11001C/H11001/H11005000 or 001, depending on the value of Rb. Because state 001 has four
exit paths, the PLA table has four corresponding rows. When Rbis 1, Roll is 1
and there is no state change. When Rb/H110050 and D711is 1, the next state is 010. When
Rb/H110050 and D2312/H11005l, the next state is 011. For the link path from state 001 to 100, Rb,
D711, and D2312are all 0, and Spis a conditional output. This path corresponds to row
4 of the PLA table, which has Sp/H110051 and A/H11001B/H11001C/H11001/H11005100. In state 010, the Win sig-
nal is always on, and the next state is 010 or 000, depending on the value of Reset .State Machine Design with SM Charts 637
D
D
ClockLoad
Sh
Ad
A+
A
BB+St
M
K
Done
PLAFIGURE 19-15
Realization of
Figure 19-10
Using a PLA and
Flip-Flops
Present PLA Inputs PLA Outputs
State ABS tMK A/H11001B/H11001Load Sh Ad Done
S0 000 - - 0 0 0 0 0 0
001 - - 0 1 1 0 0 0
S1 01 - 0 0 0 1 0 1 0 0
01 - 0 1 1 1 0 1 0 0
01 - 1 - 1 0 0 0 1 0
S2 10 - - 0 0 1 0 1 0 0
10 - - 1 1 1 0 1 0 0
S3 11 - - - 0 0 0 0 0 1TABLE 19-1
PLA Table for
Multiplier Control
Similarly, Lose is always on in state 011. In state 101, A/H11001B/H11001C/H11001/H11005010 if Eq/H110051;
otherwise, A/H11001B/H11001C/H11001/H11005011 or 100, depending on the value of D7. States 110 amd 111
are unused, so all inputs and outputs are don’t-cares in these states.
If a ROM is used instead of a PLA, the PLA table must be expanded to 29/H11005512
rows. To expand the table, the dashes in each row must be replaced with all possiblecombinations of 0’s and 1’s. For example, row 5 would be replaced with the follow-ing 8 rows:638 Unit 19
ABC Rb Reset D7D711 D2312 Eq A/H11545B/H11545C/H11545Win Lose Roll Sp
1 000 0 – – – – – 000 0 0 0 0
2 000 1 – – – – – 001 0 0 0 03 001 1 – – – – – 001 0 0 1 04 001 0 – – 0 0 – 100 0 0 0 15 001 0 – – 0 1 – 011 0 0 0 0
6 001 0 – – 1 – – 010 0 0 0 0
7 010 – 0 – – – – 010 1 0 0 08 010 – 1 – – – – 000 1 0 0 09 011 – 1 – – – – 000 0 1 0 010 011 – 0 – – – – 011 0 1 0 0
11 100 0 – – – – – 100 0 0 0 0
12 100 1 – – – – – 101 0 0 0 013 101 0 – 0 – – 0 100 0 0 0 014 101 0 – 1 – – 0 011 0 0 0 0
15 101 0 – – – – 1 010 0 0 0 0
16 101 1 – – – – – 101 0 0 1 017 110 – – – – – – --- – – – –18 111 – – – – – – --- – – – –TABLE 19-2 PLA Table for Dice Game
D
ClockA+B+
QC+
ABCEqD2312D7D711ResetRb
SpRollLoseWin
PLA
CKD
Q CKD
Q CKFIGURE 19-16
PLA Realization
of Dice Game
Controller
State Machine Design with SM Charts 639
001 0 00 01 0 0110000
001 0 00 01 1 0110000
001 0 01 01 0 0110000
001 0 01 01 1 0110000
001 0 10 01 0 0110000
001 0 10 01 1 0110000
001 0 11 01 0 0110000
001 0 11 01 1 0110000
FIGURE 19-17 Maps Derived from Table 19-2
R = Reset
E3 = D711 + D711D2312 = D711 + D2312
E4 = Eq + Eq′D7 = Eq + D7X 100 01 11 10
X 1
X 1
E100CRbAB
01
1110 X E
2R′ X00 01 11 10
R′ X
R′ X
E300CRbAB
01
1110 R′ X E
41 X00 01 11 10
1 X
X00CRbAB
01
1110
A+B+
E1 = D711D2312
E2 = D7Eq′′
′′′WinXThe added entries have been printed in boldface.
The dice game controller can also be realized using a PAL. The required PAL
equations can be derived from Table 19-2 using the method of map-entered vari-ables (Section 6.5) or using a CAD program such as LogicAid . Figure 19-17 shows
maps for A
/H11001,B/H11001, and Win. Because A/H11001,B/H11001,C/H11001, and Rbhave assigned values in most
of the rows of the table, these four variables are used on the map edges, and theremaining variables are entered within the map. E
1,E2,E3, and E4on the maps rep-
resent the expressions given below the maps.
The resulting equations are
A/H11001/H11005A/H11032B/H11032C/H11080Rb/H11032D/H11032711D/H110322312/H11001AC/H11032/H11001 A/H11080Rb/H11001A/H11080D/H110327Eq/H11032
B/H11001/H11005A/H11032B/H11032C/H11080Rb/H11032(D711/H11001D2312)/H11001B/H11080Reset /H11032/H11001 AC/H11080Rb/H11032(Eq/H11001D7)
C/H11001/H11005B/H11032/H11080Rb/H11001A/H11032B/H11032C/H11080D/H11032711D2312/H11001BC/H11080Reset /H11032/H11001 AC/H11080D7Eq/H11032
Win /H11005BC/H11032
Lose /H11005BC
Roll /H11005B/H11032C/H11080Rb
Sp/H11005A/H11032B/H11032C/H11080Rb/H11032D/H11032711D/H110322312 (19-1)
These equations can also be derived using LogicAid or another CAD program. The
entire dice game, including the control circuit, can be implemented using a smallCPLD or FPGA. Implementation using VHDL is described in Section 20.4.
This unit has illustrated one way of realizing an SM chart using a PLA or ROM.
Alternative procedures are available which make it possible to reduce the size of thePLA or ROM by adding some components to the circuit. These methods are general-ly based on transformation of the SM chart to different forms and encoding the inputsor outputs of the circuit.
Problems
19.1 Construct an SM block that has three input variables ( D,E,F), four output vari-
ables ( P,Q,R,S), and two exit paths. For this block, output Pis always 1, and Qis
1 iff D/H110051. If Dand Fare 1 or if Dand Eare 0, R/H110051 and exit path 2 is taken. If
(D/H110050 and E/H110051) or ( D/H110051 and F/H110050),S/H110051 and exit path 1 is taken.
19.2 Convert the state graph of Figure 13-11 to an SM chart.
19.3 Complete the following timing diagram for the SM chart of Figure 19-10. Assume
St/H110051.
19.4 Solve Problem 18.5 using an SM chart instead of a state graph.
19.5 Work through Programmed Exercise 18.1 using an SM chart instead of a state graph.
19.6 Solve Problem 18.6 using an SM chart instead of a state graph.
19.7 (a) For the SM chart of Figure 19-9, make the following state assignment for the
flip-flops Q0,Q1, and Q2:
S0: 000; S1: 001; S2: 100; S3: 101; S4: 110; S5: 111.
Derive the next-state and output equations by tracing link paths on the SMchart. Simplify the equations and, then, draw the circuit using D flip-flops andNAND gates.ShS0
AdKMStateClock640 Unit 19
(b) Repeat for the SM chart of Figure 19-10, using the following state assignment
for flip-flops Q0and Q1:S0: 00; S1: 01; S2:11;S3: 10.
19.8 (a) Write the next-state and output equations for the dice game by tracing link
paths on the SM chart (Figure 19-13). Use a straight binary assignment.
(b) Design the block labeled “Test Logic” on Figure 19-11.
19.9 Realize the SM chart of Figure 19-7(b) using a PLA and two D flip-flops. Draw the
block diagram and give the PLA table.
19.10 For the following SM chart:
(a) Draw a timing chart that shows the clock, the state ( S0,S1, or S2), the inputs X1
and X2, and the outputs. Assume that X3/H110050 and the input sequence for X1X2
is 01, 00, 10, 11, 01, 10. Assume that all state changes occur on the rising edge of
the clock, and the inputs change between clock pulses.
(b) Using a straight binary assignment, derive the next-state and output equa-
tions by tracing link paths. Simplify these equations using the don’t-care state (AB/H1100511) and draw the corresponding circuit.
(c) Realize the chart using a PLA and D flip-flops. Give the PLA table.(d) If a ROM is used instead of a PLA, what size ROM is required? Give the first
five rows of the ROM table.
19.11 Construct an SM block that has three input variables ( A,B, and C), four outputs 
(W,X,Y, and Z), and two exit paths. For this block, output Zis always 1, and Wis 1
iffAand Bare both 1. If C/H110051 and A/H110050,Y/H110051 and exit path 1 is taken. If C/H110050
orA/H110051,X/H110051 and exit path 2 is taken.0
10
0
11
0
1
01X1
X3S0/
X1S2/Z1S1/Z3Z2 Z1
X2
X2Z3State Machine Design with SM Charts 641
19.12 Convert the state graphs of Figures 14-4 and 14-6 to SM charts. Use conditional
outputs for Figure 14-4.
19.13 Convert the state graph of Figure 13-15 to an SM chart. Test only one variable in
each decision box. Try to minimize the number of decision boxes.
19.14 (a) Construct an SM chart for a Moore sequential circuit with a single input and a
single output such that the output is 1 if and only if the input has been 1 for atleast three consecutive clock times.
(b) Use a one-hot state assignment for the sequential circuit and derive the next-
state and output equations.
(c) Make a state assignment for the sequential circuit using a minimum number of
state variables and derive the next-state equation and output equations directlyfrom the equations for the one-hot assignment.
(d) Simplify the next-state equations found in Part (c).
19.15 (a) Construct an SM chart for the controller in Problem 18.21.
(b) Implement the controller using two D flip-flops and derive minimum two-level
NAND gate logic for the flip-flop input equations and the output equations.(Assign 00 to the initial state, 01 to the state reachable from the initial state, and11 to the third state.)
(c) Implement the controller using a one-hot state assignment. Again use D flip-
flops and two-level NAND gate logic for the flip-flop input equations and theoutput equations.
(d) Implement the controller using two D flip-flops with a 2-to-4 decoder connected
to the D flip-flops outputs and two-level NAND gate logic connected to thedecoder outputs for the flip-flop input equations and the output equations. (Usethe same 00, 01, 11 state assignment.)
19.16 Convert the state graph shown in Figure 18-8 to an SM chart.
19.17 Complete the following timing diagram for the SM chart of Figure 19-9.
SuShCStStateClock
S0 S1 S2 S2 S3 S3 S4642 Unit 19
19.18 Realize the SM chart of Figure 19-10 using a PLA and two D flip-flops. Draw the block
diagram and give the PLA table. Use the same state assignment as in Problem 19.7(b).
19.19 Work Problem 19.10 for the following SM chart and the input sequence X1X2X3/H11005
011, 101, 111, 010, 110, 101, 001.
19.20 A sequential circuit has an input ( s) and two outputs ( z1and z2). When schanges
from 0 to 1, the circuit repeats the following pattern 12 times: z1z2/H1100510, 01, i.e.,
z1is 1 for one clock period followed by z2is 1 for one clock period repeated 12
times; otherwise, both z1and z2are 0. After the 24 output patterns, the circuit
waits until sreturns to 0, if it hasn’t already, and then the operation can repeat.
The sequential circuit is to be designed in two parts: (1) a four-state controllerand (2) a 4-bit parallel loading counter. The counter diagram is shown. WhenLDN is 0, the parallel inputs are loaded into the counter. When LDN is 1 and CEis 1, the counter increments. When LDN is 1 and CE is 0, the counter does notchange state. The output TC is 1 when the counter value is decimal 15.(a) Construct an SM chart for the controller. You need to specify the signals
between the controller and the counter.
(b) Using a one-hot state assignment, write the next-state and output equations for
the controller.
(c) Make a state assignment for the controller using two state variables. Assign 00
to the initial state and make the other assignments so that only one variablechanges during each state change. Derive the next-state and output equationsfor the controller.1
01
0
10
1
0
10X2
X3S0/
X1S2/Z1S1/Z1Z2 Z1
X1
X2Z3State Machine Design with SM Charts 643
19.21 Work Problem 18.28, Parts (a), (b) and (c), but use an SM chart instead of a state
graph. For Part (d), design the controller using a minimum number of D flip-flops,a decoder, and NAND gates.
19.22 The following circuit is a multiplier for 8-bit, unsigned (positive) numbers.
When the start input ( S) changes to 1, the multiplicand and multiplier are avail-
able on the input lines, and this signals the controller to begin the multiplicationprocess. Upon completion, the product is available in the lower 8 bits of the 9-bitPU register combined with the 8-bit PL register. Assume Sremains 1 until
theDsignal is generated. Then the circuit holds Dand the product until Sis
returned to 0.
The data path portion of the circuit has the following components:
(a) 8-bit A register for holding the multiplicand(b) 8-bit B register for holding the multiplier(c) 9-bit PU register for accumulating the upper part of the product(d) 8-bit PL register for the lower part of the product(e) 8-bit adder with inputs from A reg and 8 bits of PU; sum and carry-out are
inputs of PU reg; carry-in is 0
The control section contains a 3-bit counter ( C) with an all 1’s detection circuit
connected to its outputs. The inputs to the controller are S, the least significant bitofB(B0) and the output of the all 1’s detection circuit (C1).The outputs of the con-
troller are D, and all of the control signals for the registers. The control signals for
the registers are(a) LA, load A(b) LB, load B(c) SB, shift B right with B0 connected to the shift-in bit(d) CC, clear C(e) IC, increment C(f) CP , clear PU and PL(g) LPU, load PU(h) SP , shift PU and PL right; the shift-in bit of PU is 0 and the shift-in bit of PL is
the least significant bit of PU
Construct an SM chart for the controller using a minimum number of states.
Donotmodify the data path portion of the circuit.ClkLD LDN4-Bit CounterCETCP3P2P1P0
Q3Q2Q1Q0644 Unit 19
State Machine Design with SM Charts 645
C Counter
All 1’s Detect3CC
IC
C1
ControllerS
DPU Reg (9-Bits)8
CP
LPUPL Reg
8A Reg8
CP
SPLAMultiplicand
Adder8 B0
coB Register8Multiplier
LB
8SP0 si sisiSB
ci 0
PU8
19.23 (a) Derive an SM chart for the Ultra-Slow Divider in Problem 18.30.
(b) Realize the SM chart in (a) using a PLA and D flip-flops.
19.24 (a) Derive an SM chart for the elevator controller in Problem 16.26.
(b) Realize the SM chart in (a) using a PLA and D flip-flops.
19.25 Derive an SM chart for the Thunderbird taillight controller in Problem 16.27.
19.26 (a) Derive the SM chart for the tape player controller of Problem 16.28.
(b) Realize the control circuit using a PLA and D flip-flops.
19.27 Convert the state graph of Figure 13-9 to an SM chart.
646CHAPTER
00VHDL for Digital System Design
Objectives
1.Given a block diagram and a state graph for a digital system’s control unit
of the type discussed in Unit 18, write behavioral VHDL code for the sys-tem. Use one clocked process.
2.Compile and simulate the VHDL code you wrote for Objective 1.
3.Write synthesizable VHDL code for the system using control signals. Use two
processes, one for the combinational logic and one for updating registers.
4.Compile, simulate, and synthesize the VHDL code you wrote for Objective 3.
5.Write a VHDL test bench to test a VHDL module.
UNIT
20
VHDL for Digital System Design 647
1.Study Section 20.1, VHDL Code for a Serial Adder
(a) In Figure 20-1:
Which statements represent the full adder?
Why are concurrent statements used for the full adder instead of a
clocked process?
Which VHDL statements are used to shift the X and Y register? Why are
these statements in the clocked process?
(b) What change is required in the VHDL code if all register updates occur on
the rising edge of the clock instead of the falling edge?
2.Study Section 20.2, VHDL Code for a Binary Multiplier
(a) In Figure 20-2: Why are Mplier, Mcand, and ACC declared as type
std_logic_vector instead of bit_vector?
After what state change does Done change from '1' to '0' ?
When adding Mcand to ACC(7 downto 4), why is '0' concatenated to ACC
(7downto 4)? (line 29)
What does the notation when 2⏐4⏐6⏐8 mean? (line 34)
(b) In Figure 20-3:
Why is the initial value of ACC “UUUUUUUUU” ?
When should the product be read?Study Guide
648 Unit 20
(c) If the signal X, of type std_logic_vector(8 downto 0), is “111001101” initial-
ly, what is X after the execution of the following for loop? How long doesit take?
foriin5downto 0loop
X/H11021/H11005 X(7downto 0) & X(8);
wait for 10 ns;
end loop ;
(d) In Figure 20-5, on lines 29 and 30, when i /H110052 and Done /H11005‘1’, what are the
values of Mcand and Mplier? What is the value of Product if the multiplieris working properly?
(e) In Figure 20-7:
Which statement represents the adder?
Why are Load,Ad, Sh, and Done set to '0' (line 22) before the case statement?
Write a single VHDL statement that will clear ACC(8 downto 4) and load
ACC(3 downto 0) with Mplier, so that lines 39 and 40 can be replaced with
a single line.
Why is addout loaded into ACC in the second process instead of the first
process?
In Figure 20-2 we set Done /H11021/H11005 '1'in a concurrent statement (line 42), and
not after when 9 /H11005/H11022 on line 37 in the process. Why?
In Figure 20-7 line 33, we set Done /H11021/H11005 '1'after when 9 /H11005/H11022, which is unlike
what we did in Figure 20-2. Why is this correct in this case?
(f) In Figure 20-9:
When does the statement in line 22 execute?
If Sh /H11005'1', which statements execute following a rising clock edge?
VHDL for Digital System Design 649
If the clock rises at t/H1100510 ns, at what time are A, B, Count, and State updat-
ed? Explain why A and B are shifted as a unit even though the statementsfor updating A and B execute in sequence (line 51).
(g) In Figure 20-10 at time /H1100560 ns, explain the contents of the registers after the
rising clock edge. [ Hint : Refer to Figure 18-9(c) to determine what happens
in state 2 when K /H11005'0'. Convert hexadecimal to binary and shift the binary
before converting back to hexadecimal.] Repeat for time /H11005140 ns, noting
that M /H11005'1' before the rising clock edge.
(h) Read Appendix C, Tips for Writing Synthesizable VHDL Code .
(i) Work Problems 20.1, 20.2, 20.3, and 20.4.
3.Read Section 20.3, VHDL Code for a Binary Divider
(a) In Figure 20-11:
If Dividend(8 downto 4)/H11022/H11005 Divisor, what is the value of Subout(4)?
If Dividend(8 downto 4)/H11021Divisor, what is the value of Subout(4)?
Why is C equal to not Subout(4)?
(b) Work Problems 20.5, 20.6, and 20.7.
4.Read Section 20.4, VHDL Code for a Dice Game Simulator .
Work Problem 20.8.
5.Read Section 20.5, Concluding Remarks .
By looking at the VHDL code for the dice game, determine the minimum
number of flip-flops required. Verify this against the value given in Table 20-1.
In this chapter, we illustrate the use of VHDL in the design of digital systems.
Several of the examples are based on the multiplier and divider designs developedin Unit 18. We will use VHDL to describe a digital system at the behavioral level, sowe can simulate the system to check out the algorithms used and to make sure thatthe sequence of operations is correct. We can then define the required control sig-nals and the actions performed by these signals. Next, we write a VHDL descriptionof the system in terms of the control signals and verify its correct operation by sim-ulation.We can then synthesize our design and download it to a CPLD or FPGA forfinal testing.
20.1 VHDL Code for a Serial Adder
First, we will write VHDL code that represents the serial adder with accumulatorshown in Figure 18-1. The operation of the adder is explained in Section 18.1. InFigure 18-1, if Sh/H110051, the carry from the full adder is stored in the flip-flop at the
same time the registers are shifted on the falling edge of the clock.
Figure 20-1 shows VHDL code for the serial adder. Provision for loading the
X and Y registers and clearing the carry flip-flop (Ci) is not included in this code;however, the VHDL simulator can be used to initialize X, Y, and Ci for testingthe code. The code is based on the state graph for the controller shown inFigure 18-3. We have used two processes to represent the state machine in a man-ner similar to the state machine model of Figure 17–17. The first process (lines18–28) executes whenever state or St changes, and it generates the NextState andSh signals.The second process (lines 29–38) updates the state after the falling edgeof the clock. At the same time, if Sh /H11005'1' the registers are shifted, and the carry is
stored in the flip-flop (lines 33–36). The full adder is implemented using concur-rent statements for the sum and carry (lines 15–16). This is appropriate becausethe full adder uses combinational logic that does not require a clock. Becausestd_logic and std_logic vectors are used in the code, the library and use statements(lines 1 and 2) are required. These statements could be omitted if bits and bit_vec-tors were used instead.
VHDL for Digital System Design
650
VHDL for Digital System Design 651
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. all;
3 entity serial is
4 Port (St:instd_logic;
5 Clk: instd_logic;
6 Xout: outstd_logic_vector(3 downto 0));
7 end serial;
8 architecture Behavioral ofserial is
9 signal X, Y: std_logic_vector(3 downto 0);
10 signal Sh: std_logic;
11 signal Ci, Ciplus: std_logic;
12 signal Sumi: std_logic;
13 signal State, NextState: integer range 0to3; -- 4 states
14 begin
15 Sumi /H11021/H11005 X(0)xorY(0)xorCi; -- full adder
16 Ciplus /H11021/H11005 (Ciand X(0)) or(CiandY(0)) or(X(0) andY(0));
17 Xout /H11021/H11005 X;
18 process (State, St)
19 begin
20 case State is
21 when 0/H11005/H11022
22 ifSt/H11005‘1’then Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
23 else Sh/H11021/H11005 ‘0’; NextState /H11021/H11005 0;end if ;
24 when 1/H11005/H11022  Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 2;
25 when 2/H11005/H11022 Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 3;
26 when 3/H11005/H11022 Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 0;
27 end case ;
28 end process ;
29 process (clk)
30 begin
31 ifclk’event and clk/H11005‘0’then
32 State /H11021/H11005 NextState; -- update state register
33 ifSh/H11005‘1’then
34 X /H11021/H11005 Sumi & X(3 downto 1); -- shift Sumi into X register
35 Y /H11021/H11005 Y (0) & Y(3 downto 1); -- rotate right Y register
36 Ci /H11021/H11005 Ciplus; end if ; -- store next carry
37 end if ;
38 end process ;
39 end Behavioral;FIGURE 20-1
VHDL Code for
Figure 18-1
652 Unit 20
20.2 VHDL Code for a Binary Multiplier
In Section 18.2, we designed a multiplier for unsigned binary numbers. In this section
we will show several ways of writing VHDL code to describe the multiplier operation.As indicated in Figure 18-7, 4 bits from the accumulator (ACC) and 4 bits from themultiplicand register are connected to the adder inputs; the 4 sum bits and the carryoutput from the adder are connected back to the accumulator. When an add signal(Ad) occurs, the adder outputs are loaded into the accumulator by the next clock
pulse, thus, causing the multiplicand to be added to the accumulator. An extra bit atthe left end of the product register temporarily stores any carry which is generatedwhen the multiplicand is added to the accumulator.When a shift signal ( Sh) occurs, all
9 bits of ACC are shifted right by the next clock pulse. See Section 18.2 for a moredetailed explanation of the multiplier operation.
We will write a behavioral VHDL model for the multiplier (Figure 20-2) based
on the block diagram of Figure 18-7 and the state graph of Figure 18-8. This modelwill allow us to check out the basic design of the multiplier and the multiplicationalgorithm before proceeding with a more detailed design. Because the controlcircuit has ten states, we have declared an integer in the range 0 to 9 for the state
-- This is a behavioral model of a multiplier for unsigned binary numbers. It multiplies a 4-bit-- multiplicand by a 4-bit multiplier to give an 8-bit product. The maximum number of clock-- cycles needed for a multiply is 10.
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity mult4X4 is
6 port (Clk, St: instd_logic;
7 Mplier, Mcand : instd_logic_vector(3 downto 0);
8 Done: outstd_logic;
9 Product: outstd_logic_vector (7 downto 0));
10 end mult4X4;
11 architecture behave1 ofmult4X4 is
12 signal State: integer range 0to9;
13 signal ACC: std_logic_vector(8 downto 0); -- accumulator
14 alias M: std_logic isACC(0); -- M is bit 0 of ACC
15 begin
16 Product /H11021/H11005 ACC (7 downto 0);
17 process (Clk)
18 begin
19 ifClk’event and Clk/H11005‘1’then -- executes on rising edge of clockFIGURE 20-2
Behavioral VHDL
Code for Multiplier
of Figure 18-7
signal (line 12). The signal ACC represents the 9-bit accumulator output (line 13).
The signals ACC, Mcand, and Mplier are declared as type std_logic_vector so thatthe overloaded “ /H11001” operator can be used for addition. The statement “ alias M:
std_logic isACC(0); ” allows us to use the name M in place of ACC(0). The product is
set equal to the lower 8 bits of ACC in a concurrent statement (line 16).
Because all register operations and state changes occur on the rising edge of the
clock, we will use a process that executes when Clk changes. The case statement spec-ifies the actions to be taken in each state. In state 0, if St /H11005'1' the multiplier is loaded
into the accumulator at the same time the state changes to 1 (lines 21–26). From thestate graph, we see that the same operations occur in states 1, 3, 5, and 7. The notation“when 1
⏐3⏐5⏐7/H11005/H11022” means when state is 1 or 3 or 5 or 7, the statements that follow
will execute. When M /H11005'1', the expression
‘0’& ACC(7 downto 4)/H11001Mcand
computes the adder output, which is loaded into ACC (lines 28–29). At the same
time, the circuit goes to the next state in sequence (2, 4, 6, or 8). If M /H11005'0', ACC
is shifted to the right by loading ACC with '0' concatenated with the upper 8 bitsof ACC (line 31). At the same time the state changes to 3, 5, 7, or 9 (the presentstate /H110012). In states 2, 4, 6, or 8 ACC is shifted to the right, and state changes to
the next state in sequence (lines 34–36).
The Done signal needs to be turned on only in state 9. If we had used the statement
“when 9/H11005/H11022 State /H11021/H11005 0; Done /H11021/H11005 '1'”, Done would be turned on at the same timeVHDL for Digital System Design 653
20 case State is
21 when 0/H11005/H11022 --initial State
22 ifSt/H11005’1’then
23 ACC(8 downto 4)/H11021/H11005 “00000”; -- clear upper ACC
24 ACC(3 downto 0)/H11021/H11005 Mplier; -- load the multiplier
25 State /H11021/H11005 1;
26 end if ;
27 when 1⏐3⏐5⏐7/H11005/H11022 -- “add/shift” State
28 ifM/H11005‘1’then -- Add multiplicand to ACC
29 ACC(8 downto 4)/H11021/H11005 (‘0’& ACC(7 downto 4))/H11001Mcand;
30 State /H11021/H11005 State /H110011;
31 else ACC /H11021/H11005 ‘0’ & ACC(8 downto 1); -- Shift accumulator right
32 State /H11021/H11005 State /H110012;
33 end if ;
34 when 2⏐4⏐6⏐8/H11005/H11022 -- “shift” State
35 ACC /H11021/H11005 ‘0’ & ACC(8 downto 1); -- Right shift
36 State /H11021/H11005 State /H110011;
37 when 9/H11005/H11022 -- end of cycle
38 State /H11021/H11005 0;
39 end case ;
40 end if ;
41 end process ;
42 Done /H11021/H11005 ‘1’when State /H110059else ‘0’;
43 end behave1;FIGURE 20-2
(Continued)
654 Unit 20
-- command file to test multiplier
view listadd list CLK St State ACC done productforce st 1 2, 0 22force clk 1 0, 0 10 –repeat 20force Mcand 1101force Mplier 1011run 200
ns delta clk St State ACC done product
0 /H110011 1 U 0 UUUUUUUUU 0 UUUUUUUU
2 /H110010 1 1 0 UUUUUUUUU 0 UUUUUUUU
10 /H110010 0 1 0 UUUUUUUUU 0 UUUUUUUU
20 /H110012 1 1 1 000001011 0 00001011
22 /H110010 1 0 1 000001011 0 00001011
30 /H110010 0 0 1 000001011 0 00001011
40 /H110012 1 0 2 011011011 0 11011011
50 /H110010 0 0 2 011011011 0 11011011
60 /H110012 1 0 3 001101101 0 01101101
70 /H110010 0 0 3 001101101 0 01101101
80 /H110012 1 0 4 100111101 0 00111101
90 /H110010 0 0 4 100111101 0 00111101
100 /H110012 1 0 5 010011110 0 10011110
110 /H110010 0 0 5 010011110 0 10011110
120 /H110012 1 0 7 001001111 0 01001111
130 /H110010 0 0 7 001001111 0 01001111
140 /H110012 1 0 8 100011111 0 00011111
150 /H110010 0 0 8 100011111 0 00011111
160 /H110012 1 0 9 010001111 1 10001111
170 /H110010 0 0 9 010001111 1 10001111
180 /H110010 1 0 0 010001111 0 10001111
190 /H110010 0 0 0 010001111 0 10001111
200 /H110010 1 0 0 010001111 0 10001111FIGURE 20-3
Command File and
Simulation Results
for (13 by 11)the State changed to 0.This is too late because we want Done to turn on when the State
becomes 9. Furthermore, if Done /H11021/H11005 '1' were included in the clocked process, a syn-
thesizer would infer that we wanted to store Done in a flip-flop. Because we do notwant to do this, we use a separate concurrent assignment statement. This statement isplaced outside the process so that Done will be updated whenever the State changes.
Before continuing with the design, we will test the behavioral level VHDL code
to make sure that the algorithm is correct and consistent with the hardware blockdiagram. At early stages of testing, we will want a step-by-step printout to verify theinternal operations of the multiplier and to aid in debugging if required. When wethink that the multiplier is functioning properly, we will only want to look at thefinal product output so that we can quickly test a large number of cases.
Figure 20-3 shows the command file and test results for multiplying 13 /H1100311.A clock
is defined with a 20-ns period.The St signal is turned on at 2 ns and turned off one clock
VHDL for Digital System Design 655
period later. By inspection of the state graph, the multiplication requires at most ten
clocks, so the run time is set at 200 ns. The simulator output corresponds to  the exam-ple given on page 600. Note that when Done /H11005'1', the final product is 10001111
2/H11005143.
To thoroughly test the multiplier, we need to run additional tests, including spe-
cial cases and limiting cases. Test values for the multiplicand and multiplier shouldinclude 0, maximum values, and smallest nonzero values. We will write VHDL codeto test the multiplier by supplying a sequence of values for the multiplicand andmultiplier. VHDL code that is written to test another VHDL module is oftenreferred to as a test bench . Figure 20-4 shows how the test bench is connected to the
multiplier module. The test bench generates the Clk and St signals as well as sup-plying values of Mplier and Mcand to the Multiplier module. The Multiplier mod-ule, in turn, sends the Done signal and the Product values back to the test bench.Using the VHDL test bench is analogous to having a hardware tester sitting on awork bench and plugging in the multiplier module into a test socket to test it.
Multiplier
Being
Tested
ProductDoneMcandMplierStClk
Test
BenchFIGURE 20-4
Test Bench for
Multiplier
We will use a for loop within the test bench code. The syntax for a VHDL for
loop statement is
[loop-label:] forindex in range loop
sequential statements
end loop [loop-label];
The index is an integer variable that is defined only within the loop. This variable
must notbe explicitly declared because it is automatically declared by the com-
piler. When the loop is entered, the index is initialized to the first value in therange, and the sequential statements in the loop are executed. Then, the index isincremented (or decremented) to the next value, and the statements are executedagain. This continues until the index equals the last value in the range, at whichpoint the statements are executed for the last time and the loop exits. The for loopstatement is a sequential statement that can be used within a process.
The VHDL code listing for the test bench is given in Figure 20-5. The test bench
code is intended for simulation purposes only and does not have to be synthesizable.The port declaration has been omitted from the entity (lines 5–6) because we plan touse internal signals to connect the Multiplier to the test bench.The Multiplier module(mult4X4) is declared as a component within the architecture (lines 8–14). The multi-plicand and multiplier test values are placed in constant arrays dimensioned 1 to N(lines 16–18). Because we are using six pairs of values, the constant N is set to 6 (line15).The internal signals in the test bench are declared in lines 19–22. For convenience,we have used the same signal names as used in the component declaration, althoughwe do not have to do this. At the start of the architecture body, we use a componentinstantiation statement to connect the Multiplier module to the test bench signals
656 Unit 20
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. ALL;
3 useIEEE.STD_LOGIC_ARITH. ALL;
4 useIEEE.STD_LOGIC_UNSIGNED. ALL;
5 entity testmult is
6 end testmult;
7 architecture test1 oftestmult is
8 component mult4X4
9 port (CLK: instd_logic;
10 St: instd_logic;
11 Mplier, Mcand: instd_logic_vector(3 downto 0);
12 Product: outstd_logic_vector(7 downto 0);
13 Done: outstd_logic);
14 end component ;
15 constant N: integer: /H110056;
16 type arris array (1toN)ofstd_logic_vector(3 downto 0);
17 constant Mcandarr: arr: /H11005(“1011”, “1101”, “0001”, “1000”, “1111”, “1101”);
18 constant Mplierarr: arr: /H11005(“1101”, “1011”, “0001”, “1000”, “1111”,“0000”);
19 signal CLK: std_logic: /H11005’0’;
20 signal St, Done: std_logic;
21 signal Mplier, Mcand: std_logic_vector(3 downto 0);
22 signal Product: std_logic_vector(7 downto 0);
23 begin
24 mult1: mult4X4 port map (CLK, St, Mplier, Mcand, Product, Done);
25 CLK /H11021/H11005notCLKafter 10 ns; -- clock has 20 ns period
26 process
27 begin
28 foriin1toNloop
29 Mcand /H11021/H11005 Mcandarr(i);
30 Mplier /H11021/H11005 Mplierarr(i);
31 St /H11021/H11005 ‘1’;
32 wait until CLK/H11005‘1’and CLK’event;
33 St /H11021/H11005 ‘0’;
34 wait until done /H11005‘1’ ;
35 wait until CLK/H11005‘1’and CLK’event;
36 end loop ;
37 end process ;
38 end test1;FIGURE 20-5
Test Bench for
Multiplier
(line 24). The port map lists the test signals in the same order as in the component
port. The next statement generates a CLK signal with a half period of 10 ns.
The process contains a for loop that reads values from the multiplicand and mul-
tiplier arrays and then sets the start signal to '1' (lines 29–31). After the next rising
VHDL for Digital System Design 657
clock edge, the start signal is turned off. Meanwhile, the multiplication is taking place
within the Multiplier module. When the multiplication is complete, the multiplierturns on the Done signal. Done is turned off at the same time the multiplier controlgoes back to S
0. The test bench process waits for Done /H11005'1' and then waits for the
next rising clock edge before looping back to read new values of Mcand and Mplierand restart the multiplication. After N times through the loop, the test is complete.
Figure 20-6 shows the command file for executing the test bench code and
the simulator output. In the add list command line, “–Notrigger Mplier Mcandproduct” together with “–Trigger done” causes the output to be displayed onlywhen the Done signal changes. Without the –NOtrigger and –Trigger, the outputwould be displayed every time any signal on the list changed. We have annotat-
ed the simulator output to interpret the test results.
Next, we will model the same multiplier using two processes (see Figure 20-7).
This model is based on Figures 17-16 and 17-17. The first process represents the
-- Command file to test multiplierview listadd list –NOtrigger Mplier Mcand product – Trigger donerun 1320 ns
ns /H11001delta mcand mplier product done
0 /H110010 UUUU UUUU UUUUUUUU U
0 /H110011 1011 1101 UUUUUUUU 0
150 /H110012 1011 1101 10001111 1 1 1 /H1100313/H11005143
170 /H110012 1011 1101 10001111 0
330 /H110012 1101 1011 10001111 1 1 3 /H1100311/H11005143
350 /H110012 1101 1011 10001111 0
470 /H110012 0001 0001 00000001 1 1 /H110031/H110051
490 /H110012 0001 0001 00000001 0
610 /H110012 1000 1000 01000000 1 8 /H110038/H1100564
630 /H110012 1000 1000 01000000 0
810 /H110012 1111 1111 11100001 1 1 5 /H1100315/H11005225
830 /H110012 1111 1111 11100001 0
930 /H110012 1101 0000 00000000 1 1 3 /H110030/H110050FIGURE 20-6
Command File and
Simulation of
Multiplier
-- This is a behavioral model of a multiplier for unsigned binary numbers. It multiplies a 4-bit 
-- multiplicand by a 4-bit multiplier to give an 8-bit product.The maximum number of clock cycles-- needed for a multiply is 10.
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. all;
3 useIEEE.STD_LOGIC_ARITH. all;
4 useIEEE.STD_LOGIC_UNSIGNED. all;FIGURE 20-7
Two-Process
VHDL Model for
Multiplier
658 Unit 20
5 entity mult4X4 is
6 port (Clk, St: instd_logic;
7 Mplier, Mcand: instd_logic_vector(3 downto 0);
8 Product: outstd_logic_vector(7 downto 0);
9 Done: outstd_logic);
10 end mult4X4;
11 architecture control_signals ofmult4X4 is
12 signal State, Nextstate: integer range 0to9;
13 signal ACC: std_logic_vector(8 downto 0); -- accumulator
14 alias M: std_logic isACC(0); -- M isbit 0 of ACC
15 signal addout: std_logic_vector(4 downto 0); -- adder output including carry
16 signal Load, Ad, Sh: std_logic;
17 begin
18 Product /H11021/H11005 ACC(7 downto 0);
19 addout /H11021/H11005 (‘0’ & ACC(7 downto 4))/H11001Mcand;
-- uses “ /H11001” operator from the ieee._std_logic_unsigned package
20 process (State, St, M)
21 begin
22 Load /H11021/H11005 ’0’; Ad /H11021/H11005 ’0’; Sh /H11021/H11005 ’0’; Done /H11021/H11005 ’0’;
23 case State is
24 when 0/H11005/H11022
25 ifSt/H11005’1’then Load /H11021/H11005 ’1’; Nextstate /H11021/H11005 1;
26 else Nextstate /H11021/H11005 0;end if ;
27 when 1⏐3⏐5⏐7/H11005/H11022 -- “add/shift” State
28 ifM/H11005‘1’then Ad/H11021/H11005 ’1’; -- Add multiplicand
29 Nextstate /H11021/H11005 State /H110011;
30 else Sh/H11021/H11005 ’1’; Nextstate /H11021/H11005 State /H110012;end if ;
31 when 2⏐4⏐6⏐8/H11005/H11022 -- “shift” State
32 Sh /H11021/H11005 ’1’; Nextstate /H11021/H11005 State /H110011;
33 when 9/H11005/H11022 Done /H11021/H11005 ‘1’; Nextstate /H11021/H11005 0;
34 end case ;
35 end process ;
36 process (Clk) -- Register update process
37 begin
38 ifClk’event and Clk/H11005‘1’then -- executes on rising edge of clock
39 ifLoad /H11005‘1’then ACC(8 downto 4)/H11021/H11005 “00000”;
40 ACC(3 downto 0)/H11021/H11005 Mplier; end if ; -- load the multiplier
41 ifAd/H11005‘1’then ACC(8 downto 4)/H11021/H11005 addout; end if ;
42 ifSh/H11005‘1’then ACC /H11021/H11005 ‘0’ & ACC(8 downto 1);end if ;
--Shift accumulator right
43 State /H11021/H11005 Nextstate;
44 end if ;
45 end process ;
46 end control_signals;FIGURE 20-7
(Continued)
combinational circuit that generates control signals and next-state information.
The second process updates all of the registers on the rising edge of the clock. Thismodel corresponds more closely to the actual hardware than the one-processmodel of Figure 20-2, and the control signals Ld, Sh, and Ad, as well as the adderoutput, appear explicitly in the code. The port declaration is the same for the twomodels, but the architectures are different.
Because the adder is a combinational circuit, we can define the adder output in a
concurrent statement (line 19). This 5-bit output includes the 4 sum bits and the carry.It is efficient to represent the combinational part of the sequential control circuit by aprocess with a case statement (lines 20–35). This process executes whenever State (S)or M changes, and it computes the values of Nextstate, Load, St, Ad, and Done. Thefour control signals are set to '0' in line 22, and then they are set to '1' as required in thecase statement.This technique avoids the necessity of setting these signals to '0' in eachstate and in each else clause where they are not set to '1'. At first glance, setting a sig-nal to '0' and '1' at the same instant of time appears to be a conflict. However, whentwo sequential statements in a process both change the same signal at the same time,the value assigned by the second statement to execute overrides the value assigned bythe first statement.The case statement determines the values of Nextstate and the con-trol signals. For example, when state is 1, 3, 5, or 7, if M /H11005'1', the Ad signal is turned on
and the Nextstate is the present state plus 1. However, no registers can change until thenext active clock edge.
All register updates occur in the second process after the rising edge of Clk. If
Load /H11005'1', Mplier is loaded into the lower ACC and the upper ACC is cleared (lines
38–40). If Ad /H11005'1', the adder output is loaded into the upper ACC (line 41). If Sh /H11005'1'
ACC is shifted to the right (line 42). The state register is always updated (line 43).
Because the entity is the same for both multipliers, we can use the same test
bench to test the second multiplier as we did for the first one, and we shouldobtain the same test results.
Next, we will write VHDL code for a binary multiplier that multiplies two 8-bit
numbers to give a 16-bit product. For the control circuit, we will use an add-shift con-trol with a counter, as shown in Figure 18-9, instead of using a state graph with morestates. Figure 20-8 shows the block diagram for the 8 /H110038 multiplier. This is of theVHDL for Digital System Design 659
ClrSh Lin A (8:0)
A (7:0)A(0)
8-Bit
AdderAdd-Shift
ControlLd
Load0
9
8
8
Multiplicand8
Multiplier
St8ShAd
Clr 0Sh Lin B (7:0)Ld
ShLoad
Ad
Load
Sh
KM = B(0)
ClrCt3-Bit CounterLoadCoutFIGURE 20-8
Block Diagram for
8/H110038 Binary
Multiplier
660 Unit 20
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. all;
3 useIEEE.STD_LOGIC_ARITH. all;
4 useIEEE.STD_LOGIC_UNSIGNED. all;
5 entity mult8X8 is
6 Port (Clk, St: instd_logic;
7 Mplier, Mcand: instd_logic_vector(7 downto 0);
8 Done: outstd_logic;
9 Product: outstd_logic_vector(15 downto 0));
10 end mult8X8;
11 architecture Behavioral ofmult8X8 is
12 signal State, NextState: integer range 0to3;
13 signal count: std_logic_vector(2 downto 0) :/H11005“000”; -- 3-bit counter
14 signal A: std_logic_vector(8 downto 0); -- accumulator
15 signal B: std_logic_vector(7 downto 0);
16 alias M: std_logic isB(0); -- M is bit 0 of B
17 signal addout: std_logic_vector(8 downto 0);
18 signal K, Load, Ad, Sh: std_logic;
19 begin
20 Product /H11021/H11005 A(7downto 0) & B; -- 16-bit product is in A and B
21 addout /H11021/H11005 ‘0’ & A(7 downto 0)/H11001Mcand; -- adder output is 9 bits including carry
22 K /H11021/H11005 ‘1’when count /H110057else ‘0’;
23 process (St, State, K, M)
24 begin
25 Load /H11021/H11005 ‘0’; Sh /H11021/H11005 ’0’; Ad /H11021/H11005 ’0’; Done /H11021/H11005 ’0’;
-- control signals are ‘0’ by default
26 case State is
27 when 0/H11005/H11022
28 ifSt/H11005‘1’then Load /H11021/H11005 ‘1’; NextState /H11021/H11005 1;
29 else NextState /H11021/H11005 0;end if ;
30 when 1/H11005/H11022
31 ifM/H11005‘1’then Ad/H11021/H11005 ‘1’; NextState /H11021/H11005 2;
32 else if K/H11005‘0’then Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
33 else Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 3;end if ;FIGURE 20-9
VHDL Code for
Multiplier with
Shift Countersame form as Figure 18-7 except the ACC register has been split into two registers—
Aand B.Ais the 9-bit accumulator register, and Binitially holds the 8-bit multipli-
er. When the multiplication is complete, the 16-bit product is in A(7 downto 0)& B.
The controller generates signals Load ,Sh, and Ad. The Load signal clears A, loads
the multiplier into B, and clears the shift counter. The Shsignal shifts both Aand B
together and increments the counter. The Adsignal loads the adder outputs into A.
The VHDL code for the 8 /H110038 multiplier (Figure 20-9) is based on the block
diagram of Figure 20-8 and the state graph of Figure 18-9(c). The entity and sig-nal declarations are similar to those used in the previous examples except for the
VHDL for Digital System Design 661
number of bits. The signal count in line 13 represents the 3-bit counter. Line 21
implements the 8-bit adder using a concurrent statement, and line 22 sets K to 1when the count is 7. The first process (lines 23–40) represents the combinationalpart of the state machine. It generates control signals Ad, Load, and Sh whenev-er the inputs state, St, M, and K change.
To make sure that the code will synthesize properly, we have included an else
clause in each ifstatement so that the NextState is properly defined, regardless
whether the condition is TRUE or FALSE. For example, in lines 28–29 NextStateis 1 or 0 depending on the value of St. For simulation purposes, we could omit theelse clause because a VHDL signal holds its value until it is explicitly changed.However, if we omitted the else clause, most synthesizers would generate anunnecessary latch.
The second process updates the registers on the rising edge of Clk. In lines
45–48, if Load /H11005'1', the counter is cleared when the multiplier is loaded. In lines
50–53, if Sh /H11005'1', the counter is incremented when the A-B registers are shifted. In
a clocked process, the ifstatements do not need else clauses because all registers
hold their current values until changed.34 end if ;
35 when 2/H11005/H11022
36 ifK/H11005‘0’then Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
37 else Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 3;end if ;
38 when 3/H11005/H11022
39 Done /H11021/H11005 ’1’; NextState /H11021/H11005 0;
40 end case ;
41 end process ;
42 process (Clk)
43 begin
44 ifClk’event andClk/H11005‘1’then -- update registers on rising edge of Clk
45 ifload /H11005‘1’then
46 A /H11021/H11005 “000000000“; Count /H11021/H11005 “000“; -- clear A and counter
47 B /H11021/H11005 Mplier;
48 end if ; -- load multiplier
49 ifAd/H11005‘1’then A/H11021/H11005 addout; end if
;
50 ifSh/H11005‘1’then
51 A /H11021/H11005 ‘0’ & A(8 downto 1); B /H11021/H11005 A(0)& B(7 downto 1);
-- right shift A and B
52 count /H11021/H11005 count /H110011; -- increment counter
53 -- uses “ /H11001” operator from ieee_std_logic_unsigned package
54 end if ;
55 State /H11021/H11005 NextState;
56 end if ;
57 end process ;
58 end Behavioral;FIGURE 20-9
(Continued)
Figure 20-10 shows a simulator command file used to test the multiplier with
inputs 11 /H1100313. The A and B register values and the product are shown in hexadec-
imal on the resulting waveforms. The current multiplier bit (M) is the same as b(0).Note that at time /H11005240 ns, the state changes to 3, the Done signal is turned on, and
the final product is the correct answer, 8F
16/H1100514310.
20.3 VHDL Code for a Binary Divider
In Section 18.3 we designed a parallel divider for positive binary numbers that
divides an 8-bit dividend by a 4-bit divisor to obtain a 4-bit quotient. Figure 20-11shows VHDL code for the divider based on the block diagram of Figure 18-10 and662 Unit 20
0 50 ns 100 ns 150 ns 200 ns 250 ns/mult8x8/product XXXX 000D 0586 02C3 0DC3 06E1 08F0 0478 023C 011E000 001 010 011 100 101 110 11101 21 2121 3
XXX 000 005 002 00D 006 008 004 002 001
XX 0D 86 C3 E1 F0 78 3C 1E 8F
/mult8x8/done/mult8x8/b/mult8x8/a/mult8x8/count/mult8x8/state/mult8x8/b(0)/mult8x8/st/mult8x8/clk
00B 011
11E1 0B0D 008F000
000add wave  clk st state cou nt a b done product
force st 1 2 , 0 22
force clk 1 0 , 0 10 – repeat 20
force mcand 00001011
force mplier 00001101
run 280FIGURE 20-10
Command File
and Simulation of
8/H110038 Multiplier
1 library IEEE;
2 useIEEE.STD_LOGIC_1164. all;
3 useIEEE.STD_LOGIC_ARITH. all;
4 useIEEE.STD_LOGIC_UNSIGNED. all;
5 entity Divider is
6 Port (Dividend_in: in std_logic_vector(7 downto 0);
7 Divisor: instd_logic_vector(3 downto 0);FIGURE 20-11
VHDL Code for
Divider
VHDL for Digital System Design 663
8 St, Clk: instd_logic;
9 Quotient: outstd_logic_vector(3 downto 0);
10 Remainder: outstd_logic_vector(3 downto 0);
11 Overflow: outstd_logic);
12 end Divider;
13 architecture Behavioral ofDivider is
14 signal State, NextState: integer range 0to5;
15 signal C, Load, Su, Sh: std_logic;
16 signal Subout: std_logic_vector(4 downto 0);
17 signal Dividend: std_logic_vector(8 downto 0);
18 begin
19 Subout /H11021/H11005 Dividend(8 downto 4) – (‘0’ & divisor);
20 C /H11021/H11005notSubout (4);
21 Remainder /H11021/H11005 Dividend(7 downto 4);
22 Quotient /H11021/H11005 Dividend(3 downto 0);
23 State_Graph: process (State, St, C)
24 begin
25 Load /H11021/H11005 ‘0’; Overflow /H11021/H11005 ’0’; Sh /H11021/H11005 ‘0’; Su /H11021/H11005 ‘0’;
26 case State is
27 when 0/H11005/H11022
28 if(St/H11005‘1’)then Load /H11021/H11005 ’1’; NextState /H11021/H11005 1;
29 else NextState /H11021/H11005 0;end if ;
30 when 1/H11005/H11022
31 if(C/H11005‘1’)then Overflow /H11021/H11005 ’1’; NextState /H11021/H11005 0;
32 else Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 2;end if ;
33 when 2⏐3⏐4/H11005/H11022
34 if(C/H11005‘1’)then Su/H11021/H11005 ‘1’; NextState /H11021/H11005 State;
35 else Sh/H11021/H11005 ‘1’; NextState /H11021/H11005 State /H110011;end if ;
36 when 5/H11005/H11022
37 if(C/H11005‘1’)then Su/H11021/H11005 ‘1’;end if ;
38 NextState /H11021/H11005 0;
39 end case ;
40 end process State_Graph;
41 Update: process (Clk)
42 begin
43 ifClk’event and Clk/H11005‘1’then -- rising edge of Clk
44 State /H11021/H11005 NextState;
45 ifLoad /H11005‘1’then Dividend /H11021/H11005 ‘0’ & Dividend_in; end if ;
46 ifSu/H11005‘1’then Dividend(8 downto 4)/H11021/H11005 Subout; Dividend(0) /H11021/H11005 ‘1’;end if ;
47 ifSh/H11005‘1’then Dividend /H11021/H11005 Dividend(7 downto 0) & ’0’; end if ;
48 end if ;
49 end process update;
50 end Behavioral;FIGURE 20-11
(Continued)
the state graph of Figure 18-11. A concurrent statement (line 19) computes the
subtracter output, subout, using an overloaded “ /H11002”operator. Then, line 20 com-
putes C as the complement of the high order bit of the subtracter output (seeSection 18.3 for justification).
The first process (lines 23–40) represents the combinational part of the sequen-
tial circuit. It computes the values of NextState and the control signals wheneverstate, St, or C changes. As in the other examples, line 24 sets the control signals to'0', and these signals are set to '1' as required within the case statement. The secondprocess (lines 41–49) updates the state and dividend registers on the rising edge ofthe clock. If Ld /H11005'1', the 9-bit dividend register is loaded with '0' followed by the 
8-bit dividend (line 45). If Su /H11005'1', the subtracter output is loaded into the upper
part of the dividend register and the quotient bit is set to '1' (line 46). If Sh /H11005'1',
the dividend register is shifted left (line 47).
20.4 VHDL Code for a Dice Game Simulator
In this section we will write behavioral VHDL code for the dice game described inSection 19.2. The code in Figure 20-12 is based on the block diagram for theDiceGame Module in Figure 19-11 and the SM chart of Figure 19-13. The two coun-ters and the adder will be placed in a separate module, so the input to this moduleis the sum of the two counters, which represents the roll of the dice. This sum mustbe in the range 2 to 12 as declared in line 3. The Point register is a signal with thesame range (line 8). We will use a two-process model for the dice game. The firstprocess represents the combinational logic for the controller. Whenever the inputsRb, Reset, Sum, or State change, this process computes new values for NextState, forthe control signals (Sp and Roll), and for the outputs (Win and Lose). The casestatement tests the state, and in each state nested if-then-else (or elsif ) statements
implement the conditional tests. In State 1 the Roll signal is turned on when Rb is1. If all conditions test FALSE, Sp is set to 1, and the next state is 4. In the secondprocess, the state is updated after the rising edge of the clock (line 38), and if Sp is1, the sum is stored in the point register (line 39).664 Unit 20
1 entity DiceGame is
2 port (Rb, Reset, CLK: inbit;
3 Sum: ininteger range 2to12;
4 Roll, Win, Lose: outbit);
5 end DiceGame;
6 architecture DiceBehave ofDiceGame is
7 signal State, NextState: integer range 0to5;
8 signal Point: integer range 2to12;
9 signal Sp: bit;
10 beginFIGURE 20-12
VHDL Code for Dice
Game Controller
VHDL for Digital System Design 665
11 process (Rb, Reset, Sum, State)
12 begin
13 Sp /H11021/H11005 ‘0’; Roll /H11021/H11005 ‘0’; Win /H11021/H11005 ‘0’; Lose /H11021/H11005 ‘0’;
14 case State is
15 when 0/H11005/H11022ifRb/H11005‘1’then NextState /H11021/H11005 1;else NextState /H11021/H11005 0;end if ;
16 when 1/H11005/H11022
17 ifRb/H11005‘1’then Roll/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
18 elsif Sum /H110057orSum /H1100511then NextState /H11021/H11005 2;
19 elsif Sum /H110052orSum /H110053orSum /H1100512then NextState /H11021/H11005 3;
20 else Sp/H11021/H11005 ‘1’; NextState /H11021/H11005 4;
21 end if ;
22 when 2/H11005/H11022 Win/H11021/H11005 ‘1’;
23 ifReset /H11005‘1’then NextState /H11021/H11005 0;else NextState /H11021/H11005 2;end if ;
24 when 3/H11005/H11022 Lose /H11021/H11005 ‘1’;
25 ifReset /H11005‘1’then NextState /H11021/H11005 0;else NextState /H11021/H11005 3;end if ;
26 when 4/H11005/H11022ifRb/H11005‘1’then NextState /H11021/H11005 5;else NextState /H11021/H11005 4;end if ;
27 when 5/H11005/H11022
28 ifRb/H11005‘1’then Roll/H11021/H11005 ‘1’; NextState /H11021/H11005 5;
29 elsif Sum /H11005Point then NextState /H11021/H11005 2;
30 elsif Sum /H110057then NextState /H11021/H11005 3;
31 else NextState /H11021/H11005 4;
32 end if ;
33 end case ;
34 end process ;
35 process (CLK)
36 begin
37 ifCLK’event and CLK/H11005‘1’then
38 State /H11021/H11005 NextState;
39 ifSp/H11005‘1’then Point /H11021/H11005 Sum; end if ;
40 end if ;
41 end process ;
42 end DiceBehave;FIGURE 20-12
(Continued)
To complete the VHDL implementation of the dice game we will add a mod-
ule with two counters, which count from 1 to 6, and an adder as shown in Figure20-13. The counters are initialized to 1 so that the sum of the two dice will alwaysbe in the range 2 through 12. When Cnt1 is in state 6, the next clock sets it to state1, and Cnt2 is incremented (or Cnt2 is set to 1 if it is in state 6). The concurrentstatement in line 19 implements the adder.
The main module shown in Figure 20-14 connects the DiceGame and
Counter modules together. The architecture starts with two component declara-tions (lines 6–14). The internal signals that connect the two modules, roll1 andsum1, are declared in lines 15 and 16. The two components are instantiated inlines 18 and 19. These statements connect the two components to each other andto the port signals.
666 Unit 20
1entity Game is
2 port (Rb, Reset, Clk: inbit;
3 Win, Lose: outbit);
4end Game;
5architecture Play1 ofGame is
6 component Counter
7 port(Clk, Roll: inbit;
8 Sum: outinteger range 2to12);
9 end component ;
10 component DiceGame
11 port (Rb, Reset, Clk: inbit;
12 Sum: ininteger range 2to12;
13 Roll, Win, Lose: outbit);
14 end component ;
15 signal roll1: bit;
16 signal sum1: integer range 2to12;
17 begin
18 Dice: Dicegame port map (Rb, Reset, Clk, sum1, roll1, Win, Lose);
19 Count: Counter port map (Clk, roll1, sum1);
20 end Play1;FIGURE 20-14
Main Module for
Dice Game1 entity Counter is
2 port(Clk, Roll: inbit;
3 Sum: out integer range 2 to 12);
4 end Counter;
5 architecture Count ofCounter is
6 signal Cnt1,Cnt2: integer range 1 to 6 : /H110051;
7 begin
8 process (Clk)
9 begin
10 ifClk’event and Clk/H11005’1’then
11 ifRoll/H11005’1’then
12 ifCnt1 /H110056then Cnt1 /H11021/H11005 1;else Cnt1 /H11021/H11005 Cnt1 /H110011;end if ;
13 ifCnt1 /H110056then
14 ifCnt2 /H110056then Cnt2 /H11021/H11005 1;else Cnt2 /H11021/H11005 Cnt2 /H110011;end if ;
15 end if ;
16 end if ;
17 end if ;
18 end process ;
19 Sum /H11021/H11005 Cnt1 /H11001Cnt2;
20 end Count;FIGURE 20-13
Counter Module
for Dice Game
20.5 Concluding Remarks
Except for the test bench, all of the VHDL code in this chapter is synthesizable. The
synthesis results depend on the target device and synthesizer that is used. Most syn-thesizers offer the choices of optimizing for area, for speed, or for something inbetween. Optimizing for area implies fewer macrocells or function generators areused, resulting in a smaller area used on the IC chip. Optimizing for speed meansreducing the delay times along the various paths so that a higher clock speed may beused. This often results in using more components and a larger chip area.
Table 20-1 shows some typical synthesis results for five VHDL code examples
from this chapter when the optimize for area option was chosen. Results shown hereare for Xilinx CoolRunner CPLDs and for the Xilinx Spartan and Spartan IIFPGAs. The Xilinx XST synthesizer was used for CoolRunner, and the FPGAExpress synthesizer was used for Spartan. In all cases, the number of flip-flops isminimum and the same for the different devices. For CPLDs, the most importantfactors in determining the required chip area are the number of macrocells and thenumber of product terms, and the optimizer attempts to minimize these. ForFPGAs, the optimizer attempts to reduce chip area by minimizing the requirednumber of logic cells (CLBs, or slices). Each CLB or slice contains two four-inputfunction generators (also called lookup tables or LUTs) and two flip-flops. Mostdesigns require more function generators than flip-flops, so a key factor in optimiz-ing for area is to reduce the number of four-input function generators (LUTs).
In this text we have introduced the basic VHDL features needed to write
synthesizable code. In most examples, we have related the VHDL code to the actualhardware that it represents. In Unit 10, we used concurrent statements to represent
combinational logic. In Unit 17, we used sequential statements in a process to represent
sequential logic and also to represent combinational logic. In this chapter we wroteVHDL code to describe small synchronous digital systems based on their blockdiagrams and state graphs.
In the example of Figure 20-2, we wrote a behavioral model for a multiplier
using a single process to update the state and the registers on the rising clock edge.When a single process is used, it is often necessary to add concurrent statements forthe combinational outputs (the Done signal, for example) to assure proper timing.The two-process model, used in the example of Figure 20-7, is closer to the actualVHDL for Digital System Design 667
Multiplier Multiplier Multiplier Divider Dice Game
Device Fig. 20-2 Fig. 20-7 Fig. 20-9 Fig. 20-11 Fig. 20-12 /H11001
Flip-Flops 13 13 22 12 13
CoolRunner Macrocells 18 19 32 18 24
CPLD Product terms 63 61 108 70 72Spartan 4-Input LUTs 38 32 36 23 31
FPGA CLBs 20 18 19 14 16Spartan II 4-Input LUTs 30 30 35 30 30
FPGA Slices 16 15 19 16 19TABLE 20-1
Synthesis Results
(Optimized
for Area)
668 Unit 20
hardware in that it explicitly generates control signals in a combinational process
and then uses these signals to control register updates in a clocked process. We gen-erally prefer the two-process model because it introduces fewer timing problems.This is particularly important in large systems where the operation of a number ofmodules must be properly coordinated.
When writing VHDL code for synthesis, you must constantly keep in mind
that you are designing hardware, not simply writing a computer program. EveryVHDL statement that you write implies certain hardware. Poorly written VHDLcode may result in excessive amounts of hardware when synthesized, and thehardware may malfunction because of timing problems. Simulation plays animportant role in digital design using VHDL. Functional simulation before syn-thesis is important to make sure that the hardware performs the intended func-tions and that the basic design is sound. However, just because the code simulatescorrectly does not mean that the code will synthesize and implement correctly.Review of the reports generated by the synthesizer may reveal problems such asgeneration of unintended latches. After the code is implemented, a timing simu-lation of the actual hardware is desirable. This type of simulation may reveal tim-ing problems in the design, and it will help to determine the maximum clockspeed. Debugging using a simulator is generally much easier than using the actu-al hardware because the internal signals within the hardware are generally notavailable for observation.
Appendix B summarizes the syntax for all VHDL statements used in the text.
VHDL has many other features that are not discussed in this text. VHDL variables,as distinguished from signals, have not been introduced because VHDL code usingvariables may have timing problems when synthesized. Other useful features of
VHDL include procedures, functions, attributes, generics, and generate. These fea-
tures are described in references [1], [2], [3], [13], and [14].
Problems
20.1 In Figure 20-7, if St changes from '0' to '1' at time 2 ns, and a rising edge of Clk
occurs at 10 ns, in what sequence do the VHDL statements execute? ( Hint : The first
process executes more than one time.)
20.2 Write VHDL code for the 16-bit 2’s complementer described in Programmed
Exercise 18.1. Use two processes.
20.3 Modify the VHDL code of Figure 20-7 to implement the multiplier of Problem 18.5.
You may refer to the answer to Problem 18.5 for the state graph of the control unit.
20.4 Write a test bench to test the BCD-to-excess-3 code converter of Table 17-2.Test all 10
BCD digits in order, using an input stream consisting of a single constant vector (whichshould begin “00001000010 0... ” ) . Note that the order of bits is least significant bit first,
VHDL for Digital System Design 669
as in Section 16.2. (Table 16-3 is the same as Table 17-2, but with the states named dif-
ferently.) Define an expected output vector (“11000010101 0... ” ) . Set an error flag to
'1' if the actual output does not match the expected output.
20.5 For the following VHDL code, draw a block diagram of the corresponding hardware
and a state graph for the controller. If MplierData is 0101 and McandData is 1001at the first clock edge when Start is 1, how many clock cycles will it take for Doneto become 1, and what will the value of Product be when Done becomes 1?
library IEEE;
useIEEE.STD_LOGIC_1164. ALL;
useIEEE.STD_LOGIC_ARITH. ALL;
useIEEE.STD_LOGIC_UNSIGNED. ALL;
entity olorin is
Port ( Clk, Start: instd_logic;
McandData, MplierData: instd_logic_vector(3 downto 0);
Done: outstd_logic;
Product: outstd_logic_vector(7 downto 0));
end olorin;
architecture Behavioral ofolorin is
signal Init, K, Add: std_logic;
signal Sum, Accumulator: std_logic_vector(7 downto 0);
signal Mcand, Mplier: std_logic_vector(3 downto 0);
signal State, NextState: integer range 0 to2;
begin
Sum /H11021/H11005 Accumulator /H11001Mcand;
K/H11021/H11005notMplier(3) and not Mplier(2) and not Mplier(1) and not Mplier(0);
Product /H11021/H11005 Accumulator;
Process(State, Start, K)
begin
Init/H11021/H11005 ‘0’; Add /H11021/H11005 ‘0’; Done /H11021/H11005 ‘0’;
case state is
when 0/H11005/H11022
ifStart /H11005‘1’then Init/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
else NextState /H11021/H11005 0;end if ;
when 1/H11005/H11022
ifK/H11005‘1’then Done /H11021/H11005 ‘1’; NextState /H11021/H11005 2;
else Add/H11021/H11005 ‘1’; NextState /H11021/H11005 1;end if ;
when 2/H11005/H11022
ifStart /H11005‘1’then Done /H11021/H11005 ‘1’; NextState /H11021/H11005 2;
else NextState /H11021/H11005 0;end if ;
end case ;
end process ;
670 Unit 20
Process (Clk)
begin
ifClk’event and Clk/H11005‘1’then
State /H11021/H11005 NextState;
IfInit/H11005‘1’then Mcand /H11021/H11005 McandData; Mplier /H11021/H11005 MplierData;
Accumulator /H11021/H11005 “00000000“; end if ;
IfAdd/H11005‘1’then Accumulator /H11021/H11005 Sum; Mplier /H11021/H11005 Mplier – 1; end if ;
end if ;
end process ;
end Behavioral;
20.6 A digital system consists of three registers and two adders, as shown in the follow-
ing figure. An input bus is used to load the registers in sequence A,B, and C.T h e
sum of A,B, and Cis then loaded into A. Write VHDL code that describes the
system.
20.7 Modify the VHDL code of Figure 20-11 to use a counter as in Figure 20-9. You may
refer to the answer to Problem 18.6 for the state graph for the control unit.
20.8 Write a test bench for the DiceGame controller of Figure 20-12. Use the following
test sequence for sum: 7, 11, 2, 4, 7, 5, 6, 7, 6, 8, 9, 6.
20.9 Modify the VHDL code of Figure 20-11 to implement the divider of Problem 18.7.C (7:0)Adde r
CK
CK8
9
8
8LdC
B (7:0)Adde rContro l
Circuit
CK8
8LdB
A (9:0)A (7:0)LdA
LdBSt
LdC
Ad
Z (9:0)
(Output)
X (7:0)
(Inp ut)CK
0010
1010LdA
Ad01–/Ad LdA
–/LdC –/LdBSt/LdASt′/0
S1S0
S3
S2
VHDL for Digital System Design 671
20.10 Consider the multiplier of Problem 18.28.
(a) Write VHDL code that describes the multiplier.(b) Write a test bench that tests the code of Part (a). The test cases should include
at least the following: zero multiplier, maximum multiplier and maximum mul-tiplicand, and maximum multiplier and zero multiplicand.
20.11 Repeat Problem 20.10 for the multiplier of Problem 18.29. In addition to the test
cases listed in Problem 20.10, the test cases should include combinations of maxi-mum and minimum (signed) values of the multiplicand and multiplier.
Lab Design Problems
Each of these problems is designed to fit on a small CPLD or FPGA circuit boardthat has at least eight input switches, two pushbuttons, and eight LEDs. Carry outthe following steps for your assigned digital system design problem:
1.Draw a block diagram of the system showing registers, adders, MUXes, and
other components. Define the necessary control signals. Specify the sizes of reg-isters, adders, etc. Provide an active-high asynchronous reset for your design.
2.Draw a state graph for the control circuit.
3.Based on the results of Steps 1 and 2, write a behavioral VHDL description of
the system. Use one clocked process to update the state and the registers as inFigure 20-2. Compile and simulate your code.
4.Based on the results of Steps 1 and 2, write a VHDL description of the system
using control signals and two processes as in Figure 20-7. Use one combination-al process to generate the next-state and control signals. Use a clocked processto update the state and other registers. Compile and simulate your code.
5.Synthesize your VHDL code from Step 4, download it to a CPLD or FPGA
board, test it, and then demonstrate its operation.
20.A Design a divider for unsigned binary numbers that will divide a 7-bit dividend by a
4-bit divisor to give a 3-bit quotient. Assume that the start signal (St) is 1 for exactlyone clock time. When St /H110051, the dividend register should be loaded from the input
bus. On the next clock cycle, the divisor register should be loaded from the sameinput bus. Then, if the quotient would require more than 3 bits, an overflow would
occur, so V should be set to 1, and the controller should go back to the reset state.
Otherwise, the controller should generate the appropriate sequence of shift and sub-tract signals and turn on a done signal when division is complete. Use an 8-bit divi-dend register and store the quotient in the lower 3 bits of the register.
20.B Same as 20.A, except use a 3-bit divisor and a 4-bit quotient. (An overflow would
occur if the quotient would require more than 4 bits.)
20.C Same as 20.A, except use an 8-bit dividend, a 3-bit divisor, a 5-bit quotient, and a 
9-bit dividend register. (An overflow would occur if the quotient would requiremore than 5 bits.)
672 Unit 20
20.D Same as 20.A, except use an 8-bit dividend, a 5-bit divisor, a 3-bit quotient, and a 
9-bit dividend register. (An overflow would occur if the quotient would requiremore than 3 bits.)
20.E Design a multiplier for unsigned binary numbers that will multiply a 3-bit multipli-
cand by a 4-bit multiplier to give a 7-bit product. Assume that the start signal (St) is1 for exactly one clock time. When St /H110051, the multiplier register should be loaded.
After loading the multiplier, load the multiplicand into a separate register on thenext clock, and then proceed with the multiplication. Both the multiplier and multi-plicand should come from the same input bus. Inputs to this bus should come fromswitches on the FPGA board. Use an 8-bit accumulator register. The controllershould generate the appropriate sequence of add and shift signals and turn on adone signal when multiplication is complete.
20.F Same as 20.E except use a 4-bit multiplicand, a 3-bit multiplier, and a 7-bit product.
20.G Same as 20.E except use a 5-bit multiplicand, a 3-bit multiplier, an 8-bit product, and
a 9-bit accumulator.
20.H Same as 20.E except use a 3-bit multiplicand, a 5-bit multiplier, an 8-bit product, and
a 9-bit accumulator.
20.I Design an 8-bit serial adder with accumulator for signed binary numbers similar to
Figure 18-1, except provide for loading the registers and clearing the carry flip-flop.Represent signed negative numbers in 2’s complement. Assume that the start signal(St) is 1 for exactly one clock time. When St /H110051, the accumulator register should be
parallel loaded from a bus. Then, at the next clock the addend register should be
loaded from the same bus. When addition is completed, output a Done signal for
one clock time. Output an overflow signal if a 2’s complement overflow occurs.Design the control circuit using a 3-bit counter and a state graph with four states.
20.J Same as 20.I except change 8-bit to 7-bit.
20.K Same as 20.I except design a serial subtracter instead of an adder.
20.L Same as 20.I except design a serial subtracter instead of an adder and change 8-bit
to 7-bit.
20.M Design a divider for unsigned binary numbers that divides a 16-bit dividend by an
8-bit divisor to give an 8-bit quotient. Use a 17-bit dividend register and store thequotient in the lower 8 bits of the register. Also, use a 4-bit counter to count thenumber of shifts, together with a subtract-shift controller.
The following instructions only apply to 20.N, 20.O, 20.P and 20.Q:
1.Use an active-high asynchronous reset to reset the circuit at any time.
2.When you press start and then clock the circuit, the multiplicand should be
loaded in some internal register.
3.On the next clock cycle, the multiplier should be loaded into another internal
register.
4.Note that both the multiplicand and the multiplier should be loaded from
thesame 8 switches on the board. Use the least significant bits of the 8
switches to enter the multiplicand and the multiplier.
5.Once they are loaded, the circuit should cycle through the states until the
final answer is calculated.
6.Once the product is calculated, the state should not change, and a done sig-
nal should be set to high (and remain high).
20.N Design a multiplier for unsigned binary numbers that will multiply a 6-bit multipli-
cand by a 7-bit multiplier to give a 13-bit result. Assume that the start signal (St) is1 for exactly one clock time.When St /H110051, the multiplier and multiplicand should be
loaded in sequence. Use a 14-bit accumulator. The controller should generate theappropriate sequence of add and shift signals.
20.O Work Problem 20.N except use a 7-bit multiplicand and a 6-bit multiplier.
20.P Work Problem 20.N except use a 8-bit multiplicand and a 5-bit multiplier.
20.Q Work Problem 20.N except use a 5-bit multiplicand and a 8-bit multiplier
20.R Design a divider for unsigned binary numbers that will divide a 6-bit dividend by a
4-bit divisor to give a 6-bit quotient. An asynchronous reset must be used to resetthe circuit. Assume that the start signal (St) is 1 for exactly one clock cycle time.When St /H110051, the dividend should be loaded from the input bus. On the next clock
cycle the divisor should be loaded from the same input bus. Then if the divisor is 0,an overflow will occur, the V signal should be set and the controller should go backto the reset state. Otherwise, the controller should generate the appropriatesequence of shift and subtract signals and then turn on a done signal. Use an 11-bit
dividend register and store the quotient in the lower bits.You may consult Problem18.7 as a reference. You need to show only the quotient on the FPGA LEDs.
20.S Work Problem 20.R except use a 7-bit dividend and a 3-bit divisor to give a 7-bit
quotient.
20.T Design an arithmetic unit that computes W /H11005X*Y/H11001Z, where X,Yand Zare all 
4-bit unsigned numbers. X,YandZshould be read sequentially from the same input
bus. Assume that the start signal (St) is 1 exactly for one clock cycle. When St is '1',
in the first clock cycle, the Multiplier ( X) should be loaded from the bus. In the sec-
ond clock cycle, the Multiplicand ( Y) should be loaded from the same bus. Finally,
in the third clock cycle, Z (the term to be added) should be loaded. Then the statemachine should multiply XbyY. Use a 9-bit accumulator, and design the multipli-
er without using a counter. Use the overloaded addition operator to add. Use a sec-ond adder to add ZtoX*Yand store the result in the accumulator using a fourth
load signal.VHDL for Digital System Design 673
20.U Same as Problem 20.T, except that Xis a 5-bit number, Yis a 3-bit number, and Zis
a 5-bit number. Use a 9-bit accumulator.
20.V Same as Problem 20.T, except that Xis a 3-bit number, Yis a 5-bit number, and Zis
a 5-bit number. Use a 9-bit accumulator.
20.W Same as Problem 20.T, except that Xis a 6-bit number, Yis a 2-bit number, and Zis
a 6-bit number. Use a 9-bit accumulator.674 Unit 20
CHAPTER
00MOS and CMOS Logic
APPENDIX
A
Most integrated circuits designed today use MOS or CMOS logic. MOS logic is based
on the use of MOSFETs (metal-oxide-semiconductor field-effect transistors) asswitching elements. Figure A-1 shows the symbols used to represent MOSFETs. Thesubstrate (or body) is a thin slice of silicon. The gate is a thin metallic layer depositedon the substrate and insulated from it by a thin layer of silicon dioxide. A voltageapplied to the gate is used to control the flow of current between the drain and source.
In normal operation of an n-channel MOSFET, shown in Figure A-1(a), a pos-
itive voltage ( V
DS) is applied between the drain and source. If the gate voltage
(VGS) is 0, there is no channel between the drain and source and no current flows.
When VGSis positive and exceeds a certain threshold, an n-type channel is formed
between the drain and source, which allows current to flow from DtoS. Operation
of a p-channel MOSFET is similar, except VDSand VGSare negative. When VGS
assumes a negative value less than the threshold, a p-type channel is formed
between drain and source, which allows current to flow from StoD.
The symbol in Figure A-1(c) may be used to represent either a p- or n-channel
MOSFET. When this symbol is used, it is generally understood that the substrate isconnected to the most positive circuit voltage for p-channel MOSFETs (or the most
negative for n-channel). If the power supply voltage is V
DD, we will use positive logic
675Gate
(G)
+
–VGS–VDS+
nSubstrate
Source
(S)
(a)n-channel MOSFETDrain
(D)
Gate
(G)
+
–VGS–VDS+
pSubstrate
Source
(S)SourceDrain
Gate
(b) p-channel MOSFETDrain
(D)
(c) General
MOSFET s ymbolFIGURE A-1
MOSFET Symbols
676 Appendix A
(0 volts /H11005logic 0 and VDDvolts /H11005logic 1) for n-channel MOS circuits and negative
logic ( VDDvolts /H11005logic 0 and 0 volts /H11005logic 1) for p-channel MOS circuits. Using
this convention, a logic 1 applied to the gate will switch the MOSFET to the ONstate (low resistance between drain and source), and a logic 0 will switch it to theOFF state (high resistance between drain and source).
Figure A-2(a) shows a MOS inverter.When a logic 0 is applied to the gate, the MOS-
FET is in a high-resistance or OFF state, and the output voltage is approximately V
DD.
When a logic 1 is applied to the gate, the MOSFET switches to a low-resistance or ONstate, the output is connected to ground, and the output voltage is approximately 0.
Thus, the operation of the MOSFET is analogous to the operation of a switch in
Figure A-2(b) which is open when V
inis a logic 0 and closed when Vinis a logic 1. In
Figure A-2(d), a second MOSFET serves as a load resistor. The geometry of thisMOSFET and the gate voltage V
GGare chosen so that its resistance is high compared
with the ON resistance of the lower MOSFET so that the switching operation ofFigure A-2(d) is essentially the same as Figure A-2(a).
As shown in Figure A-3, MOSFETs can be connected in parallel or series to
form NOR or NAND gates. In Figure A-3(a), a logic 1 applied to AorBturns on
the corresponding transistor and Fbecomes 0. Thus F/H11032/H11005A/H11001Band F/H11005(A/H11001B)/H11032,
which is the NOR function. In Figure A-3(c), a logic 1 applied to the AandBinputs
turns on both transistors and Fbecomes 0. In this case F/H11032/H11005AB and F/H11005(AB)/H11032,
which is the NAND function. More complex functions can be realized by usingseries-parallel combinations of MOSFETs. For example, the circuit of Figure A-3(e)performs the exclusive-OR function.The output of this circuit has a conducting pathto ground, and F/H110050 if AandBare both 1 or if A/H11032andB/H11032are both 1. Thus, F/H11032/H11005AB
/H11001A/H11032B/H11032and F/H11005A/H11032B/H11001AB/H11032/H11005A⊕B.A/H11032and B/H11032are generated by inverters as in
Figure A-2(d).
CMOS (complementary MOS) logic performs logic functions using a combina-
tion of p-channel and n-channel MOSFETs. Compared with TTL or other bipolar
transistor technologies, CMOS has the advantage of much lower power consump-
tion. Figure A-4(a) shows a CMOS inverter built from a p-channel and an n-channel
MOSFET. When 0 volts (logic 0) is applied to the gate inputs, the p
-channel transis-
tor ( Q1) is on and the n-channel transistor ( Q2) is off, so the output is /H11001V(logic 1).
When /H11001V(logic 1) is applied to the gate inputs, Q1is off and Q2is on, so the output
is 0 volts (logic 0).
VDD
Vout
Vin VinVin Vout
(a)VDD
Vout
(b) (c)0
VDD≈VDD
≈ 0VDD
Vout
VinVGG
(d)FIGURE A-2
MOS Inverter
MOS and CMOS Logic 677
In the remainder of this discussion we will use a bubble at the MOSFET gate
input to indicate a p-channel transistor, which is turned on by a logic 0. No bubble
at the gate input indicates an n-channel transistor, which is turned on by a logic 1.
Figure A-4(b) shows the CMOS inverter using this bubble notation.The switch ana-log in Figure A-4(c) illustrates the operation of the inverter when the inverter inputis 0. Q
1is on and Q2is off as indicated by the closed and open switches. When theVGG
VGGVDD VDD
A
A
BA
BBA BF = (A + B )′
F = (AB)′(a) MOS NOR gate
(c) MOS N AND gate(b) Switch ana logF
F
(d) Switch ana logVDD VDD VGG VDD
BA ′
AB ′
(e) MOS exclusive-OR gateF = A + BFIGURE A-3
MOS Gates
+V
Q1
(p-channel)
Q2
(n-channel)Vout
Vin
(a)+V
Q1
(p-channel)
Q2
(n-channel)Vout
VinVin = 0
(b)+V
Vout≈ +V
(c)Vin = + V+V
Vout≈ 0
(d)FIGURE A-4 CMOS Inverter
678 Appendix A
AB F Q1Q2Q3Q4
00 /H11001V ON ON OFF OFF
0 /H11001V /H11001V ON OFF OFF ON
/H11001V0 /H11001V OFF ON ON OFF
/H11001V /H11001V 0 OFF OFF ON ON
(b) Truth tableinput is /H11001V(logic 1), Q1is off and Q2is on, as indicated by the open and closed
switches in Figure A-4(d). The following table summarizes the operation:
Vin Vout Q1Q2
0 /H11001V ON OFF
/H11001V 0 OFF ON
Figure A-5 shows a CMOS NAND gate. If AorBis 0 volts, then Q1orQ2is ON
while Q3orQ4is off, and the output is /H11001V. If AandBare both /H11001V, then Q3andQ4
are both ON while Q1andQ2are off, and the output is 0 volts. If 0 volts represents a
logic 0 and /H11001Vrepresents a logic 1, this gate performs the NAND function, as indicat-
ed by the truth table of Figure A-5(b).
+V
Q1
Q3
Q4F
BAQ2
(a) Circuit dia gramFIGURE A-5
CMOS NAND Gate
F+V
Q1
Q2
Q3 Q4BAFIGURE A-6
CMOS NOR GateFigure A-6 shows a CMOS NOR gate. If A/H110051 (/H11001V),Q1is off and Q4is on, F/H110050.
Likewise, if B/H110051,Q2is off and Q3is on, so F/H110050. Because F/H110050 when AorBis 1,
F/H11032/H11005A/H11001B, and F/H11005(A/H11001B)/H11032, which is the NOR function.
Ap-channel and n-channel transistor pair can be connected to form a CMOS trans-
mission gate (TG) as shown in Figure A-7. The two enable inputs are normally com-plements so that when En/H110051, both transistors are enabled and a low impedance path
connects AandB. When En/H110050, points AandBare disconnected. In other words, the
transmission gate acts like a switch that is closed when En/H110051 and open when En/H110050.
Two transistors are used because the p-channel transistor does a good job of transmit-
ting a logic 1 and the n-channel transistor does a good job of transmitting a logic 0.
The 2-to-1 multiplexer of Figure 9-1 can be constructed from two TGs and an invert-er, as shown in Figure A-8. When A/H110050, the upper TG is enabled so that I
0is con-
nected to F; when A/H110051, the lower TG is enabled so that I1is connected to F.
A CMOS gated D latch, as shown in Figure A-9(a), is easily constructed using two
TGs and two inverters. The switch analogs of Figures A-9(b) and (c) represent theMOS and CMOS Logic 679
D
G
DQ′
Q
Q′
QCK′
CKTG1
TG1CK
CK
CK′CK′
TG2
TG2G = 1 G = 0(a)
(b)D Q′
QTG1
TG2
(c)FIGURE A-9
CMOS Latch and
Switch AnalogsEn′
AB
En EnABFIGURE A-7
CMOS Transmission
Gate and Switch
Analog
+V
I0
I1
AA′FFIGURE A-8
CMOS Multiplexer
680 Appendix A
Q′
QD
DCK′
CKCK
CK
CK′CK′CK
CK′CK′
CK
Clock= 1Clock
(a) Construction from two latches
(b) Switch analog for Clock = 1
Q′
QD
Clock= 0
(c) Switch analog for Clock = 0FIGURE A-10
Falling-Edge-
Triggered
D Flip-FlopTGs by switches.When G/H110051, CK /H110051 and TG1is closed.Therefore, the latch is trans-
parent, and D is transmitted through the inverters to the Qoutput. When G/H110050, TG2
is closed, and the data in the latch is stored in the closed loop of the two inverters.That
is, if Q/H110050, it is still 0 after going through the two inverters, and if Q/H110051, it is still 1
after going through the two inverters. Because TG1is open, the data does not change
when Dchanges, and the latch holds the stored value of Q.
A CMOS falling-edge-triggered D flip-flop, similar to the type shown in Figure
11-15, can be constructed from two CMOS latches [Figure A-10(a)]. The switchanalogs of Figure A-10(b) and (c) illustrate the flip-flop operation. When Clock is 1,the input latch is transparent and the output latch holds the current value of Q.When
Clock goes to 0, the input latch holds its value, which is transmitted through the out-put latch to Q. Thus, Qcan only change states following the falling edge of Clock.
The technology for implementing a CMOS integrated circuit continues to
improve, resulting in smaller transistors, lower voltage levels, faster operation, andvery high density logic. When no inputs are changing, the static power dissipation isvery low. When the CMOS gates are switching, the power dissipation is proportion-al to the switching frequency. Thus, the power dissipation at a switching frequencyof l00 MHz is ten times that at 10 MHz.
CHAPTER
00VHDL Language
Summary
APPENDIX
B
Reserved words are in boldface type. Square brackets enclose optional items. Curly
brackets enclose items which are repeated zero or more times. A vertical bar (|)indicates or.Disclaimer: This VHDL summary is not complete and contains some special cases.
Only VHDL statements used in this text are listed. For a complete description ofVHDL syntax, refer to references [1] and [2].
entity declaration
entity entity-name is
port(interface-signal-declaration);
end [entity] [entity-name];
interface-signal declaration
list-of-interface-signals: mode type [: /H11005initial-value]
{;list-of-interface-signals: mode type [: /H11005initial-value]}
Note: A signal can be of mode in,out,inout ,o rbuffer .
architecture declaration
architecture architecture-name ofentity-name is
[declarations]               -- declare internal signals herebegin
architecture-body
end [architecture ] [architecture-name];
Note: The architecture body may contain component-instantiation statements,
processes, assignment statements, procedure calls, etc.
integer type declaration
type type_name is range integer_range;
signal declaration
signal list-of-signal-names : type_name [ : /H11005initial_value ];
constant declaration
constant constant_name : type_name : /H11005constant_value;
681
682 Appendix B
alias declaration
alias identifier [:identifier-type] isitem-name;
Note: Item-name can be a constant, signal, variable, file, type name, etc.
array type and object declaration
type array_type_name is array index_range ofelement_type;
signal |constant array_name: array_type_name [ : /H11005initial_values ];
component declaration
component component-name
[generic (list-of-generics-and-their types);]
port (list-of-interface-signals-and-their-types);
end component;
component instantiation (concurrent statement)
label: component-name
[generic map (generic-association-list;)]
port map (list-of-actual-signals);
Note: Use open if a component output has no connection.
signal assignment statement (sequential or concurrent statement)
signal /H11021/H11005 [transport ] expression [ after delay_time];
Note: If concurrent, the signal value is recomputed every time a change occurs on
the right-hand side. If [ after delay-time] is omitted, the signal is updated after /H9004
time. If [ transport ] is omitted, an inertial delay is assumed.
conditional assignment statement (concurrent statement only)
signal /H11021/H11005 expression1 when condition1
else expression2 when condition2
...[else expression];
selected signal assignment statement (concurrent statement only)
with expression select
signal /H11021/H11005 expression1 [ after delay_time1] when choice1,
expression2 [ after delay_time2] when choice2,
...
[expression [ after delay_time] when others ];
process statement (with sensitivity list)
[process-label:] process (sensitivity-list)
[declarations]                   --signal declarations not allowed
begin
sequential statements
end process [process-label];
Note: This form of process is executed initially and thereafter only when an item on the
sensitivity list changes value. The sensitivity list is a list of signals. No wait statementsare allowed.
process statement (without sensitivity list)
[process-label:] process
[declarations]                   --signal declarations not allowed
begin
sequential statements
end process [process-label];
Note: This form of process must contain one or more wait statements. It starts exe-
cution immediately and continues until a wait statement is encountered.
wait statements
wait on sensitivity-list;
wait until Boolean-expression;
wait for time-expression;
if statement (sequential statement only)
ifcondition then
sequential statements
{elsif condition then
sequential statements }  -- 0 or more elsif clauses may be included
[else sequential statements]
end if;
case statement (sequential statement only)
case expression is
when choice1 /H11005> sequential statements
when choice2 /H11005> sequential statements
...[when others /H11005> sequential statements]
end case;
for loop statement (sequential statement only)
[loop-label:] forindex inrange loop
sequential statements
end loop [loop-label];
Note: You may use exit to exit the current loop.
report declaration
report string-expression
[severity severity-level];
VHDL Libraries and Packages
VHDL libraries and packages are used to extend the functionality of VHDL by
defining types, functions, components, and overloaded operators. The syntax forlibraries and packages is as follows:
library declaration
library list-of-library names;VHDL Language Summary 683
684 Appendix B
use statement
uselibrary _name.package_name.item; (.item may be .all)
package declaration
package package-name is
package declarations
end [package ][package-name];
package body
package body package-name is
package body declarations
end [package body ][package name];
When working with bits and bit_vectors, you may use the following declarations:library BITLIB;
useBITLIB.bit_pack. all;
The bit_pack package includes functions and components that work with signals of
type bit and bit_vector. For example, the function call  vec2int(A) converts abit_vector A to an integer. The CD contains a complete listing of bit_pack.
When working with std_logic and std_logic_vectors, the following declarations
are re quired:
library IEEE;
useIEEE.std_logic_1164. all;
The std_logic_1164 package defines the types std_logic and std_logic_vector, a res-
olution function for these types, conversion functions, and overloaded operators forlogic operations. It does not define overloaded operators for arithmetic operations.
In order to perform arithmetic operations on std_logic_vectors, you may add
the declaration
useIEEE.std_logic_unsigned. all;
Although this package is found in the IEEE library, it was written by Synopsis and
it is not an IEEE standard. This package treats std_logic_vectors as if they wereunsigned numbers and provides overloaded arithmetic operators for /H11001,/H11002,* ,/H11005,//H11005,
/H11022,/H11022/H11005,/H11021, and /H11021/H11005. For “ /H11001” and “ /H11002” if the left operand is a std_logic_vector, the
right operand can be the same type, integer type, or std_logic type. For the compar-ison operators, the right operand can be a std_logic_vector or an integer. The func-tion call CONV_INTEGER(A) converts a std_logic_vector A to an integer.
As an alternative to using std_logic_vectors and the overloaded operators
defined in the std_logic_unsigned package, type unsigned may be used. Unsignedtype is defined in the Synopsis package std_logic_arith and in the IEEE packagenumeric_std. To use the former, add the declaration
useIEEE.std_logic_arith. all;
A vector of type unsigned is similar to a std_logic_vector in that it is an array of
std_logic bits, but it has its own overloaded arithmetic operators. Operators for /H11001,/H11002,
*,/H11005,//H11005,/H11022,/H11022/H11005,/H11021, and /H11021/H11005 are defined in the std_logic_arith package for various
combinations of left and right operands. Unfortunately, logic operators AND, OR,and NOT are not defined for unsigned vectors in this package, so C /H11021/H11005 A/H11001B;
works for unsigned vectors, but C /H11021/H11005 Aand B; is not allowed without calling type
conversion functions. Some type conversion functions available in this package areas follows:
conv_integer(A)    converts an unsigned vector A to an integerconv_std_logic_vector(A)   converts an unsigned vector A to a std_logic_vectorconv_unsigned(B, N)   converts an integer B to an unsigned vector of length N
Conversion of a std_logic_vector to unsigned is not defined.
The IEEE numeric_std package, which actually is an IEEE standard, overcomes
a number of the deficiencies in the std_logic_arith package. The statement
useIEEE.numeric_std. all;
invokes this package. It defines unsigned type and overloaded operators for arith-metic and comparison operations in a way similar to the std_logic_arith package,but in addition it defines overloaded operators for logic operations on unsigned vec-tors. Useful conversion functions in the package include
TO_INTEGER(A)   converts an unsigned vector A to an integerTO_UNSIGNED(B, N)   converts an integer to an unsigned vector of length N
The only significant deficiency is that this package does not define an overloaded
operator for adding a std_logic bit to an unsigned type.Thus, a statement of the form
sum/H11021/H11005 A/H11001B/H11001carry;
is not allowed when carry is of type std_logic. The carry must be converted to aninteger before it can be added to the unsigned vector A /H11001B.
We have used the std_logic_unsigned package in many examples in this book
because it is easy to use. For complex VHDL projects, we recommend using thenumeric_std package. Most VHDL simulators and synthesizers work well witheither package.VHDL Language Summary 685
686CHAPTER
00Tips for writing
Synthesizable VHDLCode
APPENDIX
C
One of our goals throughout this text is to write VHDL code that not only simulates
correctly but also synthesizes correctly to implement hardware that works correctly.First and foremost, always remember that when you write VHDL code you are notwriting a computer program; you are describing hardware. If you are designing amultiplier for binary numbers, do not simply write a program to multiply binarynumbers. Instead think in terms of what registers are required and what sequence ofoperations on these registers will produce the desired result.
VHDL code that simulates correctly will not always implement correctly in
hardware. A frequent cause of problems is the creation of unintended latches. Eventhough code simulates correctly, the presence of latches may cause timing problemswhen the code is actually implemented in hardware. After synthesizing your code,check the synthesis report to make sure no latches are present. If latches are pres-ent, check your code for the following:
1.Counters, shift registers, flip-flops, and other devices that change state in
response to a clock edge must be updated only in a clocked process. The stateof these devices should never be changed in a combinational process or in aconcurrent statement. All state changes for a given device must be specifiedwithin the same process.Example: count /H11021/H11005 count /H11001 1; should not appear in a combinational process.
When this statement, which increments a counter, is placed in a clocked process,any statement that clears the counter must be placed in the same process.
2.If a combinational process sets control signals to '1' at various places in a case state-
ment, all of these signals should be set to '0' before the start of the case statement.
3.For every ifstatement in a combinational process, check each signal that is
assigned a value in the then clause. If such a signal is not assigned a value in
step 2, then make sure that it is assigned a value in the else clause.
Example: ifSt/H11005'1'then nextstate /H11021/H110051; load /H11021/H11005'1';end if; will create a latch
because nextstate is not defined when St /H11005'0'. To eliminate the latch write 
ifSt/H11005 '1'then nextstate /H11021/H11005 1; load /H11021/H11005 '1';else nextstate /H11021/H11005 0;end if;
This assumes that load is set to '0' in step (2).
Do not attempt to set the same signal to two different values in two different
processes or in a process and in a concurrent statement.
Tips for writing Synthesizable VHDL Code 687
A/H11021/H11005 '0'; is a concurrent statement, and A /H11021/H11005 B; is another concurrent state-
ment or a sequential statement in a process. These statements can attempt to setA to two different values at the same time. If A and B are bit signals, when youtry to simulate, you will get an error message that a signal has multiple drivers.That means a conflict exists because A could be driven to '0' and to '1' at thesame time. If A and B are std_logic, the conflict still exists, but you will not getthe error message. Instead, during simulation A will assume the value 'X'(unknown) if the simulator tries to set A to '0' and '1' at the same time. In bothcases, the code will not synthesize properly because it does not correspond to anyreal hardware.
Also consider the following example:
-- Example of what NOT TO DO : output A is assigned values
-- in a concurrent statement and in a processes.
entity two_drivers is
port (B,clk,reset : inbit; A : outbit);
end two_drivers;
architecture archoftwo_drivers is
begin
A/H11021/H11005 ‘0’when reset /H11005‘0’;
process (clk)
begin
ifclk’event and clk/H11005‘0’then
A/H11021/H11005 B;end if;
end process;
end arch;
In this example, A is supposed to represent a flip-flop that is reset to '0' when
the signal reset is '0' and set equal to B on the falling clock edge. Althoughthis code has correct syntax, it will not simulate properly because the two state-ments that change A occur as a concurrent statement and also as a sequential state-ment in a process so that A has two drivers. If the signals are std_logic instead ofbits, A will assume a value of 'X' at times during the simulation. The code will notsynthesize because all statements that change the output of flip-flop A must beplaced in the same process. This also would apply if A were a register or a counter.
Excercise
Change the preceding code so that the reset signal will work properly.
An easy way to write synthesizable VHDL code to perform arithmetic
operations is to represent binary numbers as std_logic_vectors so that over-loaded operators can be used. This is explained on pages 305–306 of the text.Example
688 Appendix C
Overloaded /H11001and – operators cannot be used with bit vectors. If you use over-
loaded operators with std_logic_vectors in your VHDL code, place the follow-ing declarations at the start of your code:
library IEEE; -- this library contains several useful 
-- packages
useIEEE.std_logic_1164. all; -- this package defines std_logic,
-- std_logic_vectors and logic  -- operations on these types
useIEEE.std_logic_unsigned. all; -- this package defines overloaded
-- operators for std_logic_vectors
Remember that the VHDL operators /H11001,/H11002, and & have the same precedence
and will be applied from left to right as they appear in a VHDL statement.
Thus A /H11021/H11005 B/H11001C&D; is treated as A /H11021/H11005 (B/H11001C)&D;
If you want to do concatenation first, you must use parentheses.A/H11021/H11005 B/H11001(C&D);
689CHAPTER
00Proofs of Theorems
APPENDIX
D
Finding Essential Prime Implicants
Section 5.4 presents a method for finding all of the essential prime implicants which
is based on finding adjacent 1’s on a Karnaugh map. The validity of the method isbased on the following theorem:
If a given minterm m
jofFand all of its adjacent minterms are covered by a sin-
gle term pj, then pjis an essential prime implicant of F.
Proof:
1.Assume pjisnotaprime implicant. Then, it can be combined with another
term pkto eliminate some variable xiand form another term which does not
contain xi. Therefore, xi/H110050 in pjandxi/H110051 in pk, or vice versa. Then, pkcov-
ers a minterm mkwhich differs from mjonly in the variable xi. This means
that mkis adjacent to mj, but mkis not covered by pj. This contradicts the
original assumption that all minterms adjacent to mjare covered by pj;
therefore, pjis a prime implicant.
2.Assume pjisnot essential. Then, there is another prime implicant phwhich
covers mj. Because phis not contained in pj,phmust contain at least one
minterm which is adjacent to mjand not covered by pj. This is a contradic-
tion, so pjmust be essential.
State Equivalence Theorem
The methods for determining state equivalence presented in Unit 15 are based
on Theorem 15.1:
Two states pandqof a sequential network are equivalent if and only if for every
single input x,the outputs are the same and the next states are equivalent.
Proof: We must prove both part 1, the “if” part of the theorem, and part 2, the
“only if” part.
689
1.Assume that /H9261(p, x)/H11005/H9261(q, x) and /H9254(p, x)≡ /H9254(q, x) for every input x.Then,
from Definition 15.1, for every input sequence X,
/H9261[/H9254(p, x),X]/H11005/H9261[/H9254(q, x),X].
For the input sequence Y/H11005xfollowed by X, we have
/H9261(p, Y)/H11005/H9261(p, x) followed by /H9261[/H9254(p, x),X)]
/H9261(q, Y)/H11005/H9261(q, x) followed by /H9261[/H9254(q, x),X)]
Hence, /H9261(p, Y )/H11005/H9261 (q, Y ) for every input sequence Y, and p≡qby
Definition 15.1.
2.Assume that p≡q.Then, by Definition 15.1, /H9261(p, Y)/H11005/H9261(q, Y ) for every
input sequence Y. Let Y/H11005xfollowed by X. Then,
/H9261(p, x)/H11005/H9261(q, x) and /H9261[/H9254(p, x),X]/H11005/H9261[/H9254(q, x),X]
for every sequence X. Hence, from Definition 15.1, /H9254(p, x)≡/H9254(q, x).690 Appendix D
691↓↓note borrow from column 1
↓↓note borrow from column 2
↓↓note borrow from column 3UNIT 1 Study Guide Answers
2. (e) Two of the rows are: 1110 16 14 E
1111 17 15 F
3. (b) 11002/H110021012/H11005[1/H1100323/H110011/H1100322/H110010/H1100321/H110010/H1100320]
/H11002[1 /H1100322/H110010/H1100321/H110011/H1100320]
/H11005[1/H1100323/H110011/H1100322/H11001(0/H110021)/H1100321/H11001(10/H110010)/H1100320]
/H11002[1 /H1100322/H11001 0/H1100321/H11001 1/H1100320]
/H11005[1/H1100323/H11001(1/H110021)/H1100322/H11001(10/H110021)/H1100321/H1100110/H1100320]
/H11002[1 /H1100322/H11001 0/H1100321/H11001 1/H1100320]
/H11005[(1/H110021)/H1100323/H11001(10/H110020)/H1100322/H110011/H1100321/H1100110/H1100320]
/H11002[1 /H1100322/H110010/H1100321/H110011/H1100320]
/H11005[0 /H1100323/H11001 1/H1100322/H110011/H1100321/H110011/H1100320]/H110051112
5. (f) sign & mag: /H110020, 2’s comp: /H1100232, 1’s comp: /H1100231
(g) Overflow occurs when adding n-bit numbers and the result requires n/H110011
bits for proper representation. You can tell that an overflow has occurredwhen the sum of two positive numbers is negative or the sum of two negativenumbers is positive.A carry out of the last bit position does notindicate that an overflow has occurred.
6. (a) BCD: 0001 1000 0111
excess-3: 0100 1011 1010
6-3-1-1: 0001 1011 1001
2-out-of-5: 00101 10100 10010
UNIT 1 Answers to Problems
1.1 (a) 2F5.4016/H11005001011110101.010000002
(b) 7B.2B16/H1100501111011.001010112
(c) 164.E316/H11005000101100100.111000112
(d) 427.816/H11005010000100111.10002
691Answers to Selected 
Study Guide Questions and Problems
APPENDIX
E
692 Appendix E
1.2 (a) 7261.38/H110053761.410, EB1.616/H110053761.410
(b) 2635.68/H110051437.810, 59D.C16/H110051437.810
1.3 3252.10026
1.4 (a) 5B1.1C16(b) 010110110001.000111002/H110052661.0708
(c) 112301.01304 (d) 3564.610
1.5 (a) Add: 11001. Subtract: 0101. Multiply: 10010110.
(b) Add: 1010011. Subtract: 011001. Multiply: 11000011110.(c) Add: 111010. Subtract: 001110. Multiply: 1100011000.
1.6 (a) 1111 (b) 111 1 (c) 11111 1
11110100 1110110 10110010
/H110021000111 /H11002111101 /H11002111101
10101101 0111001 01110101
1.7 2’s complement:
(a) 010101 (b) 110010 (c) 100111
/H11001001011 /H11001100000 /H11001010010
100000 (1) 010010 111001
OVERFLOW! OVERFLOW!
(d) 110100 (e) 110101
/H11001001101 /H11001101011
(1) 000001 (1) 100000
1’s complement:
(a) 010101 (b) not assigned (c) 100110
/H11001001011 because –32 cannot /H11001010010
100000 be represented 111000
OVERFLOW! in 6 bits
(d) 110011 (e) 110100
/H11001001101 /H11001101010
(1) 000000 (1) 011110
/H11001 1 /H11001 1
000001 011111
OVERFLOW!
1.8 For a word length of N, the range of 2’s complement numbers that can be repre-
sented is /H110022N/H110021to 2N/H110021/H110021.
So, for a word length of 8, the range is /H1100227to 27/H110021, or /H11002128 to 127 . Because 1’s
complement has a “negative zero” (11111111) in addition to zero (00000000), thevalues that can be represented range from /H11002(2
7/H110021) to 27/H110021, or /H11002127 to 127 .
1.9 Dec. 7-3-2-1 3659
0 0000 0011 0111 0110 10101 0001 or2 0010 01003 0011 or 01004 01015 01106 0111
Answers to Selected Study Guide Questions and Problems 693
7 1000
8 10019 1010
UNIT 2 Study Guide Answers
2. (d) 1; 0; 1; 1 (e) 1, 1; 0, 0; 0; 1
3. (a) four variables, 10 literals (d) F/H11005(A/H11032B)/H11032 (e)F/H11005(A/H11001B/H11032)C
(f)Circuit should have two OR gates, three AND gates, and three inverters.
4. (b) A,0 ,0 , A;A,1 ,A,1
6. (c) Z/H11005ABC
7. (a) Sum of products
NeitherProduct of sums (Here, AandB/H11032are each considered to be separate terms in
the product.)Neither
(b) Fewer terms are generated.(c)D[A/H11001B/H11032(C/H11001E)]/H11005D(A/H11001B/H11032)(A/H11001C/H11001E)
8. (a) AE/H11001B/H11032C/H11032/H11001C/H11032D (b)C/H11032DE/H11001AB/H11032CD/H11032E
10. (a) a/H11032/H11001b/H11001c (b)ab/H11032c/H11032
d (c)a(b/H11032/H11001c/H11032)
(d) ( a/H11001b)(c/H11032/H11001d/H11032) (e) a/H11032/H11001b(c/H11001d/H11032)
UNIT 2 Answers to Problems
2.1 (a) X(X/H11032/H11001Y)/H11005XX/H11032/H11001XY/H110050/H11001XY/H11005XY
(b)X/H11001XY/H11005X(1/H11001Y)/H11005X(1)/H11005X
(c)XY/H11001XY/H11032/H11005X(Y/H11001Y/H11032)/H11005X(1)/H11005X
(d) ( A/H11001B)(A/H11001B/H11032)/H11005AA /H11001AB/H11032/H11001AB /H11001BB/H11032/H11005A/H11001AB/H11032/H11001AB /H11001BB/H11032
/H11005A(1/H11001B/H11001B/H11032)/H110010/H11005A(1)/H11005A
2.2
=
(a)X YX
X=
(b)Y Y ZX X
ZX
2.3 (a) 1 (Theorem 5)
(b)CD/H11001AB/H11032E(Theorem 8D) (technically, we also used Theorem 3D)
(c)AF(Theorem 9) (d) C/H11001D/H11032B/H11001A/H11032(Theorem 11D)
(e)A/H11032B/H11001D(Theorem 10D) (f) A/H11001BC/H11001DE/H11001F(Theorem 11D)
2.4 (a) F/H11005A/H11001E/H11001BCD (one AND gate and one OR gate with three inputs)
(b)Y/H11005A/H11001B
2.5 (a) ACD /H11032/H11001BE (b)A/H11032B/H11032/H11001A/H11032D/H11032/H11001C/H11032B/H11032/H11001C/H11032D/H11032
2.6 (a) ( A/H11001C/H11032)(A/H11001D/H11032)(B/H11001C/H11032)(B/H11001D/H11032) (b) X(W/H11001Z)(W/H11001Y)
(c) ( A/H11032/H11001E)(B/H11001E)(C/H11001E)(A/H11032/H11001D/H11001F)(B/H11001D/H11001F)(C/H11001D/H11001F)
694 Appendix E
(d)Z(W/H11032/H11001X)(Q/H11032/H11001W/H11032/H11001Y) (e) ( A/H11032/H11001D/H11032)(C/H11001D/H11032)
(f) ( A/H11001B/H11001D)(A/H11001C/H11001D)(A/H11001B/H11001E)(A/H11001C/H11001E)
2.7
D
A
B
CE
F
(a)+U
X
Y
ZV
W
(b)+
2.8 (a) ABC /H11001ABD /H11032 (b)A/H11032B/H11032/H11001A/H11032CD/H11032 (c)A/H11032BC/H11032
2.9 (a) F/H11005A/H11032B (b)G/H11005T/H11032
UNIT 3 Study Guide Answers
1. (b) ( b/H11032/H11001d)(b/H11001a)(b/H11001c)( a/H11001d)(b/H11001d)(a/H11032/H11001b/H11032/H11001c)
(c)w/H11032y/H11032/H11001x/H11032y/H11032z/H11032/H11001xy/H11001wyz
5. (b) A/H11032B/H11032C/H11001BC/H11032D/H11032/H11001AB/H11032D/H11032/H11001BCD
(c) Add BCD ; eliminate A/H11032BD,ABC
UNIT 3 Answers to Problems
3.6 (a) WY/H11032X/H11001WY/H11032Z/H11032/H11001W/H11032X/H11032Y/H11001W/H11032X/H11032Z (b)A/H11032D/H11001AC
3.7 (a) ( C/H11032/H11001D)(C/H11001D/H11032/H11001B/H11032)
(b) ( D/H11032/H11001A/H11032/H11001B/H11032)(D/H11032/H11001C/H11001B/H11032)(D/H11001A/H11001C/H11032)(D/H11001A/H11032/H11001B)
3.8F/H11005(AB)⊕[(A≡D)/H11001D]/H11005A/H11032/H11001BD/H11032/H11001B/H11032D
3.9 No. Consider A/H110051,B/H110051,C/H110050 or A/H110051,B/H110050,C/H110051.
3.10 (a) W/H11032X/H11001WY/H11032Z/H11001WYZ /H11032 (b)BD/H11001A/H11032BC/H11001AB/H11032/H11001AC/H11032
(c) ( A/H11001C/H11001D)(A/H11032/H11001C/H11032/H11001D/H11032)(B/H11001C/H11032/H11001D)
3.11 AE/H11032/H11001AC/H11032/H11001B/H11032/H11001CD/H11032/H11001D/H11032E/H11032
3.12 A/H11032CD/H11032E/H11001A/H11032B/H11032D/H11032/H11001ABCE /H11001ABD /H11005A/H11032CD/H11032E/H11001BCD /H11032E/H11001A/H11032B/H11032D/H11032/H11001
ABCE /H11001ABD /H11005A/H11032B/H11032D/H11032/H11001ABD /H11001BCD /H11032E
UNIT 4 Study Guide Answers
2. (d) ab/H11032c/H11032d (e)a/H11001b/H11001c/H11032/H11001d/H11032
(g) ( a/H11001b/H11032/H11001c)(a/H11032/H11001b/H11001c/H11032)(a/H11032/H11001b/H11032/H11001c)(a/H11032/H11001b/H11032/H11001c/H11032)
3. (c) m0/H11001m1/H11001m3/H11001m4/H11005/H9018 m(0, 1, 3, 4) M2M5M6M7/H11005/H9016  M(2, 5, 6, 7)
4. (b) m19 (c)A/H11032BCD /H11032E
(e)M19 (f) ( A/H11001B/H11032/H11001C/H11032/H11001D/H11001E/H11032)
5. (a) 65536
(d) ( a0m0/H11001a1m1/H11001a2m2/H11001a3m3)(b0m0/H11001b1m1/H11001b2m2/H11001b3m3)/H11005.../H11005
a0b0m0/H11001a1b1m1/H11001a2b2m2/H11001a3b3m3
(f)f/H11005/H9016  M(2, 5, 6) f/H11032/H11005/H9018 m(2, 5, 6) /H11005/H9016  M(0, 1, 3, 4, 7)
6. (b) /H9018m(0, 5) /H11001/H9018 d(1, 3, 4)
Answers to Selected Study Guide Questions and Problems 695
UNIT 4 Answers to Problems
4.1 (a) U: Safe unlocked, J: Mr. Jones present, E: Mr. Evans present, B: Normal
business hours, S: Security guard present
U/H11005(J/H11001E)BS
(b) O: Wear overshoes, A: You are outside, R: Raining heavily, S: Wearing
suede shoes, M: Mother tells you to
O/H11005ARS /H11001M
(c)L: Laugh at joke, F: It is funny, G: Good taste, O: Offensive, P:Told by professor
L/H11005FGO /H11032/H11001PO/H11032
(d)D: Elevator door opens, S: Elevator is stopped, F: Level with floor,
T: Timer expired, B: Button pressed
D/H11005SFT/H11032/H11001SFB
4.2 (a) Y/H11005A/H11032B/H11032C/H11032D/H11032E/H11032/H11001AB/H11032C/H11032D/H11032E/H11032/H11001ABC /H11032D/H11032E/H11032orY/H11005C/H11032
(b) Z/H11005ABC /H11032D/H11032E/H11032/H11001ABCD /H11032E/H11032/H11001ABCDE /H11032orZ/H11005BE/H11032
4.3F1/H11001F2/H11005/H9018 m(0, 3, 4, 5, 6, 7); General rule: F1/H11001F2is the sum of all minterms
which are present in either F1orF2, because F1/H11001F2/H11005/H9018 aimi/H11001/H9018 bimi/H11005
/H9018(ai/H11001bi)mi
4.4 (a) 16
(b) F(x,y)/H110050,x/H11032y/H11032,x/H11032y,x/H11032,xy/H11032,y/H11032,x/H11032y/H11001xy/H11032,x/H11032/H11001y/H11032,xy,x/H11032y/H11032/H11001xy,y,x/H11032/H11001y,
x,x/H11001y/H11032,x/H11001y,1
4.5 ABC DE F
000 11X
001 XX1
010 XXX0 1 1 X X 1 o r11X100 X00101 XX1
110 XXX
111 X00o r 0 X 0
4.6 (a) F/H11005A/H11032B/H11032/H11001AB(d1/H110051,d5/H110050) (b) G/H11005C(d2/H110050,d6/H110050)
4.7 (a) /H9018m(1, 2, 4) (b) /H9016M(0, 3, 5, 6, 7)
4.8 (a) F/H11005A/H11032B/H11032C/H11032D/H11032/H11001 A/H11032B/H11032C/H11032D/H11001A/H11032B/H11032CD/H11032/H11001 A/H11032B/H11032CD /H11001A/H11032BC/H11032D/H11032/H11001
A/H11032BC/H11032D/H11001A/H11032BCD /H11032/H11001AB/H11032C/H11032D/H11032/H11001AB/H11032C/H11032D/H11001ABC /H11032D/H11032
F/H11005/H9018 m(0, 1, 2, 3, 4, 5, 6, 8, 9, 12)
(b) F/H11005(A/H11001B/H11032/H11001C/H11032/H11001D/H11032)(A/H11032/H11001B/H11001C/H11032/H11001D)(A/H11032/H11001B/H11001C/H11032/H11001D/H11032)
(A/H11032/H11001B/H11032/H11001C/H11001D/H11032)(A/H11032/H11001B/H11032/H11001C/H11032/H11001D)(A/H11032/H11001B/H11032/H11001C/H11032/H11001D/H11032)
F/H11005/H9016 M(7, 10, 11, 13, 14, 15)
4.9 (a) F/H11005/H9018 m(0, 1, 4, 5, 6) (b) F/H11005/H9016 M(2, 3, 7)
(c)F/H11032/H11005/H9018 m(2, 3, 7) (d) F/H11032/H11005/H9016 M(0, 1, 4, 5, 6)
4.10 (a) F/H11005/H9018 m(1, 4, 5, 6, 7, 10, 11)
(b)F/H11005/H9016 M(0, 2, 3, 8, 9, 12, 13, 14, 15)
(c)F/H11032/H11005/H9018 m(0, 2, 3, 8, 9, 12, 13, 14, 15)
(d)F/H11032/H11005/H9016 M(1, 4, 5, 6, 7, 10, 11)
696 Appendix E
4.11 (a) di/H11005xi⊕yi⊕bi
bi/H110011/H11005bix/H11032i/H11001x/H11032iyi/H11001biyi
xi′
yi
xi′
bi
yi
bibi + 1xiyi dibi
(b)di/H11005si,bi/H110011is the same as ci/H110011with xireplaced by x/H11032i
4.12
FA
FAy3 x3
z3
s3FA
FAy2 x2
z2
s2FA
FAy1 x1
z1
s1FA
FAy0 x0
z0
s0C0 = 1C0 = 0
UNIT 5 Study Guide Answers
3. (d) 6, 10, 12, 15; 0, 12, 9, 10
(g)f1/H11005a/H11032b/H11001bc/H11032/H11001a/H11032cd/H11001ac/H11032df2/H11005b/H11032c/H11001cd/H11001a/H11032bd/H11001ab/H11032d/H11032
4. (a) a/H11032b/H11032d/H11032,b/H11032c/H11032d/H11032,ac/H11032d/H11032,ac/H11032d, also a/H11032b/H11032cd, and all the other minterms.
(b)AB/H11032C/H11032andAC/H11032Dare prime implicants.
5. (a) 4 (c) We cannot determine if B/H11032C/H11032is essential.
(f) Yes (i) A/H11032D/H11032because of m4,B/H11032D/H11032because of m10
6. (b) A/H11032D/H11032is not essential because all of its minterms are covered by other prime
implicants. BC/H11032is essential because of m13.B/H11032CDis essential because of m11.
Minimum sum /H11005B/H11032CD/H11001BC/H11032/H11001BD/H11032/H11001A/H11032B/H11032.
(d)A/H11032C/H11032/H11001ACD /H11001{ABorBC/H11032}
8. (a) F/H11005AB/H11032D/H11032/H11001B/H11032D/H11032E/H11032/H11001A/H11032BDE (b) 8, 16, 25, 26, 28
(d)P1/H11001P2/H11001P3/H11001P4/H11001BCDE /H11001AC/H11032E
(f)AC/H11032E/H11032/H11001A/H11032DE/H11001ACE /H11001B/H11032CE/H11001(AB/H11032CorADE /H11032orACD orAB/H11032E/H11032)
UNIT 5 Answers to Problems
5.3 (a) f/H11005bc/H11032/H11001a/H11032c/H11032/H11001ab/H11032c (b)f/H11005e/H11032f/H11032/H11001d/H11032e/H11032/H11001d/H11032f/H11032
(c)f/H11005r/H11032/H11001t/H11032 (d)f/H11005y/H11001x/H11032z/H11001xz/H11032
5.4 (a)
(b)F/H11005D/H11032/H11001B/H11032C/H11001AB
(c)F/H11005(A/H11001B/H11032/H11001D/H11032)(B/H11001C/H11001D/H11032)
5.5 (a) C1C2X1X2 Z
00 00 0
00 01 100 10 100 11 101 00 0
01 01 1
01 10 101 11 010 00 010 01 0
10 10 0
10 11 111 00 111 01 0
11 10 011 11 1
(b)Z/H11005C1/H11032X1/H11032X2/H11001C1/H11032X1X2/H11032/H11001C1X1X2/H11001C1C2X1/H11032X2/H11032/H11001{C1/H11032C2/H11032X2or
C1/H11032C2/H11032X1orC2/H11032X1X2}
5.6 (a) f/H11005a/H11032d/H11001a/H11032b/H11032c/H11032/H11001b/H11032cd/H11001abd/H11032/H11001{a/H11032bcorbcd/H11032}
a/H11032d→m5;a/H11032b/H11032c/H11032→m0;b/H11032cd→m11;abd/H11032→m12
(b)f/H11005bd/H11001a/H11032c/H11001b/H11032d/H11032/H11001{a/H11032bora/H11032d/H11032}
bd→m13,m15;a/H11032c→m3;b/H11032d/H11032→m8,m10
(c)f/H11005c/H11032d/H11032/H11001a/H11032d/H11032/H11001b/H11032
c/H11032d/H11032→m12;a/H11032d/H11032→m6;b/H11032→m10,m11
5.8 (a) f/H11005a/H11032b c/H11032/H11001a c/H11032d/H11001b/H11032c d/H11032;f/H11005(b/H11032/H11001c/H11032)(c/H11032/H11001d/H11032)(a/H11001b/H11001c)(a/H11032/H11001c/H11001d)
(b)f/H11005a/H11032b/H11032d/H11001bc/H11032d/H11032/H11001cd;f/H11005(b/H11001d)(b/H11032/H11001d/H11032)(a/H11032/H11001c){(b/H11032/H11001c/H11032)or(c/H11032/H11001d)}1
01
41
12100 01 11 10
8
0
10
51
130
9
1
30
71
151
11
100CDAB
01
1110
21
61
141
10Answers to Selected Study Guide Questions and Problems 697
698 Appendix E
5.10 (a) C/H11032D/H11032E/H11032→m16,m24;A/H11032CE/H11032→m14;ACE →m31;A/H11032B/H11032DE→m3
(b)A/H11032B/H11032DE,A/H11032D/H11032E/H11032,CD/H11032E,A/H11032CE/H11032,ACE ,A/H11032B/H11032C,B/H11032CE,C/H11032D/H11032E/H11032,A/H11032CD/H11032
5.11 f/H11005(a/H11001b/H11001c/H11001d) (a/H11001b/H11032/H11001e/H11032) (a/H11032/H11001d/H11032/H11001e) (a/H11032/H11001b/H11001c/H11032) (a/H11001c/H11001e/H11032)
(c/H11001d/H11001e/H11032){(a/H11032/H11001b/H11032/H11001c/H11001d)or(a/H11032/H11001b/H11032/H11001c/H11001e)}
5.12 (a) F/H11005/H9016 M(0, 1, 9, 12, 13, 14)
F/H11005(A/H11001B/H11001C/H11001D)(A/H11001B/H11001C/H11001D/H11032)(A/H11032/H11001 B/H11032/H11001 C/H11001D)
(A/H11032/H11001B/H11032/H11001C/H11001D/H11032)(A/H11032/H11001B/H11032/H11001C/H11032/H11001D)(A/H11032/H11001B/H11001C/H11001D/H11032)
(b)F/H11032/H11005A/H11032B/H11032C/H11032/H11001ABD /H11032/H11001AC/H11032D
(c)F/H11005(A/H11001B/H11001C)(A/H11032/H11001B/H11032/H11001D)(A/H11032/H11001C/H11001D/H11032)
5.13 F/H11005A/H11032C/H11032/H11001B/H11032C/H11001ACD /H11032/H11001BC/H11032D
Minterms m0,m1,m2,m3,m4,m5,m7,m8,m10, and m11can be made don’t-cares
individually and will not change the given expression.
UNIT 6 Study Guide Answers
2. (f) (2,6)
3. (a) m0–a/H11032b/H11032c/H11032(m0,m1) – a/H11032b/H11032
m1–a/H11032b/H11032c (m1,m5) – b/H11032c prime
m5– ab/H11032c (m5,m7) – ac
m7–abc
(d)A/H11032B/H11032C/H11032andABC are not prime implicants.
4. (b) a/H11032c/H11032d/H11032,bc/H11032,a b/H11032c
5. (b) F/H11005bd/H11001a/H11032b,F/H11005bd/H11001bc/H11032,F/H11005bc/H11032/H11001a/H11032b,F/H11005a/H11032b/H11001c/H11032d
UNIT 6 Answers to Problems
6.2 (a) a/H11032c/H11032d (1,5) (b) a/H11032b/H11032c/H11032 (0,1)
b/H11032c/H11032d (1,9) b/H11032c/H11032d/H11032 (0,8)
a/H11032bd (5,7) ab/H11032d/H11032 (8,10)
ab/H11032d (9,11) acd/H11032 (10,14)
abd/H11032 (12,14) a/H11032d (1,3,5,7)
bcd (7,15) bc (6,7,14,15)
acd (11,15)
abc (14,15)
6.3 (a) f/H11005a/H11032c/H11032d/H11001ab/H11032d/H11001abd/H11032/H11001bcdorf/H11005b/H11032c/H11032d/H11001a/H11032bd/H11001abd/H11032/H11001acd
(b)f/H11005a/H11032d/H11001bc/H11001
6.4f/H11005b/H11032cd/H11032/H11001bc/H11032/H11001a/H11032d/H11001(a/H11032bORa/H11032c) [1 other solution]
6.5 Prime implicants: ab,c/H11032d,ac/H11032,bc/H11032,ad,bd
F/H11005ab/H11001c/H11032dorF/H11005ab/H11001ac/H11032orF/H11005ab/H11001adorF/H11005ac/H11032/H11001adorF/H11005ac/H11032/H11001bdor
F/H11005ad/H11001bc/H11032
¯˚˘˚˙a/H11032b/H11032c/H11032/H11001 ab/H11032d/H11032
OR
b/H11032c/H11032d/H11032/H11001 acd/H11032
OR
b/H11032c/H11032d/H11032/H11001 ab/H11032d/H11032
¯˚˘˚˙
6.6 (a) F/H11005A/H11032B/H11001A/H11032C/H11032D/H11032/H11001AB/H11032D/H11001A/H11032C/H11032E/H11001BCDE
(b)Z/H11005A/H11032B/H11032/H11001ABD /H11001EB/H11032C/H11032/H11001EA/H11032C/H11001FAB /H11001GBD [several other solutions]
UNIT 7 Study Guide Answers
1. (b) Z1: six gates, 13 inputs, four levels Z2: five gates, 11 inputs, five levels
(d)Answers to Selected Study Guide Questions and Problems 699
2. (a) 0; 1; 1,1,1; 0,0,0
6. (a) (1) No (2) Yes (3) No (b) because Crequires no gate
(c) five gates, 10 inputs; using common gate: four gates, nine inputs(d)F
1/H11005a/H11032cd/H11001acd /H11001ab/H11032c/H11032; F2/H11005a/H11032cd/H11001bcd/H11001a/H11032bc/H11032/H11001acd/H11032;
F3/H11005bcd/H11001acd/H11001a/H11032c/H11032d
UNIT 7 Answers to Problems
7.1 (a) f/H11005(a/H11001b)(a/H11032/H11001b/H11032)(a/H11001c/H11001d/H11032)(a/H11032/H11001c/H11032/H11001d/H11032)
OR f/H11005(a/H11001b)(a/H11032/H11001b/H11032)(a/H11001c/H11001d/H11032)(b/H11001c/H11032/H11001d/H11032)
OR f/H11005(a/H11001b)(a/H11032/H11001b/H11032)(b/H11032/H11001c/H11001d/H11032)(a/H11032/H11001c/H11032/H11001d/H11032)
OR f/H11005(a/H11001b)(a/H11032/H11001b/H11032)(b/H11032/H11001c/H11001d/H11032)(b/H11001c/H11032/H11001d/H11032)
(b)f/H11005a/H11032b(c/H11001d/H11032)/H11001ab/H11032(c/H11032/H11001d/H11032)
7.2 (a) Z/H11005(C/H11032/H11001E/H11032)(AD/H11001B)/H11001A/H11032D/H11032E/H11032(four levels, 13 inputs)
(b)Z/H11005(B(C/H11001D)/H11001A)(E/H11001FG) (four levels, 12 inputs)
7.3 AND-OR: F/H11005a/H11032bd/H11001ac/H11032d; OR-AND: F/H11005d(a/H11032/H11001c/H11032) (a/H11001b)DA
B
C
F
GZ
E
a′
c′b
d
dFaNAND-NAND
a′
c′
F
d′a
bNOR-NORa
cb′
d′
d′Fa′a
cb′
d′
d′a′OR-NAND
a
c
F
d′a′
b′a
c
a′
b′AND-NORFNOR-OR
F
dNAND-AND
700 Appendix E
7.4F/H11005BC/H11032(A/H11001D)/H11001AB/H11032C(three levels, four gates, 10 inputs)
FB
A
B′A′
D′
CC′
7.5Z/H11005(A/H11001C/H11001D)(A/H11032/H11001B/H11032C/H11032D/H11032) (convert circuit to four NOR gates)
7.6Z/H11005A(BC/H11001D)/H11001C/H11032D (convert circuit to five NAND gates)
7.7Z/H11005E(A/H11001B(D/H11001CF)) (convert circuit to five NOR gates)
7.8 (a)
A′
B
E′ Z
F
G′C
D′
(b)A
B′
E Z
F′
GC′
D
7.9f1/H11005acd/H11032/H11001ad/H11001a/H11032b/H11032d;f2/H11005a/H11032d/H11032/H11001a/H11032b/H11032d/H11001acd/H11032(six gates, 16 inputs)
7.10 f1/H11005ab/H11032d/H11001b/H11032cd/H11001a/H11032bd/H11032f2/H11005ab/H11032c/H11001b/H11032cd/H11032/H11001bc/H11032d/H11032/H11001{ac/H11032d/H11032orab/H11032d/H11032}
f3/H11005ab/H11032c/H11001b/H11032cd/H11001a/H11032bc (11 gates, 34 inputs)
7.11 F1/H11005(a/H11001c)(a/H11001b/H11032) (a/H11032/H11001b/H11032/H11001c)(a/H11032/H11001b/H11001c/H11032)
F2/H11005(a/H11001c/H11032)(b/H11032/H11001c/H11001d)(a/H11032/H11001b/H11032/H11001c)(a/H11032/H11001b/H11001c/H11032)or
(a/H11001c/H11032)(a/H11001b/H11032/H11001d)(a/H11032/H11001b/H11032/H11001c)(a/H11032/H11001b/H11001c/H11032)
(eight gates minimum, 23 gate inputs)
7.12 f1/H11005(a/H11001b/H11001c)(b/H11032/H11001d)f2/H11005(a/H11001b/H11001c)(b/H11032/H11001c/H11001d)(a/H11032/H11001c)
f3/H11005(b/H11032/H11001c/H11001d)(a/H11001c)(b/H11001c/H11032)
7.13 (a) Replace all gates in the AND-OR circuit which corresponds to
Equations (7-23(b)) with NAND gates. Invert the cinput to the f2out-
put gate.
(b) Replace all gates in Answer 7.12 with NOR.
UNIT 8 Study Guide Answers
3.Answers to Selected Study Guide Questions and Problems 701
a′
b
f
g′
d′c′
e
4. (a) Factor out the expression such that the number of inputs on each gate is less
than or equal to the maximum allowed. This will result in the addition ofmore levels of logic.
(b) Yes.(c) Even if the two-level expressions had common terms, most of these common
terms would be lost when the expressions are factored.
5. (a) B/H11032goes to 0 at 80 ns. Zgoes to 1 at 50 ns and goes to 0 at 110 ns.
6. (a) y
1goes to 1 at 15 ns. y2goes to 0 at 30 ns. Zgoes to 1 at 25 ns and, then, goes
to 0 at 40 ns.
(c) A pair of adjacent 1’s corresponding to a/H11032bcandabcare not in the same loop
in the Karnaugh map, but a/H11032bcand a/H11032bc/H11032are both in a/H11032b. Without the map,
when b/H11005c/H110051 and achanges from 0 to 1, a/H11032bmay go to 0 before acbecomes
1. But when a/H110050,b/H110051, and cchanges from 1 to 0, a/H11032bremains 1.
(g) The application of DeMorgan’s laws to convert a circuit from one form to
another will not introduce any hazards.
7. (b) If G/H110050, gate 4 is faulty. If G/H110051, gate 1 is faulty.
UNIT 8 Answers to Problems
8.1
ZV
0 510 15 20 25 30 35 40 t (ns)
8.2 (a) F/H11005A/H11032C/H11032D/H11032/H11001BC/H11032D/H11001AC(hazards are 1101 ↔1111 and 0100 ↔0101 [static 1]) 
OR F/H11005(A/H11032/H11001C/H11001D) (B/H11001C/H11001D/H11032) (A/H11001C/H11032) (hazards are 0001 ↔0011 and 
1000 ↔1001 [static 0])
(b)Ft/H11005A/H11032C/H11032D/H11032 /H11001 BC/H11032D/H11001AC/H11001A/H11032BC/H11032/H11001ABD
(c)Ft/H11005(A/H11032/H11001C/H11001D) (B/H11001C/H11001D/H11032) (A/H11001C/H11032) (A/H11032/H11001B/H11001C) (A/H11001B/H11001D/H11032)
8.3 (a) Glitch in output of Goccurs between 6 ns and 7 ns (static 1-hazard).
(b) Modified equation to avoid hazards: G/H11005A/H11032C/H11032D/H11001BC/H11001A/H11032BD
8.4 A/H110051 E/H11005X
B/H11005Z F/H110050
C/H11005X G/H110050
D/H110051 H/H11005X
8.5 Gate 3 is connected incorrectly or is malfunctioning.
702 Appendix E
UNIT 9 Study Guide Answers
2. (a)
I0
I1A
(c) Before Cchanges, Z/H11005I4, and after Cchanges, Z/H11005I5.
(d)
BI2
I30
1I0
I101
AZ01
(e) MUX inputs: I0/H11005B,I1/H11005B/H11032, control /H11005A
3. (f) AND gate inputs are A/H11032B/H11032,A/H11032B,AB/H11032, and AB
4. (a) Inputs BCD ;A/H110050
5. (b) 32 words /H110034 bits; 1024 /H110038 (c) 16 words /H110035 bits; 16 /H1100310
6. (a) Four inputs, seven terms, three outputs
(b) Four inputs, four terms, three outputs
(c) ABCD F1F2F3
11- - 10 1
1-11 110110 - 01 0
0-11 011
(f) When ABC /H11005010, F0F1F2F3/H110050111.
8. (c) f/H11005c/H11032(d/H11032/H11001a)/H11001c(a/H11032b/H11032/H11001bd)
(d)
G
a
b
fedcG00 G01 G10 G11
FG
fedcFG
fedcFG
fedcFG(b)Z/H11005A/H11032C/H11032I0/H11001A/H11032CI1/H11001AC/H11032I2/H11001ACI3
UNIT 9 Answers to Problems
9.1 (a)
(b) (c)
9.2Z
ABI0
I1
C
I2
I3
C
I4
I5
C
I6
I7
CAZI0
I1
I2
I3
BC
I4
I5
I6
I7
BCI0
I1
BI2
AZAnswers to Selected Study Guide Questions and Problems 703
Y4
4X
A4
4
X4
4Y
A44-Bit
SubtracterDifference
Bout
704 Appendix E
(b)9.3
9.4 (a)4 4
Y
4
4-Bit
SubtracterDifference
Bout4 4
X
4 4
X
4 4
YA
3-to-8
Line
Decoderm0
m1
m2
m3
m4
m5
m6X
Y
Cin
m7Sum
Cout
3-to-8
Line
Decoderm0
m1
m2
m3
m4
m5
m6X
Y
Cin
m7Sum
Cout
9.5
4-to-2
Priorit y
Encodery0
y1
y2
y3a
b
ca = y2 + y3
b = y1y2 + y3
c = y0 + y1 + y2 + y3′
Answers to Selected Study Guide Questions and Problems 705
9.6
4-to-2
Priorit y
EncoderEnA
EnB
EnC4-Bit
Adder
42
EnD4
44
Sum
Cout
444
ABCDE
28× 5
ROMa
b
c
dS3
S2
S1
S0
CoutSum
(S3 is the most
significant bit)The size of the ROM
is 256 words × 5 bits.
N1
N2e
f
g
h9.7 Block diagram for a Gray code adder:
Partial Truth Table
abcdefgh S3S2S1S0Cout
(0/H110010/H110050) 0 0 0 0 0 0 0 0 0 0 0 0 0
(1/H110012/H110053) 0 0 0 1 0 0 1 1 0 0 1 0 0
(5/H110017/H1100512) 1 1 1 0 1 0 1 1 0 0 1 1 1
(8/H110019/H1100517) 1 0 0 1 1 0 0 0 1 0 1 1 1
9.8 (a)
A
AB′D
A′C′
BC
C′D′
AC
CDBCD
X Y Z
706 Appendix E
(b) Truth Table for the ROM
X
Y
Difference
BoutBin9.9ABCD XY Z
00 00 111
00 01 11100 10 00000 11 00101 00 111
01 01 111
01 10 10001 11 10110 00 110
10 01 101
10 10 01010 11 11111 00 110
11 01 000
11 10 11011 11 111
Answers to Selected Study Guide Questions and Problems 707
W
X
Y
Z
W′
X′Y′
A4
WX′Y′
A3
W′X
XZ
XYA2
W′Y
WXY′Z′
YZA1
W′Z
WXZ′
X′Y′Z
WYZ′A0
WXYZ A4A3A2A1A0
0- -- 10000
-0 0 - 10000
1 0 0 - 010000 1 -- 00100
-1 - 1 00100-1 1 - 00100
0- 1 - 00010
1 1 0 0 00010
-- 1 1 00010
0- - 1 00001
(continued)9.10 (a) A4/H11005W/H11032/H11001X/H11032Y/H11032A3/H11005WX/H11032Y/H11032A2/H11005W/H11032X/H11001XZ/H11001XY
A1/H11005W/H11032Y/H11001WXY /H11032Z/H11032/H11001YZ A0/H11005W/H11032Z/H11001WXZ /H11032/H11001X/H11032Y/H11032Z/H11001WYZ /H11032
(b)
708 Appendix E
9.11 (a) Not inverting, three AND gates. Inverting, F/H11005ac/H11001b/H11032c/H11032d, two AND gates.
(b) Not inverting, two AND gates. Inverting, F/H11005ad/H11001ac/H11001bd/H11001bc, four
AND gates.
9.12 (b)
9.13 F/H11005b/H11032(ade/H11032/H11001a/H11032cd/H11032e)/H11001b((c/H11032d/H11032e/H11001a/H11032cd/H11032e)/H11001ac/H11032de/H11032)
UNIT 10 Study Guide Answers
1. (b) Both statements execute at 5 ns. C and D are updated at 5 /H11001/H9004 ns.
(c)M/H11021/H11005notMafter 5 ns;
(d) A/H11021/H11005 (notBandC) or (B and not C);
2. (a)
(b)F/H11021/H11005 ‘1’when A&B /H11005“00” else ‘0’when A&B /H11005“01” else C;B
A
CF0
11
0M
5 1 01 52 02 5 t (ns)a
b
c
1
Sum1 1 - 0 00001
-0 0 1 00001
1- 1 0 00001
Answers to Selected Study Guide Questions and Problems 709
(c)AB/H11021/H11005 A&B;
with ABselect
F/H11021/H11005 ‘1’when “00”, ‘0’ when “01”, C when “10”, C when “11”;
3. (c) Change all (3 downto 0) to (4 downto 0). Change (3 downto 1) to (4 downto 1).
Add another instance of a full adder –FA4: FullAdder port map (A(4), B(4), C(4), Co, S(4));
Change Co in FA3 to C(4).
(f)architecture ckt of fig8_5 is
signal G1: bit;
begin
G1/H11021/H11005 AandBafter 20 ns;
G2/H11021/H11005 G1norCafter 20 ns;
endckt;
5. (a) not(A&B xor“10”) not(A&B) xor“10”
(b) The given statement will keep executing over and over again.
7. (a) A /H11005‘1’, B /H11005‘X’, C /H11005‘0’, D /H11005‘1’, E /H11005‘X’, F /H11005‘Z’
(b) If Fis of type bit, compiler will log an error.
IfFis std_logic, it will be 0 for 2 ns and, then, become X.
(c) Addout /H1100510011, Sum /H110050011, Cout /H110051
(d)Addout /H11021/H11005 (‘0’ & A) /H11001(“000” & B);
Sum /H11021/H11005 Addout(5 downto 0);
Cout /H11021/H11005 Addout(6);
(e)
UNIT 10 Answers to Problems
10.1 (a) F/H11021/H11005notAandBandC; G /H11021/H11005 Dand not E; N /H11021/H11005 FxorG; I /H11021/H11005notN;
(b)I/H11021/H11005not((notAandBandC)xor(Dand not E));
10.2
A
BG
HI
F C
D
EE
A
F
BD
G
C
710 Appendix E
10.3 (a) (b)
10.4
entity quad_mux is
port (X,Y:inbit_vector(3 downto 0);
A:inbit;
Z:outbit_vector(3 downto 0));
endquad_mux;
architecture equations ofquad_mux is
begin
Z/H11021/H11005Xwhen A/H11005‘0’elseY;
endequations;
10.5
entity ROM is
port (A, B, Cin: inbit;
Sum, Cout: outbit);
endROM;
architecture table ofROM is
type ROM8_2 is array (0to7)ofbit_vector(1 downto 0);
constant ROM1: ROM8_2 : /H11005(“00”, “01”, “01”, “10”, “01”, “10”, “10”,”11”);
signal index: integer range 0to7;
signal S: bit_vector(1 downto 0);
begin
index /H11021/H11005 vec2int(A&B&Cin);
S/H11021/H11005 ROM1(index);
Sum /H11021/H11005 S(0);
Cout /H11021/H11005 S(1);
endtable;
10.6 (a) F/H11005000001101
(b) The expression evaluates to TRUE.C
D
E
B
DF
E
A
DC
B
E
DAG
1F0
0
1
10.7
entity average is
port (a, b, c, d: instd_logic_vector(15 downto 0);
f:outstd_logic_vector(15 downto 0));
endaverage;
architecture behavioral ofaverage is
signa l sum: std_logic_vector(17 downto 0);
beginsum/H11021/H11005 (“00” & a) /H11001b/H11001c/H11001d;
f/H11021/H11005 sum (17 downto 2)/H11001sum (1);
endbehavioral;
10.8
Bus/H11021/H11005 Awhen EnA/H11005‘1’else “ZZZZ”;
Bus/H11021/H11005 Bwhen EnB/H11005‘1’else “ZZZZ”;
Bus/H11021/H11005 Cwhen EnC/H11005‘1’else “ZZZZ”;
Bus/H11021/H11005 Dwhen EnD/H11005‘1’else “ZZZZ”;
10.9 (a) (b)
UNIT 11 Study Guide Answers
1. Left inverter has a 1 output; right inverter has a 0 output.
2. (b) P/H11005Q/H110050 (c) SandRcannot both be 1 simultaneously.
3. (c)
QGDI0
I1
I2
I3
ABFA
B
FI0T1
T2
T3
T4A
B
I1
A
B
I2
A
B
I3Answers to Selected Study Guide Questions and Problems 711
sel/H11021/H11005 A&B;
with selselect
F/H11021/H11005 I0when “00”, I1 when “01”,
I2when “10”, I3 when “11”;
712 Appendix E
4. (b) Qchanges to 1 after first rising clock edge and back to 0 after third rising
clock edge.
(d) Hold time violation ( Dis not stable for 2 ns after second falling clock edge.)
(e)/H110057 ns.
5. (c) For a rising-edge-triggered flip-flop, the value of the inputs is sensed at the
rising edge of the clock, and inputs can change when the clock is low. For amaster-slave flip-flop, if the inputs change when the clock is low, the flip-flopoutputs may be incorrect.
6. (c)
7. (b) Qchanges its value at times 1 and 2.
8. (b)
(c) If CLK /H110051, it will produce a falling edge at the clock input of the D flip-flop,
causing the output to change. If CLK /H110050, only the rising edge is affected, so
the output does not change at the wrong time.En cannot be changed when the clock is 1.The flip-flops in Figures 11-27(b) and (c) can only change on the falling edgeof the clock.
(d)
CK DCE ClrN Q/H11001
xx x 0 0
xx 0 1 Q(no change)
↓ 01 1 0
↓ 11 1 1
0,1,↑x1 1 Q(no change)
9. (b) S/H11005Q/H11032T,R/H11005QT
Same as answer to Study Guide 6(c) except connect JandKand label it T.QPresetClearDClockS
RQ
Q′CKJ
K
UNIT 11 Answers to Problems
11.1
11.2 (a) R/H110051 and H/H110050 cannot occur at the same time.
(b)
RHQ Q/H11001
000 0
001 0
010 0
011 1100 X
101 X110 1
111 1
(c)
11.3
Q
50 100 150 200PRSPQHRzyx
0 1 02 03 04 05 06 07 08 09 0 1 0 0Answers to Selected Study Guide Questions and Problems 713
Q/H11001/H11005R/H11001HQ
714 Appendix E
11.4
11.5 Connect the clock directly to the input G1and connect the clock to G2through
an inverter.
11.6 (a) Q/H11001/H11005SR/H11032/H11001R/H11032Q (b)
11.7
11.8
DQCEDinClockQKJClockS
RQ
Q′ClkS
RQPG2DClock = G1D
GS
RQ
Q′
11.9 (a)
(b)
11.10 (a)
(b) (c)
UNIT 12 Study Guide Answers
1. (a) G/H110050,H/H11005249; G/H110050,H/H1100570;G/H11005118, H/H11005118; G/H1100591,H/H11005118; G/H1100591,
H/H11005118
2. (b) S0is 1 between the rising edges of clocks 10 and 11, and also 1 between the
rising edges of clocks 14 and 16.TQ
Q′ ClkQ
D
CETQ
Q′ ClkQ
DD Q
Q′ ClkQ
J
KQ2Q1ClockClrNQClockKJPreNClrNAnswers to Selected Study Guide Questions and Problems 715
716 Appendix E
Clock Cycle State of Shift Register When Clock /H110051
Number Q7Q6Q5Q4Q3Q2Q1Q0
1 00000000
2 000000003 10000000
- --------
1 4 000000111 5 000000011 6 00000000
3. (b)
(d)
(f) State 101 goes to 110, which goes to 011.
(g) State 001 goes to 100; 101 goes to 110, which goes to 011.
4. (e)
(k)F1/H110051 F2/H110050000
011
010 111 110100DADBDCTATBTCABCClock
00001111
00110011
01010101
UNIT 12 Answers to Problems
12.1
12.2
For a right shift, Sh/H110051,Ld/H110050 or 1. For a left shift, Sh/H110050,Ld/H110051.
12.3
12.4 (a) (b)
D′
Clock
ABCD
DDD′
Clock
ABCD
TD00
01
10
11 D3
A
B
ClockSIQ3
D Q00
01
10
11 D2Q2
D Q00
01
10
11 D1Q1
D Q00
01
10
11 D0Q0
D Q4-bit Parallel-In
Parallel-Out
Shift RegisterSISerial Out
Sh
Ld
ClockClrNAdClockAnswers to Selected Study Guide Questions and Problems 717
718 Appendix E
12.5 DD/H11005D/H11001/H11005D/H11032CBA /H11001DC/H11032/H11001DB/H11032/H11001DA/H11032 DB/H11005B/H11001/H11005B/H11032A/H11001BA/H11032
DC/H11005C/H11001/H11005C/H11032BA/H11001CB/H11032/H11001CA/H11032 DA/H11005A/H11001/H11005A/H11032
12.6 Uses three flip-flops: Q3Q2Q1
Many correct solutions are possible. One is:
D3/H11005Q1/H11001Q2Q3/H11032 D2/H11005Q2/H11032Q3
D1/H11005Q1/H11032Q3/H11032
12.7 (a) DC/H11005CA/H11001BA/H11032 DB/H11005C/H11032/H11001BA/H11032
DA/H11005B/H11032A/H11032/H11001CB/H11001C/H11032B/H11032
IfCBA /H11005000, next state is 011.
(b)TC/H11005B/H11032A/H11032/H11001C/H11032A/H11032 TB/H11005C/H11032B/H11032/H11001CBA
TA/H11005CB/H11032/H11001CA/H11032/H11001C/H11032BA
IfCBA /H11005000, next state is 110.
12.8 (a) JC/H11005A/H11032 JB/H11005C/H11032 JA/H11005C
KC/H11005B/H11032A/H11032 KB/H11005CA KA/H11005CB/H11032/H11001C/H11032B
IfCBA /H11005000, next state is 110.
(b)SC/H11005BA/H11032 SB/H11005C/H11032SA/H11005CA/H11032
RC/H11005B/H11032A/H11032RB/H11005CA RA/H11005CB/H11032A/H11001C/H11032B
IfCBA /H11005000, next state is 010.
12.9 (a)
QQ/H11001MN
00 0 X
01 1 X10 X 011 X 1
(b)MC/H11005BMB/H11005C/H11032AMA/H11005C/H11032
NC/H11005ANB/H11005C/H11032 NA/H11005C/H11032/H11001B
UNIT 13 Study Guide Answers
2. (a) Mealy: output a function of both input and state
Moore: output a function of state only
(b) Before the active clock edge
After the active clock edgeWhen the flip-flops change stateWhen the flip-flops change state or when the inputs change
(c) Immediately preceding the active clock edge(d) Mealy: False outputs can appear when the state has changed to its next value,
but the input has not yet changed.Moore: No false outputs occur because output is not a function of input.Changing the inputs at the same time the state change occurs will eliminatefalse outputs.
No, because the output of the first Mealy circuit will still change to its finalvalue before the active clock edge.
3. (a) Before the clock pulse
Q
/H11001means the state of flip-flop Qafter the active clock edge (i.e., the next
state of flip-flop Q).000
001
100
010101110
(c) Mealy: output associated with transitions between states
Moore: output associated with state
(d) Present: Before the active clock edge
Next: after the clock pulse
(e) Output depends only on the state and not on the input.
4. (a) 1101 (c) 1001
(e)
5. (a)
(c)
6. (a)
(g)/H9254(S3,1 )/H11005S2,/H9261(S3,1 )/H110050,/H9254(S1,2 )/H11005S2,/H9261(S1,2 )/H110053Z2Z1
False outputZS1 S0 S2 S0 StateClock010
01X
False outputMeal y Moore
ZS1 S0 S2 S3 StateClock010
0 00 1XS2 S1 S0
,01
1
0
010
1S3
1
S2
0S0
0
S1
01
00
0
0
11
0
0
11
0ZdZ 10 01False outputsAnswers to Selected Study Guide Questions and Problems 719
720 Appendix E
UNIT 13 Answers to Problems
13.2
This is a Moore machine.
13.3 (a) A/H11001/H11005A(B/H11032/H11001X)/H11001A/H11032(BX/H11032/H11001B/H11032X) B/H11001/H11005AB/H11032X/H11001B(A/H11032/H11001X/H11032)
Present State Next State ( A/H11001B/H11001)
AB x /H110050x/H110051 Z
00 00 10 0
01 11 01 011 01 10 110 10 11 0 This is a Moore machine.
(b)Z/H11005(0)00101
(c)
13.4 (a)
Q1/H11001Q2/H11001Q3/H11001Z
Q1Q2Q3X/H1100501 0 1
S00 0 0 001 001 0 1
S10 0 1 011 011 0 1
S20 1 0 100 101 1 0
S30 1 1 010 011 1 0
S41 0 0 001 001 0 1
S51 0 1 011 011 0 1
S61 1 0 100 101 1 0
S71 1 1 010 011 1 0ZBAXClock1
11
01
10
1101
011110
11101 0 11
00
01
01
0
0
10
0000
001100
010
,
S0 S3 S5 S6S1 S7 S2 S40
0
0
0
1
10
00
11
0
1
01
0
1
01
11
1
,0
01
10
1
0
1
0
1
(b)
(c) From diagram: 0 1(0 )101
From graph :01101
(same except for false output)
(d) Change input on falling edge
of clock
13.5 (a) Mealy Machine
(b)
A/H11001B/H11001C/H11001Z
ABC X /H110050X/H110051 X/H110050X/H110051
000 011 010 1 0
001 000 100 1 0
010 100 100 0 1
011 010 000 0 1100 100 001 1 0
(c)
(d)
Correct output sequence: 00010Z
00010CBAXClock
False outputs000
010 011 100,
0010
1
0
10
01
11
0
1
01
00
1
0
01
1ZQ3Q2Q1ClockX
FalseAnswers to Selected Study Guide Questions and Problems 721
722 Appendix E
13.6 (a) 14 ns
(b)
(c)
UNIT 14 Study Guide Answers
1. (b) last row: 11 10 01 0 1
(c)JA/H11005BX/H11032KA/H11005X⊕BJB/H11005A/H11001XKB/H11005AZ /H11005AB/H11032
8. (a)
ClockManchesterRZNRZINRZBit sequence 1 0 0011100
00
0
0
11
01
1
1
10,1
0S0 S2
S1 S3ZQ2Q1D2D1XClock0 ns 5 ns 10 ns 15 ns 20 ns 25 ns 30 ns 35 ns 40 ns
Correct output sequence: Z = 0101
Next State Z
X/H110050X/H110051 X/H110050X/H110051
S0 S2 S2 00
S1 S0 S3 00
S2 S3 S1 01
S3 S1 S3 11
9. (b) Change NtoNS/H11032; add loop to S3:S/H11032N/H11032/0
NS/H11005 Z
00 01 10 11 00 01 10 11
S3 S3S5S1S5 00 10
UNIT 14 Answers to Problems
14.4
14.5
S0 S3
S1 S2S6
S7S4 S50
000
000
00
0
000
01
0
01
0
000
101
00
1
00 1
00
1
001
00
1
001
001
000
000
00
001
11
1
11
11
0,1S2
0S1
0S0
0
S3
0S8
0S5
0
S4
1S7
0S6
0Answers to Selected Study Guide Questions and Problems 723
Z1Z2
X/H110050X /H110051X /H110050X /H110051
S0 S1 S3 00 00
S1 S1 S2 00 00
S2 S4 S3 10 00
S3 S4 S3 00 00
S4 S5 S2 01 00
S5 S5 S6 00 00
S6 S7 S6 00 00
S7 S5 S6 01 00
724 Appendix E
14.6
X1X2/H11005
00 01 10 11 Z
S0 S0S1S3S2 0
S1 S0S1S3S2 0
S2 S4S1S3S2 0
S3 S4S1S3S2 0
S4 S4S5S7S6 1
S5 S0S5S7S6 1
S6 S4S5S7S6 1
S7 S0S5S7S6 1
(a 4-state solution is also possible)
14.7 (a) (b)
14.8
(a) X1X2/H11005 Z1Z2
00 01 10 11 00 01 10 11
S0 S1S2S3S4 00 00 00 00
S1 S1S2S3S4 00 10 10 10
S2 S1S2S3S4 01 00 10 10
S3 S1S2S3S4 01 01 00 10
S4 S1S2S3S4 01 01 01 000
00
00
00
00
00
0
0
1
0
00
0
1
01
01
01
0
1
01
11
01
0
1
0
S1 S2S5 S4S7 S8S6S3S0
S2 S1S0
0
00
0 1
01
01
10
1
(b) X1X2/H11005
00 01 10 11 Z1Z2
S0 S1S4S7S10 00
S1 S1S3S6S9 00
S2 S1S3S6S9 01
S3 S2S4S6S9 10
S4 S2S4S6S9 00
S5 S2S4S6S9 01
S6 S2S5S7S9 10
S7 S2S5S7S9 00
S8 S2S5S7S9 01
S9 S2S5S8S10 10
S10 S2S5S8S10 00
14.9
(a) X/H1100501 X/H1100501
S0 S0S1 01
S1 S1S0 10
(b) X/H1100501
S0 S0S1 0
S1 S1S0 1
(c, d)
14.10
Next State Output ( DEF)
000 001 010 011 100 101 110 111 000 001 010 011 100 101 110 111
S0S0S0S0S0S1S1S0S0100 100 100 100 010 010 001 001
S1S1S0S1S0S1S0S1S0110 000 110 000 101 000 101 000
For S0: For S1:
A/H11032/H11001AB/H11001AB/H11032/H11005A/H11032/H11001A/H110051 A/H11032C/H11032/H11001AC/H11032/H11001C/H11005C/H11032/H11001C/H110051
A/H11032/H11080AB/H110050;A/H11032/H11080AB/H11032/H110050; A/H11032C/H11032/H11080AC/H11032/H110050;
AB/H11080AB/H11032/H110050 A/H11032C/H11032/H11080C/H110050;AC/H11032/H11080C/H110050NRZI
(Moore)NRZI
(Meal y)NRZClock
11 0 10010
False outpu tAnswers to Selected Study Guide Questions and Problems 725
726 Appendix E
14.11
UNIT 15 Study Guide Answers
2. (b) /H9261(p, 01) /H1100500 and /H9261(q, 01) /H1100501; therefore, p [q
(c) No.You would have to try an infinite number of test sequences to be sure the
circuit s were equivalent.
(d)S2≡S3iff S1≡S5and S4≡S2. But S1[S5because the outputs are different.
Therefore, S2[S3.
3. (a)
7. (b) Z/H11005X/H11032AB/H11032/H11001XA/H11032BC/H11032
8. (b) Interchanging columns or complementing columns does not affect circuit
cost for symmetric flip-flops.
(c) Complementing columns (to make the first row all 0’s) does not change the
cost of the circuit.
(f) Numbering columns from left to right, column 3 is same as column 4, column
2 is column 5 complemented, column 1 is column 6 complemented.
9. (e) D1/H11005XQ/H110321/H11001XQ3/H11001Q2Q/H110323/H11001X/H11032Q1Q/H110322orD1/H11005XQ/H110321/H11001XQ2/H11001Q/H110322Q3/H11001X/H11032Q1Q/H110323,
D2/H11005Q3,D3/H11005X/H11032Q3/H11001XQ2Q/H110323/H11001(Q/H110321Q3orQ/H110321Q2)
Z/H11005XQ2Q3/H11001X/H11032Q/H110322Q3/H11001X/H11032Q2Q/H110323
(f)J1/H11005X,K1/H11005X/H11032Q2Q3/H11001XQ/H110322Q/H110323
11. (b) Q5/H11001/H11005XQ2/H11001X/H11032YQ2/H11001X/H11032Q5a-d
b-fa-f
f d c b aa-d
b-ga-ga-g
b-fa-d
a-b
gfdcbx′
0
x′
0x
0x
0
–z
–z–z–zS0
S3S1
S4 S2S5
(b)f≡g
(c)a≡c,b≡d,b≡e,d≡e
01 01
ab a 01
bb b 00
UNIT 15 Answers to Problems
15.1 (a)
Present StateNext State Output
X/H110050X/H110051 X/H110050X/H110051
AA C 10
BC F 00
CB A 00
FB F 10
(b)
Input 1 0 0
Output(from B)0 1 0
Output (from G)0 1 1
15.2
Next
Present State
State X/H110050X/H110051 Output
ac c 1
cd f 0
df a 1
fc d 0
15.3 (a) No, states S2andS4have no corresponding states in Mr. Ipflop’s design.
(b) Because there is no way of reaching S2and S4by starting from S0, the two
circuit s would perform the same.
15.4 (a) D/H11005X/H110321X2Q/H11032/H11001X1X/H110322Q/H11032/H11001X/H110322X3Q/H11001X2X/H110323Q
(b)S/H11005X/H110321X2Q/H11032/H11001X1X/H110322Q/H11032
R/H11005X/H110322X/H110323Q/H11001X2X3Q
15.5 (a) Only oneassignment—000 001
011 OR 010 etc.101 100
(b) 000 000 000 000 000 000 000 000 000 000
001 001 001 001 001 001 001 001 001 001 etc.010 010 010 010 011 .011 011 011 110 110100 101 110 111 100 101 110 111 010 011Answers to Selected Study Guide Questions and Problems 727
(c) Q2/H11001/H11005 Q1M
Q3/H11001/H11005 Q2K/H11001 Q1/H9010/H9012/H11032
(d) Ad /H11005 Q1M
Done /H11005 Q3
728 Appendix E
15.6 (a) (b)
15.7 (a)
(b)D1/H11005XQ1
D2/H11005Q/H110321Q/H110323/H11001X/H11032Q/H110321
D3/H11005X/H11032Q/H110321Q/H110323/H11001XQ/H110321Q3/H11001{XQ/H110322orQ2Q3}
Z/H11005XQ1
15.8 (a) A/H1100500,B/H1100501,C/H1100510,D/H1100511
(b)T1/H11005X/H110321X2Q/H110322/H11001X/H110321Q1Q2/H11001X1Q/H110321Q2/H11001X1X/H110322
T2/H11005X1Q/H110321Q/H110322/H11001X1Q1Q2
Z1/H11005X1Q2,Z2/H11005X/H110321Q1/H11001Q1Q/H110322
15.9
Q1Q2Q3 D1/H11005X/H11032Q1/H11001XY/H11032Q3
Assign S0 100 D2/H11005XQ1/H11001YQ3/H11001X/H11032Q2
S1 010 D3/H11005XQ2/H11001X/H11032Y/H11032Q3
S2 001 P/H11005XQ1/H11001Y/H11032Q3/H11001XQ2
S/H11005X/H11032Q1/H11001XY/H11032Q3
UNIT 16 Study Guide Answers
1. (a) Because the input sequences are listed in reverse order.
2. (b) mleads, where 2m/H110021/H11021n/H113492m
3. (b) 64 words /H110037 bits
(d)Z/H110050,D1/H110051,D2/H110051,D3/H110050; Q1Q2Q3/H11005110
8. (a) Yes
(c) Yes
9. (a) After the clock (when the state has just changed) and before the input is set
to its new value, the output may be wrong (false output).
(b) No, because the output is always correct before the active clock edge.AC01
BE
F
D00Q2Q3Q1
01
11
10S1 S801
S7 S5
S3 S4
S200BC
DA = A+ = A′B′ + XA′ + X′AC′
DB = B+ = etc.
DC = C+ = etc.A
01
11
10 S6S1 S201
S4 S3
S6 S5
S700BC
Z = AA
01
11
10 S8
UNIT 16 Answers to Problems
16.15
X1X2Q1Q2 Q1/H11001Q2/H11001Z1Z2
0000 1 1 0 0
0001 0 0 1 00010 1 1 0 0
0011 1 0 0 0
0100 1 0 1 00101 0 1 1 00110 0 0 1 0
0111 1 0 0 0
1000 0 1 1 11001 1 0 1 11010 0 1 1 1
1011 0 1 0 1
1100 0 0 0 11101 1 1 1 11110 0 1 0 11111 0 0 0 1
16.16 (a) Same as Figure 16-10 with ROM replaced by PLA.
(b)
XABC ZDADBDC
0 --- 0 100
0--0 00 1 0
-0-1 00 1 0
-01- 00 1 0
- 1 -- 0 001
1-0- 00 0 10101 10 0 01010 10 0 0
16.17 (a)
(b)ai/H110011/H11005ai/H11001xibi/H11005[a/H11032i(xibi)/H11032]/H11032 bi/H110011/H11005xib/H11032i/H11001x/H11032ibi/H11005[(xib/H11032i)/H11032(x/H11032ibi)/H11032]/H11032
z/H11005an/H110011bn/H110011
(c)a1/H11005b1/H110050,a2/H110050,b2/H11005x1
(d) Similar to Figure 16-9 with one output0
0S0
0
0111
1S1
0
0S2
0S3
1Answers to Selected Study Guide Questions and Problems 729
ROM
24 Words
4 Bits Per Word
DD
ClockQ1
Q2Q1+
Q2+Z2Z1
X2X1
730 Appendix E
UNIT 17 Study Guide Answers
1. (a) When a falling edge of CLK occurs
(b) Whenever there is a change in St or Q1orV
(c) Statements S3andS4will execute
(d) The code represents a rising-edge-triggered D flip-flop with asynchronous,
active-low clear and preset. Because ClrN has higher priority, Qwill be set
to ‘0’ when both ClrN and SetN are ‘0’.
(e)SNandRNoverride JandK, including at a clock edge. Qwill be ‘0’.
(f) They will get the old value of Qintbecause of the 8-ns delay.
2. (a) entity register is
port (CLK, CLR, Ld: inbit; D: inbit_vector (3 downto 0);
Q:outbit_vector (3 downto 0));
endregister;
architecture eqnofregister is
begin
-- Given code here
endeqn;
(b) Q will change at time 10 /H11001/H9004 ns
(c) On line 6 of the VHDL code, make this change—
elsif LS/H11005‘1’then Q/H11021/H11005 Q (2 downto 0) & Q (3);
(d) Change the indicated lines of code as shown—
line 3: process (ClrN, CLK)
lines 5 to 7: ifClrN /H11005‘0’then Q/H11021/H11005 “0000”;
elsif CLK’event andCLK/H11005‘1’then
ifEn/H11005‘1’then Q/H11021/H11005 Q/H110011;
(e) When Carry1 /H11005‘1’ and Qout2 /H11005“1111”
(f) No overloaded “ /H11001” operator is defined for bit_vectors
(g) After the rising edge, Qout1 /H11005“0000” and Qout2 /H11005“1010”
(h)
Control Signals Next State
ClrN LdN PT Q3/H11001Q2/H11001Q1/H11001Q0/H11001
X0X D3 D2 D1 D0
X 1 1 Present state /H110011
0 1 0 000011 0 Q
3 Q2 Q1 Q0
3. (a) process (A, B, D)
begin
E/H11021/H11005 (AandB)orDafter 5 ns;
end process;
4. (a) Nextstate /H11005S4 and Z /H110051
(b) Because there are only seven states. Also, specifying the range restricts the
number of bits used to represent the integer
When X changes to 1, Nextstate /H110052, and Z /H110050.Then, when CLK changes to 1,
State /H110052, Nextstate /H110054, and Z /H110051
(c) The glitch occurs because the change in state and change in the value of X a
little while later causes process (State, X) to execute two times, thereby up-dating the value of Nextstate two times. This glitch does not affect the ‘state’because the state will not be updated until the next positive clock edge.
(d) Because Q1, Q2, and Q3 must be updated only on the CLK edge, the other
signals must not appear on the sensitivity list. The new values will be com-puted at 5 ns, and the values are updated at 15 ns.
(e) The statements of lines 13, 14, and 18 will execute.(f) ROM output /H110051100
5. (a) Connect En to CE and A to D
(b) See Figure 11-27(c) (change to rising-edge trigger)
(c) Use four D-CE flip-flops. Connect ASR to every CE input, D3 to Q3, D2 to Q3,
D1 to Q2, and D0 to Q1. Label Q 3...Q 0  a s  A ( 3 )... A(0).
6. (a) process
begin
A/H11021/H11005 BorC;
wait on B, C;
end process ;
(b) 2 ns (Both sequential statements execute immediately with no delay.)
UNIT 17 Answers to Problems
17.1 Code to implement a T flip-flop
entity tffis
port (t, clk, clrn: inbit;
q, qn: outbit);
endtff;
architecture eqnoftffis
signal qint: bit; -- Internal value of q
beginq/H11021/H11005 qint;
qn/H11021/H11005notqint;
process (clk, clrn)
begin
ifclrn/H11005‘0’then qint/H11021/H11005 ‘0’;
elsif clk’event andclk/H11005‘1’then
qint/H11021/H11005 (tand not qint) or(nottandqint);
endif;
end process ;
endeqn;Answers to Selected Study Guide Questions and Problems 731
732 Appendix E
17.2 Right-shift register with synchronous reset
entity rsris
Port (clk, clr, ld, rs, lin: inbit;
d:inbit_vector(3 downto 0);
q:outbit_vector(3 downto 0));
endrsr;
architecture eqnofrsris
signal qint: bit_vector(3 downto 0);
beginq/H11021/H11005 qint;
process (clk)
begin
ifclk’event andclk/H11005’1’then
ifclr/H11005’1’then qint/H11021/H11005 “0000”;
elsif ld/H11005’1’then qint/H11021/H11005 d;
elsif rs/H11005’1’then qint/H11021/H11005 lin & qint(3 downto 1);
end if ;
end if ;
end process ;
endeqn;
17.3 (a) 4-bit binary up/down counter
entity updown is
Port (clrn, clk, load, ent, enp, up: instd_logic;
d:instd_logic_vector(3 downto 0);
q:outstd_logic_vector(3 downto 0);
co:outstd_logic);
endupdown;
architecture eqnofupdown is
signal qint: std_logic_vector(3 downto 0) :/H11005“0000”;
beginq/H11021/H11005 qint;
co/H11021/H11005 (qint(3) andqint(2) andqint(1) andqint(0) andentandup)
or(notqint(3) and not qint(2) and not qint(1) and not qint(0)
andentand not up);
process (clrn, clk)
begin
ifclrn/H11005’0’then qint/H11021/H11005 “0000”;
elsif clk’event andclk/H11005’1’then
ifload /H11005’0’then qint/H11021/H11005 d;
elsif (entandenpandup)/H11005’1’then qint/H11021/H11005 qint/H11001
1;
elsif (entandenpand not up)/H11005’1’then qint/H11021/H11005 qint/H110021;
end if ;
end if ;
end process ;
endeqn;
17.3 (b) 8-bit binary up/down counter. (For block diagram, connect the Carry-out
of the first counter to ENT of the second.)
entity updown8bit is
Port (clrn, clk, load, ent, enp, up: instd_logic;
d:instd_logic_vector(7 downto 0);
q:outstd_logic_vector(7 downto 0);
co:outstd_logic);
endupdown8bit;
architecture structure ofupdown8bit is
component updown is
Port (clrn, clk, load, ent, enp, up: instd_logic;
d:instd_logic_vector(3 downto 0);
q:outstd_logic_vector(3 downto 0);
co:outstd_logic);
end component ;
signal co1: std_logic;
signal q1,q2: std_logic_vector(3 downto 0);
begin
c1: updown port map (clrn, clk, load, ent, enp, up, d(3 downto 0),q1,co1);
c2: updown port map (clrn, clk, load, co1, enp, up, d(7 downto 4),q2, co);
q/H11021/H11005 q2 & q1;
endstructure;
17.4 MUX with a and b as control inputs
entity mymux is
Port (a, b, c, d: inbit;
z:outbit);
endmymux;
architecture eqnofmymux is
signal sel: bit_vector(1 downto 0);
beginsel/H11021/H11005 a & b;
process (a, b, c, d)
begin
case selis
when “00” /H11005/H11022 z/H11021/H11005notcord;
when “01” /H11005/H11022 z/H11021/H11005 c;Answers to Selected Study Guide Questions and Problems 733
734 Appendix E
when “10” /H11005/H11022 z/H11021/H11005notcxord;
when “11” /H11005/H11022 z/H11021/H11005notd;
end case ;
end process ;
endeqn;
17.5 Implements the state machine of Table 14-1
entity sm1is
Port (x, clk: inbit;
z:outbit);
endsm1;
architecture table ofsm1is
signal State, Nextstate: integer range 0to2 :/H110050;
beginprocess (State, x)
begin
case State is
when 0/H11005/H11022
ifx/H11005’0’then Nextstate /H11021/H11005 0;else Nextstate /H11021/H11005 1;end if ;
z/H11021/H11005 ‘0’;
when 1/H11005/H11022
ifx/H11005’0’then Nextstate /H11021/H11005 2;else Nextstate /H11021/H11005 1;end if ;
z/H11021/H11005 ‘0’;
when 2/H11005/H11022
ifx/H11005’0’then Nextstate /H11021/H11005 0; z /H11021/H11005 ‘0’;
else Nextstate /H11021/H11005 1; z /H11021/H11005 ‘1’;end if ;
end case ;
end process ;
process (clk)
beginifclk’event and
clk/H11005’0’then
State /H11021/H11005 Nextstate;
end if ;
end process ;
end table ;
17.6 (a) See Figure 13-17, with m/H110052,n/H110052, and k/H110052.
(b) Implements the state machine of Table 13-4
library BITLIB;
useBITLIB.bit_pack.all;
entity smis
Port (x1, x2, clk: inbit;
z1,z2: outbit);
endsm;
architecture Behavioral ofsmis
type rom16_4 isarray (0 to15)ofbit_vector(3 downto 0);
-- Input is in the order X1 X2 Q1 Q2-- Output in order Q1 Q2 Z1 Z2constant myrom: rom16_4 : /H11005(“1100”, “0010”, “1100”, “1000”, “1010”, “0110”,“0010”,
“1000”, “0111”, “1011”, “0111”, “0101”, “0001”, “1111”, “0101”, “0001”);
signal index: integer range 0to15;
signal q1,q2: bit;
signal rom_out: bit_vector(3 downto 0);
beginindex /H11021/H11005 vec2int(x1&x2&q1&q2);
rom_out /H11021/H11005 myrom(index);
z1/H11021/H11005 rom_out(1);
z2/H11021/H11005 rom_out(0);
process (clk)
begin
ifclk’event andclk/H11005’1’then
q1/H11021/H11005 rom_out(3);
q2/H11021/H11005 rom_out(2);
end if ;
end process ;
endBehavioral;
17.7 (a) There are two D-CE flip-flops. For each, CE /H11005LdA /H11001LdB.
D1/H11005LdA A1 /H11001LdA /H11032LdB B1, D2 /H11005LdA A2 /H11001LdA /H11032LdB B2.
(b) CE does not change. For each D input, replace the gates with a 2-to-1
MUX, with LdA as the control input, and B and A as the data inputs for 0and 1, respectively. (Alternately, use LdB as the control input, and swap Aand B on the data inputs.)
17.8 All statements execute at time /H1100520 ns
A becomes 1 at 35 ns (not the final value)B becomes 1 at 20 ns /H11001/H9004 (not the final value)
C becomes 1 at 30 nsD becomes 2 at 23 nsA becomes 5 at 35 ns (overrides the previous value)B becomes 7 at 20 ns /H11001/H9004 (overrides the previous value)
UNIT 18 Study Guide Answers
1. (a) XY cisici/H11001
t0 0110 0011 0 1 0
t1 1011 1001 0 0 1
t2 0101 1100 1 0 1
t3 0010 0110 1 1 0
t4 1001 0011 0 (0) (1)Answers to Selected Study Guide Questions and Problems 735
736 Appendix E
(b)Ywould fill up with 0’s from the left: 0011, 0001, 0000, 0000, 0000.
(c)S0andY0,n o .
2. (a)
a d d 000001101
1111
shift 0 1 1 1 1 1101
shift 0 0 1 1 1 1110
a d d 000111111
1111
shift 1 0 0 1 0 1111
a d d 010010111
1111
shift 1 1 0 0 0 0111
011000011
(b) 10, 6. (c) 10, 6. (d) 15 bits
(f) Product register has 17 bits.Adder is 8 bits wide, multiplicand has 8 bits. 18 states.
3-bit counter, K/H110051 when counter is in state 7 (1112), control graph unchanged.
3. (b) Change Yto 2’s complement by inverting each bit and adding 1 (by setting
the carry input of the first full adder to 1). Also change Cso that it is equal
to the carry out of the last full adder.
(c) An overflow will occur if X8X7X6X5X4/H11350Y3Y2Y1Y0, because subtraction is
possible but there is no place to store the quotient bit, since there are only4 bits available to store the quotient.
(f) To set the quotient bit to 1.
UNIT 18 Answers to Problems
18.3
Control
CircuitSI
Shx3
St
Clockx2 x1 x0
SI
CE DQ
ShShyx
d
b
x′yy x ′y3x4
y4 y2 y1 y0
18.4
18.5 18.6
18.7 (a) V/H11005y/H110320y/H110321y/H110322y/H110323y/H110324/H11005(y0/H11001y1/H11001y2/H11001y3/H11001y4)/H11032S0
(Stop)
S2S1
S3C′
0C
Su
K′C′
ShKC′
ShC
SuC
VSt′
0
St
Load
C′
ShSt′
0
St
Load–
Done
M′
Sh
M′
ShM′
Sh
M′
ShM
Ad
M
Ad
M
AdM
AdS4 S1
S3 S2S0 S5Full
Adderx1
y2
x2
y1
Full
Adder x3
y1
Full
Adder x3
y2
Full
Adder x3
y3Full
Adderx1
y3x1Z1
Z2
Z3S4
0
S5
0S3
0S2
1S1
0
S6
C71
1C6 1C5 1
C4 1C3 1C2 10
01
1
1
1
1
0
1
111
Z4
Z5
Z6y1
x2
y2
Full
Adder x2
y3Answers to Selected Study Guide Questions and Problems 737
738 Appendix E
(b) (c)
( 00101 ) Sh Su
0 0 0 0 011010 1 00 0 0 0 110100 1 00 0 0 1 101000 1 0
0 0 1 1 010000 0 1
0 0 0 0 110001 1 00 0 0 1 100010 1 00 0 1 1 000100 0 1
0 0 0 0 100101
remainder /H110051 quotient /H110055
(d) After five shifts, the division is complete.
18.8 (a) xin/H11005K/H110321K/H110322a/H11032/H11001K/H110321K2b/H11001K1K/H110322(a⊕b)/H11001K1K2a
yin/H11005K/H110321K/H110322b/H11001K/H110321K2a/H11001K1K/H110322/H110800/H11001K1K2/H110801
(b) Use the state graph of Figure 18-6(b), with nine states total.(c)
UNIT 19 Study Guide Answers
1. (b) Z1,Z2,Z4(for both charts) (d)
2. (a)
000011100 C/H110050,Sh
000111000 C/H110050, Sh
001110000 C/H110051,Su
000100001 C/H110050,Sh
001000010 C/H110050,Sh
010000100 C/H110051,Su
000110101 ( r esult)
3. (a) A/H11001/H11005BX B/H11001/H11005A/H11032X/H11001BX00
01
10
11aa
b
a
k1k2xin00
01
10
11b
a
10byin,
S0
S3S1 S5
S2 S4V
0
C′
0 C
SuSt′
0
StV′
Sh
C′
ShC′
Sh
C′
ShC′
ShC
Su
C
Su
C
SuC
Su
Z2Z1S0 S0 S1 S2 S0
ZcZbZaXStateClock
UNIT 19 Answers to Problems
19.1 19.2
19.3
ShAdKMState S0 S1 S2 S1 S1 S2 S3ClockS0/
S2/S1/
ZZZX
X
XS3/
ZX01
10
1001P
Q
S
R0 1
10
1
(1) (2)0D
EFAnswers to Selected Study Guide Questions and Problems 739
740 Appendix E
19.4
19.5
S0/
S2/N01
X
X
KK
K1 0
1 00
11 0
0 10
1S1/
XZ
ZZS0/
St01
S1/
Sh AdM10
S4/
Sh AdM10
...
19.6
19.7 (a) Q0/H11001/H11005Q/H110320Q/H110321Q2C/H11032/H11001Q0Q/H110321/H11001Q0Q/H110322
Q1/H11001/H11005Q0Q/H110321Q2C/H11032/H11001Q0Q1Q/H110322
Q2/H11001/H11005Q/H110320Q/H110321Q/H110322St/H11001Q0Q/H110322C/H11032/H11001Q0Q/H110321Q2C
Load /H11005Q/H110320Q/H110321Q/H110322St,Su/H11005Q0C,Sh/H11005Q/H110321Q2C/H11032/H11001Q0Q/H110322C/H11032,V  /H11005Q/H110320Q/H110321Q2C
(These equations could be further simplified using don’t-cares.)
(b)Q0/H11001/H11005Q/H110320Q1M/H11001Q/H110320Q1M/H11032K/H11001Q0Q1K
` Q1/H11001/H11005Q/H110320Q/H110321St/H11001Q/H110320Q1M/H11032K/H11032/H11001Q/H110320Q1M/H11001Q0Q1K/H11032
Load /H11005Q0/H11032Q1/H11032St,Sh/H11005Q0Q1/H11001Q/H110320Q1M/H11032,Ad/H11005Q/H110320Q1M, Done /H11005Q0Q/H110321
19.8 (a) A/H11001/H11005A/H11032B/H11032C/H11080Rb/H11032D/H11032711D/H110322312/H11001AB/H11032C/H11032/H11001AB/H11032/H11080Rb/H11001AB/H11032Eq/H11032D/H110327
B/H11001/H11005A/H11032B/H11032C/H11080D711/H11001A/H11032B/H11080Reset /H11032/H11001 AB/H11032C/H11080Rb/H11032Eq/H11032D/H110327
C/H11001/H11005A/H11032B/H11032Rb/H11001A/H11032BC/H11080Reset /H11032/H11001B/H11032C/H11032Rb/H11001AB/H11032C/H11080Rb/H11032Eq/H11032D7
Roll /H11005B/H11032C/H11080Rb Sp /H11005A/H11032B/H11032C/H11080Rb/H11032D/H11032711D/H110322312
Win /H11005A/H11032BC/H11032Lose /H11005A/H11032BC
(These equations could be further simplified using don’t-cares.)
(b) If the input from the adder is S3S2S1S0, then the equations realized by the
test logic block are
D7/H11005S2S1S0D711/H11005S1S0(S2/H11001S3)D2312/H11005S/H110323S/H110322/H11001S3S2
19.9 (a) A/H11001/H11005BX Za/H11005A/H11032B/H11032 Z1/H11005ABX /H11032
B/H11001/H11005A/H11032X/H11001BX Zb/H11005A/H11032BZ2/H11005ABX
Zc/H11005ABS0/
St
S1/
S2/01
C1
0
10C1 0
K
C0 1V
Sh
SuSh
SuAnswers to Selected Study Guide Questions and Problems 741
742 Appendix E
XAB A/H11001B/H11001ZaZbZcZ1Z2
1-1 1 100000
10- 0 100000
-0 0 0 010000
-0 1 0 001000-1 1 0 000100
01 1 0 000010
11 1 0 000001
19.10 (a)
(b)D1/H11005Q/H110321X/H110321X/H110322X3/H11001Q2X/H110322 D2/H11005Q/H110322X1/H11001Q/H110321Q/H110322X/H110322X/H110323/H11001Q2X2
Z1/H11005Q/H110322X/H110321/H11001Q1 Z2/H11005Q/H110321Q/H110322X1 Z3/H11005Q/H110321X/H110321X2/H11001Q2
(c)
Q1Q2X1X2X3 D1D2Z1Z2Z3
001- - 01010
0001- 00101
00001 10100
00000 0110001-0- 1000101-1- 01001100- - 00100
101- - 01100
(d) 25/H110035 ROM
Q1Q2X1X2X3 D1D2Z1Z2Z3
00000 01100
00001 1010000010 0010100011 0010100100 01010Z3Z2Z1X3X2X1StateClock
S0 S0 S1 S2 S1 S1 S2
UNIT 20 Study Guide Answers
1. (a) lines 15 and 16
The full adder is combinational logic.Lines 34 and 35, which are in clocked process because it is a clocked register
(b) In line 31, change clk /H11005‘0’ to clk /H11005‘1’.
2. (a) So we can use the overloaded “ /H11001” operator
The change from state 9 to state 0To make the result be 5 bitsLines 35 and 36 will execute when State is 2, 4, 6, or 8.
(b) ACC is uninitialized and is not loaded until St /H11005‘1’ at a rising clock edge.
When Done /H110051, i.e., in state 9, 160-180 ns.
(c)X/H11005101111001, 60 ns
(d) Mcand /H110051101, Mplier /H110051011, and product is 10001111 /H11005143
(e) Line 19
To avoid having to set them to 0 in each case where they are not 1.When theyare set to 1, it overrides line 22 because these are sequential statements.ACC /H11021/H11005“00000” & Mplier;
Because it is a clocked register that is updated on the rising clock edge.The process executes on the rising clock edge, and when state is 9 at the risingclock edge, it is too late; the state is about to change to 0.The process of lines 20–34 is not clocked; it executes when State changes to 9.
(f) Whenever the value of count changes.
Lines 51 and 52.10 ns /H11001/H9004.
Sequential statements execute in 0 time, so A and B update simultaneously.
(g) At time 60 ns, we are in state 2 when K /H110050, so Sh /H110051. So A /H1100500B
16/H11005
0000010112shifts to the right to become 00516/H110050000001012. At time 140 ns,
we are in state 1 and M /H110051, so Ad /H110051. So we add the multipicand,
0000010112, to A /H1100500616/H110050000001102to get 01116/H110050000100012.
3. (a) 0; 1
C should be 1 iff we can subtract, i.e., Dividend(8 downto 4)/H11022Divisor.
UNIT 20 Answers to Problems
20.1 First process executes at t /H110052 ns. Lines 22–25 execute.
Second process executes at t /H1100510 ns. Lines 38–40 and 43 execute.
Because the state changes, first process executes again at 10 /H11001/H9004 ns. Lines 22–23
and lines 27–30 execute.
20.2
entity complementer is
Port (clk, n: instd_logic;
Regout: outstd_logic_vector(15 downto 0));
endcomplementer;
architecture Behavioral ofcomplementer is
signal State, NextState: integer range 0to2 :/H110050;
signal count: std_logic_vector(3 downto 0) :/H11005“0000”;--4-bit counterAnswers to Selected Study Guide Questions and Problems 743
744 Appendix E
signal X, Z, Sh: std_logic;
signal K: std_logic : /H11005‘0’;
signal Reg: std_logic_vector(15 downto 0);
begin
Regout /H11021/H11005 Reg;
X/H11021/H11005 Reg(0);
K/H11021/H11005 ‘1’when count /H11005“1111” else ‘0’;
process (State, X, N, K)
begin
case State is
when 0/H11005/H11022
ifN/H11005‘0’then NextState /H11021/H11005 0; Sh /H11021/H11005 ‘0’; Z /H11021/H11005 ‘0’;
elsif X/H11005‘1’then NextState /H11021/H11005 2; Sh /H11021/H11005 ‘1’; Z /H11021/H11005 ‘1’;
else NextState /H11021/H11005 1; Sh /H11021/H11005 ‘1’; Z /H11021/H11005 ‘0’;end if ;
when 1/H11005/H11022 Sh/H11021/H11005 ‘1’;
ifK/H11005‘1’then NextState /H11021/H11005 0;
ifX/H11005‘1’then Z/H11021/H11005 ‘1’;
else Z/H11021/H11005 ‘0’;end if ;
elsif X/H11005‘0’then NextState /H11021/H11005 1; Z /H11021/H11005 ‘0’;
else NextState /H11021/H11005 2; Z /H11021/H11005 ‘1’;end if ;
when 2/H11005/H11022 Sh/H11021/H11005 ‘1’;
ifK/H11005‘1’then NextState /H11021/H11005 0;
ifX/H11005‘1’then Z/H11021/H11005 ‘0’;
else Z/H11021/H11005 ‘1’;end if ;
elsif X/H11005‘0’then NextState /H11021/H11005 2; Z /H11021/H11005 ‘1’;
else NextState /H11021/H11005 2; Z /H11021/H11005 ‘0’;end if ;
end case ;
end process ;
process (clk)
begin
ifclk’event andclk/H11005‘1’then
ifSh/H11005‘1’then Reg/H11021/H11005 Z & Reg(15 downto 1);
count /H11021/H11005 count /H110011;end if ;
State /H11021/H11005 NextState;
end if ;
end process ;
endBehavioral;
20.4
entity testis
endtest;
architecture Behavioral oftestis
component sm17_2 is
Port (x,clk: instd_logic;
z:outstd_logic);
end component ;
constant N: integer: /H1100540;
Answers to Selected Study Guide Questions and Problems 745
signal flag: std_logic: /H11005’0’;
signal clk: std_logic: /H11005’1’;
signal x,z: std_logic;
constant x_seq: std_logic_vector(1 to40) :/H11005
(“0000100001001100001010100110111000011001”);
constant z_seq: std_logic_vector(1 to40) :/H11005
(“1100001010100110111000011001010111010011”);
begin
sm1: sm17_2 port map (x,clk,z);
clk/H11021/H11005notclkafter 10 ns; -- clock has 20 ns period
processbegin
foriin1toNloop
x/H11021/H11005 x_seq(i);
wait for 5 ns; -- wait for z to become stable
ifz/H11005z_seq(i) then flag/H11021/H11005 ’0’;else flag/H11021/H11005 ’1’;end if ;
wait until clk’event andclk/H11005’1’;
wait for 5 ns;
end loop ;
end process ;
endBehavioral;
20.5
Ld
Clr Accumulator (7:0)
Adder
Mcand
(3:0)
McandDataAdd
Add
Done
InitInit
8
44
488
MplierDataClk
SumProduct
Ld Init
ClkDec
Ld Mplier (3:0)Down Counter
Add
Init
Clk
StartControl
Circuit
Start/Init
Start/Done
K/DoneStart′/0Start′/0
K′/AddK
S1 S2S0
746 Appendix E
20.6
entity prob20_6 is
Port (st, clk: instd_logic;
X:instd_logic_vector(7 downto 0);
Z:outstd_logic_vector(9 downto 0));
endprob20_6;
architecture Behavioral ofprob20_6 is
signal State, NextState: integer range 0 to 3 : /H110050;
signal lda, ldb, ldc, ad: std_logic;
signal B, C: std_logic_vector(7 downto 0);
signal A: std_logic_vector(9 downto 0);
signal sumAB: std_logic_vector(8 downto 0);
signal sumABC: std_logic_vector(9 downto 0);
begin
sumAB /H11021/H11005 (“0”&A(7 downto 0))/H11001B;
sumABC /H11021/H11005 (“0”&sumAB) /H11001C;
Z/H11021/H11005 A;
process (st, State)
begin
lda/H11021/H11005 ‘0’; ldb /H11021/H11005 ‘0’; ldc /H11021/H11005 ‘0’; ad /H11021/H11005 ‘0’;
case State is
when 0/H11005/H11022
ifst/H11005‘1’then lda/H11021/H11005 ‘1’; NextState /H11021/H11005 1;
else NextState /H11021/H11005 0;end if ;
when 1/H11005/H11022
ldb/H11021/H11005 ‘1’; NextState /H11021/H11005 2;
when 2/H11005/H11022
ldc/H11021/H11005 ‘1’; NextState /H11021/H11005 3;
when 3/H11005/H11022
ad/H11021/H11005 ‘1’; lda /H11021/H11005 ‘1’; NextState /H11021/H11005 0;
end case ;
end process ;
process (clk)
begin
ifclk’event andclk/H11005‘1’then
iflda/H11005‘1’then
ifad/H11005‘1’then A/H11021/H11005 sumABC;
else A/H11021/H11005 (“00” & X); end if ;
elsif ldb/H11005‘1’then B/H11021/H11005 X;
elsif ldc/H11005‘1’then C/H11021/H11005 X;
end if ;
State /H11021/H11005 NextState;
end if ;
end process ;
endBehavioral;
1.Ashenden, Peter J. The Designer’s Guide to VHDL , 2nd ed. San Francisco:
Morgan Kaufmann Publishers, 2002.
2.Bhasker, J. A Guide to VHDL Syntax. Upper Saddle River, NJ: Prentice-Hall, 1995.
3.Bhasker, J. VHDL Primer , 3rd ed. Upper Saddle River, NJ: Prentice-Hall, 1999.
4.Brayton, Robert, et al. Logic Minimization Algorithms for VLSI Synthesis .
Secaucus, NJ: Springer, 1984.
5.Givone, Donald D. Digital Principles and Design . New York: McGraw-Hill, 2003.
6.Katz, Randy H. and Gaetano Borriello. Contemporary Logic Design , 2nd ed.
Upper Saddle River, NJ: Prentice Hall, 2004.
7.Mano, M. Morris. Digital Design , 3rd ed. Upper Saddle River, NJ: Prentice Hall,
2001.
8.Mano, M. Morris and Charles R. Kime. Logic and Computer Design Fundamentals ,
4th ed. Old Tappan, NJ: Pearson Prentice Hall, 2008.
9.Marcovitz, Alan B. Introduction to Logic Design, 2nd ed. New York: McGraw-
Hill, 2002.
10. McCluskey, Edward J. Logic Design Principles . Upper Saddle River, NJ: Prentice
Hall, 1986.
11. Miczo,Alexander. Digital Logic Testing and Simulation , 2nd ed. New York: John
Wiley & Sons, Ltd West Sussex, England, 2003.
12. Patt, Yale N. and Sanjay J. Patel. Introduction to Computing Systems: From Bits
and Gates to C and Beyond , 2nd ed. New York: McGraw-Hill, 2004.
13. Roth, Charles H. Jr. and Lizy Kurian John. Digital Systems Design Using VHDL ,
2nd ed. Toronto, Ontario: Thomson, 2008.
14. Rushton, Andrew. VHDL for Logic Synthesis , 2nd ed. West Sussex, England:
John Wiley & Sons, Ltd, 1998.
15. Wakerly, John F. Digital Design Principles & Practices , 4th ed. Upper Saddle
River, NJ: Prentice Hall, 2006.
16. Weste, Neil and Kaamran Eshraghian. Principles of CMOS VLSI Design , 2nd ed.
Reading, MA: Addison-Wesley, 1993.
References
747
Index
74163, 561–563
74178, 380
A
Accumulator
para llel, 356–358
serial,5 9 4–596
Active low, 253, 33 4
clear an d preset inputs 33 4–335,
555–556
Adde r,binary, 100–101
para llel,1 0 4–105
para llel with acc umulator, 356–358
serial,404–405
serial with acc umulator, 59 4–596
VHDL serial adder, 650–651
Addi tion, binary, 12
1’s comp lement, 19–20
2’s comp lement, 17–19
Algeb raic simp lificat ion, 68–70, 127–128
theorems 42–43, 55
Algorithmic stat e mac hine. SeeStat e
mac hine.
Alphanumeric stat e grap h notat ion, 448–450
Alternat ive gate sym bols, 201
circuit con version using, 201–20 4
Analog syst ems, 6
AND
gate,3 5
operation, 36
VHDL, 286Arithmetic,binary, 12–15 . 
See also Addi tion, S ubtract ion,
Multiplicat ion, Division.
ASCII co de, 22–23, 2 40–2 41
ASIC, 491
ASM c hart. SeeSM c hart.
Assoc iative law,40–41
Async hrono us clear (C lrN), 33 4–336,
355, 366
VHDL, 555
Async hrono us pr eset (Pr eN), 33 4–336
Async hrono us sequential circuit, 336 
B
Bas e (number syst ems) 9
con version, 9–12
Bi-directiona l I/O P in, 256
VHDL, 306
Binary a ddition. See Addi tion, binary .
Binary n umbers
con version to decima l, 10–11
signed, 16–17
Binary s ubtract ion. SeeSubtract ion,
binary .
Binary-co ded-decima l (BC D), 20
BIT LIB, 278, 619
Boo lean a lgebra, 33– 47, 58–68
basic op erations, 35–37
basic theorems, 39– 40
laws an d theorems, 55
simp lificat ion t heorems, 42–43
748
Index 749
Boo lean expressions, 36–37
Borro w, 13–1 4, 106–107
Buffer, 253–25 4
three-stat e (tr i-stat e) 25 4–255
Bus, 253, 355
merger 606
three-stat e (tr i-stat e) 255–256, 355–356
splitter 607
VHDL 30 4–305 
C
Carry, 12
end-aro und, 19–21
flip-f lop, 404, 595–596
Charact eristic equations, 309
Clear input
async hrono us, 33 4–336
sync hrono us, 560, 561
Clocked sequential circuit
ana lysis 395– 411.
See also Sequential circuit.
CMOS Logic, 675–679
Co de con verter
hexadecima l to ASCII, 262
sequential, 515–523
sequential in VHDL, 565
Co des (BC D,8 - 4-2-1, 6-3-1-1, excess-3,
Gray, 2-o ut-of-5, weigh ted), 21–23
Com binat iona l circuit
definition, 7
design, 92–93, 219–220
testing, 229, 231
Comm utative law,40
Comparator, 519–522
VHDL, 301
Comp lementat ion, 35, 45–47
Comp uter-aided design (C AD), 28 4,
536–538
Conf igurable logic block (C LB), 270–271
Xilinx Virtex / Spartan II, 536–538
Cons ensus theorem, 55, 66–68
dual,6 7
illustrat ed by map, 133Contact bounce, 326–327
Contro l circuit
for dice gam e, 632–633
for divide r, 605
for m ultiplier, 600–602
for s erial adder, 59 4–597
Con version of gate circuits, 200–20 4
Con verting English sentences to Boo lean
equations, 90–91
Co unters, 333–3 45
binary, 362–366
design using D flip-f lops, 370–371
design using J-K f lip-f lops, 373–37 4
design using S-R f lip-f lops, 371–373
design using T f lip-f lops, 367–370
fully sync hrono us, 561
ripple,344, 362
up-down, 36 4–365
VHDL, 560–563
CP LD, 268–269, 525–526
sequential circuit design using, 525–528
Cyc lic shift r egister, 358–359
VHDL, 558–559
D
D (delay) f lip-f lop, 328–330
CMOS, 680derivation of input equations, 36 4, 370, 485
mo deling in VHDL,5 5 4–555
with clock ena
ble, 335–337
Data pat h,644
Data s elector . SeeMultiplexer.
Debouncing switches, 326
Decima l numbers
binary co des for, 21–22
con version to binary, 9–11
Decoder, 256–258
Decompos ition of s witching funct ions,
271–273
Dege nerate forms, 199
Delay
inertial, 225, 289, 682
transport, 225, 289, 682
Delta (/H9004)delay, 287, 307
DeMor gan’s laws,47–49
Dice gam e, 631–639
VHDL, 662–66 4
Digital syst ems, 6–8
design with FPG A,437–538
Distributive law,42
Divide r, para llel binary, 602–607, 630
VHDL, 662–66 4
Division
binary, 15, 602–607
Don’t car e minterm, 99–100
Don’t car e term
in Karna ugh map, 135
in pr ime imp licant c hart, 173–17 4
Dual,48
Dynam ic hazar d. SeeHazar ds.
E
EEPROM, 261
Enco der, pr iority, 258
Equation
pro ving validity, 70–72
Equivalence gate, 65–66
Equivalent s equential circuits,
481– 482
by imp licat ion ta ble,481– 482
definition, 481
determinat ion of, 481
Equivalent stat es,476– 478
definition, 476
in SM c hart, 635
theorem, 477
Espr esso-II m ethod, 176
Essential prime imp licant
definition, 138, 169
from Karna ugh map, 138–1 41
from pr ime imp licant c hart, 169
multiple output, 206–207
proof, 689
Exclusive-OR, 6 4–65
Exclusive-NOR gate,6 6
Expans ion t heorem, 272–273750 Index
F
Factor ing,45–46, 62
False output, 399– 400, 406– 408
Fan- in, 220
reduction of, 220–222
Flip-f lop
charact eristic equation, 326
clear, pr eset inputs, 33 4–336
D, 328–330
D-CE, 335
definition, 322
edge -triggered, 328–330
J-K, 332–333mast er-slave, 331
mo deling usi
ng VHDL,544–557
S-R, 331–333T, 333–33 4
typ e con version, 33 4
Flip-f lop input equations, derivation
D,3 6 4, 370, 485, 493– 494
J-K, 373–37 4,484–486
S-R, 371–373, 486
summary, 37 4–377, 484
T, 362–363, 368–370
Flowchart, 632–633
FPG A, 270–271, 535–536
sequential circuit design us
ing,
537–538
FPLA, 266
Full adder, 10 4–105
imp lemented using a P AL, 268
VHDL, 293–296
Full subtract er, 106–107
Funct ion block, 268
Funct ion generator, 270–271
Funct iona lly comp lete, 196
G
Gat e circuits, 46
multi-level , 190–19 4, 200–201
multiple-output, 20 4–206, 219–221
two-level  NAND an d NOR, 197–200
Gat e delays, 191, 222–223
Index 751
Gat e level , 190–192
Gat es
AND,3 6
equivalence, 65–66
exclusive-or, 6 4
NAND. SeeNAND gate.
NOR .SeeNOR gate.
OR, 36transm ission, 678
Glitches, 22 4–225, 229, 400, 446–447.
See also False outputs.
H
Ha lf adder, 81, 115, 31 4
Har dware descr iption language
s (H DLs),
264, 537 . See also VHDL.
Hazar ds, 22 4–229
Hexadecima l number, 9, 12
Hi-Z ( high imp edanc e), 230, 25 4,3 0 4
Ho ld time, 329–330
IEEE stan dard logic, 30 4, 570
I
Imp licant
definition, 136, 168
Imp licat ion ta ble (chart), 478– 481
Incomp letely sp ecified funct ion, 99–100
simp lificat ion, 135, 173–17 4
Incomp letely sp ecified sequential circuits,
483– 484
Inertial delay, 225, 289, 682
Integrated circuits
design an d layo ut,491
in com binat iona l circuit design,
230–250
MOS, CMOS, 675–680SSI, MSI, LSI, VLSI, 250
TT L, 561
Interconn ect array (I
A), 268–269
Inverter, 35, 201, 676, 677
Iterative circuits, 519–522
definition, 519
design, 519–522J
J-K f lip-f lop, 332–333
derivation of input equations, 373–37 4,
484–486
mast er-slave, 333
VHDL, 508–509
K
Karna ugh map, 129–1 44
3-variable, 129–133
4-variable, 133–1 41
5-variable,141–1 44
comp lementat ion, 132
multiple-output m inimizat ion, 20 4–207
other forms, 1 46
L
Laboratory t esting
com binat iona l circuits, 229–231
sequential circuits, 531–536
Latc h
CMOS, 679–680definition, 322
Gat ed D, 327
S-R, 323–327transpar ent, 327
unwant ed in VHDL proc esse
s, 57 4
VHDL mo del, 555
Left s hift r egister
VHDL, 510
Link pat h, 626, 636
Literal
definition, 38
eliminat ion of, 69
VHDL, 300
LogicAid,1 2 4, 163, 218, 429, 513,
536, 639
Lookup ta ble (LUT), 270–271, 667 
Loop ing terms on a Karna ugh map, 129–131
M
Macroc ell, 268–269, 525–529
Xilinx Coo lRunner, 527
Manc hester co de,445–447
Map- entered variables, 17 4–176, 639
Ma xterm
definition, 9 4
Ma xterm expans ion, 93–96
general form, 97–98
simp lificat ion of, 128
Mealy mac hine, 398
design,431
general mo del,408– 409
stat e table an d grap h,403
VHDL mo del, 565–567
Mealy sequential circuit. SeeMealy
mac hine.
Metal-oxide semicon ductor . SeeMOS .
Minimum pro duct of s ums, 128
from Karna ugh map, 135
Minimum s um of pro ducts, 127, 137
from Karna ugh map, 132, 135
from pr ime imp licant c hart,
169–171
Min-ma x delay, 532
Minterm
definition, 93
Minterm expans ion, 93–96
general form, 96–99
simp lificat ion of, 130
Moor e mac hine, 398
design,433– 435
stat e table an d grap h, 368–369
general mo del,410– 411
Moor e sequential circuit. SeeMoor e
mac hine.
MOS logic, 675–680
MOSF ET, 675
n-c hann el, 675
p-c hann el, 675
Multi-level  gate circuits
design, 190–19 4, 206–208
NAND an d NOR gates, 200–201
Multiple-output gate circuit
design, 192–195, 206–228
determinat ion of essential prime 
imp licants, 206–207Multiplexer (MUX), 251–253
data s election, 252–253
VHDL, 290–292
Multiplicat ion, binary, 1 4, 598–601
Multiplier, para llel binary, 598–601, 631,
636–637
VHDL, 652–65 4
Multiplying out,44, 62–6 4
N
NAND gate, 195
CMOS, 678
funct iona lly comp lete, 196
multi-level  circuits, 200–201 
two-level  circuits, 197–200
Nanos econ d, 222
Negative logic, 556, 676
Negative number representat ion, 16–18 . See
also On e’s comp lement, T wo’s
comp lement.
sign an d ma gnitude,1 6
Next stat e, 325
equation, 326
map, 367–368
Nom inal delay, 532
NOR gate, 195
CMOS, 678multi-level  circuits, 200–201
two-
level  circuits, 197–200
NOT gate. SeeInverter.
NRZ, NRZI co des,445–446
Number syst ems, 8–12
O
On e’s comp lement
addition, 19–21
representat ion of n egative number, 16–18
On e-hot stat e ass ignm ent, 495– 497, 605
OR gate,3 6
Overflow
division, 60 4–605
one’s comp lement a ddition, 19–21
two’s comp lement a ddition, 18–19,
105–106752 Index
Index 753
P
PAL (Pro gramma ble Array Logic), 266–267
in sequential circuit design, 525
Para llel adder, 10 4
Par ity, 395
Par ity c hecker
sequential, 395–397
PC boar d layo ut, 537
Petrick’s m ethod, 171–172
Phase-locked loop, 445
PLA, 263–266
in sequential circuit design, 523–525,
636–638
table,2 6 4–266
PLD, 263
pro gramm ing, 269, 536
Pos itive logic, 625
Present stat e, 325
Prime imp licant . See also Essential prime
imp licant .
chart, 168–170
definition, 136, 168
from Karna ugh map, 136–137
Pro duct of s ums (POS), 45
stan dard,94
Pro gramma ble array logic. SeePAL.
Pro gramma ble logic array . SeePLA.
Pro gramma ble logic device, 263–268
PROM, 261–262
compar ed with PLA, 266
pro gramm er, 262
Proofs of t heorems, 689–690
Propa gation delay, 222, 329, 410
Q
Quine-McC luskey m ethod, 165–17 4
R
Radix,9
Redundant stat es,eliminat ion of,
474–475
Register transf ers, 355–356
Registers, 35 4–362
Ripple co unters, 3 44, 362ROM (r ead-on ly m emory), 259–262
in sequential circuit design,
522–52 4, 638
VHDL, 300, 570–571
RZ co de,445
S
Schemat ic capt ure, 536
Sequence detector design,431– 440,
475– 476
Sequential circuit
definition, 7
Sequential circuit. See also Stat e grap h,
Stat e mac hine, Stat e table,M ealy
sequential circuit, Moor e sequential
circuit, Stat e ass ignm ent.
ana lysis, 395– 411
design with a P AL, 525
design with flip-f lops, 484–486, 51 4–518
design with PLA, 523–525
design with ROM, 523–525
general mo del,408– 411
testing, 531–536
timing charts, 399– 400
unused stat e, 381, 422
Serial adder. See Adde r, s erial.
Serial data
code con version, 444–447
transm ission of, 444–445
Set-R eset (S-R) f lip-f lop, 331–332
derivation of input equations, 371–372, 486
Setup time, 329–330, 410
Seven-s egment indicator, 236
Shift r egister, 358–362
cyc lic, 558
VHDL, 558–560
Sign an d ma gnitude,1 6
Signal trac ing, 397
Simp lificat ion. See Algeb raic simp lificat ion.
SimUa id, 318–320, 379, 537
Simulation
logic circuits, 229–331
sequential circuits, 531–536
VHDL, 307–308
SM block, 626
SM c hart (Stat e mac hine chart), 625–639
derivation, 630–636
for binary divide r, 630
for binary m ultiplier, 631
for dice gam e, 631–635
realizat ion, 635–639
Sta ble stat e, 323, 325
Stan dard pro duct of s ums, 9 4
Stan dard sum of pro ducts, 93
Stat e ass ignm ent for s equential circuits,
487– 497
equivalent ass ignm ents, 487– 490
guideli nes,490– 495
one-hot, 495– 497
Stat e equivalence theorem, 477, 689–690
Stat e grap h
alphanumeric notat ion, 448–450
con version to SM c hart, 628–629
derivation, 431– 444
for contro l circuits, 597–598,
600–601, 605
for co unter, 365, 367, 370
guideli nes for constr uction, 439– 443
Mealy,403– 404
Moor e,402
Stat e mac hine,435, 495, 570 . See also
Sequential circuit.
design using SM c harts, 625–639
Stat e table
derivation of, 430– 444
incomp letely sp ecified,483
Mealy,403
Moor e,401– 402
reduction, 474–481
Stat ic-0 hazar d. SeeHazar ds.
Stat ic-1 hazar d. SeeHazar ds.
Subtract er
full, 106–107
in binary divide r, 60 4–607
Sum of pro ducts (SOP), 44
stan dard,94
Switches
circuits of, 36–37, 39– 40Switching algebra, 3 4. SeeBoo lean a lgebra.
Switching circuit
definition, 7
Switching funct ion
decompos ition of, 271–273
Sync hron izer, 535
Sync hrono us sequential circuit. See
Sequential circuit.
Synt hesis, 302, 307–308
too ls, 537, 572–575
T
T (to ggle) flip-f lop, 333–33 4
derivation of input equations, 362–363,
367–370
Test generation, 537
Testing of c ircuits. See Laboratory t esting.
Three-stat e buffer 253–256 . See also
Tri-stat e buffer.
Three-stat e bus 255–256 . See also Tri-stat e
bus.
Timing chart ( diagram), 222–223
for co unter, 369–370
for f lip-f lops, 329, 330
for latc hes, 325, 327
for s equential circuits, 397– 400, 406– 408
for SM c hart, 629–630
Trans ients
in o utput, 22 4
Trans ition ta ble,401– 403
Transm ission gate (TG), 678
Tri-stat e buffer. See also Three-stat e buffer.
VHDL,3 0 4, 306
Tri-stat e bus, 355–356 . See also Three-stat e
bus.
Truth table,3 8
constr uction, 100–103
TT L logic, 561
Two’s comp lement
addition, 17–19
representat ion of n egative numbers, 16–17
Two-level  circuits, 46
AND-OR, 197–200
NAND-NAND, 197–200754 Index
Index 755
OR-N AND, 197–200
NOR-OR, 197–200OR- AND, 197–200
NOR-NOR, 197–200AND-NOR, 197–200
NAND-AND, 197–200
U
Un want ed latc hes in VHDL,5 7 4
V
Ve itch diagram, 1 46
Verilog HDL,2 8 4, 537
VHDL
arrays, 298–300behaviora l, 285–286
cas e-sensitivity in, 288
comp ilation, 307
conc urrent stat ements, 286–288, 682
data typ es, 297–298, 30 4
d
ataf low, 285–286, 568
definition, 285
delta delay, 287, 307–308
intro duction to, 285–302
language summary, 681–68 4
latc hes (unwant ed), 57 4
libraries, 302–303, 683, 68 4
mo dule, 292
operators, 301–302
overloaded op erators, 305, 560
pac kages, 302, 68 4–685
proc ess, 55 4–555, 575–576
sequential stat ements, 55 4–556, 559,
564, 575–576
signals, 285–288, 297
signals, c hange of value,5 7 4
signals,externa l, 565
signals,interna l, 565, 559
simulation, 29 4–295
std_logic, 30 4–306, 570, 68 4–685
structural, 285–286, 296, 303,
558–559, 569
synt hesis, 285, 572–575, 667 
test bench, 655–657typ e con version, 685
unsigned typ e,6 8 4
VHDL mo dels
for bi-directiona l I/O p in, 306
for binary divide r, 662–66 4
for binary m ultiplier, 652–663
for co de con verter, 565–567
for com binat iona l logic, 563–56 4
for comparator, 301
for co unter, 561–562
for cyc lic shift r egister, 558–559
for dice gam e simulator, 66 4–666
for f lip-f lops an d latc hes, 55 4–557
for f ull adder, 293
for gates, 286–289
for left s hift r egister, 560
for m ultiplexer, 290–292
for ROM, 300for s equential logic, 55 4–563
for s equential mac hine, 565–567
for s erial adder, 650–651
for tr i-stat e buffer, 30 4, 306
VHDL stat ement
alias declarat ion, 653, 682
arc hitecture declarat ion, 292–293, 681
array typ e an d object declarat ion,
298, 682
cas e,5 6 4–565, 683
compon ent declarat ion, 29 4–296, 682
compon ent instant iation, 297, 682
con ditiona l signal ass ignm ent, 290, 682
constant declarat ion, 297, 681
entity declarat ion, 292–293, 681
for loop, 655, 683
if-then-else, 555–556, 683
integer typ e declarat ion, 297, 681
interfac e-signal declarat ion, 681
library declarat ion, 303, 683
pac kage body, 303, 68 4
pac kage declarat ion, 302, 68 4
port declarat ion, 292–293, 68 4
proc ess with sensitivity list, 55 4–555, 682
proc ess without sensitivity list, 575, 683
report declarat ion, 683
756 Index
VHDL stat ement (Continued )
selected signal ass ignm ent, 291, 682
signal ass ignm ent stat ement, 287, 682
signal declarat ion, 297, 681
use, 303, 68 4
wait, 575, 683X
Xilinx Coo lRunner CP LDs, 525–529, 667
Xilinx Spartan, 529–530, 667
Xilinx Virtex/Spartan II, 529–530, 667
XOR ( exclusive-OR), 152–301
XNOR ( exclusive-NOR), 301
Description of the CD
The CD that accompan ies this text conta ins t hree pro grams t hat ar e useful in the comp uter-aided design
and simulation of digital logic— LogicAid,SimUa id,a n d DirectVHDL-PE.  Pr incipal features of t hese pro grams
are listed below.  Us er man uals for LogicAid an d SimUa id are pro vided  on t he CD in P DF format . The user man u-
als for DirectVHDL,which are pro vided  in the form of  HTM L help files,will be insta lled when yo u run setup
from t he DirectVHDL directory .
LogicAid Features:
• Logic funct ions may be input in the following forms :sum-of-pro ducts, pro duct-of-s ums, tr uth table,PLA
table, Karna ugh map, m interm or ma xterm expans ion
•C hoice of logic simp lificat ion a lgorithms pro vides for f inding a fast so lution or a ll minimum so lutions
•S equential logic may be input as M ealy or Moor e stat e tables, stat e grap hs (with either binary or a lphanu-
meric input/output), or SM c harts
•R educes stat e tables to a m inimum n umber of ro ws an d derives flip-f lop input equations for D, T, J-K, an d
S-R f lip-f lops
•C r eates JEDE C f iles for pro gramm ing 22 V10 P ALs
•T utorial aids include Karna ugh map t utor, stat e table checker, an d part ial grap h checker
SimUaid Features:
•F r iendly user interfac e allows easy p lacement an d wiring of compon ents
• Available devices include basic gates, f lip-f lops, s witches, pro bes, r egisters, co unters, a dders, m ultiplex-
ers, decoders, 7-s egment indicators, c locks, tr i-stat e buffers, an d stat e mac hines
•F o ur-valued logic simulation (0, 1, X, Z)
• Displays a ll device inputs an d outputs for ease of s ignal trac ing an d debuggi ng
• Pro be placement a utomat ically sets up waveform display
• Live simulation mo de allows imm ediate observation of r espons e to input switch changes
• Sync hrono us simulation a llows st epping on e clock period at a t ime
• Async hrono us simulation a llows st epping until a s ignal changes
• Con verts a c ircuit diagram to synt hesizable VHDL co de
DirectVHDL Features:
• Edits, comp iles, an d simulates VHDL co de
• Easy to learn user interfac e
• VHDL editor highligh ts synta x errors as yo u typ e
•S imulator displays waveforms an d listing output
• Comman d interfac e allows forc ing input values interact ively or from a comman d file
• Compat ible with IEEE Stan dard 1076-1993 VHDL